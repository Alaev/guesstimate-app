/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/
/******/ 	};
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 			function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 				hotAddUpdateChunk(chunkId, moreModules);
/******/ 				if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 			}
/******/ 	
/******/ 			function hotDownloadUpdateChunk(chunkId) {
/******/ 				var head = document.getElementsByTagName('head')[0];
/******/ 				var script = document.createElement('script');
/******/ 				script.type = 'text/javascript';
/******/ 				script.charset = 'utf-8';
/******/ 				script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 				head.appendChild(script);
/******/ 			}
/******/ 	
/******/ 			function hotDownloadManifest(callback) {
/******/ 				if(typeof XMLHttpRequest === "undefined")
/******/ 					return callback(new Error("No browser support"));
/******/ 				try {
/******/ 					var request = new XMLHttpRequest();
/******/ 					var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 					request.open("GET", requestPath, true);
/******/ 					request.timeout = 10000;
/******/ 					request.send(null);
/******/ 				} catch(err) {
/******/ 					return callback(err);
/******/ 				}
/******/ 				request.onreadystatechange = function() {
/******/ 					if(request.readyState !== 4) return;
/******/ 					if(request.status === 0) {
/******/ 						// timeout
/******/ 						callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 					} else if(request.status === 404) {
/******/ 						// no update available
/******/ 						callback();
/******/ 					} else if(request.status !== 200 && request.status !== 304) {
/******/ 						// other failure
/******/ 						callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 					} else {
/******/ 						// success
/******/ 						try {
/******/ 							var update = JSON.parse(request.responseText);
/******/ 						} catch(e) {
/******/ 							callback(e);
/******/ 							return;
/******/ 						}
/******/ 						callback(null, update);
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		
/******/
/******/ 	
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "97ff563606bc36d3a7ae";
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = [];
/******/ 	
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				fn[name] = __webpack_require__[name];
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 				else for(var i = 0; i < dep.length; i++)
/******/ 					hot._acceptedDependencies[dep[i]] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else for(var i = 0; i < dep.length; i++)
/******/ 					hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) { if(err) throw err };
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			for(var chunkId in installedChunks) {
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(+id);
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) { if(err) throw err };
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) { if(err) throw err };
/******/ 		}
/******/ 		
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 			
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 			
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = +id;
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j]
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 					if(child.parents.length === 0 && child.hot && child.hot._disposeHandlers && child.hot._disposeHandlers.length > 0) {
/******/ 						// Child has dispose handlers and no more references, dispose it too
/******/ 						queue.push(child.id);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		0:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".bundle.js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/scripts/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(1);\n__webpack_require__(2);\nmodule.exports = __webpack_require__(3);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** multi main\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///multi_main?");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(__resourceQuery) {var io = __webpack_require__(9);\r\nvar scriptElements = document.getElementsByTagName(\"script\");\r\nio = io.connect(true ?\r\n\t__resourceQuery.substr(1) :\r\n\tscriptElements[scriptElements.length-1].getAttribute(\"src\").replace(/\\/[^\\/]+$/, \"\")\r\n);\r\n\r\nvar hot = false;\r\nvar initial = true;\r\nvar currentHash = \"\";\r\n\r\nio.on(\"hot\", function() {\r\n\thot = true;\r\n\tconsole.log(\"[WDS] Hot Module Replacement enabled.\");\r\n});\r\n\r\nio.on(\"invalid\", function() {\r\n\tconsole.log(\"[WDS] App updated. Recompiling...\");\r\n});\r\n\r\nio.on(\"hash\", function(hash) {\r\n\tcurrentHash = hash;\r\n});\r\n\r\nio.on(\"ok\", function() {\r\n\tif(initial) return initial = false;\r\n\treloadApp();\r\n});\r\n\r\nio.on(\"warnings\", function(warnings) {\r\n\tconsole.log(\"[WDS] Warnings while compiling.\");\r\n\tfor(var i = 0; i < warnings.length; i++)\r\n\t\tconsole.warn(warnings[i]);\r\n\tif(initial) return initial = false;\r\n\treloadApp();\r\n});\r\n\r\nio.on(\"errors\", function(errors) {\r\n\tconsole.log(\"[WDS] Errors while compiling.\");\r\n\tfor(var i = 0; i < errors.length; i++)\r\n\t\tconsole.error(errors[i]);\r\n\tif(initial) return initial = false;\r\n\treloadApp();\r\n});\r\n\r\nio.on(\"proxy-error\", function(errors) {\r\n\tconsole.log(\"[WDS] Proxy error.\");\r\n\tfor(var i = 0; i < errors.length; i++)\r\n\t\tconsole.error(errors[i]);\r\n\tif(initial) return initial = false;\r\n\treloadApp();\r\n});\r\n\r\nio.on(\"disconnect\", function() {\r\n\tconsole.error(\"[WDS] Disconnected!\");\r\n});\r\n\r\nfunction reloadApp() {\r\n\tif(hot) {\r\n\t\tconsole.log(\"[WDS] App hot update...\");\r\n\t\twindow.postMessage(\"webpackHotUpdate\" + currentHash, \"*\");\r\n\t} else {\r\n\t\tconsole.log(\"[WDS] App updated. Reloading...\");\r\n\t\twindow.location.reload();\r\n\t}\r\n}\n/* WEBPACK VAR INJECTION */}.call(exports, \"?http://localhost:3000\"))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)-dev-server/client?http://localhost:3000\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)-dev-server/client?");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("if(true) {\r\n\tvar lastData;\r\n\tvar upToDate = function upToDate() {\r\n\t\treturn lastData.indexOf(__webpack_require__.h()) >= 0;\r\n\t};\r\n\tvar check = function check() {\r\n\t\tmodule.hot.check(function(err, updatedModules) {\r\n\t\t\tif(err) {\r\n\t\t\t\tif(module.hot.status() in {abort:1,fail:1}) {\r\n\t\t\t\t\tconsole.warn(\"[HMR] Cannot check for update. Need to do a full reload!\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.warn(\"[HMR] Update check failed: \" + err);\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif(!updatedModules) {\r\n\t\t\t\tconsole.warn(\"[HMR] Cannot find update. Need to do a full reload!\");\r\n\t\t\t\tconsole.warn(\"[HMR] (Propably because of restarting the webpack-dev-server)\")\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tmodule.hot.apply({\r\n\t\t\t\tignoreUnaccepted: true\r\n\t\t\t}, function(err, renewedModules) {\r\n\t\t\t\tif(err) {\r\n\t\t\t\t\tif(module.hot.status() in {abort:1,fail:1}) {\r\n\t\t\t\t\t\tconsole.warn(\"[HMR] Cannot apply update (Need to do a full reload!): \" + err);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tconsole.warn(\"[HMR] Update failed: \" + err);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(!upToDate()) {\r\n\t\t\t\t\tcheck();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar unacceptedModules = updatedModules.filter(function(moduleId) {\r\n\t\t\t\t\treturn renewedModules.indexOf(moduleId) < 0;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tif(unacceptedModules.length > 0) {\r\n\t\t\t\t\tconsole.warn(\"[HMR] The following modules couldn't be hot updated: (They would need a full reload!)\");\r\n\t\t\t\t\tunacceptedModules.forEach(function(moduleId) {\r\n\t\t\t\t\t\tconsole.warn(\"[HMR]  - \" + moduleId);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(!renewedModules || renewedModules.length === 0) {\r\n\t\t\t\t\tconsole.log(\"[HMR] Nothing hot updated.\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(\"[HMR] Updated modules:\");\r\n\t\t\t\t\trenewedModules.forEach(function(moduleId) {\r\n\t\t\t\t\t\tconsole.log(\"[HMR]  - \" + moduleId);\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tif(upToDate()) {\r\n\t\t\t\t\tconsole.log(\"[HMR] App is up to date.\");\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t});\r\n\t\t});\r\n\t};\r\n\tvar addEventListener = window.addEventListener ? function(eventName, listener) {\r\n\t\twindow.addEventListener(eventName, listener, false);\r\n\t} : function (eventName, listener) {\r\n\t\twindow.attachEvent('on' + eventName, listener);\r\n\t};\r\n\taddEventListener(\"message\", function(event) {\r\n\t\tif(typeof event.data === \"string\" && event.data.indexOf(\"webpackHotUpdate\") === 0) {\r\n\t\t\tlastData = event.data;\r\n\t\t\tif(!upToDate() && module.hot.status() === \"idle\") {\r\n\t\t\t\tconsole.log(\"[HMR] Checking for updates on the server...\");\r\n\t\t\t\tcheck();\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tconsole.log(\"[HMR] Waiting for update signal from WDS...\");\r\n} else {\r\n\tthrow new Error(\"[HMR] Hot Module Replacement is disabled\");\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/hot/only-dev-server.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/hot/only-dev-server.js?");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n'use strict';\n__webpack_require__.e/* require */(1, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(13)]; (function(_) {}.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));});\nvar React = __webpack_require__(12),\n    App = __webpack_require__(8),\n    Fgraph = __webpack_require__(7);\nwindow.Fgraph = Fgraph;\n\nReact.render(React.createElement(App, null), document.body);\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"index.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/index.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/index.js?");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar getRootInstancesFromReactMount = __webpack_require__(14);\n\nvar injectedProvider = null,\n    didWarn = false;\n\nfunction warnOnce() {\n  if (!didWarn) {\n    console.warn(\n      'It appears that React Hot Loader isn\\'t configured correctly. ' +\n      'If you\\'re using NPM, make sure your dependencies don\\'t drag duplicate React distributions into their node_modules and that require(\"react\") corresponds to the React instance you render your app with.',\n      'If you\\'re using a precompiled version of React, see https://github.com/gaearon/react-hot-loader/tree/master/docs#usage-with-external-react for integration instructions.'\n    );\n  }\n\n  didWarn = true;\n}\n\nvar RootInstanceProvider = {\n  injection: {\n    injectProvider: function (provider) {\n      injectedProvider = provider;\n    }\n  },\n\n  getRootInstances: function (ReactMount) {\n    if (injectedProvider) {\n      return injectedProvider.getRootInstances();\n    }\n\n    var instances = ReactMount && getRootInstancesFromReactMount(ReactMount) || [];\n    if (!Object.keys(instances).length) {\n      warnOnce();\n    }\n\n    return instances;\n  }\n};\n\nmodule.exports = RootInstanceProvider;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/RootInstanceProvider.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/RootInstanceProvider.js?");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isReactClassish = __webpack_require__(15),\n    isReactElementish = __webpack_require__(16);\n\nfunction makeExportsHot(m) {\n  if (isReactElementish(m.exports)) {\n    return false;\n  }\n\n  var freshExports = m.exports,\n      foundReactClasses = false;\n\n  if (isReactClassish(m.exports)) {\n    m.exports = m.makeHot(m.exports, '__MODULE_EXPORTS');\n    foundReactClasses = true;\n  }\n\n  for (var key in m.exports) {\n    if (freshExports.hasOwnProperty(key) &&\n        isReactClassish(freshExports[key])) {\n      if (Object.getOwnPropertyDescriptor(m.exports, key).writable) {\n        m.exports[key] = m.makeHot(freshExports[key], '__MODULE_EXPORTS_' + key);\n        foundReactClasses = true;\n      } else {\n        console.warn(\"Can't make class \" + key + \" hot reloadable due to being read-only. You can exclude files or directories (for example, /node_modules/) using 'exclude' option in loader configuration.\");\n      }\n    }\n  }\n\n  return foundReactClasses;\n}\n\nmodule.exports = makeExportsHot;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/makeExportsHot.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/makeExportsHot.js?");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tmodule.children = [];\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/module.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n'use strict';\n\nvar NodeCollection = __webpack_require__(17);\nvar EdgeCollection = __webpack_require__(18);\n\n\n  function Egraph(args){\n    this.nodes = new NodeCollection(args.nodes, this);\n    this.edges = new EdgeCollection(args.edges, this);\n  }\n\n\nvar data = {\n  nodes: [\n    {pid: 2, etype: 'estimate', eprops:{name: 'people in the Europe', value: 10}},\n    {pid: 3, etype: 'estimate', eprops:{name: 'people in the US', value: 10}},\n    {pid: 4, etype: 'function', eprops:{ftype: 'add'}},\n    {pid: 5, etype: 'dependent', eprops:{name: 'people in World'}},\n    {pid: 6, etype: 'function', eprops:{ftype: 'multiply'}},\n    {pid: 7, etype: 'dependent', eprops:{name: 'people in Universe'}},\n    {pid: 8, etype: 'estimate', eprops:{name: 'universe/person ratio', value: 200}},\n    {pid: 9, etype: 'estimate', eprops:{name: 'other thing', value: 2}}\n  ],\n  edges: [\n    [2,4],\n    [3,4],\n    [4,5],\n    [5,6],\n    [6,7],\n    [8,6],\n    [6,9]\n  ]\n}\nvar Fgraph = new Egraph(data);\n\nmodule.exports = Fgraph;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"fgraph.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/fgraph.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/fgraph.js?");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n'use strict';\n\nvar Backbone = __webpack_require__(43);\nvar _ = __webpack_require__(20);\nvar ReactBootstrap = __webpack_require__(44);\n\nvar Input = ReactBootstrap.Input;\nvar Button = ReactBootstrap.Button;\nvar ButtonToolbar = ReactBootstrap.ButtonToolbar;\nvar Row = ReactBootstrap.Row;\nvar Col = ReactBootstrap.Col;\n\nvar $ = __webpack_require__(45);\nvar React = __webpack_require__(12);\nvar Reflux = __webpack_require__(40);\nvar FermActions = __webpack_require__(21);\nvar fermListStore = __webpack_require__(22);\nvar fermEditingStore = __webpack_require__(23);\nvar maingraph = __webpack_require__(24);\n\n    var NewButtonPane = React.createClass({displayName: \"NewButtonPane\",\n      newEstimate: function(){\n        this.props.addItem('estimate')\n      },\n      newFunction: function(){\n        this.props.addItem('function')\n      },\n      render: function() {\n        return (\n          React.createElement(\"div\", null, \n            React.createElement(Button, {onClick: this.newEstimate}, \" New Estimate \"), \n            React.createElement(Button, {onClick: this.newFunction}, \" New Function \")\n          )\n        )\n      }\n    });\n\n    var GraphPane = React.createClass({displayName: \"GraphPane\",\n      handleClick: function() {\n        FermActions.addItem();\n      },\n      formatNodes: function() {\n        var functions_objects= {'multiplication': 'x', 'addition': '+'}\n        var nodes = _.map(this.props.data, function(d){\n          var e = _.clone(d);\n          if (e['type'] === 'function'){\n            e['name'] = functions_objects[e['function']]\n          };\n          e['nodeId'] = e['id']\n          e['id'] = 'n' + e['id'] // Nodes need letters for cytoscape\n          e = _.pick(e, ['id', 'nodeId', 'name', 'value', 'type'])\n//-          positions =  d.position\n          //return {data: e, position: positions}\n          return {data: e}\n        })\n        return nodes\n      },\n      formatEdges: function() {\n        var functionNodes = _.where(this.props.data, {type: 'function'})\n        var edges = []\n         _(functionNodes).forEach(function(node){\n            _(node.inputs).forEach(function(input){\n              var edge = {}\n              edge['id'] = node.id + '-' + input\n              edge['target'] =  'n' + node.id\n              edge['source'] = 'n' + input\n              edges.push({data:edge})\n            })\n            _([node.output]).forEach(function(output){\n              var edge = {}\n              edge['id'] = node.id + '-' + output\n              edge['target'] =  'n' + output\n              edge['source'] = 'n' + node.id\n              edges.push({data:edge})\n            })\n          })\n\n        return edges;\n      },\n      updateAllPositions: function(){\n        var oldLocations = _.map(this.props.data, function(n){return {id: n.id, renderedPosition: n.renderedPosition}})\n        var newLocations = _.map(maingraph.cy.nodes(), function(n){return {id: n.data().nodeId, renderedPosition: n.renderedPosition()}})\n        if (!_.isEqual(oldLocations, newLocations)) {\n          FermActions.updateList(newLocations);\n        }\n      },\n      componentWillUpdate: function() {\n        this.updateAllPositions();\n      },\n      componentDidMount: function() {\n        var el = $('.maingraph')[0];\n        maingraph.create(el, this.formatNodes(), this.formatEdges(), this.props.updateEditingNode, this.updatePositions, this.updateAllPositions);\n        this.updateAllPositions();\n      },\n      componentDidUpdate: function(){\n        maingraph.update(this.formatNodes(), this.formatEdges());\n      },\n      updatePositions: function(id, position){\n        // FermActions.updateItem(id, {position:position});\n      },\n      render: function() {\n        return (\n          React.createElement(\"div\", {className: \"maingraph\"})\n        )\n      }\n    });\n\n    var EditorPane = React.createClass({displayName: \"EditorPane\",\n      render: function() {\n\n        var isEstimate = (this.props.item && this.props.item.type === 'estimate')\n        var isResult = (this.props.item && this.props.item.type === 'result')\n        var isFunction = (this.props.item && this.props.item.type === 'function')\n        var form = ''\n        if (isEstimate){\n          form = React.createElement(EstimateForm, {node: this.props.item})\n        }\n        else if (isResult){\n          form = React.createElement(ResultForm, {node: this.props.item})\n        }\n        else if (isFunction){\n          form = React.createElement(FunctionForm, {nodeList: this.props.nodeList, node: this.props.item})\n        }\n        if (form !== ''){\n          var divStyle = {left: this.props.item.renderedPosition.x - 85, top: this.props.item.renderedPosition.y + 20};\n          form = React.createElement(\"div\", {className: \"well wowo\", style: divStyle}, \" \", form, \" \")\n          }\n        return (\n          React.createElement(\"div\", {className: \"editorpane\"}, \n            form, \n            React.createElement(NewButtonPane, {addItem: this.props.addItem})\n          )\n        )\n      }\n    });\n\n    var ResultForm = React.createClass({displayName: \"ResultForm\",\n      handleChange: function(evt) {\n        form_values = $(evt.target.parentElement.childNodes).filter(\":input\")\n        values = {};\n        values[form_values[0].name] = form_values.val();\n        FermActions.updateItem(this.props.node.id, values);\n      },\n      handleDestroy: function() {\n        FermActions.removeItem(this.props.node.id);\n      },\n      render: function() {\n        return (\n          React.createElement(\"form\", null, \n            React.createElement(Input, {type: \"text\", label: \"name\", name: \"name\", value: this.props.node.name, onChange: this.handleChange}), \n            React.createElement(\"div\", {className: \"btn btn-danger\", onClick: this.handleDestroy}, \" Destroy \")\n          )\n        );\n      }\n    });\n\n    var EstimateForm = React.createClass({displayName: \"EstimateForm\",\n      handleChange: function(evt) {\n        form_values = $(evt.target.parentElement.childNodes).filter(\":input\")\n        values = {};\n        values[form_values[0].name] = form_values.val();\n        FermActions.updateItem(this.props.node.id, values);\n      },\n      focusForm: function(){\n        $(this.refs.name.getDOMNode()).find('input').focus()\n\n      },\n      componentDidMount: function(){\n        this.focusForm()\n      },\n      componentDidUpdate: function(prevProps){\n        if (prevProps.node.id !== this.props.node.id){\n          this.focusForm()\n        }\n      },\n      handleDestroy: function() {\n        FermActions.removeItem(this.props.node.id);\n      },\n      render: function() {\n        return (\n          React.createElement(\"form\", null, \n            React.createElement(Input, {key: \"foobar\", ref: \"name\", type: \"text\", label: \"name\", name: \"name\", value: this.props.node.name, onChange: this.handleChange}), \n            React.createElement(Input, {type: \"text\", label: \"value\", name: \"value\", defaultValue: \"0\", value: this.props.node.value, onChange: this.handleChange}), \n            React.createElement(Input, {type: \"text\", label: \"unit\", name: \"unit\", defaultValue: \"0\", value: this.props.node.unit, onChange: this.handleChange}), \n          React.createElement(\"div\", {className: \"btn btn-danger\", onClick: this.handleDestroy}, \" Destroy \")\n          )\n        );\n      }\n    });\n\n    var FunctionForm = React.createClass({displayName: \"FunctionForm\",\n      handleChange: function(evt) {\n        form_values = $(evt.target.parentElement.childNodes).filter(\":input\")\n        values = {};\n        values[form_values[0].name] = form_values.val();\n        FermActions.updateItem(this.props.node.id, values);\n      },\n      handleDestroy: function() {\n        FermActions.removeItem(this.props.node.id);\n      },\n      render: function() {\n        var node = this.props.node;\n        var possibleInputNodes = _.filter(this.props.nodeList, function(n){\n          isNotFunction = (n.type !== 'function');\n          isNotNodeOutput = (n.id !== node.output);\n          return (isNotFunction && isNotNodeOutput);\n        });\n        var possibleInputs = _.map(possibleInputNodes, function(n){\n          return React.createElement(\"option\", {value: n.id}, n.id, \"--\", n.name, n.value)\n        });\n        return (\n          React.createElement(\"form\", null, \n            React.createElement(Input, {type: \"select\", label: \"Function\", name: \"function\", defaultValue: \"addition\", value: this.props.node.function, onChange: this.handleChange}, \n                React.createElement(\"option\", {value: \"addition\"}, \"(+) Addition \"), \n                React.createElement(\"option\", {value: \"multiplication\"}, \"(x) Multiplication \")\n            ), \n            React.createElement(Input, {type: \"select\", label: \"Multiple Select\", multiple: true, name: \"inputs\", value: this.props.node.inputs, onChange: this.handleChange, className: \"function-multiple-form\"}, \n              possibleInputs\n            ), \n          React.createElement(\"div\", {className: \"btn btn-danger\", onClick: this.handleDestroy}, \" Destroy \")\n          )\n        );\n      }\n    });\n\n    var App = React.createClass({displayName: \"App\",\n      mixins: [\n        Reflux.connect(fermListStore, \"list\"),\n        Reflux.connect(fermEditingStore, \"editingNode\")\n      ],\n      getItemById: function(itemId){\n        if (itemId){\n          return _.find(this.state.list, function(item){\n            return item.id === itemId;\n          });\n        }\n      },\n      handleThis: function(e){\n        switch (e.keyCode) {\n          case 68: // delete\n          case 70:\n          default:\n        };\n      },\n      componentDidMount: function(){\n        addEventListener(\"keydown\", this.handleThis);\n      },\n      getEditingNode: function(){\n        var id = this.state.editingNodeId;\n        var node = this.getItemById(this.state.list, id);\n        return node;\n      },\n      addItem: function(type){\n        FermActions.addItem(type)\n      },\n      updateEditingNode: function(nodeId){\n        FermActions.updateEditingNode(nodeId)\n      },\n      getDecorateList: function(){\n        var EditingNode = _.find(this.list, function(item){\n          return item.id === itemId;\n        });\n        var newList = (_.filter(this.list,function(item){\n            return item.id!==itemId;\n        }));\n        return newlist;\n      },\n      render: function() {\n        return (\n          React.createElement(\"div\", null, \n              React.createElement(GraphPane, {data: this.state.list, updateEditingNode: this.updateEditingNode}), \n              React.createElement(EditorPane, {nodeList: this.state.list, addItem: this.addItem, item: this.getEditingNode()})\n          )\n        );\n      }\n    });\n\nmodule.exports = App;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"app.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/flux/components/app.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/flux/components/app.js?");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(19);\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)-dev-server/client/web_modules/socket.io/index.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)-dev-server/client/web_modules/socket.io/index.js?");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n\"use strict\";\n\nvar DOMProperty = __webpack_require__(25);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactCurrentOwner = __webpack_require__(27);\nvar ReactElement = __webpack_require__(28);\nvar ReactLegacyElement = __webpack_require__(29);\nvar ReactInstanceHandles = __webpack_require__(30);\nvar ReactPerf = __webpack_require__(31);\n\nvar containsNode = __webpack_require__(32);\nvar deprecated = __webpack_require__(33);\nvar getReactRootElementInContainer = __webpack_require__(34);\nvar instantiateReactComponent = __webpack_require__(35);\nvar invariant = __webpack_require__(36);\nvar shouldUpdateReactComponent = __webpack_require__(37);\nvar warning = __webpack_require__(38);\n\nvar createElement = ReactLegacyElement.wrapCreateElement(\n  ReactElement.createElement\n);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !isValid(cached, id),\n          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',\n          ATTR_NAME, id\n        ) : invariant(!isValid(cached, id)));\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalGetID(node) === id,\n      'ReactMount: Unexpected modification of `%s`',\n      ATTR_NAME\n    ) : invariant(internalGetID(node) === id));\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(\n    targetID,\n    findDeepestCachedAncestorImpl\n  );\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounting is the process of initializing a React component by creatings its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function(\n      prevComponent,\n      nextComponent,\n      container,\n      callback) {\n    var nextProps = nextComponent.props;\n    ReactMount.scrollMonitor(container, function() {\n      prevComponent.replaceProps(nextProps, callback);\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] =\n        getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function(nextComponent, container) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        container.nodeType === ELEMENT_NODE_TYPE ||\n        container.nodeType === DOC_NODE_TYPE\n      ),\n      '_registerComponent(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      container.nodeType === ELEMENT_NODE_TYPE ||\n      container.nodeType === DOC_NODE_TYPE\n    )));\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: ReactPerf.measure(\n    'ReactMount',\n    '_renderNewRootComponent',\n    function(\n        nextComponent,\n        container,\n        shouldReuseMarkup) {\n      // Various parts of our code (such as ReactCompositeComponent's\n      // _renderValidatedComponent) assume that calls to render aren't nested;\n      // verify that that's the case.\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        ReactCurrentOwner.current == null,\n        '_renderNewRootComponent(): Render methods should be a pure function ' +\n        'of props and state; triggering nested component updates from ' +\n        'render is not allowed. If necessary, trigger nested updates in ' +\n        'componentDidUpdate.'\n      ) : null);\n\n      var componentInstance = instantiateReactComponent(nextComponent, null);\n      var reactRootID = ReactMount._registerComponent(\n        componentInstance,\n        container\n      );\n      componentInstance.mountComponentIntoNode(\n        reactRootID,\n        container,\n        shouldReuseMarkup\n      );\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        // Record the root element in case it later gets transplanted.\n        rootElementsByReactRootID[reactRootID] =\n          getReactRootElementInContainer(container);\n      }\n\n      return componentInstance;\n    }\n  ),\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function(nextElement, container, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactElement.isValidElement(nextElement),\n      'renderComponent(): Invalid component element.%s',\n      (\n        typeof nextElement === 'string' ?\n          ' Instead of passing an element string, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        ReactLegacyElement.isValidFactory(nextElement) ?\n          ' Instead of passing a component class, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        // Check if it quacks like a element\n        typeof nextElement.props !== \"undefined\" ?\n          ' This may be caused by unintentionally loading two independent ' +\n          'copies of React.' :\n          ''\n      )\n    ) : invariant(ReactElement.isValidElement(nextElement)));\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(\n          prevComponent,\n          nextElement,\n          container,\n          callback\n        );\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup =\n      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(\n      nextElement,\n      container,\n      shouldReuseMarkup\n    );\n    callback && callback.call(component);\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function(constructor, props, container) {\n    var element = createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function(constructor, props, id) {\n    var domNode = document.getElementById(id);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      domNode,\n      'Tried to get element with id of \"%s\" but it is not present on the page.',\n      id\n    ) : invariant(domNode));\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function(container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      'unmountComponentAtNode(): Render methods should be a pure function of ' +\n      'props and state; triggering nested component updates from render is ' +\n      'not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function(instance, container) {\n    instance.unmountComponent();\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          // Call internalGetID here because getID calls isValid which calls\n          // findReactContainerForID (this function).\n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(// Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          console.warn(\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          );\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function(node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function(node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      false,\n      'findComponentRoot(..., %s): Unable to find element. This probably ' +\n      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +\n      'usually due to forgetting a <tbody> when using tables, nesting tags ' +\n      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +\n      'parent. ' +\n      'Try inspecting the child nodes of the element with React ID `%s`.',\n      targetID,\n      ReactMount.getID(ancestorNode)\n    ) : invariant(false));\n  },\n\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  purgeID: purgeID\n};\n\n// Deprecations (remove for 0.13)\nReactMount.renderComponent = deprecated(\n  'ReactMount',\n  'renderComponent',\n  'render',\n  this,\n  ReactMount.render\n);\n\nmodule.exports = ReactMount;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMount.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMount.js?");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(39);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/index.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/index.js?");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(41);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/react.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/react.js?");

/***/ },
/* 13 */,
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nfunction getRootInstancesFromReactMount(ReactMount) {\n  return ReactMount._instancesByReactRootID || ReactMount._instancesByContainerID || [];\n}\n\nmodule.exports = getRootInstancesFromReactMount;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/getRootInstancesFromReactMount.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/getRootInstancesFromReactMount.js?");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("function isReactClassish(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (obj.prototype && typeof obj.prototype.render === 'function') {\n    // React 0.13\n    return true;\n  }\n\n  if (obj.type && obj.type.prototype && typeof obj.type.prototype.render === 'function') {\n    // React 0.12 and earlier\n    return true;\n  }\n\n  return false;\n}\n\nmodule.exports = isReactClassish;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/isReactClassish.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/isReactClassish.js?");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isReactClassish = __webpack_require__(15);\n\nfunction isReactElementish(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  return Object.prototype.toString.call(obj.props) === '[object Object]' &&\n         isReactClassish(obj.type);\n}\n\nmodule.exports = isReactElementish;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/isReactElementish.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/isReactElementish.js?");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n'use strict';\n\nvar Backbone = __webpack_require__(43);\n__webpack_require__.e/* require */(1/* duplicate */, function(__webpack_require__) { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(13)]; (function(_) {}.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));});\n\nvar multiply = {\n  name: 'multiplication',\n  sign: '*',\n  apply:function(inputs){\n    var product = _.reduce(inputs, function(product, n) { return product * n; })\n    return product;\n  }\n}\n\nvar add = {\n  name: 'addition',\n  sign: '+',\n  apply:function(inputs){\n    var sum = _.reduce(inputs, function(sum, n) { return sum + n; });\n    return sum;\n  }\n}\n\nvar efunctions = {\n  'mult': multiply,\n  'add': add\n}\n\nfunction MakeFunction(node){\n  var ftype = node.get('eprops').ftype\n  node.efunction = efunctions[ftype]\n  node.dependent = function(){ return node.outputs()[0] }\n  node.run = function(){\n    result = node._run_math()\n    node.dependent().updateValue(result)\n  }\n  node._run_math = function(){\n    inputValues = node.inputValues()\n    return node.efunction.apply(inputValues)\n  }\n}\n\nfunction MakeEstimate(node){\n  node.ttype = function(){\n    return 'estimat'\n  }\n}\nfunction MakeDependent(node){\n  node.cost = function(){\n    return 'dep'\n  },\n  node.value = null\n  node.propogate = function(){\n    node.outputs().forEach( function(e)  {return console.log(e.id);} )\n  }\n  node.updateValue = function(n){ node.value = n; node.propogate() }\n}\n\nvar ____Class0=Backbone.Model;for(var ____Class0____Key in ____Class0){if(____Class0.hasOwnProperty(____Class0____Key)){Enode[____Class0____Key]=____Class0[____Class0____Key];}}var ____SuperProtoOf____Class0=____Class0===null?null:____Class0.prototype;Enode.prototype=Object.create(____SuperProtoOf____Class0);Enode.prototype.constructor=Enode;Enode.__superConstructor__=____Class0;function Enode(){if(____Class0!==null){____Class0.apply(this,arguments);}}\n  Enode.prototype.defaults=function(){\n    return {\n      foo: 'sillybar',\n      completed: 'false'\n    }\n  };\n  Enode.prototype.initialize=function(attributes){\n    this.id = attributes.pid;\n    this.inputEdges = [];\n    this.outputEdges = [];\n\n    if (this.get('etype') === 'function'){ MakeFunction(this) }\n    if (this.get('etype') === 'estimate'){ MakeEstimate(this) }\n    if (this.get('etype') === 'dependent'){ MakeDependent(this) }\n  };\n  Enode.prototype.inputValues=function(){\n    return _.map(this.inputs(), function(i){ return i.get('eprops').value})\n  };\n  Enode.prototype.outputs=function(){\n    return _.map(this.outputEdges, function(e) {return e.outputNode})\n  };\n  Enode.prototype.inputs=function(){\n    return _.map(this.inputEdges, function(e) {return e.inputNode})\n  };\n  Enode.prototype.addInputEdge=function(inputEdge){\n    this.inputEdges.push(inputEdge)\n  };\n  Enode.prototype.addOutputEdge=function(outputEdge){\n    this.outputEdges.push(outputEdge)\n  };\n  Enode.prototype.toString=function(indent){\n    indent = indent || 0\n    console.log(this)\n    var pid = this.get('pid')\n    var etype = this.get('etype')\n    //display = this.display\n    //d\n    console.log(this)\n    var outputs = _.map(this.outputs(), function(e){return e.toString(indent + 1)})\n    var out_s = \"\"\n    if (outputs.length > 0){\n      var out_s = ' outputs => \\n' + outputs.joint('\\n')\n    }\n    sstring = (Array(indent*3).join('.')) + \"([\" + pid + etype + \"]\" + out_s + \")\"\n    return sstring\n  };\n\n\nvar NodeCollection = Backbone.Collection.extend({\n    model: Enode,\n    initialize:function(collection, graph){\n      this.graph = graph\n    }\n});\n\nmodule.exports = NodeCollection;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"nodecollection.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/nodecollection.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/nodecollection.js?");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n'use strict';\n\n//var Enode = require('./enode');\nvar Backbone = __webpack_require__(43);\n\nvar ____Class1=Backbone.Model;for(var ____Class1____Key in ____Class1){if(____Class1.hasOwnProperty(____Class1____Key)){Edge[____Class1____Key]=____Class1[____Class1____Key];}}var ____SuperProtoOf____Class1=____Class1===null?null:____Class1.prototype;Edge.prototype=Object.create(____SuperProtoOf____Class1);Edge.prototype.constructor=Edge;Edge.__superConstructor__=____Class1;function Edge(){if(____Class1!==null){____Class1.apply(this,arguments);}}\n  Edge.prototype.defaults=function(){\n  };\n  Edge.prototype.initialize=function(attributes){\n    this.inputNode = this.collection.graph.nodes.get(attributes[0]);\n    this.outputNode =  this.collection.graph.nodes.get(attributes[1]);\n    this.outputNode.addInputEdge(this)\n    this.inputNode.addOutputEdge(this)\n  };\n\n\nvar EdgeCollection = Backbone.Collection.extend({\n    model: Edge,\n    initialize:function(collection, graph){\n      this.graph = graph\n    }\n});\n\nmodule.exports = EdgeCollection;\n\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"edgecollection.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/edgecollection.js\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/edgecollection.js?");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/*! Socket.IO.js build:0.9.10, development. Copyright(c) 2011 LearnBoost <dev@learnboost.com> MIT Licensed */\r\n\r\nvar io = (false ? {} : module.exports);\r\n(function() {\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, global) {\r\n\r\n  /**\r\n   * IO namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var io = exports;\r\n\r\n  /**\r\n   * Socket.IO version\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.version = '0.9.10';\r\n\r\n  /**\r\n   * Protocol implemented.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.protocol = 1;\r\n\r\n  /**\r\n   * Available transports, these will be populated with the available transports\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  io.transports = [];\r\n\r\n  /**\r\n   * Keep track of jsonp callbacks.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.j = [];\r\n\r\n  /**\r\n   * Keep track of our io.Sockets\r\n   *\r\n   * @api private\r\n   */\r\n  io.sockets = {};\r\n\r\n\r\n  /**\r\n   * Manages connections to hosts.\r\n   *\r\n   * @param {String} uri\r\n   * @Param {Boolean} force creation of new socket (defaults to false)\r\n   * @api public\r\n   */\r\n\r\n  io.connect = function (host, details) {\r\n    var uri = io.util.parseUri(host)\r\n      , uuri\r\n      , socket;\r\n\r\n    if (global && global.location) {\r\n      uri.protocol = uri.protocol || global.location.protocol.slice(0, -1);\r\n      uri.host = uri.host || (global.document\r\n        ? global.document.domain : global.location.hostname);\r\n      uri.port = uri.port || global.location.port;\r\n    }\r\n\r\n    uuri = io.util.uniqueUri(uri);\r\n\r\n    var options = {\r\n        host: uri.host\r\n      , secure: 'https' == uri.protocol\r\n      , port: uri.port || ('https' == uri.protocol ? 443 : 80)\r\n      , query: uri.query || ''\r\n    };\r\n\r\n    io.util.merge(options, details);\r\n\r\n    if (options['force new connection'] || !io.sockets[uuri]) {\r\n      socket = new io.Socket(options);\r\n    }\r\n\r\n    if (!options['force new connection'] && socket) {\r\n      io.sockets[uuri] = socket;\r\n    }\r\n\r\n    socket = socket || io.sockets[uuri];\r\n\r\n    // if path is different from '' or /\r\n    return socket.of(uri.path.length > 1 ? uri.path : '');\r\n  };\r\n\r\n})(true ? module.exports : (this.io = {}), this);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, global) {\r\n\r\n  /**\r\n   * Utilities namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var util = exports.util = {};\r\n\r\n  /**\r\n   * Parses an URI\r\n   *\r\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n   * @api public\r\n   */\r\n\r\n  var re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password',\r\n               'host', 'port', 'relative', 'path', 'directory', 'file', 'query',\r\n               'anchor'];\r\n\r\n  util.parseUri = function (str) {\r\n    var m = re.exec(str || '')\r\n      , uri = {}\r\n      , i = 14;\r\n\r\n    while (i--) {\r\n      uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    return uri;\r\n  };\r\n\r\n  /**\r\n   * Produces a unique url that identifies a Socket.IO connection.\r\n   *\r\n   * @param {Object} uri\r\n   * @api public\r\n   */\r\n\r\n  util.uniqueUri = function (uri) {\r\n    var protocol = uri.protocol\r\n      , host = uri.host\r\n      , port = uri.port;\r\n\r\n    if ('document' in global) {\r\n      host = host || document.domain;\r\n      port = port || (protocol == 'https'\r\n        && document.location.protocol !== 'https:' ? 443 : document.location.port);\r\n    } else {\r\n      host = host || 'localhost';\r\n\r\n      if (!port && protocol == 'https') {\r\n        port = 443;\r\n      }\r\n    }\r\n\r\n    return (protocol || 'http') + '://' + host + ':' + (port || 80);\r\n  };\r\n\r\n  /**\r\n   * Mergest 2 query strings in to once unique query string\r\n   *\r\n   * @param {String} base\r\n   * @param {String} addition\r\n   * @api public\r\n   */\r\n\r\n  util.query = function (base, addition) {\r\n    var query = util.chunkQuery(base || '')\r\n      , components = [];\r\n\r\n    util.merge(query, util.chunkQuery(addition || ''));\r\n    for (var part in query) {\r\n      if (query.hasOwnProperty(part)) {\r\n        components.push(part + '=' + query[part]);\r\n      }\r\n    }\r\n\r\n    return components.length ? '?' + components.join('&') : '';\r\n  };\r\n\r\n  /**\r\n   * Transforms a querystring in to an object\r\n   *\r\n   * @param {String} qs\r\n   * @api public\r\n   */\r\n\r\n  util.chunkQuery = function (qs) {\r\n    var query = {}\r\n      , params = qs.split('&')\r\n      , i = 0\r\n      , l = params.length\r\n      , kv;\r\n\r\n    for (; i < l; ++i) {\r\n      kv = params[i].split('=');\r\n      if (kv[0]) {\r\n        query[kv[0]] = kv[1];\r\n      }\r\n    }\r\n\r\n    return query;\r\n  };\r\n\r\n  /**\r\n   * Executes the given function when the page is loaded.\r\n   *\r\n   *     io.util.load(function () { console.log('page loaded'); });\r\n   *\r\n   * @param {Function} fn\r\n   * @api public\r\n   */\r\n\r\n  var pageLoaded = false;\r\n\r\n  util.load = function (fn) {\r\n    if ('document' in global && document.readyState === 'complete' || pageLoaded) {\r\n      return fn();\r\n    }\r\n\r\n    util.on(global, 'load', fn, false);\r\n  };\r\n\r\n  /**\r\n   * Adds an event.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  util.on = function (element, event, fn, capture) {\r\n    if (element.attachEvent) {\r\n      element.attachEvent('on' + event, fn);\r\n    } else if (element.addEventListener) {\r\n      element.addEventListener(event, fn, capture);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.\r\n   *\r\n   * @param {Boolean} [xdomain] Create a request that can be used cross domain.\r\n   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.\r\n   * @api private\r\n   */\r\n\r\n  util.request = function (xdomain) {\r\n\r\n    if (xdomain && 'undefined' != typeof XDomainRequest) {\r\n      return new XDomainRequest();\r\n    }\r\n\r\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || util.ua.hasCORS)) {\r\n      return new XMLHttpRequest();\r\n    }\r\n\r\n    if (!xdomain) {\r\n      try {\r\n        return new window[(['Active'].concat('Object').join('X'))]('Microsoft.XMLHTTP');\r\n      } catch(e) { }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * XHR based transport constructor.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  /**\r\n   * Change the internal pageLoaded value.\r\n   */\r\n\r\n  if ('undefined' != typeof window) {\r\n    util.load(function () {\r\n      pageLoaded = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Defers a function to ensure a spinner is not displayed by the browser\r\n   *\r\n   * @param {Function} fn\r\n   * @api public\r\n   */\r\n\r\n  util.defer = function (fn) {\r\n    if (!util.ua.webkit || 'undefined' != typeof importScripts) {\r\n      return fn();\r\n    }\r\n\r\n    util.load(function () {\r\n      setTimeout(fn, 100);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Merges two objects.\r\n   *\r\n   * @api public\r\n   */\r\n  \r\n  util.merge = function merge (target, additional, deep, lastseen) {\r\n    var seen = lastseen || []\r\n      , depth = typeof deep == 'undefined' ? 2 : deep\r\n      , prop;\r\n\r\n    for (prop in additional) {\r\n      if (additional.hasOwnProperty(prop) && util.indexOf(seen, prop) < 0) {\r\n        if (typeof target[prop] !== 'object' || !depth) {\r\n          target[prop] = additional[prop];\r\n          seen.push(additional[prop]);\r\n        } else {\r\n          util.merge(target[prop], additional[prop], depth - 1, seen);\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n\r\n  /**\r\n   * Merges prototypes from objects\r\n   *\r\n   * @api public\r\n   */\r\n  \r\n  util.mixin = function (ctor, ctor2) {\r\n    util.merge(ctor.prototype, ctor2.prototype);\r\n  };\r\n\r\n  /**\r\n   * Shortcut for prototypical and static inheritance.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  util.inherit = function (ctor, ctor2) {\r\n    function f() {};\r\n    f.prototype = ctor2.prototype;\r\n    ctor.prototype = new f;\r\n  };\r\n\r\n  /**\r\n   * Checks if the given object is an Array.\r\n   *\r\n   *     io.util.isArray([]); // true\r\n   *     io.util.isArray({}); // false\r\n   *\r\n   * @param Object obj\r\n   * @api public\r\n   */\r\n\r\n  util.isArray = Array.isArray || function (obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Array]';\r\n  };\r\n\r\n  /**\r\n   * Intersects values of two arrays into a third\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.intersect = function (arr, arr2) {\r\n    var ret = []\r\n      , longest = arr.length > arr2.length ? arr : arr2\r\n      , shortest = arr.length > arr2.length ? arr2 : arr;\r\n\r\n    for (var i = 0, l = shortest.length; i < l; i++) {\r\n      if (~util.indexOf(longest, shortest[i]))\r\n        ret.push(shortest[i]);\r\n    }\r\n\r\n    return ret;\r\n  }\r\n\r\n  /**\r\n   * Array indexOf compatibility.\r\n   *\r\n   * @see bit.ly/a5Dxa2\r\n   * @api public\r\n   */\r\n\r\n  util.indexOf = function (arr, o, i) {\r\n    \r\n    for (var j = arr.length, i = i < 0 ? i + j < 0 ? 0 : i + j : i || 0; \r\n         i < j && arr[i] !== o; i++) {}\r\n\r\n    return j <= i ? -1 : i;\r\n  };\r\n\r\n  /**\r\n   * Converts enumerables to array.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.toArray = function (enu) {\r\n    var arr = [];\r\n\r\n    for (var i = 0, l = enu.length; i < l; i++)\r\n      arr.push(enu[i]);\r\n\r\n    return arr;\r\n  };\r\n\r\n  /**\r\n   * UA / engines detection namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  util.ua = {};\r\n\r\n  /**\r\n   * Whether the UA supports CORS for XHR.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\r\n    try {\r\n      var a = new XMLHttpRequest();\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n\r\n    return a.withCredentials != undefined;\r\n  })();\r\n\r\n  /**\r\n   * Detect webkit.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.webkit = 'undefined' != typeof navigator\r\n    && /webkit/i.test(navigator.userAgent);\r\n\r\n   /**\r\n   * Detect iPad/iPhone/iPod.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  util.ua.iDevice = 'undefined' != typeof navigator\r\n      && /iPad|iPhone|iPod/i.test(navigator.userAgent);\r\n\r\n})('undefined' != typeof io ? io : module.exports, this);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.EventEmitter = EventEmitter;\r\n\r\n  /**\r\n   * Event emitter constructor.\r\n   *\r\n   * @api public.\r\n   */\r\n\r\n  function EventEmitter () {};\r\n\r\n  /**\r\n   * Adds a listener\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.on = function (name, fn) {\r\n    if (!this.$events) {\r\n      this.$events = {};\r\n    }\r\n\r\n    if (!this.$events[name]) {\r\n      this.$events[name] = fn;\r\n    } else if (io.util.isArray(this.$events[name])) {\r\n      this.$events[name].push(fn);\r\n    } else {\r\n      this.$events[name] = [this.$events[name], fn];\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  /**\r\n   * Adds a volatile listener.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.once = function (name, fn) {\r\n    var self = this;\r\n\r\n    function on () {\r\n      self.removeListener(name, on);\r\n      fn.apply(this, arguments);\r\n    };\r\n\r\n    on.listener = fn;\r\n    this.on(name, on);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Removes a listener.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.removeListener = function (name, fn) {\r\n    if (this.$events && this.$events[name]) {\r\n      var list = this.$events[name];\r\n\r\n      if (io.util.isArray(list)) {\r\n        var pos = -1;\r\n\r\n        for (var i = 0, l = list.length; i < l; i++) {\r\n          if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\r\n            pos = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (pos < 0) {\r\n          return this;\r\n        }\r\n\r\n        list.splice(pos, 1);\r\n\r\n        if (!list.length) {\r\n          delete this.$events[name];\r\n        }\r\n      } else if (list === fn || (list.listener && list.listener === fn)) {\r\n        delete this.$events[name];\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Removes all listeners for an event.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.removeAllListeners = function (name) {\r\n    if (name === undefined) {\r\n      this.$events = {};\r\n      return this;\r\n    }\r\n\r\n    if (this.$events && this.$events[name]) {\r\n      this.$events[name] = null;\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Gets all listeners for a certain event.\r\n   *\r\n   * @api publci\r\n   */\r\n\r\n  EventEmitter.prototype.listeners = function (name) {\r\n    if (!this.$events) {\r\n      this.$events = {};\r\n    }\r\n\r\n    if (!this.$events[name]) {\r\n      this.$events[name] = [];\r\n    }\r\n\r\n    if (!io.util.isArray(this.$events[name])) {\r\n      this.$events[name] = [this.$events[name]];\r\n    }\r\n\r\n    return this.$events[name];\r\n  };\r\n\r\n  /**\r\n   * Emits an event.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  EventEmitter.prototype.emit = function (name) {\r\n    if (!this.$events) {\r\n      return false;\r\n    }\r\n\r\n    var handler = this.$events[name];\r\n\r\n    if (!handler) {\r\n      return false;\r\n    }\r\n\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n\r\n    if ('function' == typeof handler) {\r\n      handler.apply(this, args);\r\n    } else if (io.util.isArray(handler)) {\r\n      var listeners = handler.slice();\r\n\r\n      for (var i = 0, l = listeners.length; i < l; i++) {\r\n        listeners[i].apply(this, args);\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n/**\r\n * Based on JSON2 (http://www.JSON.org/js.html).\r\n */\r\n\r\n(function (exports, nativeJSON) {\r\n  \"use strict\";\r\n\r\n  // use native JSON if it's available\r\n  if (nativeJSON && nativeJSON.parse){\r\n    return exports.JSON = {\r\n      parse: nativeJSON.parse\r\n    , stringify: nativeJSON.stringify\r\n    }\r\n  }\r\n\r\n  var JSON = exports.JSON = {};\r\n\r\n  function f(n) {\r\n      // Format integers to have at least two digits.\r\n      return n < 10 ? '0' + n : n;\r\n  }\r\n\r\n  function date(d, key) {\r\n    return isFinite(d.valueOf()) ?\r\n        d.getUTCFullYear()     + '-' +\r\n        f(d.getUTCMonth() + 1) + '-' +\r\n        f(d.getUTCDate())      + 'T' +\r\n        f(d.getUTCHours())     + ':' +\r\n        f(d.getUTCMinutes())   + ':' +\r\n        f(d.getUTCSeconds())   + 'Z' : null;\r\n  };\r\n\r\n  var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n      escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n      gap,\r\n      indent,\r\n      meta = {    // table of character substitutions\r\n          '\\b': '\\\\b',\r\n          '\\t': '\\\\t',\r\n          '\\n': '\\\\n',\r\n          '\\f': '\\\\f',\r\n          '\\r': '\\\\r',\r\n          '\"' : '\\\\\"',\r\n          '\\\\': '\\\\\\\\'\r\n      },\r\n      rep;\r\n\r\n\r\n  function quote(string) {\r\n\r\n// If the string contains no control characters, no quote characters, and no\r\n// backslash characters, then we can safely slap some quotes around it.\r\n// Otherwise we must also replace the offending characters with safe escape\r\n// sequences.\r\n\r\n      escapable.lastIndex = 0;\r\n      return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\r\n          var c = meta[a];\r\n          return typeof c === 'string' ? c :\r\n              '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n      }) + '\"' : '\"' + string + '\"';\r\n  }\r\n\r\n\r\n  function str(key, holder) {\r\n\r\n// Produce a string from holder[key].\r\n\r\n      var i,          // The loop counter.\r\n          k,          // The member key.\r\n          v,          // The member value.\r\n          length,\r\n          mind = gap,\r\n          partial,\r\n          value = holder[key];\r\n\r\n// If the value has a toJSON method, call it to obtain a replacement value.\r\n\r\n      if (value instanceof Date) {\r\n          value = date(key);\r\n      }\r\n\r\n// If we were called with a replacer function, then call the replacer to\r\n// obtain a replacement value.\r\n\r\n      if (typeof rep === 'function') {\r\n          value = rep.call(holder, key, value);\r\n      }\r\n\r\n// What happens next depends on the value's type.\r\n\r\n      switch (typeof value) {\r\n      case 'string':\r\n          return quote(value);\r\n\r\n      case 'number':\r\n\r\n// JSON numbers must be finite. Encode non-finite numbers as null.\r\n\r\n          return isFinite(value) ? String(value) : 'null';\r\n\r\n      case 'boolean':\r\n      case 'null':\r\n\r\n// If the value is a boolean or null, convert it to a string. Note:\r\n// typeof null does not produce 'null'. The case is included here in\r\n// the remote chance that this gets fixed someday.\r\n\r\n          return String(value);\r\n\r\n// If the type is 'object', we might be dealing with an object or an array or\r\n// null.\r\n\r\n      case 'object':\r\n\r\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\r\n// so watch out for that case.\r\n\r\n          if (!value) {\r\n              return 'null';\r\n          }\r\n\r\n// Make an array to hold the partial results of stringifying this object value.\r\n\r\n          gap += indent;\r\n          partial = [];\r\n\r\n// Is the value an array?\r\n\r\n          if (Object.prototype.toString.apply(value) === '[object Array]') {\r\n\r\n// The value is an array. Stringify every element. Use null as a placeholder\r\n// for non-JSON values.\r\n\r\n              length = value.length;\r\n              for (i = 0; i < length; i += 1) {\r\n                  partial[i] = str(i, value) || 'null';\r\n              }\r\n\r\n// Join all of the elements together, separated with commas, and wrap them in\r\n// brackets.\r\n\r\n              v = partial.length === 0 ? '[]' : gap ?\r\n                  '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\r\n                  '[' + partial.join(',') + ']';\r\n              gap = mind;\r\n              return v;\r\n          }\r\n\r\n// If the replacer is an array, use it to select the members to be stringified.\r\n\r\n          if (rep && typeof rep === 'object') {\r\n              length = rep.length;\r\n              for (i = 0; i < length; i += 1) {\r\n                  if (typeof rep[i] === 'string') {\r\n                      k = rep[i];\r\n                      v = str(k, value);\r\n                      if (v) {\r\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\r\n                      }\r\n                  }\r\n              }\r\n          } else {\r\n\r\n// Otherwise, iterate through all of the keys in the object.\r\n\r\n              for (k in value) {\r\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\r\n                      v = str(k, value);\r\n                      if (v) {\r\n                          partial.push(quote(k) + (gap ? ': ' : ':') + v);\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n\r\n// Join all of the member texts together, separated with commas,\r\n// and wrap them in braces.\r\n\r\n          v = partial.length === 0 ? '{}' : gap ?\r\n              '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\r\n              '{' + partial.join(',') + '}';\r\n          gap = mind;\r\n          return v;\r\n      }\r\n  }\r\n\r\n// If the JSON object does not yet have a stringify method, give it one.\r\n\r\n  JSON.stringify = function (value, replacer, space) {\r\n\r\n// The stringify method takes a value and an optional replacer, and an optional\r\n// space parameter, and returns a JSON text. The replacer can be a function\r\n// that can replace values, or an array of strings that will select the keys.\r\n// A default replacer method can be provided. Use of the space parameter can\r\n// produce text that is more easily readable.\r\n\r\n      var i;\r\n      gap = '';\r\n      indent = '';\r\n\r\n// If the space parameter is a number, make an indent string containing that\r\n// many spaces.\r\n\r\n      if (typeof space === 'number') {\r\n          for (i = 0; i < space; i += 1) {\r\n              indent += ' ';\r\n          }\r\n\r\n// If the space parameter is a string, it will be used as the indent string.\r\n\r\n      } else if (typeof space === 'string') {\r\n          indent = space;\r\n      }\r\n\r\n// If there is a replacer, it must be a function or an array.\r\n// Otherwise, throw an error.\r\n\r\n      rep = replacer;\r\n      if (replacer && typeof replacer !== 'function' &&\r\n              (typeof replacer !== 'object' ||\r\n              typeof replacer.length !== 'number')) {\r\n          throw new Error('JSON.stringify');\r\n      }\r\n\r\n// Make a fake root object containing our value under the key of ''.\r\n// Return the result of stringifying the value.\r\n\r\n      return str('', {'': value});\r\n  };\r\n\r\n// If the JSON object does not yet have a parse method, give it one.\r\n\r\n  JSON.parse = function (text, reviver) {\r\n  // The parse method takes a text and an optional reviver function, and returns\r\n  // a JavaScript value if the text is a valid JSON text.\r\n\r\n      var j;\r\n\r\n      function walk(holder, key) {\r\n\r\n  // The walk method is used to recursively walk the resulting structure so\r\n  // that modifications can be made.\r\n\r\n          var k, v, value = holder[key];\r\n          if (value && typeof value === 'object') {\r\n              for (k in value) {\r\n                  if (Object.prototype.hasOwnProperty.call(value, k)) {\r\n                      v = walk(value, k);\r\n                      if (v !== undefined) {\r\n                          value[k] = v;\r\n                      } else {\r\n                          delete value[k];\r\n                      }\r\n                  }\r\n              }\r\n          }\r\n          return reviver.call(holder, key, value);\r\n      }\r\n\r\n\r\n  // Parsing happens in four stages. In the first stage, we replace certain\r\n  // Unicode characters with escape sequences. JavaScript handles many characters\r\n  // incorrectly, either silently deleting them, or treating them as line endings.\r\n\r\n      text = String(text);\r\n      cx.lastIndex = 0;\r\n      if (cx.test(text)) {\r\n          text = text.replace(cx, function (a) {\r\n              return '\\\\u' +\r\n                  ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n          });\r\n      }\r\n\r\n  // In the second stage, we run the text against regular expressions that look\r\n  // for non-JSON patterns. We are especially concerned with '()' and 'new'\r\n  // because they can cause invocation, and '=' because it can cause mutation.\r\n  // But just to be safe, we want to reject all unexpected forms.\r\n\r\n  // We split the second stage into 4 regexp operations in order to work around\r\n  // crippling inefficiencies in IE's and Safari's regexp engines. First we\r\n  // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\r\n  // replace all simple value tokens with ']' characters. Third, we delete all\r\n  // open brackets that follow a colon or comma or that begin the text. Finally,\r\n  // we look to see that the remaining characters are only whitespace or ']' or\r\n  // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\r\n\r\n      if (/^[\\],:{}\\s]*$/\r\n              .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\r\n                  .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\r\n                  .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\r\n\r\n  // In the third stage we use the eval function to compile the text into a\r\n  // JavaScript structure. The '{' operator is subject to a syntactic ambiguity\r\n  // in JavaScript: it can begin a block or an object literal. We wrap the text\r\n  // in parens to eliminate the ambiguity.\r\n\r\n          j = eval('(' + text + ')');\r\n\r\n  // In the optional fourth stage, we recursively walk the new structure, passing\r\n  // each name/value pair to a reviver function for possible transformation.\r\n\r\n          return typeof reviver === 'function' ?\r\n              walk({'': j}, '') : j;\r\n      }\r\n\r\n  // If the text is not JSON parseable, then a SyntaxError is thrown.\r\n\r\n      throw new SyntaxError('JSON.parse');\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , typeof JSON !== 'undefined' ? JSON : undefined\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Parser namespace.\r\n   *\r\n   * @namespace\r\n   */\r\n\r\n  var parser = exports.parser = {};\r\n\r\n  /**\r\n   * Packet types.\r\n   */\r\n\r\n  var packets = parser.packets = [\r\n      'disconnect'\r\n    , 'connect'\r\n    , 'heartbeat'\r\n    , 'message'\r\n    , 'json'\r\n    , 'event'\r\n    , 'ack'\r\n    , 'error'\r\n    , 'noop'\r\n  ];\r\n\r\n  /**\r\n   * Errors reasons.\r\n   */\r\n\r\n  var reasons = parser.reasons = [\r\n      'transport not supported'\r\n    , 'client not handshaken'\r\n    , 'unauthorized'\r\n  ];\r\n\r\n  /**\r\n   * Errors advice.\r\n   */\r\n\r\n  var advice = parser.advice = [\r\n      'reconnect'\r\n  ];\r\n\r\n  /**\r\n   * Shortcuts.\r\n   */\r\n\r\n  var JSON = io.JSON\r\n    , indexOf = io.util.indexOf;\r\n\r\n  /**\r\n   * Encodes a packet.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  parser.encodePacket = function (packet) {\r\n    var type = indexOf(packets, packet.type)\r\n      , id = packet.id || ''\r\n      , endpoint = packet.endpoint || ''\r\n      , ack = packet.ack\r\n      , data = null;\r\n\r\n    switch (packet.type) {\r\n      case 'error':\r\n        var reason = packet.reason ? indexOf(reasons, packet.reason) : ''\r\n          , adv = packet.advice ? indexOf(advice, packet.advice) : '';\r\n\r\n        if (reason !== '' || adv !== '')\r\n          data = reason + (adv !== '' ? ('+' + adv) : '');\r\n\r\n        break;\r\n\r\n      case 'message':\r\n        if (packet.data !== '')\r\n          data = packet.data;\r\n        break;\r\n\r\n      case 'event':\r\n        var ev = { name: packet.name };\r\n\r\n        if (packet.args && packet.args.length) {\r\n          ev.args = packet.args;\r\n        }\r\n\r\n        data = JSON.stringify(ev);\r\n        break;\r\n\r\n      case 'json':\r\n        data = JSON.stringify(packet.data);\r\n        break;\r\n\r\n      case 'connect':\r\n        if (packet.qs)\r\n          data = packet.qs;\r\n        break;\r\n\r\n      case 'ack':\r\n        data = packet.ackId\r\n          + (packet.args && packet.args.length\r\n              ? '+' + JSON.stringify(packet.args) : '');\r\n        break;\r\n    }\r\n\r\n    // construct packet with required fragments\r\n    var encoded = [\r\n        type\r\n      , id + (ack == 'data' ? '+' : '')\r\n      , endpoint\r\n    ];\r\n\r\n    // data fragment is optional\r\n    if (data !== null && data !== undefined)\r\n      encoded.push(data);\r\n\r\n    return encoded.join(':');\r\n  };\r\n\r\n  /**\r\n   * Encodes multiple messages (payload).\r\n   *\r\n   * @param {Array} messages\r\n   * @api private\r\n   */\r\n\r\n  parser.encodePayload = function (packets) {\r\n    var decoded = '';\r\n\r\n    if (packets.length == 1)\r\n      return packets[0];\r\n\r\n    for (var i = 0, l = packets.length; i < l; i++) {\r\n      var packet = packets[i];\r\n      decoded += '\\ufffd' + packet.length + '\\ufffd' + packets[i];\r\n    }\r\n\r\n    return decoded;\r\n  };\r\n\r\n  /**\r\n   * Decodes a packet\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  var regexp = /([^:]+):([0-9]+)?(\\+)?:([^:]+)?:?([\\s\\S]*)?/;\r\n\r\n  parser.decodePacket = function (data) {\r\n    var pieces = data.match(regexp);\r\n\r\n    if (!pieces) return {};\r\n\r\n    var id = pieces[2] || ''\r\n      , data = pieces[5] || ''\r\n      , packet = {\r\n            type: packets[pieces[1]]\r\n          , endpoint: pieces[4] || ''\r\n        };\r\n\r\n    // whether we need to acknowledge the packet\r\n    if (id) {\r\n      packet.id = id;\r\n      if (pieces[3])\r\n        packet.ack = 'data';\r\n      else\r\n        packet.ack = true;\r\n    }\r\n\r\n    // handle different packet types\r\n    switch (packet.type) {\r\n      case 'error':\r\n        var pieces = data.split('+');\r\n        packet.reason = reasons[pieces[0]] || '';\r\n        packet.advice = advice[pieces[1]] || '';\r\n        break;\r\n\r\n      case 'message':\r\n        packet.data = data || '';\r\n        break;\r\n\r\n      case 'event':\r\n        try {\r\n          var opts = JSON.parse(data);\r\n          packet.name = opts.name;\r\n          packet.args = opts.args;\r\n        } catch (e) { }\r\n\r\n        packet.args = packet.args || [];\r\n        break;\r\n\r\n      case 'json':\r\n        try {\r\n          packet.data = JSON.parse(data);\r\n        } catch (e) { }\r\n        break;\r\n\r\n      case 'connect':\r\n        packet.qs = data || '';\r\n        break;\r\n\r\n      case 'ack':\r\n        var pieces = data.match(/^([0-9]+)(\\+)?(.*)/);\r\n        if (pieces) {\r\n          packet.ackId = pieces[1];\r\n          packet.args = [];\r\n\r\n          if (pieces[3]) {\r\n            try {\r\n              packet.args = pieces[3] ? JSON.parse(pieces[3]) : [];\r\n            } catch (e) { }\r\n          }\r\n        }\r\n        break;\r\n\r\n      case 'disconnect':\r\n      case 'heartbeat':\r\n        break;\r\n    };\r\n\r\n    return packet;\r\n  };\r\n\r\n  /**\r\n   * Decodes data payload. Detects multiple messages\r\n   *\r\n   * @return {Array} messages\r\n   * @api public\r\n   */\r\n\r\n  parser.decodePayload = function (data) {\r\n    // IE doesn't like data[i] for unicode chars, charAt works fine\r\n    if (data.charAt(0) == '\\ufffd') {\r\n      var ret = [];\r\n\r\n      for (var i = 1, length = ''; i < data.length; i++) {\r\n        if (data.charAt(i) == '\\ufffd') {\r\n          ret.push(parser.decodePacket(data.substr(i + 1).substr(0, length)));\r\n          i += Number(length) + 1;\r\n          length = '';\r\n        } else {\r\n          length += data.charAt(i);\r\n        }\r\n      }\r\n\r\n      return ret;\r\n    } else {\r\n      return [parser.decodePacket(data)];\r\n    }\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.Transport = Transport;\r\n\r\n  /**\r\n   * This is the transport template for all supported transport methods.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function Transport (socket, sessid) {\r\n    this.socket = socket;\r\n    this.sessid = sessid;\r\n  };\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(Transport, io.EventEmitter);\r\n\r\n\r\n  /**\r\n   * Indicates whether heartbeats is enabled for this transport\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.heartbeats = function () {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Handles the response from the server. When a new response is received\r\n   * it will automatically update the timeout, decode the message and\r\n   * forwards the response to the onMessage function for further processing.\r\n   *\r\n   * @param {String} data Response from the server.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onData = function (data) {\r\n    this.clearCloseTimeout();\r\n    \r\n    // If the connection in currently open (or in a reopening state) reset the close \r\n    // timeout since we have just received data. This check is necessary so\r\n    // that we don't reset the timeout on an explicitly disconnected connection.\r\n    if (this.socket.connected || this.socket.connecting || this.socket.reconnecting) {\r\n      this.setCloseTimeout();\r\n    }\r\n\r\n    if (data !== '') {\r\n      // todo: we should only do decodePayload for xhr transports\r\n      var msgs = io.parser.decodePayload(data);\r\n\r\n      if (msgs && msgs.length) {\r\n        for (var i = 0, l = msgs.length; i < l; i++) {\r\n          this.onPacket(msgs[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handles packets.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onPacket = function (packet) {\r\n    this.socket.setHeartbeatTimeout();\r\n\r\n    if (packet.type == 'heartbeat') {\r\n      return this.onHeartbeat();\r\n    }\r\n\r\n    if (packet.type == 'connect' && packet.endpoint == '') {\r\n      this.onConnect();\r\n    }\r\n\r\n    if (packet.type == 'error' && packet.advice == 'reconnect') {\r\n      this.isOpen = false;\r\n    }\r\n\r\n    this.socket.onPacket(packet);\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sets close timeout\r\n   *\r\n   * @api private\r\n   */\r\n  \r\n  Transport.prototype.setCloseTimeout = function () {\r\n    if (!this.closeTimeout) {\r\n      var self = this;\r\n\r\n      this.closeTimeout = setTimeout(function () {\r\n        self.onDisconnect();\r\n      }, this.socket.closeTimeout);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when transport disconnects.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onDisconnect = function () {\r\n    if (this.isOpen) this.close();\r\n    this.clearTimeouts();\r\n    this.socket.onDisconnect();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Called when transport connects\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onConnect = function () {\r\n    this.socket.onConnect();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Clears close timeout\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.clearCloseTimeout = function () {\r\n    if (this.closeTimeout) {\r\n      clearTimeout(this.closeTimeout);\r\n      this.closeTimeout = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Clear timeouts\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.clearTimeouts = function () {\r\n    this.clearCloseTimeout();\r\n\r\n    if (this.reopenTimeout) {\r\n      clearTimeout(this.reopenTimeout);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Sends a packet\r\n   *\r\n   * @param {Object} packet object.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.packet = function (packet) {\r\n    this.send(io.parser.encodePacket(packet));\r\n  };\r\n\r\n  /**\r\n   * Send the received heartbeat message back to server. So the server\r\n   * knows we are still connected.\r\n   *\r\n   * @param {String} heartbeat Heartbeat response from the server.\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onHeartbeat = function (heartbeat) {\r\n    this.packet({ type: 'heartbeat' });\r\n  };\r\n \r\n  /**\r\n   * Called when the transport opens.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onOpen = function () {\r\n    this.isOpen = true;\r\n    this.clearCloseTimeout();\r\n    this.socket.onOpen();\r\n  };\r\n\r\n  /**\r\n   * Notifies the base when the connection with the Socket.IO server\r\n   * has been disconnected.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.onClose = function () {\r\n    var self = this;\r\n\r\n    /* FIXME: reopen delay causing a infinit loop\r\n    this.reopenTimeout = setTimeout(function () {\r\n      self.open();\r\n    }, this.socket.options['reopen delay']);*/\r\n\r\n    this.isOpen = false;\r\n    this.socket.onClose();\r\n    this.onDisconnect();\r\n  };\r\n\r\n  /**\r\n   * Generates a connection url based on the Socket.IO URL Protocol.\r\n   * See <https://github.com/learnboost/socket.io-node/> for more details.\r\n   *\r\n   * @returns {String} Connection url\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.prepareUrl = function () {\r\n    var options = this.socket.options;\r\n\r\n    return this.scheme() + '://'\r\n      + options.host + ':' + options.port + '/'\r\n      + options.resource + '/' + io.protocol\r\n      + '/' + this.name + '/' + this.sessid;\r\n  };\r\n\r\n  /**\r\n   * Checks if the transport is ready to start a connection.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  Transport.prototype.ready = function (socket, fn) {\r\n    fn.call(this);\r\n  };\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.Socket = Socket;\r\n\r\n  /**\r\n   * Create a new `Socket.IO client` which can establish a persistent\r\n   * connection with a Socket.IO enabled server.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  function Socket (options) {\r\n    this.options = {\r\n        port: 80\r\n      , secure: false\r\n      , document: 'document' in global ? document : false\r\n      , resource: 'socket.io'\r\n      , transports: io.transports\r\n      , 'connect timeout': 10000\r\n      , 'try multiple transports': true\r\n      , 'reconnect': true\r\n      , 'reconnection delay': 500\r\n      , 'reconnection limit': Infinity\r\n      , 'reopen delay': 3000\r\n      , 'max reconnection attempts': 10\r\n      , 'sync disconnect on unload': false\r\n      , 'auto connect': true\r\n      , 'flash policy port': 10843\r\n      , 'manualFlush': false\r\n    };\r\n\r\n    io.util.merge(this.options, options);\r\n\r\n    this.connected = false;\r\n    this.open = false;\r\n    this.connecting = false;\r\n    this.reconnecting = false;\r\n    this.namespaces = {};\r\n    this.buffer = [];\r\n    this.doBuffer = false;\r\n\r\n    if (this.options['sync disconnect on unload'] &&\r\n        (!this.isXDomain() || io.util.ua.hasCORS)) {\r\n      var self = this;\r\n      io.util.on(global, 'beforeunload', function () {\r\n        self.disconnectSync();\r\n      }, false);\r\n    }\r\n\r\n    if (this.options['auto connect']) {\r\n      this.connect();\r\n    }\r\n};\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(Socket, io.EventEmitter);\r\n\r\n  /**\r\n   * Returns a namespace listener/emitter for this socket\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.of = function (name) {\r\n    if (!this.namespaces[name]) {\r\n      this.namespaces[name] = new io.SocketNamespace(this, name);\r\n\r\n      if (name !== '') {\r\n        this.namespaces[name].packet({ type: 'connect' });\r\n      }\r\n    }\r\n\r\n    return this.namespaces[name];\r\n  };\r\n\r\n  /**\r\n   * Emits the given event to the Socket and all namespaces\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.publish = function () {\r\n    this.emit.apply(this, arguments);\r\n\r\n    var nsp;\r\n\r\n    for (var i in this.namespaces) {\r\n      if (this.namespaces.hasOwnProperty(i)) {\r\n        nsp = this.of(i);\r\n        nsp.$emit.apply(nsp, arguments);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Performs the handshake\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function empty () { };\r\n\r\n  Socket.prototype.handshake = function (fn) {\r\n    var self = this\r\n      , options = this.options;\r\n\r\n    function complete (data) {\r\n      if (data instanceof Error) {\r\n        self.connecting = false;\r\n        self.onError(data.message);\r\n      } else {\r\n        fn.apply(null, data.split(':'));\r\n      }\r\n    };\r\n\r\n    var url = [\r\n          'http' + (options.secure ? 's' : '') + ':/'\r\n        , options.host + ':' + options.port\r\n        , options.resource\r\n        , io.protocol\r\n        , io.util.query(this.options.query, 't=' + +new Date)\r\n      ].join('/');\r\n\r\n    if (this.isXDomain() && !io.util.ua.hasCORS) {\r\n      var insertAt = document.getElementsByTagName('script')[0]\r\n        , script = document.createElement('script');\r\n\r\n      script.src = url + '&jsonp=' + io.j.length;\r\n      insertAt.parentNode.insertBefore(script, insertAt);\r\n\r\n      io.j.push(function (data) {\r\n        complete(data);\r\n        script.parentNode.removeChild(script);\r\n      });\r\n    } else {\r\n      var xhr = io.util.request();\r\n\r\n      xhr.open('GET', url, true);\r\n      if (this.isXDomain()) {\r\n        xhr.withCredentials = true;\r\n      }\r\n      xhr.onreadystatechange = function () {\r\n        if (xhr.readyState == 4) {\r\n          xhr.onreadystatechange = empty;\r\n\r\n          if (xhr.status == 200) {\r\n            complete(xhr.responseText);\r\n          } else if (xhr.status == 403) {\r\n            self.onError(xhr.responseText);\r\n          } else {\r\n            self.connecting = false;            \r\n            !self.reconnecting && self.onError(xhr.responseText);\r\n          }\r\n        }\r\n      };\r\n      xhr.send(null);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Find an available transport based on the options supplied in the constructor.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.getTransport = function (override) {\r\n    var transports = override || this.transports, match;\r\n\r\n    for (var i = 0, transport; transport = transports[i]; i++) {\r\n      if (io.Transport[transport]\r\n        && io.Transport[transport].check(this)\r\n        && (!this.isXDomain() || io.Transport[transport].xdomainCheck(this))) {\r\n        return new io.Transport[transport](this, this.sessionid);\r\n      }\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * Connects to the server.\r\n   *\r\n   * @param {Function} [fn] Callback.\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.connect = function (fn) {\r\n    if (this.connecting) {\r\n      return this;\r\n    }\r\n\r\n    var self = this;\r\n    self.connecting = true;\r\n    \r\n    this.handshake(function (sid, heartbeat, close, transports) {\r\n      self.sessionid = sid;\r\n      self.closeTimeout = close * 1000;\r\n      self.heartbeatTimeout = heartbeat * 1000;\r\n      if(!self.transports)\r\n          self.transports = self.origTransports = (transports ? io.util.intersect(\r\n              transports.split(',')\r\n            , self.options.transports\r\n          ) : self.options.transports);\r\n\r\n      self.setHeartbeatTimeout();\r\n\r\n      function connect (transports){\r\n        if (self.transport) self.transport.clearTimeouts();\r\n\r\n        self.transport = self.getTransport(transports);\r\n        if (!self.transport) return self.publish('connect_failed');\r\n\r\n        // once the transport is ready\r\n        self.transport.ready(self, function () {\r\n          self.connecting = true;\r\n          self.publish('connecting', self.transport.name);\r\n          self.transport.open();\r\n\r\n          if (self.options['connect timeout']) {\r\n            self.connectTimeoutTimer = setTimeout(function () {\r\n              if (!self.connected) {\r\n                self.connecting = false;\r\n\r\n                if (self.options['try multiple transports']) {\r\n                  var remaining = self.transports;\r\n\r\n                  while (remaining.length > 0 && remaining.splice(0,1)[0] !=\r\n                         self.transport.name) {}\r\n\r\n                    if (remaining.length){\r\n                      connect(remaining);\r\n                    } else {\r\n                      self.publish('connect_failed');\r\n                    }\r\n                }\r\n              }\r\n            }, self.options['connect timeout']);\r\n          }\r\n        });\r\n      }\r\n\r\n      connect(self.transports);\r\n\r\n      self.once('connect', function (){\r\n        clearTimeout(self.connectTimeoutTimer);\r\n\r\n        fn && typeof fn == 'function' && fn();\r\n      });\r\n    });\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Clears and sets a new heartbeat timeout using the value given by the\r\n   * server during the handshake.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.setHeartbeatTimeout = function () {\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n    if(this.transport && !this.transport.heartbeats()) return;\r\n\r\n    var self = this;\r\n    this.heartbeatTimeoutTimer = setTimeout(function () {\r\n      self.transport.onClose();\r\n    }, this.heartbeatTimeout);\r\n  };\r\n\r\n  /**\r\n   * Sends a message.\r\n   *\r\n   * @param {Object} data packet.\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.packet = function (data) {\r\n    if (this.connected && !this.doBuffer) {\r\n      this.transport.packet(data);\r\n    } else {\r\n      this.buffer.push(data);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sets buffer state\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.setBuffer = function (v) {\r\n    this.doBuffer = v;\r\n\r\n    if (!v && this.connected && this.buffer.length) {\r\n      if (!this.options['manualFlush']) {\r\n        this.flushBuffer();\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Flushes the buffer data over the wire.\r\n   * To be invoked manually when 'manualFlush' is set to true.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.flushBuffer = function() {\r\n    this.transport.payload(this.buffer);\r\n    this.buffer = [];\r\n  };\r\n  \r\n\r\n  /**\r\n   * Disconnect the established connect.\r\n   *\r\n   * @returns {io.Socket}\r\n   * @api public\r\n   */\r\n\r\n  Socket.prototype.disconnect = function () {\r\n    if (this.connected || this.connecting) {\r\n      if (this.open) {\r\n        this.of('').packet({ type: 'disconnect' });\r\n      }\r\n\r\n      // handle disconnection immediately\r\n      this.onDisconnect('booted');\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnects the socket with a sync XHR.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.disconnectSync = function () {\r\n    // ensure disconnection\r\n    var xhr = io.util.request();\r\n    var uri = [\r\n        'http' + (this.options.secure ? 's' : '') + ':/'\r\n      , this.options.host + ':' + this.options.port\r\n      , this.options.resource\r\n      , io.protocol\r\n      , ''\r\n      , this.sessionid\r\n    ].join('/') + '/?disconnect=1';\r\n\r\n    xhr.open('GET', uri, false);\r\n    xhr.send(null);\r\n\r\n    // handle disconnection immediately\r\n    this.onDisconnect('booted');\r\n  };\r\n\r\n  /**\r\n   * Check if we need to use cross domain enabled transports. Cross domain would\r\n   * be a different port or different domain name.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.isXDomain = function () {\r\n\r\n    var port = global.location.port ||\r\n      ('https:' == global.location.protocol ? 443 : 80);\r\n\r\n    return this.options.host !== global.location.hostname \r\n      || this.options.port != port;\r\n  };\r\n\r\n  /**\r\n   * Called upon handshake.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onConnect = function () {\r\n    if (!this.connected) {\r\n      this.connected = true;\r\n      this.connecting = false;\r\n      if (!this.doBuffer) {\r\n        // make sure to flush the buffer\r\n        this.setBuffer(false);\r\n      }\r\n      this.emit('connect');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called when the transport opens\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onOpen = function () {\r\n    this.open = true;\r\n  };\r\n\r\n  /**\r\n   * Called when the transport closes.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onClose = function () {\r\n    this.open = false;\r\n    clearTimeout(this.heartbeatTimeoutTimer);\r\n  };\r\n\r\n  /**\r\n   * Called when the transport first opens a connection\r\n   *\r\n   * @param text\r\n   */\r\n\r\n  Socket.prototype.onPacket = function (packet) {\r\n    this.of(packet.endpoint).onPacket(packet);\r\n  };\r\n\r\n  /**\r\n   * Handles an error.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onError = function (err) {\r\n    if (err && err.advice) {\r\n      if (err.advice === 'reconnect' && (this.connected || this.connecting)) {\r\n        this.disconnect();\r\n        if (this.options.reconnect) {\r\n          this.reconnect();\r\n        }\r\n      }\r\n    }\r\n\r\n    this.publish('error', err && err.reason ? err.reason : err);\r\n  };\r\n\r\n  /**\r\n   * Called when the transport disconnects.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.onDisconnect = function (reason) {\r\n    var wasConnected = this.connected\r\n      , wasConnecting = this.connecting;\r\n\r\n    this.connected = false;\r\n    this.connecting = false;\r\n    this.open = false;\r\n\r\n    if (wasConnected || wasConnecting) {\r\n      this.transport.close();\r\n      this.transport.clearTimeouts();\r\n      if (wasConnected) {\r\n        this.publish('disconnect', reason);\r\n\r\n        if ('booted' != reason && this.options.reconnect && !this.reconnecting) {\r\n          this.reconnect();\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Called upon reconnection.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  Socket.prototype.reconnect = function () {\r\n    this.reconnecting = true;\r\n    this.reconnectionAttempts = 0;\r\n    this.reconnectionDelay = this.options['reconnection delay'];\r\n\r\n    var self = this\r\n      , maxAttempts = this.options['max reconnection attempts']\r\n      , tryMultiple = this.options['try multiple transports']\r\n      , limit = this.options['reconnection limit'];\r\n\r\n    function reset () {\r\n      if (self.connected) {\r\n        for (var i in self.namespaces) {\r\n          if (self.namespaces.hasOwnProperty(i) && '' !== i) {\r\n              self.namespaces[i].packet({ type: 'connect' });\r\n          }\r\n        }\r\n        self.publish('reconnect', self.transport.name, self.reconnectionAttempts);\r\n      }\r\n\r\n      clearTimeout(self.reconnectionTimer);\r\n\r\n      self.removeListener('connect_failed', maybeReconnect);\r\n      self.removeListener('connect', maybeReconnect);\r\n\r\n      self.reconnecting = false;\r\n\r\n      delete self.reconnectionAttempts;\r\n      delete self.reconnectionDelay;\r\n      delete self.reconnectionTimer;\r\n      delete self.redoTransports;\r\n\r\n      self.options['try multiple transports'] = tryMultiple;\r\n    };\r\n\r\n    function maybeReconnect () {\r\n      if (!self.reconnecting) {\r\n        return;\r\n      }\r\n\r\n      if (self.connected) {\r\n        return reset();\r\n      };\r\n\r\n      if (self.connecting && self.reconnecting) {\r\n        return self.reconnectionTimer = setTimeout(maybeReconnect, 1000);\r\n      }\r\n\r\n      if (self.reconnectionAttempts++ >= maxAttempts) {\r\n        if (!self.redoTransports) {\r\n          self.on('connect_failed', maybeReconnect);\r\n          self.options['try multiple transports'] = true;\r\n          self.transports = self.origTransports;\r\n          self.transport = self.getTransport();\r\n          self.redoTransports = true;\r\n          self.connect();\r\n        } else {\r\n          self.publish('reconnect_failed');\r\n          reset();\r\n        }\r\n      } else {\r\n        if (self.reconnectionDelay < limit) {\r\n          self.reconnectionDelay *= 2; // exponential back off\r\n        }\r\n\r\n        self.connect();\r\n        self.publish('reconnecting', self.reconnectionDelay, self.reconnectionAttempts);\r\n        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);\r\n      }\r\n    };\r\n\r\n    this.options['try multiple transports'] = false;\r\n    this.reconnectionTimer = setTimeout(maybeReconnect, this.reconnectionDelay);\r\n\r\n    this.on('connect', maybeReconnect);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , this\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.SocketNamespace = SocketNamespace;\r\n\r\n  /**\r\n   * Socket namespace constructor.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function SocketNamespace (socket, name) {\r\n    this.socket = socket;\r\n    this.name = name || '';\r\n    this.flags = {};\r\n    this.json = new Flag(this, 'json');\r\n    this.ackPackets = 0;\r\n    this.acks = {};\r\n  };\r\n\r\n  /**\r\n   * Apply EventEmitter mixin.\r\n   */\r\n\r\n  io.util.mixin(SocketNamespace, io.EventEmitter);\r\n\r\n  /**\r\n   * Copies emit since we override it\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;\r\n\r\n  /**\r\n   * Creates a new namespace, by proxying the request to the socket. This\r\n   * allows us to use the synax as we do on the server.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.of = function () {\r\n    return this.socket.of.apply(this.socket, arguments);\r\n  };\r\n\r\n  /**\r\n   * Sends a packet.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.packet = function (packet) {\r\n    packet.endpoint = this.name;\r\n    this.socket.packet(packet);\r\n    this.flags = {};\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Sends a message\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  SocketNamespace.prototype.send = function (data, fn) {\r\n    var packet = {\r\n        type: this.flags.json ? 'json' : 'message'\r\n      , data: data\r\n    };\r\n\r\n    if ('function' == typeof fn) {\r\n      packet.id = ++this.ackPackets;\r\n      packet.ack = true;\r\n      this.acks[packet.id] = fn;\r\n    }\r\n\r\n    return this.packet(packet);\r\n  };\r\n\r\n  /**\r\n   * Emits an event\r\n   *\r\n   * @api public\r\n   */\r\n  \r\n  SocketNamespace.prototype.emit = function (name) {\r\n    var args = Array.prototype.slice.call(arguments, 1)\r\n      , lastArg = args[args.length - 1]\r\n      , packet = {\r\n            type: 'event'\r\n          , name: name\r\n        };\r\n\r\n    if ('function' == typeof lastArg) {\r\n      packet.id = ++this.ackPackets;\r\n      packet.ack = 'data';\r\n      this.acks[packet.id] = lastArg;\r\n      args = args.slice(0, args.length - 1);\r\n    }\r\n\r\n    packet.args = args;\r\n\r\n    return this.packet(packet);\r\n  };\r\n\r\n  /**\r\n   * Disconnects the namespace\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.disconnect = function () {\r\n    if (this.name === '') {\r\n      this.socket.disconnect();\r\n    } else {\r\n      this.packet({ type: 'disconnect' });\r\n      this.$emit('disconnect');\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handles a packet\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  SocketNamespace.prototype.onPacket = function (packet) {\r\n    var self = this;\r\n\r\n    function ack () {\r\n      self.packet({\r\n          type: 'ack'\r\n        , args: io.util.toArray(arguments)\r\n        , ackId: packet.id\r\n      });\r\n    };\r\n\r\n    switch (packet.type) {\r\n      case 'connect':\r\n        this.$emit('connect');\r\n        break;\r\n\r\n      case 'disconnect':\r\n        if (this.name === '') {\r\n          this.socket.onDisconnect(packet.reason || 'booted');\r\n        } else {\r\n          this.$emit('disconnect', packet.reason);\r\n        }\r\n        break;\r\n\r\n      case 'message':\r\n      case 'json':\r\n        var params = ['message', packet.data];\r\n\r\n        if (packet.ack == 'data') {\r\n          params.push(ack);\r\n        } else if (packet.ack) {\r\n          this.packet({ type: 'ack', ackId: packet.id });\r\n        }\r\n\r\n        this.$emit.apply(this, params);\r\n        break;\r\n\r\n      case 'event':\r\n        var params = [packet.name].concat(packet.args);\r\n\r\n        if (packet.ack == 'data')\r\n          params.push(ack);\r\n\r\n        this.$emit.apply(this, params);\r\n        break;\r\n\r\n      case 'ack':\r\n        if (this.acks[packet.ackId]) {\r\n          this.acks[packet.ackId].apply(this, packet.args);\r\n          delete this.acks[packet.ackId];\r\n        }\r\n        break;\r\n\r\n      case 'error':\r\n        if (packet.advice){\r\n          this.socket.onError(packet);\r\n        } else {\r\n          if (packet.reason == 'unauthorized') {\r\n            this.$emit('connect_failed', packet.reason);\r\n          } else {\r\n            this.$emit('error', packet.reason);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Flag interface.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function Flag (nsp, name) {\r\n    this.namespace = nsp;\r\n    this.name = name;\r\n  };\r\n\r\n  /**\r\n   * Send a message\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flag.prototype.send = function () {\r\n    this.namespace.flags[this.name] = true;\r\n    this.namespace.send.apply(this.namespace, arguments);\r\n  };\r\n\r\n  /**\r\n   * Emit an event\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flag.prototype.emit = function () {\r\n    this.namespace.flags[this.name] = true;\r\n    this.namespace.emit.apply(this.namespace, arguments);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.websocket = WS;\r\n\r\n  /**\r\n   * The WebSocket transport uses the HTML5 WebSocket API to establish an\r\n   * persistent connection with the Socket.IO server. This transport will also\r\n   * be inherited by the FlashSocket fallback as it provides a API compatible\r\n   * polyfill for the WebSockets.\r\n   *\r\n   * @constructor\r\n   * @extends {io.Transport}\r\n   * @api public\r\n   */\r\n\r\n  function WS (socket) {\r\n    io.Transport.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(WS, io.Transport);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.name = 'websocket';\r\n\r\n  /**\r\n   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach\r\n   * all the appropriate listeners to handle the responses from the server.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.open = function () {\r\n    var query = io.util.query(this.socket.options.query)\r\n      , self = this\r\n      , Socket\r\n\r\n\r\n    if (!Socket) {\r\n      Socket = global.MozWebSocket || global.WebSocket;\r\n    }\r\n\r\n    this.websocket = new Socket(this.prepareUrl() + query);\r\n\r\n    this.websocket.onopen = function () {\r\n      self.onOpen();\r\n      self.socket.setBuffer(false);\r\n    };\r\n    this.websocket.onmessage = function (ev) {\r\n      self.onData(ev.data);\r\n    };\r\n    this.websocket.onclose = function () {\r\n      self.onClose();\r\n      self.socket.setBuffer(true);\r\n    };\r\n    this.websocket.onerror = function (e) {\r\n      self.onError(e);\r\n    };\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Send a message to the Socket.IO server. The message will automatically be\r\n   * encoded in the correct message format.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  // Do to a bug in the current IDevices browser, we need to wrap the send in a \r\n  // setTimeout, when they resume from sleeping the browser will crash if \r\n  // we don't allow the browser time to detect the socket has been closed\r\n  if (io.util.ua.iDevice) {\r\n    WS.prototype.send = function (data) {\r\n      var self = this;\r\n      setTimeout(function() {\r\n         self.websocket.send(data);\r\n      },0);\r\n      return this;\r\n    };\r\n  } else {\r\n    WS.prototype.send = function (data) {\r\n      this.websocket.send(data);\r\n      return this;\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Payload\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  WS.prototype.payload = function (arr) {\r\n    for (var i = 0, l = arr.length; i < l; i++) {\r\n      this.packet(arr[i]);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnect the established `WebSocket` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  WS.prototype.close = function () {\r\n    this.websocket.close();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Handle the errors that `WebSocket` might be giving when we\r\n   * are attempting to connect or send messages.\r\n   *\r\n   * @param {Error} e The error.\r\n   * @api private\r\n   */\r\n\r\n  WS.prototype.onError = function (e) {\r\n    this.socket.onError(e);\r\n  };\r\n\r\n  /**\r\n   * Returns the appropriate scheme for the URI generation.\r\n   *\r\n   * @api private\r\n   */\r\n  WS.prototype.scheme = function () {\r\n    return this.socket.options.secure ? 'wss' : 'ws';\r\n  };\r\n\r\n  /**\r\n   * Checks if the browser has support for native `WebSockets` and that\r\n   * it's not the polyfill created for the FlashSocket transport.\r\n   *\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  WS.check = function () {\r\n    return ('WebSocket' in global && !('__addTask' in WebSocket))\r\n          || 'MozWebSocket' in global;\r\n  };\r\n\r\n  /**\r\n   * Check if the `WebSocket` transport support cross domain communications.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  WS.xdomainCheck = function () {\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('websocket');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , this\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.flashsocket = Flashsocket;\r\n\r\n  /**\r\n   * The FlashSocket transport. This is a API wrapper for the HTML5 WebSocket\r\n   * specification. It uses a .swf file to communicate with the server. If you want\r\n   * to serve the .swf file from a other server than where the Socket.IO script is\r\n   * coming from you need to use the insecure version of the .swf. More information\r\n   * about this can be found on the github page.\r\n   *\r\n   * @constructor\r\n   * @extends {io.Transport.websocket}\r\n   * @api public\r\n   */\r\n\r\n  function Flashsocket () {\r\n    io.Transport.websocket.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(Flashsocket, io.Transport.websocket);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  Flashsocket.prototype.name = 'flashsocket';\r\n\r\n  /**\r\n   * Disconnect the established `FlashSocket` connection. This is done by adding a \r\n   * new task to the FlashSocket. The rest will be handled off by the `WebSocket` \r\n   * transport.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  Flashsocket.prototype.open = function () {\r\n    var self = this\r\n      , args = arguments;\r\n\r\n    WebSocket.__addTask(function () {\r\n      io.Transport.websocket.prototype.open.apply(self, args);\r\n    });\r\n    return this;\r\n  };\r\n  \r\n  /**\r\n   * Sends a message to the Socket.IO server. This is done by adding a new\r\n   * task to the FlashSocket. The rest will be handled off by the `WebSocket` \r\n   * transport.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  Flashsocket.prototype.send = function () {\r\n    var self = this, args = arguments;\r\n    WebSocket.__addTask(function () {\r\n      io.Transport.websocket.prototype.send.apply(self, args);\r\n    });\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Disconnects the established `FlashSocket` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  Flashsocket.prototype.close = function () {\r\n    WebSocket.__tasks.length = 0;\r\n    io.Transport.websocket.prototype.close.call(this);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * The WebSocket fall back needs to append the flash container to the body\r\n   * element, so we need to make sure we have access to it. Or defer the call\r\n   * until we are sure there is a body element.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  Flashsocket.prototype.ready = function (socket, fn) {\r\n    function init () {\r\n      var options = socket.options\r\n        , port = options['flash policy port']\r\n        , path = [\r\n              'http' + (options.secure ? 's' : '') + ':/'\r\n            , options.host + ':' + options.port\r\n            , options.resource\r\n            , 'static/flashsocket'\r\n            , 'WebSocketMain' + (socket.isXDomain() ? 'Insecure' : '') + '.swf'\r\n          ];\r\n\r\n      // Only start downloading the swf file when the checked that this browser\r\n      // actually supports it\r\n      if (!Flashsocket.loaded) {\r\n        if (typeof WEB_SOCKET_SWF_LOCATION === 'undefined') {\r\n          // Set the correct file based on the XDomain settings\r\n          WEB_SOCKET_SWF_LOCATION = path.join('/');\r\n        }\r\n\r\n        if (port !== 843) {\r\n          WebSocket.loadFlashPolicyFile('xmlsocket://' + options.host + ':' + port);\r\n        }\r\n\r\n        WebSocket.__initialize();\r\n        Flashsocket.loaded = true;\r\n      }\r\n\r\n      fn.call(self);\r\n    }\r\n\r\n    var self = this;\r\n    if (document.body) return init();\r\n\r\n    io.util.load(init);\r\n  };\r\n\r\n  /**\r\n   * Check if the FlashSocket transport is supported as it requires that the Adobe\r\n   * Flash Player plug-in version `10.0.0` or greater is installed. And also check if\r\n   * the polyfill is correctly loaded.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  Flashsocket.check = function () {\r\n    if (\r\n        typeof WebSocket == 'undefined'\r\n      || !('__initialize' in WebSocket) || !swfobject\r\n    ) return false;\r\n\r\n    return swfobject.getFlashPlayerVersion().major >= 10;\r\n  };\r\n\r\n  /**\r\n   * Check if the FlashSocket transport can be used as cross domain / cross origin \r\n   * transport. Because we can't see which type (secure or insecure) of .swf is used\r\n   * we will just return true.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  Flashsocket.xdomainCheck = function () {\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Disable AUTO_INITIALIZATION\r\n   */\r\n\r\n  if (typeof window != 'undefined') {\r\n    WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\r\n  }\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('flashsocket');\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n/*\tSWFObject v2.2 <http://code.google.com/p/swfobject/> \r\n\tis released under the MIT License <http://www.opensource.org/licenses/mit-license.php> \r\n*/\r\nif ('undefined' != typeof window) {\r\nvar swfobject=function(){var D=\"undefined\",r=\"object\",S=\"Shockwave Flash\",W=\"ShockwaveFlash.ShockwaveFlash\",q=\"application/x-shockwave-flash\",R=\"SWFObjectExprInst\",x=\"onreadystatechange\",O=window,j=document,t=navigator,T=false,U=[h],o=[],N=[],I=[],l,Q,E,B,J=false,a=false,n,G,m=true,M=function(){var aa=typeof j.getElementById!=D&&typeof j.getElementsByTagName!=D&&typeof j.createElement!=D,ah=t.userAgent.toLowerCase(),Y=t.platform.toLowerCase(),ae=Y?/win/.test(Y):/win/.test(ah),ac=Y?/mac/.test(Y):/mac/.test(ah),af=/webkit/.test(ah)?parseFloat(ah.replace(/^.*webkit\\/(\\d+(\\.\\d+)?).*$/,\"$1\")):false,X=!+\"\\v1\",ag=[0,0,0],ab=null;if(typeof t.plugins!=D&&typeof t.plugins[S]==r){ab=t.plugins[S].description;if(ab&&!(typeof t.mimeTypes!=D&&t.mimeTypes[q]&&!t.mimeTypes[q].enabledPlugin)){T=true;X=false;ab=ab.replace(/^.*\\s+(\\S+\\s+\\S+$)/,\"$1\");ag[0]=parseInt(ab.replace(/^(.*)\\..*$/,\"$1\"),10);ag[1]=parseInt(ab.replace(/^.*\\.(.*)\\s.*$/,\"$1\"),10);ag[2]=/[a-zA-Z]/.test(ab)?parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/,\"$1\"),10):0}}else{if(typeof O[(['Active'].concat('Object').join('X'))]!=D){try{var ad=new window[(['Active'].concat('Object').join('X'))](W);if(ad){ab=ad.GetVariable(\"$version\");if(ab){X=true;ab=ab.split(\" \")[1].split(\",\");ag=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}}catch(Z){}}}return{w3:aa,pv:ag,wk:af,ie:X,win:ae,mac:ac}}(),k=function(){if(!M.w3){return}if((typeof j.readyState!=D&&j.readyState==\"complete\")||(typeof j.readyState==D&&(j.getElementsByTagName(\"body\")[0]||j.body))){f()}if(!J){if(typeof j.addEventListener!=D){j.addEventListener(\"DOMContentLoaded\",f,false)}if(M.ie&&M.win){j.attachEvent(x,function(){if(j.readyState==\"complete\"){j.detachEvent(x,arguments.callee);f()}});if(O==top){(function(){if(J){return}try{j.documentElement.doScroll(\"left\")}catch(X){setTimeout(arguments.callee,0);return}f()})()}}if(M.wk){(function(){if(J){return}if(!/loaded|complete/.test(j.readyState)){setTimeout(arguments.callee,0);return}f()})()}s(f)}}();function f(){if(J){return}try{var Z=j.getElementsByTagName(\"body\")[0].appendChild(C(\"span\"));Z.parentNode.removeChild(Z)}catch(aa){return}J=true;var X=U.length;for(var Y=0;Y<X;Y++){U[Y]()}}function K(X){if(J){X()}else{U[U.length]=X}}function s(Y){if(typeof O.addEventListener!=D){O.addEventListener(\"load\",Y,false)}else{if(typeof j.addEventListener!=D){j.addEventListener(\"load\",Y,false)}else{if(typeof O.attachEvent!=D){i(O,\"onload\",Y)}else{if(typeof O.onload==\"function\"){var X=O.onload;O.onload=function(){X();Y()}}else{O.onload=Y}}}}}function h(){if(T){V()}else{H()}}function V(){var X=j.getElementsByTagName(\"body\")[0];var aa=C(r);aa.setAttribute(\"type\",q);var Z=X.appendChild(aa);if(Z){var Y=0;(function(){if(typeof Z.GetVariable!=D){var ab=Z.GetVariable(\"$version\");if(ab){ab=ab.split(\" \")[1].split(\",\");M.pv=[parseInt(ab[0],10),parseInt(ab[1],10),parseInt(ab[2],10)]}}else{if(Y<10){Y++;setTimeout(arguments.callee,10);return}}X.removeChild(aa);Z=null;H()})()}else{H()}}function H(){var ag=o.length;if(ag>0){for(var af=0;af<ag;af++){var Y=o[af].id;var ab=o[af].callbackFn;var aa={success:false,id:Y};if(M.pv[0]>0){var ae=c(Y);if(ae){if(F(o[af].swfVersion)&&!(M.wk&&M.wk<312)){w(Y,true);if(ab){aa.success=true;aa.ref=z(Y);ab(aa)}}else{if(o[af].expressInstall&&A()){var ai={};ai.data=o[af].expressInstall;ai.width=ae.getAttribute(\"width\")||\"0\";ai.height=ae.getAttribute(\"height\")||\"0\";if(ae.getAttribute(\"class\")){ai.styleclass=ae.getAttribute(\"class\")}if(ae.getAttribute(\"align\")){ai.align=ae.getAttribute(\"align\")}var ah={};var X=ae.getElementsByTagName(\"param\");var ac=X.length;for(var ad=0;ad<ac;ad++){if(X[ad].getAttribute(\"name\").toLowerCase()!=\"movie\"){ah[X[ad].getAttribute(\"name\")]=X[ad].getAttribute(\"value\")}}P(ai,ah,Y,ab)}else{p(ae);if(ab){ab(aa)}}}}}else{w(Y,true);if(ab){var Z=z(Y);if(Z&&typeof Z.SetVariable!=D){aa.success=true;aa.ref=Z}ab(aa)}}}}}function z(aa){var X=null;var Y=c(aa);if(Y&&Y.nodeName==\"OBJECT\"){if(typeof Y.SetVariable!=D){X=Y}else{var Z=Y.getElementsByTagName(r)[0];if(Z){X=Z}}}return X}function A(){return !a&&F(\"6.0.65\")&&(M.win||M.mac)&&!(M.wk&&M.wk<312)}function P(aa,ab,X,Z){a=true;E=Z||null;B={success:false,id:X};var ae=c(X);if(ae){if(ae.nodeName==\"OBJECT\"){l=g(ae);Q=null}else{l=ae;Q=X}aa.id=R;if(typeof aa.width==D||(!/%$/.test(aa.width)&&parseInt(aa.width,10)<310)){aa.width=\"310\"}if(typeof aa.height==D||(!/%$/.test(aa.height)&&parseInt(aa.height,10)<137)){aa.height=\"137\"}j.title=j.title.slice(0,47)+\" - Flash Player Installation\";var ad=M.ie&&M.win?(['Active'].concat('').join('X')):\"PlugIn\",ac=\"MMredirectURL=\"+O.location.toString().replace(/&/g,\"%26\")+\"&MMplayerType=\"+ad+\"&MMdoctitle=\"+j.title;if(typeof ab.flashvars!=D){ab.flashvars+=\"&\"+ac}else{ab.flashvars=ac}if(M.ie&&M.win&&ae.readyState!=4){var Y=C(\"div\");X+=\"SWFObjectNew\";Y.setAttribute(\"id\",X);ae.parentNode.insertBefore(Y,ae);ae.style.display=\"none\";(function(){if(ae.readyState==4){ae.parentNode.removeChild(ae)}else{setTimeout(arguments.callee,10)}})()}u(aa,ab,X)}}function p(Y){if(M.ie&&M.win&&Y.readyState!=4){var X=C(\"div\");Y.parentNode.insertBefore(X,Y);X.parentNode.replaceChild(g(Y),X);Y.style.display=\"none\";(function(){if(Y.readyState==4){Y.parentNode.removeChild(Y)}else{setTimeout(arguments.callee,10)}})()}else{Y.parentNode.replaceChild(g(Y),Y)}}function g(ab){var aa=C(\"div\");if(M.win&&M.ie){aa.innerHTML=ab.innerHTML}else{var Y=ab.getElementsByTagName(r)[0];if(Y){var ad=Y.childNodes;if(ad){var X=ad.length;for(var Z=0;Z<X;Z++){if(!(ad[Z].nodeType==1&&ad[Z].nodeName==\"PARAM\")&&!(ad[Z].nodeType==8)){aa.appendChild(ad[Z].cloneNode(true))}}}}}return aa}function u(ai,ag,Y){var X,aa=c(Y);if(M.wk&&M.wk<312){return X}if(aa){if(typeof ai.id==D){ai.id=Y}if(M.ie&&M.win){var ah=\"\";for(var ae in ai){if(ai[ae]!=Object.prototype[ae]){if(ae.toLowerCase()==\"data\"){ag.movie=ai[ae]}else{if(ae.toLowerCase()==\"styleclass\"){ah+=' class=\"'+ai[ae]+'\"'}else{if(ae.toLowerCase()!=\"classid\"){ah+=\" \"+ae+'=\"'+ai[ae]+'\"'}}}}}var af=\"\";for(var ad in ag){if(ag[ad]!=Object.prototype[ad]){af+='<param name=\"'+ad+'\" value=\"'+ag[ad]+'\" />'}}aa.outerHTML='<object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"'+ah+\">\"+af+\"</object>\";N[N.length]=ai.id;X=c(ai.id)}else{var Z=C(r);Z.setAttribute(\"type\",q);for(var ac in ai){if(ai[ac]!=Object.prototype[ac]){if(ac.toLowerCase()==\"styleclass\"){Z.setAttribute(\"class\",ai[ac])}else{if(ac.toLowerCase()!=\"classid\"){Z.setAttribute(ac,ai[ac])}}}}for(var ab in ag){if(ag[ab]!=Object.prototype[ab]&&ab.toLowerCase()!=\"movie\"){e(Z,ab,ag[ab])}}aa.parentNode.replaceChild(Z,aa);X=Z}}return X}function e(Z,X,Y){var aa=C(\"param\");aa.setAttribute(\"name\",X);aa.setAttribute(\"value\",Y);Z.appendChild(aa)}function y(Y){var X=c(Y);if(X&&X.nodeName==\"OBJECT\"){if(M.ie&&M.win){X.style.display=\"none\";(function(){if(X.readyState==4){b(Y)}else{setTimeout(arguments.callee,10)}})()}else{X.parentNode.removeChild(X)}}}function b(Z){var Y=c(Z);if(Y){for(var X in Y){if(typeof Y[X]==\"function\"){Y[X]=null}}Y.parentNode.removeChild(Y)}}function c(Z){var X=null;try{X=j.getElementById(Z)}catch(Y){}return X}function C(X){return j.createElement(X)}function i(Z,X,Y){Z.attachEvent(X,Y);I[I.length]=[Z,X,Y]}function F(Z){var Y=M.pv,X=Z.split(\".\");X[0]=parseInt(X[0],10);X[1]=parseInt(X[1],10)||0;X[2]=parseInt(X[2],10)||0;return(Y[0]>X[0]||(Y[0]==X[0]&&Y[1]>X[1])||(Y[0]==X[0]&&Y[1]==X[1]&&Y[2]>=X[2]))?true:false}function v(ac,Y,ad,ab){if(M.ie&&M.mac){return}var aa=j.getElementsByTagName(\"head\")[0];if(!aa){return}var X=(ad&&typeof ad==\"string\")?ad:\"screen\";if(ab){n=null;G=null}if(!n||G!=X){var Z=C(\"style\");Z.setAttribute(\"type\",\"text/css\");Z.setAttribute(\"media\",X);n=aa.appendChild(Z);if(M.ie&&M.win&&typeof j.styleSheets!=D&&j.styleSheets.length>0){n=j.styleSheets[j.styleSheets.length-1]}G=X}if(M.ie&&M.win){if(n&&typeof n.addRule==r){n.addRule(ac,Y)}}else{if(n&&typeof j.createTextNode!=D){n.appendChild(j.createTextNode(ac+\" {\"+Y+\"}\"))}}}function w(Z,X){if(!m){return}var Y=X?\"visible\":\"hidden\";if(J&&c(Z)){c(Z).style.visibility=Y}else{v(\"#\"+Z,\"visibility:\"+Y)}}function L(Y){var Z=/[\\\\\\\"<>\\.;]/;var X=Z.exec(Y)!=null;return X&&typeof encodeURIComponent!=D?encodeURIComponent(Y):Y}var d=function(){if(M.ie&&M.win){window.attachEvent(\"onunload\",function(){var ac=I.length;for(var ab=0;ab<ac;ab++){I[ab][0].detachEvent(I[ab][1],I[ab][2])}var Z=N.length;for(var aa=0;aa<Z;aa++){y(N[aa])}for(var Y in M){M[Y]=null}M=null;for(var X in swfobject){swfobject[X]=null}swfobject=null})}}();return{registerObject:function(ab,X,aa,Z){if(M.w3&&ab&&X){var Y={};Y.id=ab;Y.swfVersion=X;Y.expressInstall=aa;Y.callbackFn=Z;o[o.length]=Y;w(ab,false)}else{if(Z){Z({success:false,id:ab})}}},getObjectById:function(X){if(M.w3){return z(X)}},embedSWF:function(ab,ah,ae,ag,Y,aa,Z,ad,af,ac){var X={success:false,id:ah};if(M.w3&&!(M.wk&&M.wk<312)&&ab&&ah&&ae&&ag&&Y){w(ah,false);K(function(){ae+=\"\";ag+=\"\";var aj={};if(af&&typeof af===r){for(var al in af){aj[al]=af[al]}}aj.data=ab;aj.width=ae;aj.height=ag;var am={};if(ad&&typeof ad===r){for(var ak in ad){am[ak]=ad[ak]}}if(Z&&typeof Z===r){for(var ai in Z){if(typeof am.flashvars!=D){am.flashvars+=\"&\"+ai+\"=\"+Z[ai]}else{am.flashvars=ai+\"=\"+Z[ai]}}}if(F(Y)){var an=u(aj,am,ah);if(aj.id==ah){w(ah,true)}X.success=true;X.ref=an}else{if(aa&&A()){aj.data=aa;P(aj,am,ah,ac);return}else{w(ah,true)}}if(ac){ac(X)}})}else{if(ac){ac(X)}}},switchOffAutoHideShow:function(){m=false},ua:M,getFlashPlayerVersion:function(){return{major:M.pv[0],minor:M.pv[1],release:M.pv[2]}},hasFlashPlayerVersion:F,createSWF:function(Z,Y,X){if(M.w3){return u(Z,Y,X)}else{return undefined}},showExpressInstall:function(Z,aa,X,Y){if(M.w3&&A()){P(Z,aa,X,Y)}},removeSWF:function(X){if(M.w3){y(X)}},createCSS:function(aa,Z,Y,X){if(M.w3){v(aa,Z,Y,X)}},addDomLoadEvent:K,addLoadEvent:s,getQueryParamValue:function(aa){var Z=j.location.search||j.location.hash;if(Z){if(/\\?/.test(Z)){Z=Z.split(\"?\")[1]}if(aa==null){return L(Z)}var Y=Z.split(\"&\");for(var X=0;X<Y.length;X++){if(Y[X].substring(0,Y[X].indexOf(\"=\"))==aa){return L(Y[X].substring((Y[X].indexOf(\"=\")+1)))}}}return\"\"},expressInstallCallback:function(){if(a){var X=c(R);if(X&&l){X.parentNode.replaceChild(l,X);if(Q){w(Q,true);if(M.ie&&M.win){l.style.display=\"block\"}}if(E){E(B)}}a=false}}}}();\r\n}\r\n// Copyright: Hiroshi Ichikawa <http://gimite.net/en/>\r\n// License: New BSD License\r\n// Reference: http://dev.w3.org/html5/websockets/\r\n// Reference: http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\r\n\r\n(function() {\r\n  \r\n  if ('undefined' == typeof window || window.WebSocket) return;\r\n\r\n  var console = window.console;\r\n  if (!console || !console.log || !console.error) {\r\n    console = {log: function(){ }, error: function(){ }};\r\n  }\r\n  \r\n  if (!swfobject.hasFlashPlayerVersion(\"10.0.0\")) {\r\n    console.error(\"Flash Player >= 10.0.0 is required.\");\r\n    return;\r\n  }\r\n  if (location.protocol == \"file:\") {\r\n    console.error(\r\n      \"WARNING: web-socket-js doesn't work in file:///... URL \" +\r\n      \"unless you set Flash Security Settings properly. \" +\r\n      \"Open the page via Web server i.e. http://...\");\r\n  }\r\n\r\n  /**\r\n   * This class represents a faux web socket.\r\n   * @param {string} url\r\n   * @param {array or string} protocols\r\n   * @param {string} proxyHost\r\n   * @param {int} proxyPort\r\n   * @param {string} headers\r\n   */\r\n  WebSocket = function(url, protocols, proxyHost, proxyPort, headers) {\r\n    var self = this;\r\n    self.__id = WebSocket.__nextId++;\r\n    WebSocket.__instances[self.__id] = self;\r\n    self.readyState = WebSocket.CONNECTING;\r\n    self.bufferedAmount = 0;\r\n    self.__events = {};\r\n    if (!protocols) {\r\n      protocols = [];\r\n    } else if (typeof protocols == \"string\") {\r\n      protocols = [protocols];\r\n    }\r\n    // Uses setTimeout() to make sure __createFlash() runs after the caller sets ws.onopen etc.\r\n    // Otherwise, when onopen fires immediately, onopen is called before it is set.\r\n    setTimeout(function() {\r\n      WebSocket.__addTask(function() {\r\n        WebSocket.__flash.create(\r\n            self.__id, url, protocols, proxyHost || null, proxyPort || 0, headers || null);\r\n      });\r\n    }, 0);\r\n  };\r\n\r\n  /**\r\n   * Send data to the web socket.\r\n   * @param {string} data  The data to send to the socket.\r\n   * @return {boolean}  True for success, false for failure.\r\n   */\r\n  WebSocket.prototype.send = function(data) {\r\n    if (this.readyState == WebSocket.CONNECTING) {\r\n      throw \"INVALID_STATE_ERR: Web Socket connection has not been established\";\r\n    }\r\n    // We use encodeURIComponent() here, because FABridge doesn't work if\r\n    // the argument includes some characters. We don't use escape() here\r\n    // because of this:\r\n    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Functions#escape_and_unescape_Functions\r\n    // But it looks decodeURIComponent(encodeURIComponent(s)) doesn't\r\n    // preserve all Unicode characters either e.g. \"\\uffff\" in Firefox.\r\n    // Note by wtritch: Hopefully this will not be necessary using ExternalInterface.  Will require\r\n    // additional testing.\r\n    var result = WebSocket.__flash.send(this.__id, encodeURIComponent(data));\r\n    if (result < 0) { // success\r\n      return true;\r\n    } else {\r\n      this.bufferedAmount += result;\r\n      return false;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Close this web socket gracefully.\r\n   */\r\n  WebSocket.prototype.close = function() {\r\n    if (this.readyState == WebSocket.CLOSED || this.readyState == WebSocket.CLOSING) {\r\n      return;\r\n    }\r\n    this.readyState = WebSocket.CLOSING;\r\n    WebSocket.__flash.close(this.__id);\r\n  };\r\n\r\n  /**\r\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\r\n   *\r\n   * @param {string} type\r\n   * @param {function} listener\r\n   * @param {boolean} useCapture\r\n   * @return void\r\n   */\r\n  WebSocket.prototype.addEventListener = function(type, listener, useCapture) {\r\n    if (!(type in this.__events)) {\r\n      this.__events[type] = [];\r\n    }\r\n    this.__events[type].push(listener);\r\n  };\r\n\r\n  /**\r\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\r\n   *\r\n   * @param {string} type\r\n   * @param {function} listener\r\n   * @param {boolean} useCapture\r\n   * @return void\r\n   */\r\n  WebSocket.prototype.removeEventListener = function(type, listener, useCapture) {\r\n    if (!(type in this.__events)) return;\r\n    var events = this.__events[type];\r\n    for (var i = events.length - 1; i >= 0; --i) {\r\n      if (events[i] === listener) {\r\n        events.splice(i, 1);\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Implementation of {@link <a href=\"http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-registration\">DOM 2 EventTarget Interface</a>}\r\n   *\r\n   * @param {Event} event\r\n   * @return void\r\n   */\r\n  WebSocket.prototype.dispatchEvent = function(event) {\r\n    var events = this.__events[event.type] || [];\r\n    for (var i = 0; i < events.length; ++i) {\r\n      events[i](event);\r\n    }\r\n    var handler = this[\"on\" + event.type];\r\n    if (handler) handler(event);\r\n  };\r\n\r\n  /**\r\n   * Handles an event from Flash.\r\n   * @param {Object} flashEvent\r\n   */\r\n  WebSocket.prototype.__handleEvent = function(flashEvent) {\r\n    if (\"readyState\" in flashEvent) {\r\n      this.readyState = flashEvent.readyState;\r\n    }\r\n    if (\"protocol\" in flashEvent) {\r\n      this.protocol = flashEvent.protocol;\r\n    }\r\n    \r\n    var jsEvent;\r\n    if (flashEvent.type == \"open\" || flashEvent.type == \"error\") {\r\n      jsEvent = this.__createSimpleEvent(flashEvent.type);\r\n    } else if (flashEvent.type == \"close\") {\r\n      // TODO implement jsEvent.wasClean\r\n      jsEvent = this.__createSimpleEvent(\"close\");\r\n    } else if (flashEvent.type == \"message\") {\r\n      var data = decodeURIComponent(flashEvent.message);\r\n      jsEvent = this.__createMessageEvent(\"message\", data);\r\n    } else {\r\n      throw \"unknown event type: \" + flashEvent.type;\r\n    }\r\n    \r\n    this.dispatchEvent(jsEvent);\r\n  };\r\n  \r\n  WebSocket.prototype.__createSimpleEvent = function(type) {\r\n    if (document.createEvent && window.Event) {\r\n      var event = document.createEvent(\"Event\");\r\n      event.initEvent(type, false, false);\r\n      return event;\r\n    } else {\r\n      return {type: type, bubbles: false, cancelable: false};\r\n    }\r\n  };\r\n  \r\n  WebSocket.prototype.__createMessageEvent = function(type, data) {\r\n    if (document.createEvent && window.MessageEvent && !window.opera) {\r\n      var event = document.createEvent(\"MessageEvent\");\r\n      event.initMessageEvent(\"message\", false, false, data, null, null, window, null);\r\n      return event;\r\n    } else {\r\n      // IE and Opera, the latter one truncates the data parameter after any 0x00 bytes.\r\n      return {type: type, data: data, bubbles: false, cancelable: false};\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Define the WebSocket readyState enumeration.\r\n   */\r\n  WebSocket.CONNECTING = 0;\r\n  WebSocket.OPEN = 1;\r\n  WebSocket.CLOSING = 2;\r\n  WebSocket.CLOSED = 3;\r\n\r\n  WebSocket.__flash = null;\r\n  WebSocket.__instances = {};\r\n  WebSocket.__tasks = [];\r\n  WebSocket.__nextId = 0;\r\n  \r\n  /**\r\n   * Load a new flash security policy file.\r\n   * @param {string} url\r\n   */\r\n  WebSocket.loadFlashPolicyFile = function(url){\r\n    WebSocket.__addTask(function() {\r\n      WebSocket.__flash.loadManualPolicyFile(url);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Loads WebSocketMain.swf and creates WebSocketMain object in Flash.\r\n   */\r\n  WebSocket.__initialize = function() {\r\n    if (WebSocket.__flash) return;\r\n    \r\n    if (WebSocket.__swfLocation) {\r\n      // For backword compatibility.\r\n      window.WEB_SOCKET_SWF_LOCATION = WebSocket.__swfLocation;\r\n    }\r\n    if (!window.WEB_SOCKET_SWF_LOCATION) {\r\n      console.error(\"[WebSocket] set WEB_SOCKET_SWF_LOCATION to location of WebSocketMain.swf\");\r\n      return;\r\n    }\r\n    var container = document.createElement(\"div\");\r\n    container.id = \"webSocketContainer\";\r\n    // Hides Flash box. We cannot use display: none or visibility: hidden because it prevents\r\n    // Flash from loading at least in IE. So we move it out of the screen at (-100, -100).\r\n    // But this even doesn't work with Flash Lite (e.g. in Droid Incredible). So with Flash\r\n    // Lite, we put it at (0, 0). This shows 1x1 box visible at left-top corner but this is\r\n    // the best we can do as far as we know now.\r\n    container.style.position = \"absolute\";\r\n    if (WebSocket.__isFlashLite()) {\r\n      container.style.left = \"0px\";\r\n      container.style.top = \"0px\";\r\n    } else {\r\n      container.style.left = \"-100px\";\r\n      container.style.top = \"-100px\";\r\n    }\r\n    var holder = document.createElement(\"div\");\r\n    holder.id = \"webSocketFlash\";\r\n    container.appendChild(holder);\r\n    document.body.appendChild(container);\r\n    // See this article for hasPriority:\r\n    // http://help.adobe.com/en_US/as3/mobile/WS4bebcd66a74275c36cfb8137124318eebc6-7ffd.html\r\n    swfobject.embedSWF(\r\n      WEB_SOCKET_SWF_LOCATION,\r\n      \"webSocketFlash\",\r\n      \"1\" /* width */,\r\n      \"1\" /* height */,\r\n      \"10.0.0\" /* SWF version */,\r\n      null,\r\n      null,\r\n      {hasPriority: true, swliveconnect : true, allowScriptAccess: \"always\"},\r\n      null,\r\n      function(e) {\r\n        if (!e.success) {\r\n          console.error(\"[WebSocket] swfobject.embedSWF failed\");\r\n        }\r\n      });\r\n  };\r\n  \r\n  /**\r\n   * Called by Flash to notify JS that it's fully loaded and ready\r\n   * for communication.\r\n   */\r\n  WebSocket.__onFlashInitialized = function() {\r\n    // We need to set a timeout here to avoid round-trip calls\r\n    // to flash during the initialization process.\r\n    setTimeout(function() {\r\n      WebSocket.__flash = document.getElementById(\"webSocketFlash\");\r\n      WebSocket.__flash.setCallerUrl(location.href);\r\n      WebSocket.__flash.setDebug(!!window.WEB_SOCKET_DEBUG);\r\n      for (var i = 0; i < WebSocket.__tasks.length; ++i) {\r\n        WebSocket.__tasks[i]();\r\n      }\r\n      WebSocket.__tasks = [];\r\n    }, 0);\r\n  };\r\n  \r\n  /**\r\n   * Called by Flash to notify WebSockets events are fired.\r\n   */\r\n  WebSocket.__onFlashEvent = function() {\r\n    setTimeout(function() {\r\n      try {\r\n        // Gets events using receiveEvents() instead of getting it from event object\r\n        // of Flash event. This is to make sure to keep message order.\r\n        // It seems sometimes Flash events don't arrive in the same order as they are sent.\r\n        var events = WebSocket.__flash.receiveEvents();\r\n        for (var i = 0; i < events.length; ++i) {\r\n          WebSocket.__instances[events[i].webSocketId].__handleEvent(events[i]);\r\n        }\r\n      } catch (e) {\r\n        console.error(e);\r\n      }\r\n    }, 0);\r\n    return true;\r\n  };\r\n  \r\n  // Called by Flash.\r\n  WebSocket.__log = function(message) {\r\n    console.log(decodeURIComponent(message));\r\n  };\r\n  \r\n  // Called by Flash.\r\n  WebSocket.__error = function(message) {\r\n    console.error(decodeURIComponent(message));\r\n  };\r\n  \r\n  WebSocket.__addTask = function(task) {\r\n    if (WebSocket.__flash) {\r\n      task();\r\n    } else {\r\n      WebSocket.__tasks.push(task);\r\n    }\r\n  };\r\n  \r\n  /**\r\n   * Test if the browser is running flash lite.\r\n   * @return {boolean} True if flash lite is running, false otherwise.\r\n   */\r\n  WebSocket.__isFlashLite = function() {\r\n    if (!window.navigator || !window.navigator.mimeTypes) {\r\n      return false;\r\n    }\r\n    var mimeType = window.navigator.mimeTypes[\"application/x-shockwave-flash\"];\r\n    if (!mimeType || !mimeType.enabledPlugin || !mimeType.enabledPlugin.filename) {\r\n      return false;\r\n    }\r\n    return mimeType.enabledPlugin.filename.match(/flashlite/i) ? true : false;\r\n  };\r\n  \r\n  if (!window.WEB_SOCKET_DISABLE_AUTO_INITIALIZATION) {\r\n    if (window.addEventListener) {\r\n      window.addEventListener(\"load\", function(){\r\n        WebSocket.__initialize();\r\n      }, false);\r\n    } else {\r\n      window.attachEvent(\"onload\", function(){\r\n        WebSocket.__initialize();\r\n      });\r\n    }\r\n  }\r\n  \r\n})();\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  exports.XHR = XHR;\r\n\r\n  /**\r\n   * XHR constructor\r\n   *\r\n   * @costructor\r\n   * @api public\r\n   */\r\n\r\n  function XHR (socket) {\r\n    if (!socket) return;\r\n\r\n    io.Transport.apply(this, arguments);\r\n    this.sendBuffer = [];\r\n  };\r\n\r\n  /**\r\n   * Inherits from Transport.\r\n   */\r\n\r\n  io.util.inherit(XHR, io.Transport);\r\n\r\n  /**\r\n   * Establish a connection\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.open = function () {\r\n    this.socket.setBuffer(false);\r\n    this.onOpen();\r\n    this.get();\r\n\r\n    // we need to make sure the request succeeds since we have no indication\r\n    // whether the request opened or not until it succeeded.\r\n    this.setCloseTimeout();\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Check if we need to send data to the Socket.IO server, if we have data in our\r\n   * buffer we encode it and forward it to the `post` method.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.payload = function (payload) {\r\n    var msgs = [];\r\n\r\n    for (var i = 0, l = payload.length; i < l; i++) {\r\n      msgs.push(io.parser.encodePacket(payload[i]));\r\n    }\r\n\r\n    this.send(io.parser.encodePayload(msgs));\r\n  };\r\n\r\n  /**\r\n   * Send data to the Socket.IO server.\r\n   *\r\n   * @param data The message\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.send = function (data) {\r\n    this.post(data);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Posts a encoded message to the Socket.IO server.\r\n   *\r\n   * @param {String} data A encoded message.\r\n   * @api private\r\n   */\r\n\r\n  function empty () { };\r\n\r\n  XHR.prototype.post = function (data) {\r\n    var self = this;\r\n    this.socket.setBuffer(true);\r\n\r\n    function stateChange () {\r\n      if (this.readyState == 4) {\r\n        this.onreadystatechange = empty;\r\n        self.posting = false;\r\n\r\n        if (this.status == 200){\r\n          self.socket.setBuffer(false);\r\n        } else {\r\n          self.onClose();\r\n        }\r\n      }\r\n    }\r\n\r\n    function onload () {\r\n      this.onload = empty;\r\n      self.socket.setBuffer(false);\r\n    };\r\n\r\n    this.sendXHR = this.request('POST');\r\n\r\n    if (global.XDomainRequest && this.sendXHR instanceof XDomainRequest) {\r\n      this.sendXHR.onload = this.sendXHR.onerror = onload;\r\n    } else {\r\n      this.sendXHR.onreadystatechange = stateChange;\r\n    }\r\n\r\n    this.sendXHR.send(data);\r\n  };\r\n\r\n  /**\r\n   * Disconnects the established `XHR` connection.\r\n   *\r\n   * @returns {Transport}\r\n   * @api public\r\n   */\r\n\r\n  XHR.prototype.close = function () {\r\n    this.onClose();\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Generates a configured XHR request\r\n   *\r\n   * @param {String} url The url that needs to be requested.\r\n   * @param {String} method The method the request should use.\r\n   * @returns {XMLHttpRequest}\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.request = function (method) {\r\n    var req = io.util.request(this.socket.isXDomain())\r\n      , query = io.util.query(this.socket.options.query, 't=' + +new Date);\r\n\r\n    req.open(method || 'GET', this.prepareUrl() + query, true);\r\n\r\n    if (method == 'POST') {\r\n      try {\r\n        if (req.setRequestHeader) {\r\n          req.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\r\n        } else {\r\n          // XDomainRequest\r\n          req.contentType = 'text/plain';\r\n        }\r\n      } catch (e) {}\r\n    }\r\n\r\n    return req;\r\n  };\r\n\r\n  /**\r\n   * Returns the scheme to use for the transport URLs.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHR.prototype.scheme = function () {\r\n    return this.socket.options.secure ? 'https' : 'http';\r\n  };\r\n\r\n  /**\r\n   * Check if the XHR transports are supported\r\n   *\r\n   * @param {Boolean} xdomain Check if we support cross domain requests.\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  XHR.check = function (socket, xdomain) {\r\n    try {\r\n      var request = io.util.request(xdomain),\r\n          usesXDomReq = (global.XDomainRequest && request instanceof XDomainRequest),\r\n          socketProtocol = (socket && socket.options && socket.options.secure ? 'https:' : 'http:'),\r\n          isXProtocol = (socketProtocol != global.location.protocol);\r\n      if (request && !(usesXDomReq && isXProtocol)) {\r\n        return true;\r\n      }\r\n    } catch(e) {}\r\n\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if the XHR transport supports cross domain requests.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  XHR.xdomainCheck = function (socket) {\r\n    return XHR.check(socket, true);\r\n  };\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , this\r\n);\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports.htmlfile = HTMLFile;\r\n\r\n  /**\r\n   * The HTMLFile transport creates a `forever iframe` based transport\r\n   * for Internet Explorer. Regular forever iframe implementations will \r\n   * continuously trigger the browsers buzy indicators. If the forever iframe\r\n   * is created inside a `htmlfile` these indicators will not be trigged.\r\n   *\r\n   * @constructor\r\n   * @extends {io.Transport.XHR}\r\n   * @api public\r\n   */\r\n\r\n  function HTMLFile (socket) {\r\n    io.Transport.XHR.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from XHR transport.\r\n   */\r\n\r\n  io.util.inherit(HTMLFile, io.Transport.XHR);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  HTMLFile.prototype.name = 'htmlfile';\r\n\r\n  /**\r\n   * Creates a new Ac...eX `htmlfile` with a forever loading iframe\r\n   * that can be used to listen to messages. Inside the generated\r\n   * `htmlfile` a reference will be made to the HTMLFile transport.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  HTMLFile.prototype.get = function () {\r\n    this.doc = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\r\n    this.doc.open();\r\n    this.doc.write('<html></html>');\r\n    this.doc.close();\r\n    this.doc.parentWindow.s = this;\r\n\r\n    var iframeC = this.doc.createElement('div');\r\n    iframeC.className = 'socketio';\r\n\r\n    this.doc.body.appendChild(iframeC);\r\n    this.iframe = this.doc.createElement('iframe');\r\n\r\n    iframeC.appendChild(this.iframe);\r\n\r\n    var self = this\r\n      , query = io.util.query(this.socket.options.query, 't='+ +new Date);\r\n\r\n    this.iframe.src = this.prepareUrl() + query;\r\n\r\n    io.util.on(window, 'unload', function () {\r\n      self.destroy();\r\n    });\r\n  };\r\n\r\n  /**\r\n   * The Socket.IO server will write script tags inside the forever\r\n   * iframe, this function will be used as callback for the incoming\r\n   * information.\r\n   *\r\n   * @param {String} data The message\r\n   * @param {document} doc Reference to the context\r\n   * @api private\r\n   */\r\n\r\n  HTMLFile.prototype._ = function (data, doc) {\r\n    this.onData(data);\r\n    try {\r\n      var script = doc.getElementsByTagName('script')[0];\r\n      script.parentNode.removeChild(script);\r\n    } catch (e) { }\r\n  };\r\n\r\n  /**\r\n   * Destroy the established connection, iframe and `htmlfile`.\r\n   * And calls the `CollectGarbage` function of Internet Explorer\r\n   * to release the memory.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  HTMLFile.prototype.destroy = function () {\r\n    if (this.iframe){\r\n      try {\r\n        this.iframe.src = 'about:blank';\r\n      } catch(e){}\r\n\r\n      this.doc = null;\r\n      this.iframe.parentNode.removeChild(this.iframe);\r\n      this.iframe = null;\r\n\r\n      CollectGarbage();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Disconnects the established connection.\r\n   *\r\n   * @returns {Transport} Chaining.\r\n   * @api public\r\n   */\r\n\r\n  HTMLFile.prototype.close = function () {\r\n    this.destroy();\r\n    return io.Transport.XHR.prototype.close.call(this);\r\n  };\r\n\r\n  /**\r\n   * Checks if the browser supports this transport. The browser\r\n   * must have an `Ac...eXObject` implementation.\r\n   *\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  HTMLFile.check = function (socket) {\r\n    if (typeof window != \"undefined\" && (['Active'].concat('Object').join('X')) in window){\r\n      try {\r\n        var a = new window[(['Active'].concat('Object').join('X'))]('htmlfile');\r\n        return a && io.Transport.XHR.check(socket);\r\n      } catch(e){}\r\n    }\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Check if cross domain requests are supported.\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  HTMLFile.xdomainCheck = function () {\r\n    // we can probably do handling for sub-domains, we should\r\n    // test that it's cross domain but a subdomain here\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('htmlfile');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports['xhr-polling'] = XHRPolling;\r\n\r\n  /**\r\n   * The XHR-polling transport uses long polling XHR requests to create a\r\n   * \"persistent\" connection with the server.\r\n   *\r\n   * @constructor\r\n   * @api public\r\n   */\r\n\r\n  function XHRPolling () {\r\n    io.Transport.XHR.apply(this, arguments);\r\n  };\r\n\r\n  /**\r\n   * Inherits from XHR transport.\r\n   */\r\n\r\n  io.util.inherit(XHRPolling, io.Transport.XHR);\r\n\r\n  /**\r\n   * Merge the properties from XHR transport\r\n   */\r\n\r\n  io.util.merge(XHRPolling, io.Transport.XHR);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  XHRPolling.prototype.name = 'xhr-polling';\r\n\r\n  /**\r\n   * Indicates whether heartbeats is enabled for this transport\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.heartbeats = function () {\r\n    return false;\r\n  };\r\n\r\n  /** \r\n   * Establish a connection, for iPhone and Android this will be done once the page\r\n   * is loaded.\r\n   *\r\n   * @returns {Transport} Chaining.\r\n   * @api public\r\n   */\r\n\r\n  XHRPolling.prototype.open = function () {\r\n    var self = this;\r\n\r\n    io.Transport.XHR.prototype.open.call(self);\r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Starts a XHR request to wait for incoming messages.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  function empty () {};\r\n\r\n  XHRPolling.prototype.get = function () {\r\n    if (!this.isOpen) return;\r\n\r\n    var self = this;\r\n\r\n    function stateChange () {\r\n      if (this.readyState == 4) {\r\n        this.onreadystatechange = empty;\r\n\r\n        if (this.status == 200) {\r\n          self.onData(this.responseText);\r\n          self.get();\r\n        } else {\r\n          self.onClose();\r\n        }\r\n      }\r\n    };\r\n\r\n    function onload () {\r\n      this.onload = empty;\r\n      this.onerror = empty;\r\n      self.onData(this.responseText);\r\n      self.get();\r\n    };\r\n\r\n    function onerror () {\r\n      self.onClose();\r\n    };\r\n\r\n    this.xhr = this.request();\r\n\r\n    if (global.XDomainRequest && this.xhr instanceof XDomainRequest) {\r\n      this.xhr.onload = onload;\r\n      this.xhr.onerror = onerror;\r\n    } else {\r\n      this.xhr.onreadystatechange = stateChange;\r\n    }\r\n\r\n    this.xhr.send(null);\r\n  };\r\n\r\n  /**\r\n   * Handle the unclean close behavior.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.onClose = function () {\r\n    io.Transport.XHR.prototype.onClose.call(this);\r\n\r\n    if (this.xhr) {\r\n      this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = empty;\r\n      try {\r\n        this.xhr.abort();\r\n      } catch(e){}\r\n      this.xhr = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Webkit based browsers show a infinit spinner when you start a XHR request\r\n   * before the browsers onload event is called so we need to defer opening of\r\n   * the transport until the onload event is called. Wrapping the cb in our\r\n   * defer method solve this.\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  XHRPolling.prototype.ready = function (socket, fn) {\r\n    var self = this;\r\n\r\n    io.util.defer(function () {\r\n      fn.call(self);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('xhr-polling');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , this\r\n);\r\n\r\n/**\r\n * socket.io\r\n * Copyright(c) 2011 LearnBoost <dev@learnboost.com>\r\n * MIT Licensed\r\n */\r\n\r\n(function (exports, io, global) {\r\n  /**\r\n   * There is a way to hide the loading indicator in Firefox. If you create and\r\n   * remove a iframe it will stop showing the current loading indicator.\r\n   * Unfortunately we can't feature detect that and UA sniffing is evil.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  var indicator = global.document && \"MozAppearance\" in\r\n    global.document.documentElement.style;\r\n\r\n  /**\r\n   * Expose constructor.\r\n   */\r\n\r\n  exports['jsonp-polling'] = JSONPPolling;\r\n\r\n  /**\r\n   * The JSONP transport creates an persistent connection by dynamically\r\n   * inserting a script tag in the page. This script tag will receive the\r\n   * information of the Socket.IO server. When new information is received\r\n   * it creates a new script tag for the new data stream.\r\n   *\r\n   * @constructor\r\n   * @extends {io.Transport.xhr-polling}\r\n   * @api public\r\n   */\r\n\r\n  function JSONPPolling (socket) {\r\n    io.Transport['xhr-polling'].apply(this, arguments);\r\n\r\n    this.index = io.j.length;\r\n\r\n    var self = this;\r\n\r\n    io.j.push(function (msg) {\r\n      self._(msg);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Inherits from XHR polling transport.\r\n   */\r\n\r\n  io.util.inherit(JSONPPolling, io.Transport['xhr-polling']);\r\n\r\n  /**\r\n   * Transport name\r\n   *\r\n   * @api public\r\n   */\r\n\r\n  JSONPPolling.prototype.name = 'jsonp-polling';\r\n\r\n  /**\r\n   * Posts a encoded message to the Socket.IO server using an iframe.\r\n   * The iframe is used because script tags can create POST based requests.\r\n   * The iframe is positioned outside of the view so the user does not\r\n   * notice it's existence.\r\n   *\r\n   * @param {String} data A encoded message.\r\n   * @api private\r\n   */\r\n\r\n  JSONPPolling.prototype.post = function (data) {\r\n    var self = this\r\n      , query = io.util.query(\r\n             this.socket.options.query\r\n          , 't='+ (+new Date) + '&i=' + this.index\r\n        );\r\n\r\n    if (!this.form) {\r\n      var form = document.createElement('form')\r\n        , area = document.createElement('textarea')\r\n        , id = this.iframeId = 'socketio_iframe_' + this.index\r\n        , iframe;\r\n\r\n      form.className = 'socketio';\r\n      form.style.position = 'absolute';\r\n      form.style.top = '0px';\r\n      form.style.left = '0px';\r\n      form.style.display = 'none';\r\n      form.target = id;\r\n      form.method = 'POST';\r\n      form.setAttribute('accept-charset', 'utf-8');\r\n      area.name = 'd';\r\n      form.appendChild(area);\r\n      document.body.appendChild(form);\r\n\r\n      this.form = form;\r\n      this.area = area;\r\n    }\r\n\r\n    this.form.action = this.prepareUrl() + query;\r\n\r\n    function complete () {\r\n      initIframe();\r\n      self.socket.setBuffer(false);\r\n    };\r\n\r\n    function initIframe () {\r\n      if (self.iframe) {\r\n        self.form.removeChild(self.iframe);\r\n      }\r\n\r\n      try {\r\n        // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\r\n        iframe = document.createElement('<iframe name=\"'+ self.iframeId +'\">');\r\n      } catch (e) {\r\n        iframe = document.createElement('iframe');\r\n        iframe.name = self.iframeId;\r\n      }\r\n\r\n      iframe.id = self.iframeId;\r\n\r\n      self.form.appendChild(iframe);\r\n      self.iframe = iframe;\r\n    };\r\n\r\n    initIframe();\r\n\r\n    // we temporarily stringify until we figure out how to prevent\r\n    // browsers from turning `\\n` into `\\r\\n` in form inputs\r\n    this.area.value = io.JSON.stringify(data);\r\n\r\n    try {\r\n      this.form.submit();\r\n    } catch(e) {}\r\n\r\n    if (this.iframe.attachEvent) {\r\n      iframe.onreadystatechange = function () {\r\n        if (self.iframe.readyState == 'complete') {\r\n          complete();\r\n        }\r\n      };\r\n    } else {\r\n      this.iframe.onload = complete;\r\n    }\r\n\r\n    this.socket.setBuffer(true);\r\n  };\r\n  \r\n  /**\r\n   * Creates a new JSONP poll that can be used to listen\r\n   * for messages from the Socket.IO server.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  JSONPPolling.prototype.get = function () {\r\n    var self = this\r\n      , script = document.createElement('script')\r\n      , query = io.util.query(\r\n             this.socket.options.query\r\n          , 't='+ (+new Date) + '&i=' + this.index\r\n        );\r\n\r\n    if (this.script) {\r\n      this.script.parentNode.removeChild(this.script);\r\n      this.script = null;\r\n    }\r\n\r\n    script.async = true;\r\n    script.src = this.prepareUrl() + query;\r\n    script.onerror = function () {\r\n      self.onClose();\r\n    };\r\n\r\n    var insertAt = document.getElementsByTagName('script')[0]\r\n    insertAt.parentNode.insertBefore(script, insertAt);\r\n    this.script = script;\r\n\r\n    if (indicator) {\r\n      setTimeout(function () {\r\n        var iframe = document.createElement('iframe');\r\n        document.body.appendChild(iframe);\r\n        document.body.removeChild(iframe);\r\n      }, 100);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Callback function for the incoming message stream from the Socket.IO server.\r\n   *\r\n   * @param {String} data The message\r\n   * @api private\r\n   */\r\n\r\n  JSONPPolling.prototype._ = function (msg) {\r\n    this.onData(msg);\r\n    if (this.isOpen) {\r\n      this.get();\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * The indicator hack only works after onload\r\n   *\r\n   * @param {Socket} socket The socket instance that needs a transport\r\n   * @param {Function} fn The callback\r\n   * @api private\r\n   */\r\n\r\n  JSONPPolling.prototype.ready = function (socket, fn) {\r\n    var self = this;\r\n    if (!indicator) return fn.call(this);\r\n\r\n    io.util.load(function () {\r\n      fn.call(self);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Checks if browser supports this transport.\r\n   *\r\n   * @return {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  JSONPPolling.check = function () {\r\n    return 'document' in global;\r\n  };\r\n\r\n  /**\r\n   * Check if cross domain requests are supported\r\n   *\r\n   * @returns {Boolean}\r\n   * @api public\r\n   */\r\n\r\n  JSONPPolling.xdomainCheck = function () {\r\n    return true;\r\n  };\r\n\r\n  /**\r\n   * Add the transport to your public io.transports array.\r\n   *\r\n   * @api private\r\n   */\r\n\r\n  io.transports.push('jsonp-polling');\r\n\r\n})(\r\n    'undefined' != typeof io ? io.Transport : module.exports\r\n  , 'undefined' != typeof io ? io : module.parent.exports\r\n  , this\r\n);\r\n\r\n})();\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)-dev-server/client/web_modules/socket.io/socket.io.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)-dev-server/client/web_modules/socket.io/socket.io.js?");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n/**\n * @license\n * Lo-Dash 2.4.1 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE\n * Build: `lodash modern -o ./dist/lodash.js`\n */\n;(function(){function n(n,t,e){e=(e||0)-1;for(var r=n?n.length:0;++e<r;)if(n[e]===t)return e;return-1}function t(t,e){var r=typeof e;if(t=t.l,\"boolean\"==r||null==e)return t[e]?0:-1;\"number\"!=r&&\"string\"!=r&&(r=\"object\");var u=\"number\"==r?e:m+e;return t=(t=t[r])&&t[u],\"object\"==r?t&&-1<n(t,e)?0:-1:t?0:-1}function e(n){var t=this.l,e=typeof n;if(\"boolean\"==e||null==n)t[n]=true;else{\"number\"!=e&&\"string\"!=e&&(e=\"object\");var r=\"number\"==e?n:m+n,t=t[e]||(t[e]={});\"object\"==e?(t[r]||(t[r]=[])).push(n):t[r]=true\n}}function r(n){return n.charCodeAt(0)}function u(n,t){for(var e=n.m,r=t.m,u=-1,o=e.length;++u<o;){var i=e[u],a=r[u];if(i!==a){if(i>a||typeof i==\"undefined\")return 1;if(i<a||typeof a==\"undefined\")return-1}}return n.n-t.n}function o(n){var t=-1,r=n.length,u=n[0],o=n[r/2|0],i=n[r-1];if(u&&typeof u==\"object\"&&o&&typeof o==\"object\"&&i&&typeof i==\"object\")return false;for(u=f(),u[\"false\"]=u[\"null\"]=u[\"true\"]=u.undefined=false,o=f(),o.k=n,o.l=u,o.push=e;++t<r;)o.push(n[t]);return o}function i(n){return\"\\\\\"+U[n]\n}function a(){return h.pop()||[]}function f(){return g.pop()||{k:null,l:null,m:null,\"false\":false,n:0,\"null\":false,number:null,object:null,push:null,string:null,\"true\":false,undefined:false,o:null}}function l(n){n.length=0,h.length<_&&h.push(n)}function c(n){var t=n.l;t&&c(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,g.length<_&&g.push(n)}function p(n,t,e){t||(t=0),typeof e==\"undefined\"&&(e=n?n.length:0);var r=-1;e=e-t||0;for(var u=Array(0>e?0:e);++r<e;)u[r]=n[t+r];return u}function s(e){function h(n,t,e){if(!n||!V[typeof n])return n;\nt=t&&typeof e==\"undefined\"?t:tt(t,e,3);for(var r=-1,u=V[typeof n]&&Fe(n),o=u?u.length:0;++r<o&&(e=u[r],false!==t(n[e],e,n)););return n}function g(n,t,e){var r;if(!n||!V[typeof n])return n;t=t&&typeof e==\"undefined\"?t:tt(t,e,3);for(r in n)if(false===t(n[r],r,n))break;return n}function _(n,t,e){var r,u=n,o=u;if(!u)return o;for(var i=arguments,a=0,f=typeof e==\"number\"?2:i.length;++a<f;)if((u=i[a])&&V[typeof u])for(var l=-1,c=V[typeof u]&&Fe(u),p=c?c.length:0;++l<p;)r=c[l],\"undefined\"==typeof o[r]&&(o[r]=u[r]);\nreturn o}function U(n,t,e){var r,u=n,o=u;if(!u)return o;var i=arguments,a=0,f=typeof e==\"number\"?2:i.length;if(3<f&&\"function\"==typeof i[f-2])var l=tt(i[--f-1],i[f--],2);else 2<f&&\"function\"==typeof i[f-1]&&(l=i[--f]);for(;++a<f;)if((u=i[a])&&V[typeof u])for(var c=-1,p=V[typeof u]&&Fe(u),s=p?p.length:0;++c<s;)r=p[c],o[r]=l?l(o[r],u[r]):u[r];return o}function H(n){var t,e=[];if(!n||!V[typeof n])return e;for(t in n)me.call(n,t)&&e.push(t);return e}function J(n){return n&&typeof n==\"object\"&&!Te(n)&&me.call(n,\"__wrapped__\")?n:new Q(n)\n}function Q(n,t){this.__chain__=!!t,this.__wrapped__=n}function X(n){function t(){if(r){var n=p(r);be.apply(n,arguments)}if(this instanceof t){var o=nt(e.prototype),n=e.apply(o,n||arguments);return wt(n)?n:o}return e.apply(u,n||arguments)}var e=n[0],r=n[2],u=n[4];return $e(t,n),t}function Z(n,t,e,r,u){if(e){var o=e(n);if(typeof o!=\"undefined\")return o}if(!wt(n))return n;var i=ce.call(n);if(!K[i])return n;var f=Ae[i];switch(i){case T:case F:return new f(+n);case W:case P:return new f(n);case z:return o=f(n.source,C.exec(n)),o.lastIndex=n.lastIndex,o\n}if(i=Te(n),t){var c=!r;r||(r=a()),u||(u=a());for(var s=r.length;s--;)if(r[s]==n)return u[s];o=i?f(n.length):{}}else o=i?p(n):U({},n);return i&&(me.call(n,\"index\")&&(o.index=n.index),me.call(n,\"input\")&&(o.input=n.input)),t?(r.push(n),u.push(o),(i?St:h)(n,function(n,i){o[i]=Z(n,t,e,r,u)}),c&&(l(r),l(u)),o):o}function nt(n){return wt(n)?ke(n):{}}function tt(n,t,e){if(typeof n!=\"function\")return Ut;if(typeof t==\"undefined\"||!(\"prototype\"in n))return n;var r=n.__bindData__;if(typeof r==\"undefined\"&&(De.funcNames&&(r=!n.name),r=r||!De.funcDecomp,!r)){var u=ge.call(n);\nDe.funcNames||(r=!O.test(u)),r||(r=E.test(u),$e(n,r))}if(false===r||true!==r&&1&r[1])return n;switch(e){case 1:return function(e){return n.call(t,e)};case 2:return function(e,r){return n.call(t,e,r)};case 3:return function(e,r,u){return n.call(t,e,r,u)};case 4:return function(e,r,u,o){return n.call(t,e,r,u,o)}}return Mt(n,t)}function et(n){function t(){var n=f?i:this;if(u){var h=p(u);be.apply(h,arguments)}return(o||c)&&(h||(h=p(arguments)),o&&be.apply(h,o),c&&h.length<a)?(r|=16,et([e,s?r:-4&r,h,null,i,a])):(h||(h=arguments),l&&(e=n[v]),this instanceof t?(n=nt(e.prototype),h=e.apply(n,h),wt(h)?h:n):e.apply(n,h))\n}var e=n[0],r=n[1],u=n[2],o=n[3],i=n[4],a=n[5],f=1&r,l=2&r,c=4&r,s=8&r,v=e;return $e(t,n),t}function rt(e,r){var u=-1,i=st(),a=e?e.length:0,f=a>=b&&i===n,l=[];if(f){var p=o(r);p?(i=t,r=p):f=false}for(;++u<a;)p=e[u],0>i(r,p)&&l.push(p);return f&&c(r),l}function ut(n,t,e,r){r=(r||0)-1;for(var u=n?n.length:0,o=[];++r<u;){var i=n[r];if(i&&typeof i==\"object\"&&typeof i.length==\"number\"&&(Te(i)||yt(i))){t||(i=ut(i,t,e));var a=-1,f=i.length,l=o.length;for(o.length+=f;++a<f;)o[l++]=i[a]}else e||o.push(i)}return o\n}function ot(n,t,e,r,u,o){if(e){var i=e(n,t);if(typeof i!=\"undefined\")return!!i}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&V[typeof n]||t&&V[typeof t]))return false;if(null==n||null==t)return n===t;var f=ce.call(n),c=ce.call(t);if(f==D&&(f=q),c==D&&(c=q),f!=c)return false;switch(f){case T:case F:return+n==+t;case W:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case z:case P:return n==oe(t)}if(c=f==$,!c){var p=me.call(n,\"__wrapped__\"),s=me.call(t,\"__wrapped__\");if(p||s)return ot(p?n.__wrapped__:n,s?t.__wrapped__:t,e,r,u,o);\nif(f!=q)return false;if(f=n.constructor,p=t.constructor,f!=p&&!(dt(f)&&f instanceof f&&dt(p)&&p instanceof p)&&\"constructor\"in n&&\"constructor\"in t)return false}for(f=!u,u||(u=a()),o||(o=a()),p=u.length;p--;)if(u[p]==n)return o[p]==t;var v=0,i=true;if(u.push(n),o.push(t),c){if(p=n.length,v=t.length,(i=v==p)||r)for(;v--;)if(c=p,s=t[v],r)for(;c--&&!(i=ot(n[c],s,e,r,u,o)););else if(!(i=ot(n[v],s,e,r,u,o)))break}else g(t,function(t,a,f){return me.call(f,a)?(v++,i=me.call(n,a)&&ot(n[a],t,e,r,u,o)):void 0}),i&&!r&&g(n,function(n,t,e){return me.call(e,t)?i=-1<--v:void 0\n});return u.pop(),o.pop(),f&&(l(u),l(o)),i}function it(n,t,e,r,u){(Te(t)?St:h)(t,function(t,o){var i,a,f=t,l=n[o];if(t&&((a=Te(t))||Pe(t))){for(f=r.length;f--;)if(i=r[f]==t){l=u[f];break}if(!i){var c;e&&(f=e(l,t),c=typeof f!=\"undefined\")&&(l=f),c||(l=a?Te(l)?l:[]:Pe(l)?l:{}),r.push(t),u.push(l),c||it(l,t,e,r,u)}}else e&&(f=e(l,t),typeof f==\"undefined\"&&(f=t)),typeof f!=\"undefined\"&&(l=f);n[o]=l})}function at(n,t){return n+he(Re()*(t-n+1))}function ft(e,r,u){var i=-1,f=st(),p=e?e.length:0,s=[],v=!r&&p>=b&&f===n,h=u||v?a():s;\nfor(v&&(h=o(h),f=t);++i<p;){var g=e[i],y=u?u(g,i,e):g;(r?!i||h[h.length-1]!==y:0>f(h,y))&&((u||v)&&h.push(y),s.push(g))}return v?(l(h.k),c(h)):u&&l(h),s}function lt(n){return function(t,e,r){var u={};e=J.createCallback(e,r,3),r=-1;var o=t?t.length:0;if(typeof o==\"number\")for(;++r<o;){var i=t[r];n(u,i,e(i,r,t),t)}else h(t,function(t,r,o){n(u,t,e(t,r,o),o)});return u}}function ct(n,t,e,r,u,o){var i=1&t,a=4&t,f=16&t,l=32&t;if(!(2&t||dt(n)))throw new ie;f&&!e.length&&(t&=-17,f=e=false),l&&!r.length&&(t&=-33,l=r=false);\nvar c=n&&n.__bindData__;return c&&true!==c?(c=p(c),c[2]&&(c[2]=p(c[2])),c[3]&&(c[3]=p(c[3])),!i||1&c[1]||(c[4]=u),!i&&1&c[1]&&(t|=8),!a||4&c[1]||(c[5]=o),f&&be.apply(c[2]||(c[2]=[]),e),l&&we.apply(c[3]||(c[3]=[]),r),c[1]|=t,ct.apply(null,c)):(1==t||17===t?X:et)([n,t,e,r,u,o])}function pt(n){return Be[n]}function st(){var t=(t=J.indexOf)===Wt?n:t;return t}function vt(n){return typeof n==\"function\"&&pe.test(n)}function ht(n){var t,e;return n&&ce.call(n)==q&&(t=n.constructor,!dt(t)||t instanceof t)?(g(n,function(n,t){e=t\n}),typeof e==\"undefined\"||me.call(n,e)):false}function gt(n){return We[n]}function yt(n){return n&&typeof n==\"object\"&&typeof n.length==\"number\"&&ce.call(n)==D||false}function mt(n,t,e){var r=Fe(n),u=r.length;for(t=tt(t,e,3);u--&&(e=r[u],false!==t(n[e],e,n)););return n}function bt(n){var t=[];return g(n,function(n,e){dt(n)&&t.push(e)}),t.sort()}function _t(n){for(var t=-1,e=Fe(n),r=e.length,u={};++t<r;){var o=e[t];u[n[o]]=o}return u}function dt(n){return typeof n==\"function\"}function wt(n){return!(!n||!V[typeof n])\n}function jt(n){return typeof n==\"number\"||n&&typeof n==\"object\"&&ce.call(n)==W||false}function kt(n){return typeof n==\"string\"||n&&typeof n==\"object\"&&ce.call(n)==P||false}function xt(n){for(var t=-1,e=Fe(n),r=e.length,u=Xt(r);++t<r;)u[t]=n[e[t]];return u}function Ct(n,t,e){var r=-1,u=st(),o=n?n.length:0,i=false;return e=(0>e?Ie(0,o+e):e)||0,Te(n)?i=-1<u(n,t,e):typeof o==\"number\"?i=-1<(kt(n)?n.indexOf(t,e):u(n,t,e)):h(n,function(n){return++r<e?void 0:!(i=n===t)}),i}function Ot(n,t,e){var r=true;t=J.createCallback(t,e,3),e=-1;\nvar u=n?n.length:0;if(typeof u==\"number\")for(;++e<u&&(r=!!t(n[e],e,n)););else h(n,function(n,e,u){return r=!!t(n,e,u)});return r}function Nt(n,t,e){var r=[];t=J.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u==\"number\")for(;++e<u;){var o=n[e];t(o,e,n)&&r.push(o)}else h(n,function(n,e,u){t(n,e,u)&&r.push(n)});return r}function It(n,t,e){t=J.createCallback(t,e,3),e=-1;var r=n?n.length:0;if(typeof r!=\"number\"){var u;return h(n,function(n,e,r){return t(n,e,r)?(u=n,false):void 0}),u}for(;++e<r;){var o=n[e];\nif(t(o,e,n))return o}}function St(n,t,e){var r=-1,u=n?n.length:0;if(t=t&&typeof e==\"undefined\"?t:tt(t,e,3),typeof u==\"number\")for(;++r<u&&false!==t(n[r],r,n););else h(n,t);return n}function Et(n,t,e){var r=n?n.length:0;if(t=t&&typeof e==\"undefined\"?t:tt(t,e,3),typeof r==\"number\")for(;r--&&false!==t(n[r],r,n););else{var u=Fe(n),r=u.length;h(n,function(n,e,o){return e=u?u[--r]:--r,t(o[e],e,o)})}return n}function Rt(n,t,e){var r=-1,u=n?n.length:0;if(t=J.createCallback(t,e,3),typeof u==\"number\")for(var o=Xt(u);++r<u;)o[r]=t(n[r],r,n);\nelse o=[],h(n,function(n,e,u){o[++r]=t(n,e,u)});return o}function At(n,t,e){var u=-1/0,o=u;if(typeof t!=\"function\"&&e&&e[t]===n&&(t=null),null==t&&Te(n)){e=-1;for(var i=n.length;++e<i;){var a=n[e];a>o&&(o=a)}}else t=null==t&&kt(n)?r:J.createCallback(t,e,3),St(n,function(n,e,r){e=t(n,e,r),e>u&&(u=e,o=n)});return o}function Dt(n,t,e,r){if(!n)return e;var u=3>arguments.length;t=J.createCallback(t,r,4);var o=-1,i=n.length;if(typeof i==\"number\")for(u&&(e=n[++o]);++o<i;)e=t(e,n[o],o,n);else h(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)\n});return e}function $t(n,t,e,r){var u=3>arguments.length;return t=J.createCallback(t,r,4),Et(n,function(n,r,o){e=u?(u=false,n):t(e,n,r,o)}),e}function Tt(n){var t=-1,e=n?n.length:0,r=Xt(typeof e==\"number\"?e:0);return St(n,function(n){var e=at(0,++t);r[t]=r[e],r[e]=n}),r}function Ft(n,t,e){var r;t=J.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u==\"number\")for(;++e<u&&!(r=t(n[e],e,n)););else h(n,function(n,e,u){return!(r=t(n,e,u))});return!!r}function Bt(n,t,e){var r=0,u=n?n.length:0;if(typeof t!=\"number\"&&null!=t){var o=-1;\nfor(t=J.createCallback(t,e,3);++o<u&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[0]:v;return p(n,0,Se(Ie(0,r),u))}function Wt(t,e,r){if(typeof r==\"number\"){var u=t?t.length:0;r=0>r?Ie(0,u+r):r||0}else if(r)return r=zt(t,e),t[r]===e?r:-1;return n(t,e,r)}function qt(n,t,e){if(typeof t!=\"number\"&&null!=t){var r=0,u=-1,o=n?n.length:0;for(t=J.createCallback(t,e,3);++u<o&&t(n[u],u,n);)r++}else r=null==t||e?1:Ie(0,t);return p(n,r)}function zt(n,t,e,r){var u=0,o=n?n.length:u;for(e=e?J.createCallback(e,r,1):Ut,t=e(t);u<o;)r=u+o>>>1,e(n[r])<t?u=r+1:o=r;\nreturn u}function Pt(n,t,e,r){return typeof t!=\"boolean\"&&null!=t&&(r=e,e=typeof t!=\"function\"&&r&&r[t]===n?null:t,t=false),null!=e&&(e=J.createCallback(e,r,3)),ft(n,t,e)}function Kt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,e=n?At(Ve(n,\"length\")):0,r=Xt(0>e?0:e);++t<e;)r[t]=Ve(n,t);return r}function Lt(n,t){var e=-1,r=n?n.length:0,u={};for(t||!r||Te(n[0])||(t=[]);++e<r;){var o=n[e];t?u[o]=t[e]:o&&(u[o[0]]=o[1])}return u}function Mt(n,t){return 2<arguments.length?ct(n,17,p(arguments,2),null,t):ct(n,1,null,null,t)\n}function Vt(n,t,e){function r(){c&&ve(c),i=c=p=v,(g||h!==t)&&(s=Ue(),a=n.apply(l,o),c||i||(o=l=null))}function u(){var e=t-(Ue()-f);0<e?c=_e(u,e):(i&&ve(i),e=p,i=c=p=v,e&&(s=Ue(),a=n.apply(l,o),c||i||(o=l=null)))}var o,i,a,f,l,c,p,s=0,h=false,g=true;if(!dt(n))throw new ie;if(t=Ie(0,t)||0,true===e)var y=true,g=false;else wt(e)&&(y=e.leading,h=\"maxWait\"in e&&(Ie(t,e.maxWait)||0),g=\"trailing\"in e?e.trailing:g);return function(){if(o=arguments,f=Ue(),l=this,p=g&&(c||!y),false===h)var e=y&&!c;else{i||y||(s=f);var v=h-(f-s),m=0>=v;\nm?(i&&(i=ve(i)),s=f,a=n.apply(l,o)):i||(i=_e(r,v))}return m&&c?c=ve(c):c||t===h||(c=_e(u,t)),e&&(m=true,a=n.apply(l,o)),!m||c||i||(o=l=null),a}}function Ut(n){return n}function Gt(n,t,e){var r=true,u=t&&bt(t);t&&(e||u.length)||(null==e&&(e=t),o=Q,t=n,n=J,u=bt(t)),false===e?r=false:wt(e)&&\"chain\"in e&&(r=e.chain);var o=n,i=dt(o);St(u,function(e){var u=n[e]=t[e];i&&(o.prototype[e]=function(){var t=this.__chain__,e=this.__wrapped__,i=[e];if(be.apply(i,arguments),i=u.apply(n,i),r||t){if(e===i&&wt(i))return this;\ni=new o(i),i.__chain__=t}return i})})}function Ht(){}function Jt(n){return function(t){return t[n]}}function Qt(){return this.__wrapped__}e=e?Y.defaults(G.Object(),e,Y.pick(G,A)):G;var Xt=e.Array,Yt=e.Boolean,Zt=e.Date,ne=e.Function,te=e.Math,ee=e.Number,re=e.Object,ue=e.RegExp,oe=e.String,ie=e.TypeError,ae=[],fe=re.prototype,le=e._,ce=fe.toString,pe=ue(\"^\"+oe(ce).replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\").replace(/toString| for [^\\]]+/g,\".*?\")+\"$\"),se=te.ceil,ve=e.clearTimeout,he=te.floor,ge=ne.prototype.toString,ye=vt(ye=re.getPrototypeOf)&&ye,me=fe.hasOwnProperty,be=ae.push,_e=e.setTimeout,de=ae.splice,we=ae.unshift,je=function(){try{var n={},t=vt(t=re.defineProperty)&&t,e=t(n,n,n)&&t\n}catch(r){}return e}(),ke=vt(ke=re.create)&&ke,xe=vt(xe=Xt.isArray)&&xe,Ce=e.isFinite,Oe=e.isNaN,Ne=vt(Ne=re.keys)&&Ne,Ie=te.max,Se=te.min,Ee=e.parseInt,Re=te.random,Ae={};Ae[$]=Xt,Ae[T]=Yt,Ae[F]=Zt,Ae[B]=ne,Ae[q]=re,Ae[W]=ee,Ae[z]=ue,Ae[P]=oe,Q.prototype=J.prototype;var De=J.support={};De.funcDecomp=!vt(e.a)&&E.test(s),De.funcNames=typeof ne.name==\"string\",J.templateSettings={escape:/<%-([\\s\\S]+?)%>/g,evaluate:/<%([\\s\\S]+?)%>/g,interpolate:N,variable:\"\",imports:{_:J}},ke||(nt=function(){function n(){}return function(t){if(wt(t)){n.prototype=t;\nvar r=new n;n.prototype=null}return r||e.Object()}}());var $e=je?function(n,t){M.value=t,je(n,\"__bindData__\",M)}:Ht,Te=xe||function(n){return n&&typeof n==\"object\"&&typeof n.length==\"number\"&&ce.call(n)==$||false},Fe=Ne?function(n){return wt(n)?Ne(n):[]}:H,Be={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\"},We=_t(Be),qe=ue(\"(\"+Fe(We).join(\"|\")+\")\",\"g\"),ze=ue(\"[\"+Fe(Be).join(\"\")+\"]\",\"g\"),Pe=ye?function(n){if(!n||ce.call(n)!=q)return false;var t=n.valueOf,e=vt(t)&&(e=ye(t))&&ye(e);return e?n==e||ye(n)==e:ht(n)\n}:ht,Ke=lt(function(n,t,e){me.call(n,e)?n[e]++:n[e]=1}),Le=lt(function(n,t,e){(me.call(n,e)?n[e]:n[e]=[]).push(t)}),Me=lt(function(n,t,e){n[e]=t}),Ve=Rt,Ue=vt(Ue=Zt.now)&&Ue||function(){return(new Zt).getTime()},Ge=8==Ee(d+\"08\")?Ee:function(n,t){return Ee(kt(n)?n.replace(I,\"\"):n,t||0)};return J.after=function(n,t){if(!dt(t))throw new ie;return function(){return 1>--n?t.apply(this,arguments):void 0}},J.assign=U,J.at=function(n){for(var t=arguments,e=-1,r=ut(t,true,false,1),t=t[2]&&t[2][t[1]]===n?1:r.length,u=Xt(t);++e<t;)u[e]=n[r[e]];\nreturn u},J.bind=Mt,J.bindAll=function(n){for(var t=1<arguments.length?ut(arguments,true,false,1):bt(n),e=-1,r=t.length;++e<r;){var u=t[e];n[u]=ct(n[u],1,null,null,n)}return n},J.bindKey=function(n,t){return 2<arguments.length?ct(t,19,p(arguments,2),null,n):ct(t,3,null,null,n)},J.chain=function(n){return n=new Q(n),n.__chain__=true,n},J.compact=function(n){for(var t=-1,e=n?n.length:0,r=[];++t<e;){var u=n[t];u&&r.push(u)}return r},J.compose=function(){for(var n=arguments,t=n.length;t--;)if(!dt(n[t]))throw new ie;\nreturn function(){for(var t=arguments,e=n.length;e--;)t=[n[e].apply(this,t)];return t[0]}},J.constant=function(n){return function(){return n}},J.countBy=Ke,J.create=function(n,t){var e=nt(n);return t?U(e,t):e},J.createCallback=function(n,t,e){var r=typeof n;if(null==n||\"function\"==r)return tt(n,t,e);if(\"object\"!=r)return Jt(n);var u=Fe(n),o=u[0],i=n[o];return 1!=u.length||i!==i||wt(i)?function(t){for(var e=u.length,r=false;e--&&(r=ot(t[u[e]],n[u[e]],null,true)););return r}:function(n){return n=n[o],i===n&&(0!==i||1/i==1/n)\n}},J.curry=function(n,t){return t=typeof t==\"number\"?t:+t||n.length,ct(n,4,null,null,null,t)},J.debounce=Vt,J.defaults=_,J.defer=function(n){if(!dt(n))throw new ie;var t=p(arguments,1);return _e(function(){n.apply(v,t)},1)},J.delay=function(n,t){if(!dt(n))throw new ie;var e=p(arguments,2);return _e(function(){n.apply(v,e)},t)},J.difference=function(n){return rt(n,ut(arguments,true,true,1))},J.filter=Nt,J.flatten=function(n,t,e,r){return typeof t!=\"boolean\"&&null!=t&&(r=e,e=typeof t!=\"function\"&&r&&r[t]===n?null:t,t=false),null!=e&&(n=Rt(n,e,r)),ut(n,t)\n},J.forEach=St,J.forEachRight=Et,J.forIn=g,J.forInRight=function(n,t,e){var r=[];g(n,function(n,t){r.push(t,n)});var u=r.length;for(t=tt(t,e,3);u--&&false!==t(r[u--],r[u],n););return n},J.forOwn=h,J.forOwnRight=mt,J.functions=bt,J.groupBy=Le,J.indexBy=Me,J.initial=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!=\"number\"&&null!=t){var o=u;for(t=J.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else r=null==t||e?1:t||r;return p(n,0,Se(Ie(0,u-r),u))},J.intersection=function(){for(var e=[],r=-1,u=arguments.length,i=a(),f=st(),p=f===n,s=a();++r<u;){var v=arguments[r];\n(Te(v)||yt(v))&&(e.push(v),i.push(p&&v.length>=b&&o(r?e[r]:s)))}var p=e[0],h=-1,g=p?p.length:0,y=[];n:for(;++h<g;){var m=i[0],v=p[h];if(0>(m?t(m,v):f(s,v))){for(r=u,(m||s).push(v);--r;)if(m=i[r],0>(m?t(m,v):f(e[r],v)))continue n;y.push(v)}}for(;u--;)(m=i[u])&&c(m);return l(i),l(s),y},J.invert=_t,J.invoke=function(n,t){var e=p(arguments,2),r=-1,u=typeof t==\"function\",o=n?n.length:0,i=Xt(typeof o==\"number\"?o:0);return St(n,function(n){i[++r]=(u?t:n[t]).apply(n,e)}),i},J.keys=Fe,J.map=Rt,J.mapValues=function(n,t,e){var r={};\nreturn t=J.createCallback(t,e,3),h(n,function(n,e,u){r[e]=t(n,e,u)}),r},J.max=At,J.memoize=function(n,t){function e(){var r=e.cache,u=t?t.apply(this,arguments):m+arguments[0];return me.call(r,u)?r[u]:r[u]=n.apply(this,arguments)}if(!dt(n))throw new ie;return e.cache={},e},J.merge=function(n){var t=arguments,e=2;if(!wt(n))return n;if(\"number\"!=typeof t[2]&&(e=t.length),3<e&&\"function\"==typeof t[e-2])var r=tt(t[--e-1],t[e--],2);else 2<e&&\"function\"==typeof t[e-1]&&(r=t[--e]);for(var t=p(arguments,1,e),u=-1,o=a(),i=a();++u<e;)it(n,t[u],r,o,i);\nreturn l(o),l(i),n},J.min=function(n,t,e){var u=1/0,o=u;if(typeof t!=\"function\"&&e&&e[t]===n&&(t=null),null==t&&Te(n)){e=-1;for(var i=n.length;++e<i;){var a=n[e];a<o&&(o=a)}}else t=null==t&&kt(n)?r:J.createCallback(t,e,3),St(n,function(n,e,r){e=t(n,e,r),e<u&&(u=e,o=n)});return o},J.omit=function(n,t,e){var r={};if(typeof t!=\"function\"){var u=[];g(n,function(n,t){u.push(t)});for(var u=rt(u,ut(arguments,true,false,1)),o=-1,i=u.length;++o<i;){var a=u[o];r[a]=n[a]}}else t=J.createCallback(t,e,3),g(n,function(n,e,u){t(n,e,u)||(r[e]=n)\n});return r},J.once=function(n){var t,e;if(!dt(n))throw new ie;return function(){return t?e:(t=true,e=n.apply(this,arguments),n=null,e)}},J.pairs=function(n){for(var t=-1,e=Fe(n),r=e.length,u=Xt(r);++t<r;){var o=e[t];u[t]=[o,n[o]]}return u},J.partial=function(n){return ct(n,16,p(arguments,1))},J.partialRight=function(n){return ct(n,32,null,p(arguments,1))},J.pick=function(n,t,e){var r={};if(typeof t!=\"function\")for(var u=-1,o=ut(arguments,true,false,1),i=wt(n)?o.length:0;++u<i;){var a=o[u];a in n&&(r[a]=n[a])\n}else t=J.createCallback(t,e,3),g(n,function(n,e,u){t(n,e,u)&&(r[e]=n)});return r},J.pluck=Ve,J.property=Jt,J.pull=function(n){for(var t=arguments,e=0,r=t.length,u=n?n.length:0;++e<r;)for(var o=-1,i=t[e];++o<u;)n[o]===i&&(de.call(n,o--,1),u--);return n},J.range=function(n,t,e){n=+n||0,e=typeof e==\"number\"?e:+e||1,null==t&&(t=n,n=0);var r=-1;t=Ie(0,se((t-n)/(e||1)));for(var u=Xt(t);++r<t;)u[r]=n,n+=e;return u},J.reject=function(n,t,e){return t=J.createCallback(t,e,3),Nt(n,function(n,e,r){return!t(n,e,r)\n})},J.remove=function(n,t,e){var r=-1,u=n?n.length:0,o=[];for(t=J.createCallback(t,e,3);++r<u;)e=n[r],t(e,r,n)&&(o.push(e),de.call(n,r--,1),u--);return o},J.rest=qt,J.shuffle=Tt,J.sortBy=function(n,t,e){var r=-1,o=Te(t),i=n?n.length:0,p=Xt(typeof i==\"number\"?i:0);for(o||(t=J.createCallback(t,e,3)),St(n,function(n,e,u){var i=p[++r]=f();o?i.m=Rt(t,function(t){return n[t]}):(i.m=a())[0]=t(n,e,u),i.n=r,i.o=n}),i=p.length,p.sort(u);i--;)n=p[i],p[i]=n.o,o||l(n.m),c(n);return p},J.tap=function(n,t){return t(n),n\n},J.throttle=function(n,t,e){var r=true,u=true;if(!dt(n))throw new ie;return false===e?r=false:wt(e)&&(r=\"leading\"in e?e.leading:r,u=\"trailing\"in e?e.trailing:u),L.leading=r,L.maxWait=t,L.trailing=u,Vt(n,t,L)},J.times=function(n,t,e){n=-1<(n=+n)?n:0;var r=-1,u=Xt(n);for(t=tt(t,e,1);++r<n;)u[r]=t(r);return u},J.toArray=function(n){return n&&typeof n.length==\"number\"?p(n):xt(n)},J.transform=function(n,t,e,r){var u=Te(n);if(null==e)if(u)e=[];else{var o=n&&n.constructor;e=nt(o&&o.prototype)}return t&&(t=J.createCallback(t,r,4),(u?St:h)(n,function(n,r,u){return t(e,n,r,u)\n})),e},J.union=function(){return ft(ut(arguments,true,true))},J.uniq=Pt,J.values=xt,J.where=Nt,J.without=function(n){return rt(n,p(arguments,1))},J.wrap=function(n,t){return ct(t,16,[n])},J.xor=function(){for(var n=-1,t=arguments.length;++n<t;){var e=arguments[n];if(Te(e)||yt(e))var r=r?ft(rt(r,e).concat(rt(e,r))):e}return r||[]},J.zip=Kt,J.zipObject=Lt,J.collect=Rt,J.drop=qt,J.each=St,J.eachRight=Et,J.extend=U,J.methods=bt,J.object=Lt,J.select=Nt,J.tail=qt,J.unique=Pt,J.unzip=Kt,Gt(J),J.clone=function(n,t,e,r){return typeof t!=\"boolean\"&&null!=t&&(r=e,e=t,t=false),Z(n,t,typeof e==\"function\"&&tt(e,r,1))\n},J.cloneDeep=function(n,t,e){return Z(n,true,typeof t==\"function\"&&tt(t,e,1))},J.contains=Ct,J.escape=function(n){return null==n?\"\":oe(n).replace(ze,pt)},J.every=Ot,J.find=It,J.findIndex=function(n,t,e){var r=-1,u=n?n.length:0;for(t=J.createCallback(t,e,3);++r<u;)if(t(n[r],r,n))return r;return-1},J.findKey=function(n,t,e){var r;return t=J.createCallback(t,e,3),h(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},J.findLast=function(n,t,e){var r;return t=J.createCallback(t,e,3),Et(n,function(n,e,u){return t(n,e,u)?(r=n,false):void 0\n}),r},J.findLastIndex=function(n,t,e){var r=n?n.length:0;for(t=J.createCallback(t,e,3);r--;)if(t(n[r],r,n))return r;return-1},J.findLastKey=function(n,t,e){var r;return t=J.createCallback(t,e,3),mt(n,function(n,e,u){return t(n,e,u)?(r=e,false):void 0}),r},J.has=function(n,t){return n?me.call(n,t):false},J.identity=Ut,J.indexOf=Wt,J.isArguments=yt,J.isArray=Te,J.isBoolean=function(n){return true===n||false===n||n&&typeof n==\"object\"&&ce.call(n)==T||false},J.isDate=function(n){return n&&typeof n==\"object\"&&ce.call(n)==F||false\n},J.isElement=function(n){return n&&1===n.nodeType||false},J.isEmpty=function(n){var t=true;if(!n)return t;var e=ce.call(n),r=n.length;return e==$||e==P||e==D||e==q&&typeof r==\"number\"&&dt(n.splice)?!r:(h(n,function(){return t=false}),t)},J.isEqual=function(n,t,e,r){return ot(n,t,typeof e==\"function\"&&tt(e,r,2))},J.isFinite=function(n){return Ce(n)&&!Oe(parseFloat(n))},J.isFunction=dt,J.isNaN=function(n){return jt(n)&&n!=+n},J.isNull=function(n){return null===n},J.isNumber=jt,J.isObject=wt,J.isPlainObject=Pe,J.isRegExp=function(n){return n&&typeof n==\"object\"&&ce.call(n)==z||false\n},J.isString=kt,J.isUndefined=function(n){return typeof n==\"undefined\"},J.lastIndexOf=function(n,t,e){var r=n?n.length:0;for(typeof e==\"number\"&&(r=(0>e?Ie(0,r+e):Se(e,r-1))+1);r--;)if(n[r]===t)return r;return-1},J.mixin=Gt,J.noConflict=function(){return e._=le,this},J.noop=Ht,J.now=Ue,J.parseInt=Ge,J.random=function(n,t,e){var r=null==n,u=null==t;return null==e&&(typeof n==\"boolean\"&&u?(e=n,n=1):u||typeof t!=\"boolean\"||(e=t,u=true)),r&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,e||n%1||t%1?(e=Re(),Se(n+e*(t-n+parseFloat(\"1e-\"+((e+\"\").length-1))),t)):at(n,t)\n},J.reduce=Dt,J.reduceRight=$t,J.result=function(n,t){if(n){var e=n[t];return dt(e)?n[t]():e}},J.runInContext=s,J.size=function(n){var t=n?n.length:0;return typeof t==\"number\"?t:Fe(n).length},J.some=Ft,J.sortedIndex=zt,J.template=function(n,t,e){var r=J.templateSettings;n=oe(n||\"\"),e=_({},e,r);var u,o=_({},e.imports,r.imports),r=Fe(o),o=xt(o),a=0,f=e.interpolate||S,l=\"__p+='\",f=ue((e.escape||S).source+\"|\"+f.source+\"|\"+(f===N?x:S).source+\"|\"+(e.evaluate||S).source+\"|$\",\"g\");n.replace(f,function(t,e,r,o,f,c){return r||(r=o),l+=n.slice(a,c).replace(R,i),e&&(l+=\"'+__e(\"+e+\")+'\"),f&&(u=true,l+=\"';\"+f+\";\\n__p+='\"),r&&(l+=\"'+((__t=(\"+r+\"))==null?'':__t)+'\"),a=c+t.length,t\n}),l+=\"';\",f=e=e.variable,f||(e=\"obj\",l=\"with(\"+e+\"){\"+l+\"}\"),l=(u?l.replace(w,\"\"):l).replace(j,\"$1\").replace(k,\"$1;\"),l=\"function(\"+e+\"){\"+(f?\"\":e+\"||(\"+e+\"={});\")+\"var __t,__p='',__e=_.escape\"+(u?\",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}\":\";\")+l+\"return __p}\";try{var c=ne(r,\"return \"+l).apply(v,o)}catch(p){throw p.source=l,p}return t?c(t):(c.source=l,c)},J.unescape=function(n){return null==n?\"\":oe(n).replace(qe,gt)},J.uniqueId=function(n){var t=++y;return oe(null==n?\"\":n)+t\n},J.all=Ot,J.any=Ft,J.detect=It,J.findWhere=It,J.foldl=Dt,J.foldr=$t,J.include=Ct,J.inject=Dt,Gt(function(){var n={};return h(J,function(t,e){J.prototype[e]||(n[e]=t)}),n}(),false),J.first=Bt,J.last=function(n,t,e){var r=0,u=n?n.length:0;if(typeof t!=\"number\"&&null!=t){var o=u;for(t=J.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[u-1]:v;return p(n,Ie(0,u-r))},J.sample=function(n,t,e){return n&&typeof n.length!=\"number\"&&(n=xt(n)),null==t||e?n?n[at(0,n.length-1)]:v:(n=Tt(n),n.length=Se(Ie(0,t),n.length),n)\n},J.take=Bt,J.head=Bt,h(J,function(n,t){var e=\"sample\"!==t;J.prototype[t]||(J.prototype[t]=function(t,r){var u=this.__chain__,o=n(this.__wrapped__,t,r);return u||null!=t&&(!r||e&&typeof t==\"function\")?new Q(o,u):o})}),J.VERSION=\"2.4.1\",J.prototype.chain=function(){return this.__chain__=true,this},J.prototype.toString=function(){return oe(this.__wrapped__)},J.prototype.value=Qt,J.prototype.valueOf=Qt,St([\"join\",\"pop\",\"shift\"],function(n){var t=ae[n];J.prototype[n]=function(){var n=this.__chain__,e=t.apply(this.__wrapped__,arguments);\nreturn n?new Q(e,n):e}}),St([\"push\",\"reverse\",\"sort\",\"unshift\"],function(n){var t=ae[n];J.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),St([\"concat\",\"slice\",\"splice\"],function(n){var t=ae[n];J.prototype[n]=function(){return new Q(t.apply(this.__wrapped__,arguments),this.__chain__)}}),J}var v,h=[],g=[],y=0,m=+new Date+\"\",b=75,_=40,d=\" \\t\\x0B\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\",w=/\\b__p\\+='';/g,j=/\\b(__p\\+=)''\\+/g,k=/(__e\\(.*?\\)|\\b__t\\))\\+'';/g,x=/\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g,C=/\\w*$/,O=/^\\s*function[ \\n\\r\\t]+\\w/,N=/<%=([\\s\\S]+?)%>/g,I=RegExp(\"^[\"+d+\"]*0+(?=.$)\"),S=/($^)/,E=/\\bthis\\b/,R=/['\\n\\r\\t\\u2028\\u2029\\\\]/g,A=\"Array Boolean Date Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setTimeout\".split(\" \"),D=\"[object Arguments]\",$=\"[object Array]\",T=\"[object Boolean]\",F=\"[object Date]\",B=\"[object Function]\",W=\"[object Number]\",q=\"[object Object]\",z=\"[object RegExp]\",P=\"[object String]\",K={};\nK[B]=false,K[D]=K[$]=K[T]=K[F]=K[W]=K[q]=K[z]=K[P]=true;var L={leading:false,maxWait:0,trailing:false},M={configurable:false,enumerable:false,value:null,writable:false},V={\"boolean\":false,\"function\":true,object:true,number:false,string:false,undefined:false},U={\"\\\\\":\"\\\\\",\"'\":\"'\",\"\\n\":\"n\",\"\\r\":\"r\",\"\\t\":\"t\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},G=V[typeof window]&&window||this,H=V[typeof exports]&&exports&&!exports.nodeType&&exports,J=V[typeof module]&&module&&!module.nodeType&&module,Q=J&&J.exports===H&&H,X=V[typeof global]&&global;!X||X.global!==X&&X.window!==X||(G=X);\nvar Y=s();true?(G._=Y, !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return Y}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))):H&&J?Q?(J.exports=Y)._=Y:H._=Y:G._=Y}).call(this);\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"lodash.min.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module), (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/lodash.min.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/lodash.min.js?");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\n'use strict';\n\nvar React = __webpack_require__(12);\nvar Reflux = __webpack_require__(40);\n\nvar FermActions = Reflux.createActions([\n    \"chooseItem\",\n    \"updateItem\",\n    \"removeItem\",\n    \"addItem\",\n    \"updateList\",\n    \"addFunction\",\n    \"addEstimate\",\n    \"updateEditingNode\",\n    \"resetEditingNode\"\n]);\n\nmodule.exports = FermActions;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"actions.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/flux/actions.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/flux/actions.js?");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\nvar React = __webpack_require__(12);\nvar Reflux = __webpack_require__(40);\nvar FermActions = __webpack_require__(21);\nvar _ = __webpack_require__(20);\n\nvar todoCounter = 0,\n    localStorageKey = \"fermi\";\n\nvar fermListStore = Reflux.createStore({\n    listenables: [FermActions],\n    getItems: function() {\n        return this.list;\n    },\n    addEstimate: function() {\n        var newItem = {\n            id: todoCounter++,\n            created: new Date(),\n            name: '',\n            value: '',\n            type: 'estimate'\n        };\n        this.updateList([newItem].concat(this.list));\n        FermActions.updateEditingNode(newItem.id)\n    },\n    addFunction: function() {\n        var newResult = {\n            id: todoCounter++,\n            created: new Date(),\n            name: '',\n            value: '',\n            type: 'result'\n        };\n        var newFun = {\n            id: todoCounter++,\n            created: new Date(),\n            function: 'addition',\n            type: 'function',\n            output: newResult.id\n        };\n        this.updateList([newResult, newFun].concat(this.list));\n        FermActions.updateEditingNode(newResult)\n    },\n    onAddItem: function(type) {\n        if (type==\"estimate\"){\n            this.addEstimate();\n        } else {\n            this.addFunction();\n        }\n    },\n    onUpdateList: function(list){\n        _.map(list, function(n){this._onUpdateItem(n.id, n)}, this)\n        this.updateList(this.list);\n    },\n    onUpdateItem: function(itemId, newValues) {\n        this._onUpdateItem(itemId, newValues)\n        this.updateList(this.list);\n    },\n    updateList: function(list) {\n        localStorage.setItem(localStorageKey, JSON.stringify(list));\n        this.list = list;\n        this.trigger(list);\n    },\n    _onUpdateItem: function(itemId, newValues){\n        var item = this.getItem(parseInt(itemId));\n        if (!item) {\n            return;\n        };\n        item = _.merge(item, newValues)\n    },\n    onRemoveItem: function(itemId) {\n        var newList = (_.filter(this.list,function(item){\n            return item.id!==itemId;\n        }));\n        this.updateList(newList);\n        FermActions.resetEditingNode()\n    },\n    getItem: function(itemId){\n        return _.find(this.list, function(item){\n            return item.id === itemId;\n        })\n    },\n    getList: function(){\n        return this.list;\n    },\n    getInitialState: function() {\n        var loadedList = localStorage.getItem(localStorageKey);\n        if (!loadedList) {\n            // If no list is in localstorage, start out with a default one\n            this.list = [\n                {\n                    id: todoCounter++,\n                    created: new Date(),\n                    name: 'first item',\n                    mean: 0,\n                    type: 'estimate'\n                },\n                {\n                    id: todoCounter++,\n                    created: new Date(),\n                    name: 'second item',\n                    mean: 0,\n                    type: 'estimate'\n                }\n            ];\n        } else {\n            this.list = JSON.parse(loadedList);\n            todoCounter = parseInt(_.max(this.list, 'id').id) + 1\n        }\n        return this.list;\n    }\n})\n\nmodule.exports = fermListStore;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"fermliststore.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/flux/stores/fermliststore.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/flux/stores/fermliststore.js?");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\nvar Reflux = __webpack_require__(40);\nvar FermActions = __webpack_require__(21);\nvar fermListStore = __webpack_require__(22);\n\nvar fermEditingStore = Reflux.createStore({\n    listenables: [FermActions],\n    getInitialState: function(){\n        this.editingNode = 3;\n        return this.editingNode;\n    },\n\n    // Getters\n    getEditingNodeId: function(){\n        return this.editingNode;\n    },\n    getEditingNode: function(){\n        return fermListStore.getItem(this.editingNode);\n    },\n\n    // Setters\n    onUpdateEditingNode: function(id) {\n        this.updateEditingNode(id);\n    },\n    onResetEditingNode: function(id) {\n        this.updateEditingNode(null);\n    },\n\n    // Helpers\n    updateEditingNode: function(id) {\n        this.editingNode = id;\n        this.trigger(this.editingNode);\n    }\n});\n\nmodule.exports = fermEditingStore;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"fermeditingstore.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/flux/stores/fermeditingstore.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/flux/stores/fermeditingstore.js?");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(module) {/* REACT HOT LOADER */ if (true) { (function () { var ReactHotAPI = __webpack_require__(11), RootInstanceProvider = __webpack_require__(4), ReactMount = __webpack_require__(10); module.makeHot = module.hot.data ? module.hot.data.makeHot : ReactHotAPI(function () { return RootInstanceProvider.getRootInstances(ReactMount); }); })(); } (function () {\n\nvar cytoscape = __webpack_require__(125);\n\nvar maingraph = {};\n\n\nmaingraph.create = function(el, inputNodes, inputEdges, mainfun, updatefun, isCreated){\n\n  this.cy = cytoscape({\n    container: el,\n    style: cytoscape.stylesheet()\n      .selector('node')\n        .css({\n          'content': 'data(name)',\n          'font-size': 14,\n          'text-valign': 'center',\n          'text-halign': 'center',\n        })\n      .selector('node[type=\"function\"]')\n          .css({\n            'background-color': '#fff',\n            'color': '#8E3C3A',\n            'text-valign': 'center',\n            'text-halign': 'center',\n            'font-size': 30,\n            'width': 40,\n            'height': 40,\n        })\n      .selector('node[type=\"estimate\"]')\n          .css({\n            'width': 80,\n            'font-weight': 'bold',\n            'height': 25,\n            'color': '#444',\n            'background-color': '#fff',\n            'text-outline-width': 4,\n            'text-outline-color': '#fff'\n        })\n      .selector('node[type=\"result\"]')\n          .css({\n            'color': '#8E3C3A',\n            'width': 80,\n            'font-weight': 'bold',\n            'height': 25,\n            'background-color': '#fff',\n            'text-outline-width': 4,\n            'text-outline-color': '#fff'\n        })\n      .selector('edge')\n        .css({\n          'target-arrow-shape': 'triangle',\n          'width': 2,\n          'line-color': '#ddd',\n          'target-arrow-color': '#666'\n        })\n      .selector('.highlighted')\n        .css({\n          'background-color': '#61bffc',\n          'line-color': '#61bffc',\n          'target-arrow-color': '#61bffc',\n          'transition-property': 'background-color, line-color, target-arrow-color',\n          'transition-duration': '0.5s'\n        }),\n\n    elements: {\n        nodes: inputNodes,\n        edges: inputEdges\n      },\n    layout: {\n      name: 'breadthfirst',\n      directed: true,\n      padding: 10,\n      avoidOverlap: true\n    },\n    ready: function(){\n      this.on('tap', 'node', function(event){\n        console.log('touched')\n        id = event.cyTarget.data().nodeId;\n        if (id !== undefined) {\n          console.log('id is' + id)\n          mainfun(id)\n        }\n      });\n      this.on('free', 'node', function(event){\n        id = event.cyTarget.data().nodeId;\n        position = event.cyTarget.position()\n        updatefun(id, position)\n      });\n      isCreated();\n    }\n  });\n\n};\nmaingraph.update = function(inputNodes, inputEdges){\n  this.cy.load({\n    nodes: inputNodes,\n    edges: inputEdges\n  });\n}\n\nmodule.exports = maingraph;\n\n\n/* REACT HOT LOADER */ })(); if (true) { (function () { module.hot.dispose(function (data) { data.makeHot = module.makeHot; }); if (module.exports && module.makeHot) { var makeExportsHot = __webpack_require__(5), foundReactClasses = false; if (makeExportsHot(module)) { foundReactClasses = true; } var shouldAcceptModule = true && foundReactClasses; if (shouldAcceptModule) { module.hot.accept(function (err) { if (err) { console.error(\"Cannot not apply hot update to \" + \"estimate_graph.js\" + \": \" + err.message); } }); } } })(); }\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)(module)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/flux/components/estimate_graph.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./scripts/flux/components/estimate_graph.js?");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMProperty\n * @typechecks static-only\n */\n\n/*jslint bitwise: true */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\nfunction checkMask(value, bitmask) {\n  return (value & bitmask) === bitmask;\n}\n\nvar DOMPropertyInjection = {\n  /**\n   * Mapping from normalized, camelcased property names to a configuration that\n   * specifies how the associated DOM property should be accessed or rendered.\n   */\n  MUST_USE_ATTRIBUTE: 0x1,\n  MUST_USE_PROPERTY: 0x2,\n  HAS_SIDE_EFFECTS: 0x4,\n  HAS_BOOLEAN_VALUE: 0x8,\n  HAS_NUMERIC_VALUE: 0x10,\n  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,\n  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,\n\n  /**\n   * Inject some specialized knowledge about the DOM. This takes a config object\n   * with the following properties:\n   *\n   * isCustomAttribute: function that given an attribute name will return true\n   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*\n   * attributes where it's impossible to enumerate all of the possible\n   * attribute names,\n   *\n   * Properties: object mapping DOM property name to one of the\n   * DOMPropertyInjection constants or null. If your attribute isn't in here,\n   * it won't get written to the DOM.\n   *\n   * DOMAttributeNames: object mapping React attribute name to the DOM\n   * attribute name. Attribute names not specified use the **lowercase**\n   * normalized name.\n   *\n   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n   * Property names not specified use the normalized name.\n   *\n   * DOMMutationMethods: Properties that require special mutation methods. If\n   * `value` is undefined, the mutation method should unset the property.\n   *\n   * @param {object} domPropertyConfig the config as described above.\n   */\n  injectDOMPropertyConfig: function(domPropertyConfig) {\n    var Properties = domPropertyConfig.Properties || {};\n    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};\n    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n    if (domPropertyConfig.isCustomAttribute) {\n      DOMProperty._isCustomAttributeFunctions.push(\n        domPropertyConfig.isCustomAttribute\n      );\n    }\n\n    for (var propName in Properties) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !DOMProperty.isStandardName.hasOwnProperty(propName),\n        'injectDOMPropertyConfig(...): You\\'re trying to inject DOM property ' +\n        '\\'%s\\' which has already been injected. You may be accidentally ' +\n        'injecting the same DOM property config twice, or you may be ' +\n        'injecting two configs that have conflicting property names.',\n        propName\n      ) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));\n\n      DOMProperty.isStandardName[propName] = true;\n\n      var lowerCased = propName.toLowerCase();\n      DOMProperty.getPossibleStandardName[lowerCased] = propName;\n\n      if (DOMAttributeNames.hasOwnProperty(propName)) {\n        var attributeName = DOMAttributeNames[propName];\n        DOMProperty.getPossibleStandardName[attributeName] = propName;\n        DOMProperty.getAttributeName[propName] = attributeName;\n      } else {\n        DOMProperty.getAttributeName[propName] = lowerCased;\n      }\n\n      DOMProperty.getPropertyName[propName] =\n        DOMPropertyNames.hasOwnProperty(propName) ?\n          DOMPropertyNames[propName] :\n          propName;\n\n      if (DOMMutationMethods.hasOwnProperty(propName)) {\n        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];\n      } else {\n        DOMProperty.getMutationMethod[propName] = null;\n      }\n\n      var propConfig = Properties[propName];\n      DOMProperty.mustUseAttribute[propName] =\n        checkMask(propConfig, DOMPropertyInjection.MUST_USE_ATTRIBUTE);\n      DOMProperty.mustUseProperty[propName] =\n        checkMask(propConfig, DOMPropertyInjection.MUST_USE_PROPERTY);\n      DOMProperty.hasSideEffects[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_SIDE_EFFECTS);\n      DOMProperty.hasBooleanValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_BOOLEAN_VALUE);\n      DOMProperty.hasNumericValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_NUMERIC_VALUE);\n      DOMProperty.hasPositiveNumericValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE);\n      DOMProperty.hasOverloadedBooleanValue[propName] =\n        checkMask(propConfig, DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE);\n\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !DOMProperty.mustUseAttribute[propName] ||\n          !DOMProperty.mustUseProperty[propName],\n        'DOMProperty: Cannot require using both attribute and property: %s',\n        propName\n      ) : invariant(!DOMProperty.mustUseAttribute[propName] ||\n        !DOMProperty.mustUseProperty[propName]));\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        DOMProperty.mustUseProperty[propName] ||\n          !DOMProperty.hasSideEffects[propName],\n        'DOMProperty: Properties that have side effects must use property: %s',\n        propName\n      ) : invariant(DOMProperty.mustUseProperty[propName] ||\n        !DOMProperty.hasSideEffects[propName]));\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !!DOMProperty.hasBooleanValue[propName] +\n          !!DOMProperty.hasNumericValue[propName] +\n          !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1,\n        'DOMProperty: Value can be one of boolean, overloaded boolean, or ' +\n        'numeric value, but not a combination: %s',\n        propName\n      ) : invariant(!!DOMProperty.hasBooleanValue[propName] +\n        !!DOMProperty.hasNumericValue[propName] +\n        !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));\n    }\n  }\n};\nvar defaultValueCache = {};\n\n/**\n * DOMProperty exports lookup objects that can be used like functions:\n *\n *   > DOMProperty.isValid['id']\n *   true\n *   > DOMProperty.isValid['foobar']\n *   undefined\n *\n * Although this may be confusing, it performs better in general.\n *\n * @see http://jsperf.com/key-exists\n * @see http://jsperf.com/key-missing\n */\nvar DOMProperty = {\n\n  ID_ATTRIBUTE_NAME: 'data-reactid',\n\n  /**\n   * Checks whether a property name is a standard property.\n   * @type {Object}\n   */\n  isStandardName: {},\n\n  /**\n   * Mapping from lowercase property names to the properly cased version, used\n   * to warn in the case of missing properties.\n   * @type {Object}\n   */\n  getPossibleStandardName: {},\n\n  /**\n   * Mapping from normalized names to attribute names that differ. Attribute\n   * names are used when rendering markup or with `*Attribute()`.\n   * @type {Object}\n   */\n  getAttributeName: {},\n\n  /**\n   * Mapping from normalized names to properties on DOM node instances.\n   * (This includes properties that mutate due to external factors.)\n   * @type {Object}\n   */\n  getPropertyName: {},\n\n  /**\n   * Mapping from normalized names to mutation methods. This will only exist if\n   * mutation cannot be set simply by the property or `setAttribute()`.\n   * @type {Object}\n   */\n  getMutationMethod: {},\n\n  /**\n   * Whether the property must be accessed and mutated as an object property.\n   * @type {Object}\n   */\n  mustUseAttribute: {},\n\n  /**\n   * Whether the property must be accessed and mutated using `*Attribute()`.\n   * (This includes anything that fails `<propName> in <element>`.)\n   * @type {Object}\n   */\n  mustUseProperty: {},\n\n  /**\n   * Whether or not setting a value causes side effects such as triggering\n   * resources to be loaded or text selection changes. We must ensure that\n   * the value is only set if it has changed.\n   * @type {Object}\n   */\n  hasSideEffects: {},\n\n  /**\n   * Whether the property should be removed when set to a falsey value.\n   * @type {Object}\n   */\n  hasBooleanValue: {},\n\n  /**\n   * Whether the property must be numeric or parse as a\n   * numeric and should be removed when set to a falsey value.\n   * @type {Object}\n   */\n  hasNumericValue: {},\n\n  /**\n   * Whether the property must be positive numeric or parse as a positive\n   * numeric and should be removed when set to a falsey value.\n   * @type {Object}\n   */\n  hasPositiveNumericValue: {},\n\n  /**\n   * Whether the property can be used as a flag as well as with a value. Removed\n   * when strictly equal to false; present without a value when strictly equal\n   * to true; present with a value otherwise.\n   * @type {Object}\n   */\n  hasOverloadedBooleanValue: {},\n\n  /**\n   * All of the isCustomAttribute() functions that have been injected.\n   */\n  _isCustomAttributeFunctions: [],\n\n  /**\n   * Checks whether a property name is a custom attribute.\n   * @method\n   */\n  isCustomAttribute: function(attributeName) {\n    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {\n      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];\n      if (isCustomAttributeFn(attributeName)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Returns the default property value for a DOM property (i.e., not an\n   * attribute). Most default values are '' or false, but not all. Worse yet,\n   * some (in particular, `type`) vary depending on the type of element.\n   *\n   * TODO: Is it better to grab all the possible properties when creating an\n   * element to avoid having to create the same element twice?\n   */\n  getDefaultValueForProperty: function(nodeName, prop) {\n    var nodeDefaults = defaultValueCache[nodeName];\n    var testElement;\n    if (!nodeDefaults) {\n      defaultValueCache[nodeName] = nodeDefaults = {};\n    }\n    if (!(prop in nodeDefaults)) {\n      testElement = document.createElement(nodeName);\n      nodeDefaults[prop] = testElement[prop];\n    }\n    return nodeDefaults[prop];\n  },\n\n  injection: DOMPropertyInjection\n};\n\nmodule.exports = DOMProperty;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMProperty.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMProperty.js?");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactBrowserEventEmitter\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPluginHub = __webpack_require__(47);\nvar EventPluginRegistry = __webpack_require__(48);\nvar ReactEventEmitterMixin = __webpack_require__(49);\nvar ViewportMetrics = __webpack_require__(50);\n\nvar assign = __webpack_require__(51);\nvar isEventSupported = __webpack_require__(52);\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactEventListener, which is injected and can therefore support pluggable\n *    event sources. This is the only work that occurs in the main thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar isMonitoringScrollValue = false;\nvar reactTopListenersCounter = 0;\n\n// For events like 'submit' which don't consistently bubble (which we trap at a\n// lower node than `document`), binding at `document` would cause duplicate\n// events so we don't include them here\nvar topEventMapping = {\n  topBlur: 'blur',\n  topChange: 'change',\n  topClick: 'click',\n  topCompositionEnd: 'compositionend',\n  topCompositionStart: 'compositionstart',\n  topCompositionUpdate: 'compositionupdate',\n  topContextMenu: 'contextmenu',\n  topCopy: 'copy',\n  topCut: 'cut',\n  topDoubleClick: 'dblclick',\n  topDrag: 'drag',\n  topDragEnd: 'dragend',\n  topDragEnter: 'dragenter',\n  topDragExit: 'dragexit',\n  topDragLeave: 'dragleave',\n  topDragOver: 'dragover',\n  topDragStart: 'dragstart',\n  topDrop: 'drop',\n  topFocus: 'focus',\n  topInput: 'input',\n  topKeyDown: 'keydown',\n  topKeyPress: 'keypress',\n  topKeyUp: 'keyup',\n  topMouseDown: 'mousedown',\n  topMouseMove: 'mousemove',\n  topMouseOut: 'mouseout',\n  topMouseOver: 'mouseover',\n  topMouseUp: 'mouseup',\n  topPaste: 'paste',\n  topScroll: 'scroll',\n  topSelectionChange: 'selectionchange',\n  topTextInput: 'textInput',\n  topTouchCancel: 'touchcancel',\n  topTouchEnd: 'touchend',\n  topTouchMove: 'touchmove',\n  topTouchStart: 'touchstart',\n  topWheel: 'wheel'\n};\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = \"_reactListenersID\" + String(Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For\n * example:\n *\n *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);\n *\n * This would allocate a \"registration\" of `('onClick', myFunction)` on 'myID'.\n *\n * @internal\n */\nvar ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {\n\n  /**\n   * Injectable event backend\n   */\n  ReactEventListener: null,\n\n  injection: {\n    /**\n     * @param {object} ReactEventListener\n     */\n    injectReactEventListener: function(ReactEventListener) {\n      ReactEventListener.setHandleTopLevel(\n        ReactBrowserEventEmitter.handleTopLevel\n      );\n      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;\n    }\n  },\n\n  /**\n   * Sets whether or not any created callbacks should be enabled.\n   *\n   * @param {boolean} enabled True if callbacks should be enabled.\n   */\n  setEnabled: function(enabled) {\n    if (ReactBrowserEventEmitter.ReactEventListener) {\n      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);\n    }\n  },\n\n  /**\n   * @return {boolean} True if callbacks are enabled.\n   */\n  isEnabled: function() {\n    return !!(\n      ReactBrowserEventEmitter.ReactEventListener &&\n      ReactBrowserEventEmitter.ReactEventListener.isEnabled()\n    );\n  },\n\n  /**\n   * We listen for bubbled touch events on the document object.\n   *\n   * Firefox v8.01 (and possibly others) exhibited strange behavior when\n   * mounting `onmousemove` events at some node that was not the document\n   * element. The symptoms were that if your mouse is not moving over something\n   * contained within that mount point (for example on the background) the\n   * top-level listeners for `onmousemove` won't be called. However, if you\n   * register the `mousemove` on the document object, then it will of course\n   * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n   * top-level listeners to the document object only, at least for these\n   * movement types of events and possibly all events.\n   *\n   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n   *\n   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n   * they bubble to document.\n   *\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {object} contentDocumentHandle Document which owns the container\n   */\n  listenTo: function(registrationName, contentDocumentHandle) {\n    var mountAt = contentDocumentHandle;\n    var isListening = getListeningForDocument(mountAt);\n    var dependencies = EventPluginRegistry.\n      registrationNameDependencies[registrationName];\n\n    var topLevelTypes = EventConstants.topLevelTypes;\n    for (var i = 0, l = dependencies.length; i < l; i++) {\n      var dependency = dependencies[i];\n      if (!(\n            isListening.hasOwnProperty(dependency) &&\n            isListening[dependency]\n          )) {\n        if (dependency === topLevelTypes.topWheel) {\n          if (isEventSupported('wheel')) {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topWheel,\n              'wheel',\n              mountAt\n            );\n          } else if (isEventSupported('mousewheel')) {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topWheel,\n              'mousewheel',\n              mountAt\n            );\n          } else {\n            // Firefox needs to capture a different mouse scroll event.\n            // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topWheel,\n              'DOMMouseScroll',\n              mountAt\n            );\n          }\n        } else if (dependency === topLevelTypes.topScroll) {\n\n          if (isEventSupported('scroll', true)) {\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n              topLevelTypes.topScroll,\n              'scroll',\n              mountAt\n            );\n          } else {\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topScroll,\n              'scroll',\n              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE\n            );\n          }\n        } else if (dependency === topLevelTypes.topFocus ||\n            dependency === topLevelTypes.topBlur) {\n\n          if (isEventSupported('focus', true)) {\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n              topLevelTypes.topFocus,\n              'focus',\n              mountAt\n            );\n            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n              topLevelTypes.topBlur,\n              'blur',\n              mountAt\n            );\n          } else if (isEventSupported('focusin')) {\n            // IE has `focusin` and `focusout` events which bubble.\n            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topFocus,\n              'focusin',\n              mountAt\n            );\n            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n              topLevelTypes.topBlur,\n              'focusout',\n              mountAt\n            );\n          }\n\n          // to make sure blur and focus event listeners are only attached once\n          isListening[topLevelTypes.topBlur] = true;\n          isListening[topLevelTypes.topFocus] = true;\n        } else if (topEventMapping.hasOwnProperty(dependency)) {\n          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n            dependency,\n            topEventMapping[dependency],\n            mountAt\n          );\n        }\n\n        isListening[dependency] = true;\n      }\n    }\n  },\n\n  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {\n    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(\n      topLevelType,\n      handlerBaseName,\n      handle\n    );\n  },\n\n  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {\n    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(\n      topLevelType,\n      handlerBaseName,\n      handle\n    );\n  },\n\n  /**\n   * Listens to window scroll and resize events. We cache scroll values so that\n   * application code can access them without triggering reflows.\n   *\n   * NOTE: Scroll events do not bubble.\n   *\n   * @see http://www.quirksmode.org/dom/events/scroll.html\n   */\n  ensureScrollValueMonitoring: function(){\n    if (!isMonitoringScrollValue) {\n      var refresh = ViewportMetrics.refreshScrollValues;\n      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);\n      isMonitoringScrollValue = true;\n    }\n  },\n\n  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,\n\n  registrationNameModules: EventPluginHub.registrationNameModules,\n\n  putListener: EventPluginHub.putListener,\n\n  getListener: EventPluginHub.getListener,\n\n  deleteListener: EventPluginHub.deleteListener,\n\n  deleteAllListeners: EventPluginHub.deleteAllListeners\n\n});\n\nmodule.exports = ReactBrowserEventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactBrowserEventEmitter.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactBrowserEventEmitter.js?");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCurrentOwner\n */\n\n\"use strict\";\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n *\n * The depth indicate how many composite components are above this render level.\n */\nvar ReactCurrentOwner = {\n\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n\n};\n\nmodule.exports = ReactCurrentOwner;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCurrentOwner.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCurrentOwner.js?");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElement\n */\n\n\"use strict\";\n\nvar ReactContext = __webpack_require__(53);\nvar ReactCurrentOwner = __webpack_require__(27);\n\nvar warning = __webpack_require__(38);\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true\n};\n\n/**\n * Warn for mutations.\n *\n * @internal\n * @param {object} object\n * @param {string} key\n */\nfunction defineWarningProperty(object, key) {\n  Object.defineProperty(object, key, {\n\n    configurable: false,\n    enumerable: true,\n\n    get: function() {\n      if (!this._store) {\n        return null;\n      }\n      return this._store[key];\n    },\n\n    set: function(value) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        false,\n        'Don\\'t set the ' + key + ' property of the component. ' +\n        'Mutate the existing props object instead.'\n      ) : null);\n      this._store[key] = value;\n    }\n\n  });\n}\n\n/**\n * This is updated to true if the membrane is successfully created.\n */\nvar useMutationMembrane = false;\n\n/**\n * Warn for mutations.\n *\n * @internal\n * @param {object} element\n */\nfunction defineMutationMembrane(prototype) {\n  try {\n    var pseudoFrozenProperties = {\n      props: true\n    };\n    for (var key in pseudoFrozenProperties) {\n      defineWarningProperty(prototype, key);\n    }\n    useMutationMembrane = true;\n  } catch (x) {\n    // IE will fail on defineProperty\n  }\n}\n\n/**\n * Base constructor for all React elements. This is only used to make this\n * work with a dynamic instanceof check. Nothing should live on this prototype.\n *\n * @param {*} type\n * @param {string|object} ref\n * @param {*} key\n * @param {*} props\n * @internal\n */\nvar ReactElement = function(type, key, ref, owner, context, props) {\n  // Built-in properties that belong on the element\n  this.type = type;\n  this.key = key;\n  this.ref = ref;\n\n  // Record the component responsible for creating this element.\n  this._owner = owner;\n\n  // TODO: Deprecate withContext, and then the context becomes accessible\n  // through the owner.\n  this._context = context;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    // The validation flag and props are currently mutative. We put them on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    this._store = { validated: false, props: props };\n\n    // We're not allowed to set props directly on the object so we early\n    // return and rely on the prototype membrane to forward to the backing\n    // store.\n    if (useMutationMembrane) {\n      Object.freeze(this);\n      return;\n    }\n  }\n\n  this.props = props;\n};\n\n// We intentionally don't expose the function on the constructor property.\n// ReactElement should be indistinguishable from a plain object.\nReactElement.prototype = {\n  _isReactElement: true\n};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  defineMutationMembrane(ReactElement.prototype);\n}\n\nReactElement.createElement = function(type, config, children) {\n  var propName;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n\n  if (config != null) {\n    ref = config.ref === undefined ? null : config.ref;\n    if (\"production\" !== process.env.NODE_ENV) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        config.key !== null,\n        'createElement(...): Encountered component with a `key` of null. In ' +\n        'a future version, this will be treated as equivalent to the string ' +\n        '\\'null\\'; instead, provide an explicit key or use undefined.'\n      ) : null);\n    }\n    // TODO: Change this back to `config.key === undefined`\n    key = config.key == null ? null : '' + config.key;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (config.hasOwnProperty(propName) &&\n          !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (typeof props[propName] === 'undefined') {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  return new ReactElement(\n    type,\n    key,\n    ref,\n    ReactCurrentOwner.current,\n    ReactContext.current,\n    props\n  );\n};\n\nReactElement.createFactory = function(type) {\n  var factory = ReactElement.createElement.bind(null, type);\n  // Expose the type on the factory and the prototype so that it can be\n  // easily accessed on elements. E.g. <Foo />.type === Foo.type.\n  // This should not be named `constructor` since this may not be the function\n  // that created the element, and it may not even be a constructor.\n  factory.type = type;\n  return factory;\n};\n\nReactElement.cloneAndReplaceProps = function(oldElement, newProps) {\n  var newElement = new ReactElement(\n    oldElement.type,\n    oldElement.key,\n    oldElement.ref,\n    oldElement._owner,\n    oldElement._context,\n    newProps\n  );\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    // If the key on the original is valid, then the clone is valid\n    newElement._store.validated = oldElement._store.validated;\n  }\n  return newElement;\n};\n\n/**\n * @param {?object} object\n * @return {boolean} True if `object` is a valid component.\n * @final\n */\nReactElement.isValidElement = function(object) {\n  // ReactTestUtils is often used outside of beforeEach where as React is\n  // within it. This leads to two different instances of React on the same\n  // page. To identify a element from a different React instance we use\n  // a flag instead of an instanceof check.\n  var isElement = !!(object && object._isReactElement);\n  // if (isElement && !(object instanceof ReactElement)) {\n  // This is an indicator that you're using multiple versions of React at the\n  // same time. This will screw with ownership and stuff. Fix it, please.\n  // TODO: We could possibly warn here.\n  // }\n  return isElement;\n};\n\nmodule.exports = ReactElement;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactElement.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactElement.js?");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactLegacyElement\n */\n\n\"use strict\";\n\nvar ReactCurrentOwner = __webpack_require__(27);\n\nvar invariant = __webpack_require__(36);\nvar monitorCodeUse = __webpack_require__(54);\nvar warning = __webpack_require__(38);\n\nvar legacyFactoryLogs = {};\nfunction warnForLegacyFactoryCall() {\n  if (!ReactLegacyElementFactory._isLegacyCallWarningEnabled) {\n    return;\n  }\n  var owner = ReactCurrentOwner.current;\n  var name = owner && owner.constructor ? owner.constructor.displayName : '';\n  if (!name) {\n    name = 'Something';\n  }\n  if (legacyFactoryLogs.hasOwnProperty(name)) {\n    return;\n  }\n  legacyFactoryLogs[name] = true;\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    false,\n    name + ' is calling a React component directly. ' +\n    'Use a factory or JSX instead. See: http://fb.me/react-legacyfactory'\n  ) : null);\n  monitorCodeUse('react_legacy_factory_call', { version: 3, name: name });\n}\n\nfunction warnForPlainFunctionType(type) {\n  var isReactClass =\n    type.prototype &&\n    typeof type.prototype.mountComponent === 'function' &&\n    typeof type.prototype.receiveComponent === 'function';\n  if (isReactClass) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'Did not expect to get a React class here. Use `Component` instead ' +\n      'of `Component.type` or `this.constructor`.'\n    ) : null);\n  } else {\n    if (!type._reactWarnedForThisType) {\n      try {\n        type._reactWarnedForThisType = true;\n      } catch (x) {\n        // just incase this is a frozen object or some special object\n      }\n      monitorCodeUse(\n        'react_non_component_in_jsx',\n        { version: 3, name: type.name }\n      );\n    }\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'This JSX uses a plain function. Only React components are ' +\n      'valid in React\\'s JSX transform.'\n    ) : null);\n  }\n}\n\nfunction warnForNonLegacyFactory(type) {\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    false,\n    'Do not pass React.DOM.' + type.type + ' to JSX or createFactory. ' +\n    'Use the string \"' + type.type + '\" instead.'\n  ) : null);\n}\n\n/**\n * Transfer static properties from the source to the target. Functions are\n * rebound to have this reflect the original source.\n */\nfunction proxyStaticMethods(target, source) {\n  if (typeof source !== 'function') {\n    return;\n  }\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var value = source[key];\n      if (typeof value === 'function') {\n        var bound = value.bind(source);\n        // Copy any properties defined on the function, such as `isRequired` on\n        // a PropTypes validator.\n        for (var k in value) {\n          if (value.hasOwnProperty(k)) {\n            bound[k] = value[k];\n          }\n        }\n        target[key] = bound;\n      } else {\n        target[key] = value;\n      }\n    }\n  }\n}\n\n// We use an object instead of a boolean because booleans are ignored by our\n// mocking libraries when these factories gets mocked.\nvar LEGACY_MARKER = {};\nvar NON_LEGACY_MARKER = {};\n\nvar ReactLegacyElementFactory = {};\n\nReactLegacyElementFactory.wrapCreateFactory = function(createFactory) {\n  var legacyCreateFactory = function(type) {\n    if (typeof type !== 'function') {\n      // Non-function types cannot be legacy factories\n      return createFactory(type);\n    }\n\n    if (type.isReactNonLegacyFactory) {\n      // This is probably a factory created by ReactDOM we unwrap it to get to\n      // the underlying string type. It shouldn't have been passed here so we\n      // warn.\n      if (\"production\" !== process.env.NODE_ENV) {\n        warnForNonLegacyFactory(type);\n      }\n      return createFactory(type.type);\n    }\n\n    if (type.isReactLegacyFactory) {\n      // This is probably a legacy factory created by ReactCompositeComponent.\n      // We unwrap it to get to the underlying class.\n      return createFactory(type.type);\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      warnForPlainFunctionType(type);\n    }\n\n    // Unless it's a legacy factory, then this is probably a plain function,\n    // that is expecting to be invoked by JSX. We can just return it as is.\n    return type;\n  };\n  return legacyCreateFactory;\n};\n\nReactLegacyElementFactory.wrapCreateElement = function(createElement) {\n  var legacyCreateElement = function(type, props, children) {\n    if (typeof type !== 'function') {\n      // Non-function types cannot be legacy factories\n      return createElement.apply(this, arguments);\n    }\n\n    var args;\n\n    if (type.isReactNonLegacyFactory) {\n      // This is probably a factory created by ReactDOM we unwrap it to get to\n      // the underlying string type. It shouldn't have been passed here so we\n      // warn.\n      if (\"production\" !== process.env.NODE_ENV) {\n        warnForNonLegacyFactory(type);\n      }\n      args = Array.prototype.slice.call(arguments, 0);\n      args[0] = type.type;\n      return createElement.apply(this, args);\n    }\n\n    if (type.isReactLegacyFactory) {\n      // This is probably a legacy factory created by ReactCompositeComponent.\n      // We unwrap it to get to the underlying class.\n      if (type._isMockFunction) {\n        // If this is a mock function, people will expect it to be called. We\n        // will actually call the original mock factory function instead. This\n        // future proofs unit testing that assume that these are classes.\n        type.type._mockedReactClassConstructor = type;\n      }\n      args = Array.prototype.slice.call(arguments, 0);\n      args[0] = type.type;\n      return createElement.apply(this, args);\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      warnForPlainFunctionType(type);\n    }\n\n    // This is being called with a plain function we should invoke it\n    // immediately as if this was used with legacy JSX.\n    return type.apply(null, Array.prototype.slice.call(arguments, 1));\n  };\n  return legacyCreateElement;\n};\n\nReactLegacyElementFactory.wrapFactory = function(factory) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    typeof factory === 'function',\n    'This is suppose to accept a element factory'\n  ) : invariant(typeof factory === 'function'));\n  var legacyElementFactory = function(config, children) {\n    // This factory should not be called when JSX is used. Use JSX instead.\n    if (\"production\" !== process.env.NODE_ENV) {\n      warnForLegacyFactoryCall();\n    }\n    return factory.apply(this, arguments);\n  };\n  proxyStaticMethods(legacyElementFactory, factory.type);\n  legacyElementFactory.isReactLegacyFactory = LEGACY_MARKER;\n  legacyElementFactory.type = factory.type;\n  return legacyElementFactory;\n};\n\n// This is used to mark a factory that will remain. E.g. we're allowed to call\n// it as a function. However, you're not suppose to pass it to createElement\n// or createFactory, so it will warn you if you do.\nReactLegacyElementFactory.markNonLegacyFactory = function(factory) {\n  factory.isReactNonLegacyFactory = NON_LEGACY_MARKER;\n  return factory;\n};\n\n// Checks if a factory function is actually a legacy factory pretending to\n// be a class.\nReactLegacyElementFactory.isValidFactory = function(factory) {\n  // TODO: This will be removed and moved into a class validator or something.\n  return typeof factory === 'function' &&\n    factory.isReactLegacyFactory === LEGACY_MARKER;\n};\n\nReactLegacyElementFactory.isValidClass = function(factory) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'isValidClass is deprecated and will be removed in a future release. ' +\n      'Use a more specific validator instead.'\n    ) : null);\n  }\n  return ReactLegacyElementFactory.isValidFactory(factory);\n};\n\nReactLegacyElementFactory._isLegacyCallWarningEnabled = true;\n\nmodule.exports = ReactLegacyElementFactory;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactLegacyElement.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactLegacyElement.js?");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar ReactRootIndex = __webpack_require__(55);\n\nvar invariant = __webpack_require__(36);\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 100;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || (\n    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR\n  );\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return (\n    descendantID.indexOf(ancestorID) === 0 &&\n    isBoundary(descendantID, ancestorID.length)\n  );\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isValidID(ancestorID) && isValidID(destinationID),\n    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',\n    ancestorID,\n    destinationID\n  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isAncestorIDOf(ancestorID, destinationID),\n    'getNextDescendantID(...): React has made an invalid assumption about ' +\n    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',\n    ancestorID,\n    destinationID\n  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  for (var i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    isValidID(longestCommonID),\n    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',\n    oneID,\n    twoID,\n    longestCommonID\n  ) : invariant(isValidID(longestCommonID)));\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them. If the\n * callback returns `false`, traversal is stopped.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    start !== stop,\n    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',\n    start\n  ) : invariant(start !== stop));\n  var traverseUp = isAncestorIDOf(stop, start);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    traverseUp || isAncestorIDOf(start, stop),\n    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +\n    'not have a parent path.',\n    start,\n    stop\n  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for (var id = start; /* until break */; id = traverse(id, stop)) {\n    var ret;\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      depth++ < MAX_TREE_DEPTH,\n      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +\n      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',\n      start, stop\n    ) : invariant(depth++ < MAX_TREE_DEPTH));\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n\n  /**\n   * Constructs a React root ID\n   * @return {string} A React root ID.\n   */\n  createReactRootID: function() {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function(rootID, name) {\n    return rootID + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function(id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n    return null;\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function(targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseAncestors: function(targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n\n  isAncestorIDOf: isAncestorIDOf,\n\n  SEPARATOR: SEPARATOR\n\n};\n\nmodule.exports = ReactInstanceHandles;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInstanceHandles.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInstanceHandles.js?");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPerf\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * ReactPerf is a general AOP system designed to measure performance. This\n * module only has the hooks: see ReactDefaultPerf for the analysis tool.\n */\nvar ReactPerf = {\n  /**\n   * Boolean to enable/disable measurement. Set to false by default to prevent\n   * accidental logging and perf loss.\n   */\n  enableMeasure: false,\n\n  /**\n   * Holds onto the measure function in use. By default, don't measure\n   * anything, but we'll override this if we inject a measure function.\n   */\n  storedMeasure: _noMeasure,\n\n  /**\n   * Use this to wrap methods you want to measure. Zero overhead in production.\n   *\n   * @param {string} objName\n   * @param {string} fnName\n   * @param {function} func\n   * @return {function}\n   */\n  measure: function(objName, fnName, func) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      var measuredFunc = null;\n      var wrapper = function() {\n        if (ReactPerf.enableMeasure) {\n          if (!measuredFunc) {\n            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);\n          }\n          return measuredFunc.apply(this, arguments);\n        }\n        return func.apply(this, arguments);\n      };\n      wrapper.displayName = objName + '_' + fnName;\n      return wrapper;\n    }\n    return func;\n  },\n\n  injection: {\n    /**\n     * @param {function} measure\n     */\n    injectMeasure: function(measure) {\n      ReactPerf.storedMeasure = measure;\n    }\n  }\n};\n\n/**\n * Simply passes through the measured function, without measuring it.\n *\n * @param {string} objName\n * @param {string} fnName\n * @param {function} func\n * @return {function}\n */\nfunction _noMeasure(objName, fnName, func) {\n  return func;\n}\n\nmodule.exports = ReactPerf;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPerf.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPerf.js?");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule containsNode\n * @typechecks\n */\n\nvar isTextNode = __webpack_require__(56);\n\n/*jslint bitwise:true */\n\n/**\n * Checks if a given DOM node contains or is another DOM node.\n *\n * @param {?DOMNode} outerNode Outer DOM node.\n * @param {?DOMNode} innerNode Inner DOM node.\n * @return {boolean} True if `outerNode` contains or is `innerNode`.\n */\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if (outerNode.contains) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = containsNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/containsNode.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/containsNode.js?");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule deprecated\n */\n\nvar assign = __webpack_require__(51);\nvar warning = __webpack_require__(38);\n\n/**\n * This will log a single deprecation notice per function and forward the call\n * on to the new API.\n *\n * @param {string} namespace The namespace of the call, eg 'React'\n * @param {string} oldName The old function name, eg 'renderComponent'\n * @param {string} newName The new function name, eg 'render'\n * @param {*} ctx The context this forwarded call should run in\n * @param {function} fn The function to forward on to\n * @return {*} Will be the value as returned from `fn`\n */\nfunction deprecated(namespace, oldName, newName, ctx, fn) {\n  var warned = false;\n  if (\"production\" !== process.env.NODE_ENV) {\n    var newFn = function() {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        warned,\n        (namespace + \".\" + oldName + \" will be deprecated in a future version. \") +\n        (\"Use \" + namespace + \".\" + newName + \" instead.\")\n      ) : null);\n      warned = true;\n      return fn.apply(ctx, arguments);\n    };\n    newFn.displayName = (namespace + \"_\" + oldName);\n    // We need to make sure all properties of the original fn are copied over.\n    // In particular, this is needed to support PropTypes\n    return assign(newFn, fn);\n  }\n\n  return fn;\n}\n\nmodule.exports = deprecated;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/deprecated.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/deprecated.js?");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getReactRootElementInContainer\n */\n\n\"use strict\";\n\nvar DOC_NODE_TYPE = 9;\n\n/**\n * @param {DOMElement|DOMDocument} container DOM element that may contain\n *                                           a React component\n * @return {?*} DOM element that may have the reactRoot ID, or null.\n */\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOC_NODE_TYPE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nmodule.exports = getReactRootElementInContainer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getReactRootElementInContainer.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getReactRootElementInContainer.js?");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule instantiateReactComponent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar warning = __webpack_require__(38);\n\nvar ReactElement = __webpack_require__(28);\nvar ReactLegacyElement = __webpack_require__(29);\nvar ReactNativeComponent = __webpack_require__(57);\nvar ReactEmptyComponent = __webpack_require__(58);\n\n/**\n * Given an `element` create an instance that will actually be mounted.\n *\n * @param {object} element\n * @param {*} parentCompositeType The composite type that resolved this.\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(element, parentCompositeType) {\n  var instance;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      element && (typeof element.type === 'function' ||\n                     typeof element.type === 'string'),\n      'Only functions or strings can be mounted as React components.'\n    ) : null);\n\n    // Resolve mock instances\n    if (element.type._mockedReactClassConstructor) {\n      // If this is a mocked class, we treat the legacy factory as if it was the\n      // class constructor for future proofing unit tests. Because this might\n      // be mocked as a legacy factory, we ignore any warnings triggerd by\n      // this temporary hack.\n      ReactLegacyElement._isLegacyCallWarningEnabled = false;\n      try {\n        instance = new element.type._mockedReactClassConstructor(\n          element.props\n        );\n      } finally {\n        ReactLegacyElement._isLegacyCallWarningEnabled = true;\n      }\n\n      // If the mock implementation was a legacy factory, then it returns a\n      // element. We need to turn this into a real component instance.\n      if (ReactElement.isValidElement(instance)) {\n        instance = new instance.type(instance.props);\n      }\n\n      var render = instance.render;\n      if (!render) {\n        // For auto-mocked factories, the prototype isn't shimmed and therefore\n        // there is no render function on the instance. We replace the whole\n        // component with an empty component instance instead.\n        element = ReactEmptyComponent.getEmptyComponent();\n      } else {\n        if (render._isMockFunction && !render._getMockImplementation()) {\n          // Auto-mocked components may have a prototype with a mocked render\n          // function. For those, we'll need to mock the result of the render\n          // since we consider undefined to be invalid results from render.\n          render.mockImplementation(\n            ReactEmptyComponent.getEmptyComponent\n          );\n        }\n        instance.construct(element);\n        return instance;\n      }\n    }\n  }\n\n  // Special case string values\n  if (typeof element.type === 'string') {\n    instance = ReactNativeComponent.createInstanceForTag(\n      element.type,\n      element.props,\n      parentCompositeType\n    );\n  } else {\n    // Normal case for non-mocks and non-strings\n    instance = new element.type(element.props);\n  }\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      typeof instance.construct === 'function' &&\n      typeof instance.mountComponent === 'function' &&\n      typeof instance.receiveComponent === 'function',\n      'Only React Components can be mounted.'\n    ) : null);\n  }\n\n  // This actually sets up the internal instance. This will become decoupled\n  // from the public instance in a future diff.\n  instance.construct(element);\n\n  return instance;\n}\n\nmodule.exports = instantiateReactComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/instantiateReactComponent.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/instantiateReactComponent.js?");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule invariant\n */\n\n\"use strict\";\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        'Invariant Violation: ' +\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/invariant.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/invariant.js?");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shouldUpdateReactComponent\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * Given a `prevElement` and `nextElement`, determines if the existing\n * instance should be updated as opposed to being destroyed or replaced by a new\n * instance. Both arguments are elements. This ensures that this logic can\n * operate on stateless trees without any backing instance.\n *\n * @param {?object} prevElement\n * @param {?object} nextElement\n * @return {boolean} True if the existing instance should be updated.\n * @protected\n */\nfunction shouldUpdateReactComponent(prevElement, nextElement) {\n  if (prevElement && nextElement &&\n      prevElement.type === nextElement.type &&\n      prevElement.key === nextElement.key &&\n      prevElement._owner === nextElement._owner) {\n    return true;\n  }\n  return false;\n}\n\nmodule.exports = shouldUpdateReactComponent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/shouldUpdateReactComponent.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/shouldUpdateReactComponent.js?");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule warning\n */\n\n\"use strict\";\n\nvar emptyFunction = __webpack_require__(59);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (\"production\" !== process.env.NODE_ENV) {\n  warning = function(condition, format ) {for (var args=[],$__0=2,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));\n    }\n  };\n}\n\nmodule.exports = warning;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/warning.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/warning.js?");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar makePatchReactClass = __webpack_require__(60);\n\n/**\n * Returns a function that, when invoked, patches a React class with a new\n * version of itself. To patch different classes, pass different IDs.\n */\nmodule.exports = function makeMakeHot(getRootInstances) {\n  if (typeof getRootInstances !== 'function') {\n    throw new Error('Expected getRootInstances to be a function.');\n  }\n\n  var patchers = {};\n\n  return function makeHot(NextClass, persistentId) {\n    persistentId = persistentId || NextClass.displayName || NextClass.name;\n\n    if (!persistentId) {\n      console.error(\n        'Hot reload is disabled for one of your types. To enable it, pass a ' +\n        'string uniquely identifying this class within this current module ' +\n        'as a second parameter to makeHot.'\n      );\n      return NextClass;\n    }\n\n    if (!patchers[persistentId]) {\n      patchers[persistentId] = makePatchReactClass(getRootInstances);\n    }\n\n    var patchReactClass = patchers[persistentId];\n    return patchReactClass(NextClass);\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/makeMakeHot.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/makeMakeHot.js?");

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__(76);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/index.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/index.js?");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule React\n */\n\n\"use strict\";\n\nvar DOMPropertyOperations = __webpack_require__(61);\nvar EventPluginUtils = __webpack_require__(62);\nvar ReactChildren = __webpack_require__(63);\nvar ReactComponent = __webpack_require__(64);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactContext = __webpack_require__(53);\nvar ReactCurrentOwner = __webpack_require__(27);\nvar ReactElement = __webpack_require__(28);\nvar ReactElementValidator = __webpack_require__(66);\nvar ReactDOM = __webpack_require__(67);\nvar ReactDOMComponent = __webpack_require__(68);\nvar ReactDefaultInjection = __webpack_require__(69);\nvar ReactInstanceHandles = __webpack_require__(30);\nvar ReactLegacyElement = __webpack_require__(29);\nvar ReactMount = __webpack_require__(10);\nvar ReactMultiChild = __webpack_require__(70);\nvar ReactPerf = __webpack_require__(31);\nvar ReactPropTypes = __webpack_require__(71);\nvar ReactServerRendering = __webpack_require__(72);\nvar ReactTextComponent = __webpack_require__(73);\n\nvar assign = __webpack_require__(51);\nvar deprecated = __webpack_require__(33);\nvar onlyChild = __webpack_require__(74);\n\nReactDefaultInjection.inject();\n\nvar createElement = ReactElement.createElement;\nvar createFactory = ReactElement.createFactory;\n\nif (\"production\" !== process.env.NODE_ENV) {\n  createElement = ReactElementValidator.createElement;\n  createFactory = ReactElementValidator.createFactory;\n}\n\n// TODO: Drop legacy elements once classes no longer export these factories\ncreateElement = ReactLegacyElement.wrapCreateElement(\n  createElement\n);\ncreateFactory = ReactLegacyElement.wrapCreateFactory(\n  createFactory\n);\n\nvar render = ReactPerf.measure('React', 'render', ReactMount.render);\n\nvar React = {\n  Children: {\n    map: ReactChildren.map,\n    forEach: ReactChildren.forEach,\n    count: ReactChildren.count,\n    only: onlyChild\n  },\n  DOM: ReactDOM,\n  PropTypes: ReactPropTypes,\n  initializeTouchEvents: function(shouldUseTouch) {\n    EventPluginUtils.useTouchEvents = shouldUseTouch;\n  },\n  createClass: ReactCompositeComponent.createClass,\n  createElement: createElement,\n  createFactory: createFactory,\n  constructAndRenderComponent: ReactMount.constructAndRenderComponent,\n  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,\n  render: render,\n  renderToString: ReactServerRendering.renderToString,\n  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,\n  unmountComponentAtNode: ReactMount.unmountComponentAtNode,\n  isValidClass: ReactLegacyElement.isValidClass,\n  isValidElement: ReactElement.isValidElement,\n  withContext: ReactContext.withContext,\n\n  // Hook for JSX spread, don't use this for anything else.\n  __spread: assign,\n\n  // Deprecations (remove for 0.13)\n  renderComponent: deprecated(\n    'React',\n    'renderComponent',\n    'render',\n    this,\n    render\n  ),\n  renderComponentToString: deprecated(\n    'React',\n    'renderComponentToString',\n    'renderToString',\n    this,\n    ReactServerRendering.renderToString\n  ),\n  renderComponentToStaticMarkup: deprecated(\n    'React',\n    'renderComponentToStaticMarkup',\n    'renderToStaticMarkup',\n    this,\n    ReactServerRendering.renderToStaticMarkup\n  ),\n  isValidComponent: deprecated(\n    'React',\n    'isValidComponent',\n    'isValidElement',\n    this,\n    ReactElement.isValidElement\n  )\n};\n\n// Inject the runtime into a devtools global hook regardless of browser.\n// Allows for debugging when the hook is injected on the page.\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({\n    Component: ReactComponent,\n    CurrentOwner: ReactCurrentOwner,\n    DOMComponent: ReactDOMComponent,\n    DOMPropertyOperations: DOMPropertyOperations,\n    InstanceHandles: ReactInstanceHandles,\n    Mount: ReactMount,\n    MultiChild: ReactMultiChild,\n    TextComponent: ReactTextComponent\n  });\n}\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var ExecutionEnvironment = __webpack_require__(75);\n  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {\n\n    // If we're in Chrome, look for the devtools marker and provide a download\n    // link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1) {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n        console.debug(\n          'Download the React DevTools for a better development experience: ' +\n          'http://fb.me/react-devtools'\n        );\n      }\n    }\n\n    var expectedFeatures = [\n      // shims\n      Array.isArray,\n      Array.prototype.every,\n      Array.prototype.forEach,\n      Array.prototype.indexOf,\n      Array.prototype.map,\n      Date.now,\n      Function.prototype.bind,\n      Object.keys,\n      String.prototype.split,\n      String.prototype.trim,\n\n      // shams\n      Object.create,\n      Object.freeze\n    ];\n\n    for (var i = 0; i < expectedFeatures.length; i++) {\n      if (!expectedFeatures[i]) {\n        console.error(\n          'One or more ES5 shim/shams expected by React are not available: ' +\n          'http://fb.me/react-warning-polyfills'\n        );\n        break;\n      }\n    }\n  }\n}\n\n// Version exists only in the open-source version of React, not in Facebook's\n// internal version.\nReact.version = '0.12.2';\n\nmodule.exports = React;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/React.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/React.js?");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/process/browser.js?");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.1.2\n\n//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Backbone may be freely distributed under the MIT license.\n//     For all details and documentation:\n//     http://backbonejs.org\n\n(function(root, factory) {\n\n  // Set up Backbone appropriately for the environment. Start with AMD.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(190), __webpack_require__(45), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function(_, $, exports) {\n      // Export global even in AMD case in case this script is loaded with\n      // others that may still expect a global Backbone.\n      root.Backbone = factory(root, exports, _, $);\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n  // Next for Node.js or CommonJS. jQuery may not be needed as a module.\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    factory(root, exports, _);\n\n  // Finally, as a browser global.\n  } else {\n    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n\n}(this, function(root, Backbone, _, $) {\n\n  // Initial Setup\n  // -------------\n\n  // Save the previous value of the `Backbone` variable, so that it can be\n  // restored later on, if `noConflict` is used.\n  var previousBackbone = root.Backbone;\n\n  // Create local references to array methods we'll want to use later.\n  var array = [];\n  var push = array.push;\n  var slice = array.slice;\n  var splice = array.splice;\n\n  // Current version of the library. Keep in sync with `package.json`.\n  Backbone.VERSION = '1.1.2';\n\n  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns\n  // the `$` variable.\n  Backbone.$ = $;\n\n  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable\n  // to its previous owner. Returns a reference to this Backbone object.\n  Backbone.noConflict = function() {\n    root.Backbone = previousBackbone;\n    return this;\n  };\n\n  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option\n  // will fake `\"PATCH\"`, `\"PUT\"` and `\"DELETE\"` requests via the `_method` parameter and\n  // set a `X-Http-Method-Override` header.\n  Backbone.emulateHTTP = false;\n\n  // Turn on `emulateJSON` to support legacy servers that can't deal with direct\n  // `application/json` requests ... will encode the body as\n  // `application/x-www-form-urlencoded` instead and will send the model in a\n  // form param named `model`.\n  Backbone.emulateJSON = false;\n\n  // Backbone.Events\n  // ---------------\n\n  // A module that can be mixed in to *any object* in order to provide it with\n  // custom events. You may bind with `on` or remove with `off` callback\n  // functions to an event; `trigger`-ing an event fires all callbacks in\n  // succession.\n  //\n  //     var object = {};\n  //     _.extend(object, Backbone.Events);\n  //     object.on('expand', function(){ alert('expanded'); });\n  //     object.trigger('expand');\n  //\n  var Events = Backbone.Events = {\n\n    // Bind an event to a `callback` function. Passing `\"all\"` will bind\n    // the callback to all events fired.\n    on: function(name, callback, context) {\n      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n      this._events || (this._events = {});\n      var events = this._events[name] || (this._events[name] = []);\n      events.push({callback: callback, context: context, ctx: context || this});\n      return this;\n    },\n\n    // Bind an event to only be triggered a single time. After the first time\n    // the callback is invoked, it will be removed.\n    once: function(name, callback, context) {\n      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n      var self = this;\n      var once = _.once(function() {\n        self.off(name, once);\n        callback.apply(this, arguments);\n      });\n      once._callback = callback;\n      return this.on(name, once, context);\n    },\n\n    // Remove one or many callbacks. If `context` is null, removes all\n    // callbacks with that function. If `callback` is null, removes all\n    // callbacks for the event. If `name` is null, removes all bound\n    // callbacks for all events.\n    off: function(name, callback, context) {\n      var retain, ev, events, names, i, l, j, k;\n      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n      if (!name && !callback && !context) {\n        this._events = void 0;\n        return this;\n      }\n      names = name ? [name] : _.keys(this._events);\n      for (i = 0, l = names.length; i < l; i++) {\n        name = names[i];\n        if (events = this._events[name]) {\n          this._events[name] = retain = [];\n          if (callback || context) {\n            for (j = 0, k = events.length; j < k; j++) {\n              ev = events[j];\n              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||\n                  (context && context !== ev.context)) {\n                retain.push(ev);\n              }\n            }\n          }\n          if (!retain.length) delete this._events[name];\n        }\n      }\n\n      return this;\n    },\n\n    // Trigger one or many events, firing all bound callbacks. Callbacks are\n    // passed the same arguments as `trigger` is, apart from the event name\n    // (unless you're listening on `\"all\"`, which will cause your callback to\n    // receive the true name of the event as the first argument).\n    trigger: function(name) {\n      if (!this._events) return this;\n      var args = slice.call(arguments, 1);\n      if (!eventsApi(this, 'trigger', name, args)) return this;\n      var events = this._events[name];\n      var allEvents = this._events.all;\n      if (events) triggerEvents(events, args);\n      if (allEvents) triggerEvents(allEvents, arguments);\n      return this;\n    },\n\n    // Tell this object to stop listening to either specific events ... or\n    // to every object it's currently listening to.\n    stopListening: function(obj, name, callback) {\n      var listeningTo = this._listeningTo;\n      if (!listeningTo) return this;\n      var remove = !name && !callback;\n      if (!callback && typeof name === 'object') callback = this;\n      if (obj) (listeningTo = {})[obj._listenId] = obj;\n      for (var id in listeningTo) {\n        obj = listeningTo[id];\n        obj.off(name, callback, this);\n        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];\n      }\n      return this;\n    }\n\n  };\n\n  // Regular expression used to split event strings.\n  var eventSplitter = /\\s+/;\n\n  // Implement fancy features of the Events API such as multiple event\n  // names `\"change blur\"` and jQuery-style event maps `{change: action}`\n  // in terms of the existing API.\n  var eventsApi = function(obj, action, name, rest) {\n    if (!name) return true;\n\n    // Handle event maps.\n    if (typeof name === 'object') {\n      for (var key in name) {\n        obj[action].apply(obj, [key, name[key]].concat(rest));\n      }\n      return false;\n    }\n\n    // Handle space separated event names.\n    if (eventSplitter.test(name)) {\n      var names = name.split(eventSplitter);\n      for (var i = 0, l = names.length; i < l; i++) {\n        obj[action].apply(obj, [names[i]].concat(rest));\n      }\n      return false;\n    }\n\n    return true;\n  };\n\n  // A difficult-to-believe, but optimized internal dispatch function for\n  // triggering events. Tries to keep the usual cases speedy (most internal\n  // Backbone events have 3 arguments).\n  var triggerEvents = function(events, args) {\n    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];\n    switch (args.length) {\n      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;\n      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;\n      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;\n      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;\n      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;\n    }\n  };\n\n  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  _.each(listenMethods, function(implementation, method) {\n    Events[method] = function(obj, name, callback) {\n      var listeningTo = this._listeningTo || (this._listeningTo = {});\n      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));\n      listeningTo[id] = obj;\n      if (!callback && typeof name === 'object') callback = this;\n      obj[implementation](name, callback, this);\n      return this;\n    };\n  });\n\n  // Aliases for backwards compatibility.\n  Events.bind   = Events.on;\n  Events.unbind = Events.off;\n\n  // Allow the `Backbone` object to serve as a global event bus, for folks who\n  // want global \"pubsub\" in a convenient place.\n  _.extend(Backbone, Events);\n\n  // Backbone.Model\n  // --------------\n\n  // Backbone **Models** are the basic data object in the framework --\n  // frequently representing a row in a table in a database on your server.\n  // A discrete chunk of data and a bunch of useful, related methods for\n  // performing computations and transformations on that data.\n\n  // Create a new model with the specified attributes. A client id (`cid`)\n  // is automatically generated and assigned for you.\n  var Model = Backbone.Model = function(attributes, options) {\n    var attrs = attributes || {};\n    options || (options = {});\n    this.cid = _.uniqueId('c');\n    this.attributes = {};\n    if (options.collection) this.collection = options.collection;\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));\n    this.set(attrs, options);\n    this.changed = {};\n    this.initialize.apply(this, arguments);\n  };\n\n  // Attach all inheritable methods to the Model prototype.\n  _.extend(Model.prototype, Events, {\n\n    // A hash of attributes whose current and previous value differ.\n    changed: null,\n\n    // The value returned during the last failed validation.\n    validationError: null,\n\n    // The default name for the JSON `id` attribute is `\"id\"`. MongoDB and\n    // CouchDB users may want to set this to `\"_id\"`.\n    idAttribute: 'id',\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Return a copy of the model's `attributes` object.\n    toJSON: function(options) {\n      return _.clone(this.attributes);\n    },\n\n    // Proxy `Backbone.sync` by default -- but override this if you need\n    // custom syncing semantics for *this* particular model.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Get the value of an attribute.\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    // Get the HTML-escaped value of an attribute.\n    escape: function(attr) {\n      return _.escape(this.get(attr));\n    },\n\n    // Returns `true` if the attribute contains a value that is not null\n    // or undefined.\n    has: function(attr) {\n      return this.get(attr) != null;\n    },\n\n    // Set a hash of model attributes on the object, firing `\"change\"`. This is\n    // the core primitive operation of a model, updating the data and notifying\n    // anyone who needs to know about the change in state. The heart of the beast.\n    set: function(key, val, options) {\n      var attr, attrs, unset, changes, silent, changing, prev, current;\n      if (key == null) return this;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options || (options = {});\n\n      // Run validation.\n      if (!this._validate(attrs, options)) return false;\n\n      // Extract attributes and options.\n      unset           = options.unset;\n      silent          = options.silent;\n      changes         = [];\n      changing        = this._changing;\n      this._changing  = true;\n\n      if (!changing) {\n        this._previousAttributes = _.clone(this.attributes);\n        this.changed = {};\n      }\n      current = this.attributes, prev = this._previousAttributes;\n\n      // Check for changes of `id`.\n      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n      // For each `set` attribute, update or delete the current value.\n      for (attr in attrs) {\n        val = attrs[attr];\n        if (!_.isEqual(current[attr], val)) changes.push(attr);\n        if (!_.isEqual(prev[attr], val)) {\n          this.changed[attr] = val;\n        } else {\n          delete this.changed[attr];\n        }\n        unset ? delete current[attr] : current[attr] = val;\n      }\n\n      // Trigger all relevant attribute changes.\n      if (!silent) {\n        if (changes.length) this._pending = options;\n        for (var i = 0, l = changes.length; i < l; i++) {\n          this.trigger('change:' + changes[i], this, current[changes[i]], options);\n        }\n      }\n\n      // You might be wondering why there's a `while` loop here. Changes can\n      // be recursively nested within `\"change\"` events.\n      if (changing) return this;\n      if (!silent) {\n        while (this._pending) {\n          options = this._pending;\n          this._pending = false;\n          this.trigger('change', this, options);\n        }\n      }\n      this._pending = false;\n      this._changing = false;\n      return this;\n    },\n\n    // Remove an attribute from the model, firing `\"change\"`. `unset` is a noop\n    // if the attribute doesn't exist.\n    unset: function(attr, options) {\n      return this.set(attr, void 0, _.extend({}, options, {unset: true}));\n    },\n\n    // Clear all attributes on the model, firing `\"change\"`.\n    clear: function(options) {\n      var attrs = {};\n      for (var key in this.attributes) attrs[key] = void 0;\n      return this.set(attrs, _.extend({}, options, {unset: true}));\n    },\n\n    // Determine if the model has changed since the last `\"change\"` event.\n    // If you specify an attribute name, determine if that attribute has changed.\n    hasChanged: function(attr) {\n      if (attr == null) return !_.isEmpty(this.changed);\n      return _.has(this.changed, attr);\n    },\n\n    // Return an object containing all the attributes that have changed, or\n    // false if there are no changed attributes. Useful for determining what\n    // parts of a view need to be updated and/or what attributes need to be\n    // persisted to the server. Unset attributes will be set to undefined.\n    // You can also pass an attributes object to diff against the model,\n    // determining if there *would be* a change.\n    changedAttributes: function(diff) {\n      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;\n      var val, changed = false;\n      var old = this._changing ? this._previousAttributes : this.attributes;\n      for (var attr in diff) {\n        if (_.isEqual(old[attr], (val = diff[attr]))) continue;\n        (changed || (changed = {}))[attr] = val;\n      }\n      return changed;\n    },\n\n    // Get the previous value of an attribute, recorded at the time the last\n    // `\"change\"` event was fired.\n    previous: function(attr) {\n      if (attr == null || !this._previousAttributes) return null;\n      return this._previousAttributes[attr];\n    },\n\n    // Get all of the attributes of the model at the time of the previous\n    // `\"change\"` event.\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    // Fetch the model from the server. If the server's representation of the\n    // model differs from its current attributes, they will be overridden,\n    // triggering a `\"change\"` event.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        if (!model.set(model.parse(resp, options), options)) return false;\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Set a hash of model attributes, and sync the model to the server.\n    // If the server returns an attributes hash that differs, the model's\n    // state will be `set` again.\n    save: function(key, val, options) {\n      var attrs, method, xhr, attributes = this.attributes;\n\n      // Handle both `\"key\", value` and `{key: value}` -style arguments.\n      if (key == null || typeof key === 'object') {\n        attrs = key;\n        options = val;\n      } else {\n        (attrs = {})[key] = val;\n      }\n\n      options = _.extend({validate: true}, options);\n\n      // If we're not waiting and attributes exist, save acts as\n      // `set(attr).save(null, opts)` with validation. Otherwise, check if\n      // the model will be valid when the attributes, if any, are set.\n      if (attrs && !options.wait) {\n        if (!this.set(attrs, options)) return false;\n      } else {\n        if (!this._validate(attrs, options)) return false;\n      }\n\n      // Set temporary attributes if `{wait: true}`.\n      if (attrs && options.wait) {\n        this.attributes = _.extend({}, attributes, attrs);\n      }\n\n      // After a successful server-side save, the client is (optionally)\n      // updated with the server-side state.\n      if (options.parse === void 0) options.parse = true;\n      var model = this;\n      var success = options.success;\n      options.success = function(resp) {\n        // Ensure attributes are restored during synchronous saves.\n        model.attributes = attributes;\n        var serverAttrs = model.parse(resp, options);\n        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);\n        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {\n          return false;\n        }\n        if (success) success(model, resp, options);\n        model.trigger('sync', model, resp, options);\n      };\n      wrapError(this, options);\n\n      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');\n      if (method === 'patch') options.attrs = attrs;\n      xhr = this.sync(method, this, options);\n\n      // Restore attributes.\n      if (attrs && options.wait) this.attributes = attributes;\n\n      return xhr;\n    },\n\n    // Destroy this model on the server if it was already persisted.\n    // Optimistically removes the model from its collection, if it has one.\n    // If `wait: true` is passed, waits for the server to respond before removal.\n    destroy: function(options) {\n      options = options ? _.clone(options) : {};\n      var model = this;\n      var success = options.success;\n\n      var destroy = function() {\n        model.trigger('destroy', model, model.collection, options);\n      };\n\n      options.success = function(resp) {\n        if (options.wait || model.isNew()) destroy();\n        if (success) success(model, resp, options);\n        if (!model.isNew()) model.trigger('sync', model, resp, options);\n      };\n\n      if (this.isNew()) {\n        options.success();\n        return false;\n      }\n      wrapError(this, options);\n\n      var xhr = this.sync('delete', this, options);\n      if (!options.wait) destroy();\n      return xhr;\n    },\n\n    // Default URL for the model's representation on the server -- if you're\n    // using Backbone's restful methods, override this to change the endpoint\n    // that will be called.\n    url: function() {\n      var base =\n        _.result(this, 'urlRoot') ||\n        _.result(this.collection, 'url') ||\n        urlError();\n      if (this.isNew()) return base;\n      return base.replace(/([^\\/])$/, '$1/') + encodeURIComponent(this.id);\n    },\n\n    // **parse** converts a response into the hash of attributes to be `set` on\n    // the model. The default implementation is just to pass the response along.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new model with identical attributes to this one.\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    // A model is new if it has never been saved to the server, and lacks an id.\n    isNew: function() {\n      return !this.has(this.idAttribute);\n    },\n\n    // Check if the model is currently in a valid state.\n    isValid: function(options) {\n      return this._validate({}, _.extend(options || {}, { validate: true }));\n    },\n\n    // Run validation against the next complete set of model attributes,\n    // returning `true` if all is well. Otherwise, fire an `\"invalid\"` event.\n    _validate: function(attrs, options) {\n      if (!options.validate || !this.validate) return true;\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validationError = this.validate(attrs, options) || null;\n      if (!error) return true;\n      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));\n      return false;\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Model.\n  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];\n\n  // Mix in each Underscore method as a proxy to `Model#attributes`.\n  _.each(modelMethods, function(method) {\n    Model.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.attributes);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Backbone.Collection\n  // -------------------\n\n  // If models tend to represent a single row of data, a Backbone Collection is\n  // more analagous to a table full of data ... or a small slice or page of that\n  // table, or a collection of rows that belong together for a particular reason\n  // -- all of the messages in this particular folder, all of the documents\n  // belonging to this particular author, and so on. Collections maintain\n  // indexes of their models, both in order, and for lookup by `id`.\n\n  // Create a new **Collection**, perhaps to contain a specific type of `model`.\n  // If a `comparator` is specified, the Collection will maintain\n  // its models in sort order, as they're added and removed.\n  var Collection = Backbone.Collection = function(models, options) {\n    options || (options = {});\n    if (options.model) this.model = options.model;\n    if (options.comparator !== void 0) this.comparator = options.comparator;\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) this.reset(models, _.extend({silent: true}, options));\n  };\n\n  // Default options for `Collection#set`.\n  var setOptions = {add: true, remove: true, merge: true};\n  var addOptions = {add: true, remove: false};\n\n  // Define the Collection's inheritable methods.\n  _.extend(Collection.prototype, Events, {\n\n    // The default model for a collection is just a **Backbone.Model**.\n    // This should be overridden in most cases.\n    model: Model,\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // The JSON representation of a Collection is an array of the\n    // models' attributes.\n    toJSON: function(options) {\n      return this.map(function(model){ return model.toJSON(options); });\n    },\n\n    // Proxy `Backbone.sync` by default.\n    sync: function() {\n      return Backbone.sync.apply(this, arguments);\n    },\n\n    // Add a model, or list of models to the set.\n    add: function(models, options) {\n      return this.set(models, _.extend({merge: false}, options, addOptions));\n    },\n\n    // Remove a model, or a list of models from the set.\n    remove: function(models, options) {\n      var singular = !_.isArray(models);\n      models = singular ? [models] : _.clone(models);\n      options || (options = {});\n      var i, l, index, model;\n      for (i = 0, l = models.length; i < l; i++) {\n        model = models[i] = this.get(models[i]);\n        if (!model) continue;\n        delete this._byId[model.id];\n        delete this._byId[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger('remove', model, this, options);\n        }\n        this._removeReference(model, options);\n      }\n      return singular ? models[0] : models;\n    },\n\n    // Update a collection by `set`-ing a new list of models, adding new ones,\n    // removing models that are no longer present, and merging models that\n    // already exist in the collection, as necessary. Similar to **Model#set**,\n    // the core operation for updating the data contained by the collection.\n    set: function(models, options) {\n      options = _.defaults({}, options, setOptions);\n      if (options.parse) models = this.parse(models, options);\n      var singular = !_.isArray(models);\n      models = singular ? (models ? [models] : []) : _.clone(models);\n      var i, l, id, model, attrs, existing, sort;\n      var at = options.at;\n      var targetModel = this.model;\n      var sortable = this.comparator && (at == null) && options.sort !== false;\n      var sortAttr = _.isString(this.comparator) ? this.comparator : null;\n      var toAdd = [], toRemove = [], modelMap = {};\n      var add = options.add, merge = options.merge, remove = options.remove;\n      var order = !sortable && add && remove ? [] : false;\n\n      // Turn bare objects into model references, and prevent invalid models\n      // from being added.\n      for (i = 0, l = models.length; i < l; i++) {\n        attrs = models[i] || {};\n        if (attrs instanceof Model) {\n          id = model = attrs;\n        } else {\n          id = attrs[targetModel.prototype.idAttribute || 'id'];\n        }\n\n        // If a duplicate is found, prevent it from being added and\n        // optionally merge it into the existing model.\n        if (existing = this.get(id)) {\n          if (remove) modelMap[existing.cid] = true;\n          if (merge) {\n            attrs = attrs === model ? model.attributes : attrs;\n            if (options.parse) attrs = existing.parse(attrs, options);\n            existing.set(attrs, options);\n            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;\n          }\n          models[i] = existing;\n\n        // If this is a new, valid model, push it to the `toAdd` list.\n        } else if (add) {\n          model = models[i] = this._prepareModel(attrs, options);\n          if (!model) continue;\n          toAdd.push(model);\n          this._addReference(model, options);\n        }\n\n        // Do not add multiple models with the same `id`.\n        model = existing || model;\n        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);\n        modelMap[model.id] = true;\n      }\n\n      // Remove nonexistent models if appropriate.\n      if (remove) {\n        for (i = 0, l = this.length; i < l; ++i) {\n          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n        }\n        if (toRemove.length) this.remove(toRemove, options);\n      }\n\n      // See if sorting is needed, update `length` and splice in new models.\n      if (toAdd.length || (order && order.length)) {\n        if (sortable) sort = true;\n        this.length += toAdd.length;\n        if (at != null) {\n          for (i = 0, l = toAdd.length; i < l; i++) {\n            this.models.splice(at + i, 0, toAdd[i]);\n          }\n        } else {\n          if (order) this.models.length = 0;\n          var orderedModels = order || toAdd;\n          for (i = 0, l = orderedModels.length; i < l; i++) {\n            this.models.push(orderedModels[i]);\n          }\n        }\n      }\n\n      // Silently sort the collection if appropriate.\n      if (sort) this.sort({silent: true});\n\n      // Unless silenced, it's time to fire all appropriate add/sort events.\n      if (!options.silent) {\n        for (i = 0, l = toAdd.length; i < l; i++) {\n          (model = toAdd[i]).trigger('add', model, this, options);\n        }\n        if (sort || (order && order.length)) this.trigger('sort', this, options);\n      }\n\n      // Return the added (or merged) model (or models).\n      return singular ? models[0] : models;\n    },\n\n    // When you have more items than you want to add or remove individually,\n    // you can reset the entire set with a new list of models, without firing\n    // any granular `add` or `remove` events. Fires `reset` when finished.\n    // Useful for bulk operations and optimizations.\n    reset: function(models, options) {\n      options || (options = {});\n      for (var i = 0, l = this.models.length; i < l; i++) {\n        this._removeReference(this.models[i], options);\n      }\n      options.previousModels = this.models;\n      this._reset();\n      models = this.add(models, _.extend({silent: true}, options));\n      if (!options.silent) this.trigger('reset', this, options);\n      return models;\n    },\n\n    // Add a model to the end of the collection.\n    push: function(model, options) {\n      return this.add(model, _.extend({at: this.length}, options));\n    },\n\n    // Remove a model from the end of the collection.\n    pop: function(options) {\n      var model = this.at(this.length - 1);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Add a model to the beginning of the collection.\n    unshift: function(model, options) {\n      return this.add(model, _.extend({at: 0}, options));\n    },\n\n    // Remove a model from the beginning of the collection.\n    shift: function(options) {\n      var model = this.at(0);\n      this.remove(model, options);\n      return model;\n    },\n\n    // Slice out a sub-array of models from the collection.\n    slice: function() {\n      return slice.apply(this.models, arguments);\n    },\n\n    // Get a model from the set by id.\n    get: function(obj) {\n      if (obj == null) return void 0;\n      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];\n    },\n\n    // Get the model at the given index.\n    at: function(index) {\n      return this.models[index];\n    },\n\n    // Return models with matching attributes. Useful for simple cases of\n    // `filter`.\n    where: function(attrs, first) {\n      if (_.isEmpty(attrs)) return first ? void 0 : [];\n      return this[first ? 'find' : 'filter'](function(model) {\n        for (var key in attrs) {\n          if (attrs[key] !== model.get(key)) return false;\n        }\n        return true;\n      });\n    },\n\n    // Return the first model with matching attributes. Useful for simple cases\n    // of `find`.\n    findWhere: function(attrs) {\n      return this.where(attrs, true);\n    },\n\n    // Force the collection to re-sort itself. You don't need to call this under\n    // normal circumstances, as the set will maintain sort order as each item\n    // is added.\n    sort: function(options) {\n      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n      options || (options = {});\n\n      // Run sort based on type of `comparator`.\n      if (_.isString(this.comparator) || this.comparator.length === 1) {\n        this.models = this.sortBy(this.comparator, this);\n      } else {\n        this.models.sort(_.bind(this.comparator, this));\n      }\n\n      if (!options.silent) this.trigger('sort', this, options);\n      return this;\n    },\n\n    // Pluck an attribute from each model in the collection.\n    pluck: function(attr) {\n      return _.invoke(this.models, 'get', attr);\n    },\n\n    // Fetch the default set of models for this collection, resetting the\n    // collection when they arrive. If `reset: true` is passed, the response\n    // data will be passed through the `reset` method instead of `set`.\n    fetch: function(options) {\n      options = options ? _.clone(options) : {};\n      if (options.parse === void 0) options.parse = true;\n      var success = options.success;\n      var collection = this;\n      options.success = function(resp) {\n        var method = options.reset ? 'reset' : 'set';\n        collection[method](resp, options);\n        if (success) success(collection, resp, options);\n        collection.trigger('sync', collection, resp, options);\n      };\n      wrapError(this, options);\n      return this.sync('read', this, options);\n    },\n\n    // Create a new instance of a model in this collection. Add the model to the\n    // collection immediately, unless `wait: true` is passed, in which case we\n    // wait for the server to agree.\n    create: function(model, options) {\n      options = options ? _.clone(options) : {};\n      if (!(model = this._prepareModel(model, options))) return false;\n      if (!options.wait) this.add(model, options);\n      var collection = this;\n      var success = options.success;\n      options.success = function(model, resp) {\n        if (options.wait) collection.add(model, options);\n        if (success) success(model, resp, options);\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    // **parse** converts a response into a list of models to be added to the\n    // collection. The default implementation is just to pass it through.\n    parse: function(resp, options) {\n      return resp;\n    },\n\n    // Create a new collection with an identical list of models as this one.\n    clone: function() {\n      return new this.constructor(this.models);\n    },\n\n    // Private method to reset all internal state. Called when the collection\n    // is first initialized or reset.\n    _reset: function() {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n    },\n\n    // Prepare a hash of attributes (or other model) to be added to this\n    // collection.\n    _prepareModel: function(attrs, options) {\n      if (attrs instanceof Model) return attrs;\n      options = options ? _.clone(options) : {};\n      options.collection = this;\n      var model = new this.model(attrs, options);\n      if (!model.validationError) return model;\n      this.trigger('invalid', this, model.validationError, options);\n      return false;\n    },\n\n    // Internal method to create a model's ties to a collection.\n    _addReference: function(model, options) {\n      this._byId[model.cid] = model;\n      if (model.id != null) this._byId[model.id] = model;\n      if (!model.collection) model.collection = this;\n      model.on('all', this._onModelEvent, this);\n    },\n\n    // Internal method to sever a model's ties to a collection.\n    _removeReference: function(model, options) {\n      if (this === model.collection) delete model.collection;\n      model.off('all', this._onModelEvent, this);\n    },\n\n    // Internal method called every time a model in the set fires an event.\n    // Sets need to update their indexes when models change ids. All other\n    // events simply proxy through. \"add\" and \"remove\" events that originate\n    // in other collections are ignored.\n    _onModelEvent: function(event, model, collection, options) {\n      if ((event === 'add' || event === 'remove') && collection !== this) return;\n      if (event === 'destroy') this.remove(model, options);\n      if (model && event === 'change:' + model.idAttribute) {\n        delete this._byId[model.previous(model.idAttribute)];\n        if (model.id != null) this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  // 90% of the core usefulness of Backbone Collections is actually implemented\n  // right here:\n  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',\n    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',\n    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',\n    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',\n    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',\n    'lastIndexOf', 'isEmpty', 'chain', 'sample'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  _.each(methods, function(method) {\n    Collection.prototype[method] = function() {\n      var args = slice.call(arguments);\n      args.unshift(this.models);\n      return _[method].apply(_, args);\n    };\n  });\n\n  // Underscore methods that take a property name as an argument.\n  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];\n\n  // Use attributes instead of properties.\n  _.each(attributeMethods, function(method) {\n    Collection.prototype[method] = function(value, context) {\n      var iterator = _.isFunction(value) ? value : function(model) {\n        return model.get(value);\n      };\n      return _[method](this.models, iterator, context);\n    };\n  });\n\n  // Backbone.View\n  // -------------\n\n  // Backbone Views are almost more convention than they are actual code. A View\n  // is simply a JavaScript object that represents a logical chunk of UI in the\n  // DOM. This might be a single item, an entire list, a sidebar or panel, or\n  // even the surrounding frame which wraps your whole app. Defining a chunk of\n  // UI as a **View** allows you to define your DOM events declaratively, without\n  // having to worry about render order ... and makes it easy for the view to\n  // react to specific changes in the state of your models.\n\n  // Creating a Backbone.View creates its initial element outside of the DOM,\n  // if an existing element is not provided...\n  var View = Backbone.View = function(options) {\n    this.cid = _.uniqueId('view');\n    options || (options = {});\n    _.extend(this, _.pick(options, viewOptions));\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var delegateEventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];\n\n  // Set up all inheritable **Backbone.View** properties and methods.\n  _.extend(View.prototype, Events, {\n\n    // The default `tagName` of a View's element is `\"div\"`.\n    tagName: 'div',\n\n    // jQuery delegate for element lookup, scoped to DOM elements within the\n    // current view. This should be preferred to global lookups where possible.\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // **render** is the core function that your view should override, in order\n    // to populate its element (`this.el`), with the appropriate HTML. The\n    // convention is for **render** to always return `this`.\n    render: function() {\n      return this;\n    },\n\n    // Remove this view by taking the element out of the DOM, and removing any\n    // applicable Backbone.Events listeners.\n    remove: function() {\n      this.$el.remove();\n      this.stopListening();\n      return this;\n    },\n\n    // Change the view's element (`this.el` property), including event\n    // re-delegation.\n    setElement: function(element, delegate) {\n      if (this.$el) this.undelegateEvents();\n      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) this.delegateEvents();\n      return this;\n    },\n\n    // Set callbacks, where `this.events` is a hash of\n    //\n    // *{\"event selector\": \"callback\"}*\n    //\n    //     {\n    //       'mousedown .title':  'edit',\n    //       'click .button':     'save',\n    //       'click .open':       function(e) { ... }\n    //     }\n    //\n    // pairs. Callbacks will be bound to the view, with `this` set properly.\n    // Uses event delegation for efficiency.\n    // Omitting the selector binds the event to `this.el`.\n    // This only works for delegate-able events: not `focus`, `blur`, and\n    // not `change`, `submit`, and `reset` in Internet Explorer.\n    delegateEvents: function(events) {\n      if (!(events || (events = _.result(this, 'events')))) return this;\n      this.undelegateEvents();\n      for (var key in events) {\n        var method = events[key];\n        if (!_.isFunction(method)) method = this[events[key]];\n        if (!method) continue;\n\n        var match = key.match(delegateEventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, this);\n        eventName += '.delegateEvents' + this.cid;\n        if (selector === '') {\n          this.$el.on(eventName, method);\n        } else {\n          this.$el.on(eventName, selector, method);\n        }\n      }\n      return this;\n    },\n\n    // Clears all callbacks previously bound to the view with `delegateEvents`.\n    // You usually don't need to use this, but may wish to if you have multiple\n    // Backbone views attached to the same DOM element.\n    undelegateEvents: function() {\n      this.$el.off('.delegateEvents' + this.cid);\n      return this;\n    },\n\n    // Ensure that the View has a DOM element to render into.\n    // If `this.el` is a string, pass it through `$()`, take the first\n    // matching element, and re-assign it to `el`. Otherwise, create\n    // an element from the `id`, `className` and `tagName` properties.\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = _.extend({}, _.result(this, 'attributes'));\n        if (this.id) attrs.id = _.result(this, 'id');\n        if (this.className) attrs['class'] = _.result(this, 'className');\n        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);\n        this.setElement($el, false);\n      } else {\n        this.setElement(_.result(this, 'el'), false);\n      }\n    }\n\n  });\n\n  // Backbone.sync\n  // -------------\n\n  // Override this function to change the manner in which Backbone persists\n  // models to the server. You will be passed the type of request, and the\n  // model in question. By default, makes a RESTful Ajax request\n  // to the model's `url()`. Some possible customizations could be:\n  //\n  // * Use `setTimeout` to batch rapid-fire updates into a single request.\n  // * Send up the models as XML instead of JSON.\n  // * Persist models via WebSockets instead of Ajax.\n  //\n  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests\n  // as `POST`, with a `_method` parameter containing the true HTTP method,\n  // as well as all requests with the body as `application/x-www-form-urlencoded`\n  // instead of `application/json` with the model in a param named `model`.\n  // Useful when interfacing with server-side languages like **PHP** that make\n  // it difficult to read the body of `PUT` requests.\n  Backbone.sync = function(method, model, options) {\n    var type = methodMap[method];\n\n    // Default options, unless specified.\n    _.defaults(options || (options = {}), {\n      emulateHTTP: Backbone.emulateHTTP,\n      emulateJSON: Backbone.emulateJSON\n    });\n\n    // Default JSON-request options.\n    var params = {type: type, dataType: 'json'};\n\n    // Ensure that we have a URL.\n    if (!options.url) {\n      params.url = _.result(model, 'url') || urlError();\n    }\n\n    // Ensure that we have the appropriate request data.\n    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {\n      params.contentType = 'application/json';\n      params.data = JSON.stringify(options.attrs || model.toJSON(options));\n    }\n\n    // For older servers, emulate JSON by encoding the request into an HTML-form.\n    if (options.emulateJSON) {\n      params.contentType = 'application/x-www-form-urlencoded';\n      params.data = params.data ? {model: params.data} : {};\n    }\n\n    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`\n    // And an `X-HTTP-Method-Override` header.\n    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {\n      params.type = 'POST';\n      if (options.emulateJSON) params.data._method = type;\n      var beforeSend = options.beforeSend;\n      options.beforeSend = function(xhr) {\n        xhr.setRequestHeader('X-HTTP-Method-Override', type);\n        if (beforeSend) return beforeSend.apply(this, arguments);\n      };\n    }\n\n    // Don't process data on a non-GET request.\n    if (params.type !== 'GET' && !options.emulateJSON) {\n      params.processData = false;\n    }\n\n    // If we're sending a `PATCH` request, and we're in an old Internet Explorer\n    // that still has ActiveX enabled by default, override jQuery to use that\n    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.\n    if (params.type === 'PATCH' && noXhrPatch) {\n      params.xhr = function() {\n        return new ActiveXObject(\"Microsoft.XMLHTTP\");\n      };\n    }\n\n    // Make the request, allowing the user to override any Ajax options.\n    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));\n    model.trigger('request', model, xhr, options);\n    return xhr;\n  };\n\n  var noXhrPatch =\n    typeof window !== 'undefined' && !!window.ActiveXObject &&\n      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);\n\n  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.\n  var methodMap = {\n    'create': 'POST',\n    'update': 'PUT',\n    'patch':  'PATCH',\n    'delete': 'DELETE',\n    'read':   'GET'\n  };\n\n  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.\n  // Override this if you'd like to use a different library.\n  Backbone.ajax = function() {\n    return Backbone.$.ajax.apply(Backbone.$, arguments);\n  };\n\n  // Backbone.Router\n  // ---------------\n\n  // Routers map faux-URLs to actions, and fire events when routes are\n  // matched. Creating a new one sets its `routes` hash, if not set statically.\n  var Router = Backbone.Router = function(options) {\n    options || (options = {});\n    if (options.routes) this.routes = options.routes;\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var optionalParam = /\\((.*?)\\)/g;\n  var namedParam    = /(\\(\\?)?:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n  // Set up all inheritable **Backbone.Router** properties and methods.\n  _.extend(Router.prototype, Events, {\n\n    // Initialize is an empty function by default. Override it with your own\n    // initialization logic.\n    initialize: function(){},\n\n    // Manually bind a single named route to a callback. For example:\n    //\n    //     this.route('search/:query/p:num', 'search', function(query, num) {\n    //       ...\n    //     });\n    //\n    route: function(route, name, callback) {\n      if (!_.isRegExp(route)) route = this._routeToRegExp(route);\n      if (_.isFunction(name)) {\n        callback = name;\n        name = '';\n      }\n      if (!callback) callback = this[name];\n      var router = this;\n      Backbone.history.route(route, function(fragment) {\n        var args = router._extractParameters(route, fragment);\n        router.execute(callback, args);\n        router.trigger.apply(router, ['route:' + name].concat(args));\n        router.trigger('route', name, args);\n        Backbone.history.trigger('route', router, name, args);\n      });\n      return this;\n    },\n\n    // Execute a route handler with the provided parameters.  This is an\n    // excellent place to do pre-route setup or post-route cleanup.\n    execute: function(callback, args) {\n      if (callback) callback.apply(this, args);\n    },\n\n    // Simple proxy to `Backbone.history` to save a fragment into the history.\n    navigate: function(fragment, options) {\n      Backbone.history.navigate(fragment, options);\n      return this;\n    },\n\n    // Bind all defined routes to `Backbone.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) return;\n      this.routes = _.result(this, 'routes');\n      var route, routes = _.keys(this.routes);\n      while ((route = routes.pop()) != null) {\n        this.route(route, this.routes[route]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, '\\\\$&')\n                   .replace(optionalParam, '(?:$1)?')\n                   .replace(namedParam, function(match, optional) {\n                     return optional ? match : '([^/?]+)';\n                   })\n                   .replace(splatParam, '([^?]*?)');\n      return new RegExp('^' + route + '(?:\\\\?([\\\\s\\\\S]*))?$');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted decoded parameters. Empty or unmatched parameters will be\n    // treated as `null` to normalize cross-browser behavior.\n    _extractParameters: function(route, fragment) {\n      var params = route.exec(fragment).slice(1);\n      return _.map(params, function(param, i) {\n        // Don't decode the search params.\n        if (i === params.length - 1) return param || null;\n        return param ? decodeURIComponent(param) : null;\n      });\n    }\n\n  });\n\n  // Backbone.History\n  // ----------------\n\n  // Handles cross-browser history management, based on either\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\n  // and URL fragments. If the browser supports neither (old IE, natch),\n  // falls back to polling.\n  var History = Backbone.History = function() {\n    this.handlers = [];\n    _.bindAll(this, 'checkUrl');\n\n    // Ensure that `History` can be used outside of the browser.\n    if (typeof window !== 'undefined') {\n      this.location = window.location;\n      this.history = window.history;\n    }\n  };\n\n  // Cached regex for stripping a leading hash/slash and trailing space.\n  var routeStripper = /^[#\\/]|\\s+$/g;\n\n  // Cached regex for stripping leading and trailing slashes.\n  var rootStripper = /^\\/+|\\/+$/g;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Cached regex for removing a trailing slash.\n  var trailingSlash = /\\/$/;\n\n  // Cached regex for stripping urls of hash.\n  var pathStripper = /#.*$/;\n\n  // Has the history handling already been started?\n  History.started = false;\n\n  // Set up all inheritable **Backbone.History** properties and methods.\n  _.extend(History.prototype, Events, {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Are we at the app root?\n    atRoot: function() {\n      return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\n    },\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(window) {\n      var match = (window || this).location.href.match(/#(.*)$/);\n      return match ? match[1] : '';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (fragment == null) {\n        if (this._hasPushState || !this._wantsHashChange || forcePushState) {\n          fragment = decodeURI(this.location.pathname + this.location.search);\n          var root = this.root.replace(trailingSlash, '');\n          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      return fragment.replace(routeStripper, '');\n    },\n\n    // Start the hash change handling, returning `true` if the current URL matches\n    // an existing route, and `false` otherwise.\n    start: function(options) {\n      if (History.started) throw new Error(\"Backbone.history has already been started\");\n      History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options          = _.extend({root: '/'}, this.options, options);\n      this.root             = this.options.root;\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState  = !!this.options.pushState;\n      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);\n      var fragment          = this.getFragment();\n      var docMode           = document.documentMode;\n      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));\n\n      // Normalize root to always include a leading and trailing slash.\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\n\n      if (oldIE && this._wantsHashChange) {\n        var frame = Backbone.$('<iframe src=\"javascript:0\" tabindex=\"-1\">');\n        this.iframe = frame.hide().appendTo('body')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we're using pushState or hashes, and whether\n      // 'onhashchange' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Backbone.$(window).on('popstate', this.checkUrl);\n      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {\n        Backbone.$(window).on('hashchange', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = this.location;\n\n      // Transition from hashChange to pushState or vice versa if both are\n      // requested.\n      if (this._wantsHashChange && this._wantsPushState) {\n\n        // If we've started off with a route from a `pushState`-enabled\n        // browser, but we're currently in a browser that doesn't support it...\n        if (!this._hasPushState && !this.atRoot()) {\n          this.fragment = this.getFragment(null, true);\n          this.location.replace(this.root + '#' + this.fragment);\n          // Return immediately as browser will do redirect to new url\n          return true;\n\n        // Or if we've started out with a hash-based route, but we're currently\n        // in a browser where it could be `pushState`-based instead...\n        } else if (this._hasPushState && this.atRoot() && loc.hash) {\n          this.fragment = this.getHash().replace(routeStripper, '');\n          this.history.replaceState({}, document.title, this.root + this.fragment);\n        }\n\n      }\n\n      if (!this.options.silent) return this.loadUrl();\n    },\n\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\n      History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) return false;\n      if (this.iframe) this.navigate(current);\n      this.loadUrl();\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragment) {\n      fragment = this.fragment = this.getFragment(fragment);\n      return _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // 'replace' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the history.\n    navigate: function(fragment, options) {\n      if (!History.started) return false;\n      if (!options || options === true) options = {trigger: !!options};\n\n      var url = this.root + (fragment = this.getFragment(fragment || ''));\n\n      // Strip the hash for matching.\n      fragment = fragment.replace(pathStripper, '');\n\n      if (this.fragment === fragment) return;\n      this.fragment = fragment;\n\n      // Don't include a trailing slash on the root.\n      if (fragment === '' && url !== '/') url = url.slice(0, -1);\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\n\n      // If hash changes haven't been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this._updateHash(this.location, fragment, options.replace);\n        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier to push a\n          // history entry on hash-tag change.  When replace is true, we don't\n          // want this.\n          if(!options.replace) this.iframe.document.open().close();\n          this._updateHash(this.iframe.location, fragment, options.replace);\n        }\n\n      // If you've told us that you explicitly don't want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        return this.location.assign(url);\n      }\n      if (options.trigger) return this.loadUrl(fragment);\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var href = location.href.replace(/(javascript:|#).*$/, '');\n        location.replace(href + '#' + fragment);\n      } else {\n        // Some browsers require that `hash` contains a leading #.\n        location.hash = '#' + fragment;\n      }\n    }\n\n  });\n\n  // Create the default Backbone.history.\n  Backbone.history = new History;\n\n  // Helpers\n  // -------\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var extend = function(protoProps, staticProps) {\n    var parent = this;\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the \"constructor\" property in your `extend` definition), or defaulted\n    // by us to simply call the parent's constructor.\n    if (protoProps && _.has(protoProps, 'constructor')) {\n      child = protoProps.constructor;\n    } else {\n      child = function(){ return parent.apply(this, arguments); };\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    _.extend(child, parent, staticProps);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`'s constructor function.\n    var Surrogate = function(){ this.constructor = child; };\n    Surrogate.prototype = parent.prototype;\n    child.prototype = new Surrogate;\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) _.extend(child.prototype, protoProps);\n\n    // Set a convenience property in case the parent's prototype is needed\n    // later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set up inheritance for the model, collection, router, view and history.\n  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;\n\n  // Throw an error when a URL is needed, and none is supplied.\n  var urlError = function() {\n    throw new Error('A \"url\" property or function must be specified');\n  };\n\n  // Wrap an optional error callback with a fallback error event.\n  var wrapError = function(model, options) {\n    var error = options.error;\n    options.error = function(resp) {\n      if (error) error(model, resp, options);\n      model.trigger('error', model, resp, options);\n    };\n  };\n\n  return Backbone;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/backbone/backbone.js\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/backbone/backbone.js?");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = {\n  Accordion: __webpack_require__(77),\n  Affix: __webpack_require__(78),\n  AffixMixin: __webpack_require__(79),\n  Alert: __webpack_require__(80),\n  BootstrapMixin: __webpack_require__(81),\n  Badge: __webpack_require__(82),\n  Button: __webpack_require__(83),\n  ButtonGroup: __webpack_require__(84),\n  ButtonToolbar: __webpack_require__(85),\n  Carousel: __webpack_require__(86),\n  CarouselItem: __webpack_require__(87),\n  Col: __webpack_require__(88),\n  CollapsableMixin: __webpack_require__(89),\n  DropdownButton: __webpack_require__(90),\n  DropdownMenu: __webpack_require__(91),\n  DropdownStateMixin: __webpack_require__(92),\n  FadeMixin: __webpack_require__(93),\n  Glyphicon: __webpack_require__(94),\n  Grid: __webpack_require__(95),\n  Input: __webpack_require__(96),\n  Interpolate: __webpack_require__(97),\n  Jumbotron: __webpack_require__(98),\n  Label: __webpack_require__(99),\n  ListGroup: __webpack_require__(100),\n  ListGroupItem: __webpack_require__(101),\n  MenuItem: __webpack_require__(102),\n  Modal: __webpack_require__(103),\n  Nav: __webpack_require__(104),\n  Navbar: __webpack_require__(105),\n  NavItem: __webpack_require__(106),\n  ModalTrigger: __webpack_require__(107),\n  OverlayTrigger: __webpack_require__(108),\n  OverlayMixin: __webpack_require__(109),\n  PageHeader: __webpack_require__(110),\n  Panel: __webpack_require__(111),\n  PanelGroup: __webpack_require__(112),\n  PageItem: __webpack_require__(113),\n  Pager: __webpack_require__(114),\n  Popover: __webpack_require__(115),\n  ProgressBar: __webpack_require__(116),\n  Row: __webpack_require__(117),\n  SplitButton: __webpack_require__(118),\n  SubNav: __webpack_require__(119),\n  TabbedArea: __webpack_require__(120),\n  Table: __webpack_require__(121),\n  TabPane: __webpack_require__(122),\n  Tooltip: __webpack_require__(123),\n  Well: __webpack_require__(124)\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/main.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/main.js?");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.1.3\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-18T15:11Z\n */\n\n(function( global, factory ) {\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Support: Firefox 18+\n// Can't be in strict mode, several libs including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n//\n\nvar arr = [];\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar support = {};\n\n\n\nvar\n\t// Use the correct document accordingly with window argument (sandbox)\n\tdocument = window.document,\n\n\tversion = \"2.1.3\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android<4.1\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n\t// Matches dashed string for camelizing\n\trmsPrefix = /^-ms-/,\n\trdashAlpha = /-([\\da-z])/gi,\n\n\t// Used by jQuery.camelCase as callback to replace()\n\tfcamelCase = function( all, letter ) {\n\t\treturn letter.toUpperCase();\n\t};\n\njQuery.fn = jQuery.prototype = {\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// Start with an empty selector\n\tselector: \"\",\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\t\treturn num != null ?\n\n\t\t\t// Return just the one element from the set\n\t\t\t( num < 0 ? this[ num + this.length ] : this[ num ] ) :\n\n\t\t\t// Return all the elements in a clean array\n\t\t\tslice.call( this );\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\t\tret.context = this.context;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\t// (You can seed the arguments with an array of args, but this is\n\t// only used internally.)\n\teach: function( callback, args ) {\n\t\treturn jQuery.each( this, callback, args );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map(this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t}));\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor(null);\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend({\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisFunction: function( obj ) {\n\t\treturn jQuery.type(obj) === \"function\";\n\t},\n\n\tisArray: Array.isArray,\n\n\tisWindow: function( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t},\n\n\tisNumeric: function( obj ) {\n\t\t// parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t// adding 1 corrects loss of precision from parseFloat (#15100)\n\t\treturn !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;\n\t},\n\n\tisPlainObject: function( obj ) {\n\t\t// Not plain objects:\n\t\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t\t// - DOM nodes\n\t\t// - window\n\t\tif ( jQuery.type( obj ) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( obj.constructor &&\n\t\t\t\t!hasOwn.call( obj.constructor.prototype, \"isPrototypeOf\" ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the function hasn't returned already, we're confident that\n\t\t// |obj| is a plain object, created by {} or constructed with new Object\n\t\treturn true;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\ttype: function( obj ) {\n\t\tif ( obj == null ) {\n\t\t\treturn obj + \"\";\n\t\t}\n\t\t// Support: Android<4.0, iOS<6 (functionish RegExp)\n\t\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\t\tclass2type[ toString.call(obj) ] || \"object\" :\n\t\t\ttypeof obj;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tvar script,\n\t\t\tindirect = eval;\n\n\t\tcode = jQuery.trim( code );\n\n\t\tif ( code ) {\n\t\t\t// If the code includes a valid, prologue position\n\t\t\t// strict mode pragma, execute code by injecting a\n\t\t\t// script tag into the document.\n\t\t\tif ( code.indexOf(\"use strict\") === 1 ) {\n\t\t\t\tscript = document.createElement(\"script\");\n\t\t\t\tscript.text = code;\n\t\t\t\tdocument.head.appendChild( script ).parentNode.removeChild( script );\n\t\t\t} else {\n\t\t\t// Otherwise, avoid the DOM node creation, insertion\n\t\t\t// and removal by using an indirect global eval\n\t\t\t\tindirect( code );\n\t\t\t}\n\t\t}\n\t},\n\n\t// Convert dashed to camelCase; used by the css and data modules\n\t// Support: IE9-11+\n\t// Microsoft forgot to hump their vendor prefix (#9572)\n\tcamelCase: function( string ) {\n\t\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n\t},\n\n\tnodeName: function( elem, name ) {\n\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\t},\n\n\t// args is for internal usage only\n\teach: function( obj, callback, args ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = obj.length,\n\t\t\tisArray = isArraylike( obj );\n\n\t\tif ( args ) {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.apply( obj[ i ], args );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t\t} else {\n\t\t\tif ( isArray ) {\n\t\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( i in obj ) {\n\t\t\t\t\tvalue = callback.call( obj[ i ], i, obj[ i ] );\n\n\t\t\t\t\tif ( value === false ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android<4.1\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArraylike( Object(arr) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar value,\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tisArray = isArraylike( elems ),\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArray ) {\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// Bind a function to a context, optionally partially applying any\n\t// arguments.\n\tproxy: function( fn, context ) {\n\t\tvar tmp, args, proxy;\n\n\t\tif ( typeof context === \"string\" ) {\n\t\t\ttmp = fn[ context ];\n\t\t\tcontext = fn;\n\t\t\tfn = tmp;\n\t\t}\n\n\t\t// Quick check to determine if target is callable, in the spec\n\t\t// this throws a TypeError, but we will just return undefined.\n\t\tif ( !jQuery.isFunction( fn ) ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// Simulated bind\n\t\targs = slice.call( arguments, 2 );\n\t\tproxy = function() {\n\t\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t\t};\n\n\t\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\t\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\t\treturn proxy;\n\t},\n\n\tnow: Date.now,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n});\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n\tvar length = obj.length,\n\t\ttype = jQuery.type( obj );\n\n\tif ( type === \"function\" || jQuery.isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\tif ( obj.nodeType === 1 && length ) {\n\t\treturn true;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.2.0-pre\n * http://sizzlejs.com/\n *\n * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2014-12-16\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t// http://www.w3.org/TR/css3-syntax/#characters\n\tcharacterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Loosely modeled on CSS identifier characters\n\t// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\t// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + characterEncoding + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar match, elem, m, nodeType,\n\t\t// QSA vars\n\t\ti, groups, old, nid, newContext, newSelector;\n\n\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\n\tcontext = context || document;\n\tresults = results || [];\n\tnodeType = context.nodeType;\n\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\tif ( !seed && documentIsHTML ) {\n\n\t\t// Try to shortcut find operations when possible (e.g., not under DocumentFragment)\n\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\t\t\t// Speed-up: Sizzle(\"#ID\")\n\t\t\tif ( (m = match[1]) ) {\n\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\telem = context.getElementById( m );\n\t\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t\t// nodes that are no longer in the document (jQuery #6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Handle the case where IE, Opera, and Webkit return items\n\t\t\t\t\t\t// by name instead of ID\n\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Context is not a document\n\t\t\t\t\tif ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n\t\t\t\t\t\tcontains( context, elem ) && elem.id === m ) {\n\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Speed-up: Sizzle(\"TAG\")\n\t\t\t} else if ( match[2] ) {\n\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\treturn results;\n\n\t\t\t// Speed-up: Sizzle(\".CLASS\")\n\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName ) {\n\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\treturn results;\n\t\t\t}\n\t\t}\n\n\t\t// QSA path\n\t\tif ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\t\t\tnid = old = expando;\n\t\t\tnewContext = context;\n\t\t\tnewSelector = nodeType !== 1 && selector;\n\n\t\t\t// qSA works strangely on Element-rooted queries\n\t\t\t// We can work around this by specifying an extra ID on the root\n\t\t\t// and working up from there (Thanks to Andrew Dupont for the technique)\n\t\t\t// IE 8 doesn't work on object elements\n\t\t\tif ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n\t\t\t\tgroups = tokenize( selector );\n\n\t\t\t\tif ( (old = context.getAttribute(\"id\")) ) {\n\t\t\t\t\tnid = old.replace( rescape, \"\\\\$&\" );\n\t\t\t\t} else {\n\t\t\t\t\tcontext.setAttribute( \"id\", nid );\n\t\t\t\t}\n\t\t\t\tnid = \"[id='\" + nid + \"'] \";\n\n\t\t\t\ti = groups.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tgroups[i] = nid + toSelector( groups[i] );\n\t\t\t\t}\n\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;\n\t\t\t\tnewSelector = groups.join(\",\");\n\t\t\t}\n\n\t\t\tif ( newSelector ) {\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch(qsaError) {\n\t\t\t\t} finally {\n\t\t\t\t\tif ( !old ) {\n\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = attrs.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// If no document and documentElement is available, return\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Set our document\n\tdocument = doc;\n\tdocElem = doc.documentElement;\n\tparent = doc.defaultView;\n\n\t// Support: IE>8\n\t// If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n\t// IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n\t// IE6-8 do not support the defaultView property so parent will be undefined\n\tif ( parent && parent !== parent.top ) {\n\t\t// IE11 does not have attachEvent, so all must suffer\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Support tests\n\t---------------------------------------------------------------------- */\n\tdocumentIsHTML = !isXML( doc );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( doc.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( doc.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\t// Check parentNode to catch when Blackberry 4.6 returns\n\t\t\t\t// nodes that are no longer in the document #6963\n\t\t\t\treturn m && m.parentNode ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\f]' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = doc.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully does not implement inclusive descendent\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === doc ? -1 :\n\t\t\t\tb === doc ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, outerCache, node, diff, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\touterCache = parent[ expando ] || (parent[ expando ] = {});\n\t\t\t\t\t\t\tcache = outerCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = cache[0] === dirruns && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\touterCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n\t\t\t\t\t\t\tdiff = cache[1];\n\n\t\t\t\t\t\t// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\tif ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\t\t\t\t\t\tif ( (oldCache = outerCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\touterCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context !== document && context;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\tmatchedCount += i;\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is no seed and only one group\n\tif ( match.length === 1 ) {\n\n\t\t// Take a shortcut and set the context if the root selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\trsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\nvar rsingleTag = (/^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/);\n\n\n\nvar risSimple = /^.[^:#\\[\\.,]*$/;\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( jQuery.isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\t/* jshint -W018 */\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t});\n\n\t}\n\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t});\n\n\t}\n\n\tif ( typeof qualifier === \"string\" ) {\n\t\tif ( risSimple.test( qualifier ) ) {\n\t\t\treturn jQuery.filter( qualifier, elements, not );\n\t\t}\n\n\t\tqualifier = jQuery.filter( qualifier, elements );\n\t}\n\n\treturn jQuery.grep( elements, function( elem ) {\n\t\treturn ( indexOf.call( qualifier, elem ) >= 0 ) !== not;\n\t});\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\treturn elems.length === 1 && elem.nodeType === 1 ?\n\t\tjQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n\t\tjQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\t\treturn elem.nodeType === 1;\n\t\t}));\n};\n\njQuery.fn.extend({\n\tfind: function( selector ) {\n\t\tvar i,\n\t\t\tlen = this.length,\n\t\t\tret = [],\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter(function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}) );\n\t\t}\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\t// Needed because $( selector, context ) becomes $( context ).find( selector )\n\t\tret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n\t\tret.selector = this.selector ? this.selector + \" \" + selector : selector;\n\t\treturn ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], false) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow(this, selector || [], true) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n});\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n\tinit = jQuery.fn.init = function( selector, context ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[0] === \"<\" && selector[ selector.length - 1 ] === \">\" && selector.length >= 3 ) {\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && (match[1] || !context) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[1] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[0] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( jQuery.isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[2] );\n\n\t\t\t\t\t// Support: Blackberry 4.6\n\t\t\t\t\t// gEBID returns nodes no longer in the document (#6963)\n\t\t\t\t\tif ( elem && elem.parentNode ) {\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t\tthis[0] = elem;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.context = document;\n\t\t\t\t\tthis.selector = selector;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || rootjQuery ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis.context = this[0] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( jQuery.isFunction( selector ) ) {\n\t\t\treturn typeof rootjQuery.ready !== \"undefined\" ?\n\t\t\t\trootjQuery.ready( selector ) :\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\tif ( selector.selector !== undefined ) {\n\t\t\tthis.selector = selector.selector;\n\t\t\tthis.context = selector.context;\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.extend({\n\tdir: function( elem, dir, until ) {\n\t\tvar matched = [],\n\t\t\ttruncate = until !== undefined;\n\n\t\twhile ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatched.push( elem );\n\t\t\t}\n\t\t}\n\t\treturn matched;\n\t},\n\n\tsibling: function( n, elem ) {\n\t\tvar matched = [];\n\n\t\tfor ( ; n; n = n.nextSibling ) {\n\t\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\t\tmatched.push( n );\n\t\t\t}\n\t\t}\n\n\t\treturn matched;\n\t}\n});\n\njQuery.fn.extend({\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter(function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[i] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\tpos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n\t\t\t\tjQuery( selectors, context || this.context ) :\n\t\t\t\t0;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tfor ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n\t\t\t\t// Always skip document fragments\n\t\t\t\tif ( cur.nodeType < 11 && (pos ?\n\t\t\t\t\tpos.index(cur) > -1 :\n\n\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\tjQuery.find.matchesSelector(cur, selectors)) ) {\n\n\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.unique(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter(selector)\n\t\t);\n\t}\n});\n\nfunction sibling( cur, dir ) {\n\twhile ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each({\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn jQuery.dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn jQuery.dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn jQuery.sibling( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\treturn elem.contentDocument || jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.unique( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n});\nvar rnotwhite = (/\\S+/g);\n\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n// The deferred used on DOM ready\nvar readyList;\n\njQuery.fn.ready = function( fn ) {\n\t// Add the callback\n\tjQuery.ready.promise().done( fn );\n\n\treturn this;\n};\n\njQuery.extend({\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Hold (or release) the ready event\n\tholdReady: function( hold ) {\n\t\tif ( hold ) {\n\t\t\tjQuery.readyWait++;\n\t\t} else {\n\t\t\tjQuery.ready( true );\n\t\t}\n\t},\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\n\t\t// Trigger any bound ready events\n\t\tif ( jQuery.fn.triggerHandler ) {\n\t\t\tjQuery( document ).triggerHandler( \"ready\" );\n\t\t\tjQuery( document ).off( \"ready\" );\n\t\t}\n\t}\n});\n\n/**\n * The ready event handler and self cleanup method\n */\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed, false );\n\twindow.removeEventListener( \"load\", completed, false );\n\tjQuery.ready();\n}\n\njQuery.ready.promise = function( obj ) {\n\tif ( !readyList ) {\n\n\t\treadyList = jQuery.Deferred();\n\n\t\t// Catch cases where $(document).ready() is called after the browser event has already occurred.\n\t\t// We once tried to use readyState \"interactive\" here, but it caused issues like the one\n\t\t// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n\t\tif ( document.readyState === \"complete\" ) {\n\t\t\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\t\t\tsetTimeout( jQuery.ready );\n\n\t\t} else {\n\n\t\t\t// Use the handy event callback\n\t\t\tdocument.addEventListener( \"DOMContentLoaded\", completed, false );\n\n\t\t\t// A fallback to window.onload, that will always work\n\t\t\twindow.addEventListener( \"load\", completed, false );\n\t\t}\n\t}\n\treturn readyList.promise( obj );\n};\n\n// Kick off the DOM ready check even if the user does not\njQuery.ready.promise();\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( jQuery.type( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\tjQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !jQuery.isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chainable ?\n\t\telems :\n\n\t\t// Gets\n\t\tbulk ?\n\t\t\tfn.call( elems ) :\n\t\t\tlen ? fn( elems[0], key ) : emptyGet;\n};\n\n\n/**\n * Determines whether an object can have data\n */\njQuery.acceptData = function( owner ) {\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\t/* jshint -W018 */\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\nfunction Data() {\n\t// Support: Android<4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android<4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\nvar data_priv = new Data();\n\nvar data_user = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /([A-Z])/g;\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = data === \"true\" ? true :\n\t\t\t\t\tdata === \"false\" ? false :\n\t\t\t\t\tdata === \"null\" ? null :\n\t\t\t\t\t// Only convert to a number if it doesn't change the string\n\t\t\t\t\t+data + \"\" === data ? +data :\n\t\t\t\t\trbrace.test( data ) ? jQuery.parseJSON( data ) :\n\t\t\t\t\tdata;\n\t\t\t} catch( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdata_user.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend({\n\thasData: function( elem ) {\n\t\treturn data_user.hasData( elem ) || data_priv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn data_user.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdata_user.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to data_priv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn data_priv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdata_priv.remove( elem, name );\n\t}\n});\n\njQuery.fn.extend({\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = data_user.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !data_priv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE11+\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = jQuery.camelCase( name.slice(5) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdata_priv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each(function() {\n\t\t\t\tdata_user.set( this, key );\n\t\t\t});\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data,\n\t\t\t\tcamelKey = jQuery.camelCase( key );\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key as-is\n\t\t\t\tdata = data_user.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// with the key camelized\n\t\t\t\tdata = data_user.get( elem, camelKey );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, camelKey, undefined );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each(function() {\n\t\t\t\t// First, attempt to store a copy or reference of any\n\t\t\t\t// data that might've been store with a camelCased key.\n\t\t\t\tvar data = data_user.get( this, camelKey );\n\n\t\t\t\t// For HTML5 data-* attribute interop, we have to\n\t\t\t\t// store property names with dashes in a camelCase form.\n\t\t\t\t// This might not apply to all properties...*\n\t\t\t\tdata_user.set( this, camelKey, value );\n\n\t\t\t\t// *... In the case of properties that might _actually_\n\t\t\t\t// have dashes, we need to also store a copy of that\n\t\t\t\t// unchanged property.\n\t\t\t\tif ( key.indexOf(\"-\") !== -1 && data !== undefined ) {\n\t\t\t\t\tdata_user.set( this, key, value );\n\t\t\t\t}\n\t\t\t});\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each(function() {\n\t\t\tdata_user.remove( this, key );\n\t\t});\n\t}\n});\n\n\njQuery.extend({\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = data_priv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || jQuery.isArray( data ) ) {\n\t\t\t\t\tqueue = data_priv.access( elem, type, jQuery.makeArray(data) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn data_priv.get( elem, key ) || data_priv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks(\"once memory\").add(function() {\n\t\t\t\tdata_priv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t})\n\t\t});\n\t}\n});\n\njQuery.fn.extend({\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[0], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each(function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t});\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t});\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = data_priv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n});\nvar pnum = (/[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/).source;\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHidden = function( elem, el ) {\n\t\t// isHidden might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\t\treturn jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n\t};\n\nvar rcheckableType = (/^(?:checkbox|radio)$/i);\n\n\n\n(function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Safari<=5.1\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Safari<=5.1, Android<4.2\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE<=11+\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n})();\nvar strundefined = typeof undefined;\n\n\n\nsupport.focusinBubbles = \"onfocusin\" in window;\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,\n\trfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !(events = elemData.events) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !(eventHandle = elemData.handle) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend({\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join(\".\")\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !(handlers = events[ type ]) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle, false );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = data_priv.hasData( elem ) && data_priv.get( elem );\n\n\t\tif ( !elemData || !(events = elemData.events) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnotwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[t] ) || [];\n\t\t\ttype = origType = tmp[1];\n\t\t\tnamespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdelete elemData.handle;\n\t\t\tdata_priv.remove( elem, \"events\" );\n\t\t}\n\t},\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n\t\tcur = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf(\".\") >= 0 ) {\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split(\".\");\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join(\".\");\n\t\tevent.namespace_re = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === (elem.ownerDocument || document) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( data_priv.get( cur, \"events\" ) || {} )[ event.type ] && data_priv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && jQuery.acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n\t\t\t\tjQuery.acceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\t\t\t\t\telem[ type ]();\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\tdispatch: function( event ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tevent = jQuery.event.fix( event );\n\n\t\tvar i, j, ret, matched, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\targs = slice.call( arguments ),\n\t\t\thandlers = ( data_priv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[0] = event;\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n\t\t\t\t\t\t\t.apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( (event.result = ret) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, matches, sel, handleObj,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\t// Black-hole SVG <use> instance trees (#13180)\n\t\t// Avoid non-left-click bubbling in Firefox (#3861)\n\t\tif ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.disabled !== true || event.type !== \"click\" ) {\n\t\t\t\t\tmatches = [];\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matches[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatches[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) >= 0 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matches[ sel ] ) {\n\t\t\t\t\t\t\tmatches.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matches.length ) {\n\t\t\t\t\t\thandlerQueue.push({ elem: cur, handlers: matches });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\t// Includes some event props shared by KeyEvent and MouseEvent\n\tprops: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n\tfixHooks: {},\n\n\tkeyHooks: {\n\t\tprops: \"char charCode key keyCode\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\n\t\t\t// Add which for key events\n\t\t\tif ( event.which == null ) {\n\t\t\t\tevent.which = original.charCode != null ? original.charCode : original.keyCode;\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tmouseHooks: {\n\t\tprops: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n\t\tfilter: function( event, original ) {\n\t\t\tvar eventDoc, doc, body,\n\t\t\t\tbutton = original.button;\n\n\t\t\t// Calculate pageX/Y if missing and clientX/Y available\n\t\t\tif ( event.pageX == null && original.clientX != null ) {\n\t\t\t\teventDoc = event.target.ownerDocument || document;\n\t\t\t\tdoc = eventDoc.documentElement;\n\t\t\t\tbody = eventDoc.body;\n\n\t\t\t\tevent.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n\t\t\t\tevent.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n\t\t\t}\n\n\t\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\t\t// Note: button is not normalized, so don't use it\n\t\t\tif ( !event.which && button !== undefined ) {\n\t\t\t\tevent.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n\t\t\t}\n\n\t\t\treturn event;\n\t\t}\n\t},\n\n\tfix: function( event ) {\n\t\tif ( event[ jQuery.expando ] ) {\n\t\t\treturn event;\n\t\t}\n\n\t\t// Create a writable copy of the event object and normalize some properties\n\t\tvar i, prop, copy,\n\t\t\ttype = event.type,\n\t\t\toriginalEvent = event,\n\t\t\tfixHook = this.fixHooks[ type ];\n\n\t\tif ( !fixHook ) {\n\t\t\tthis.fixHooks[ type ] = fixHook =\n\t\t\t\trmouseEvent.test( type ) ? this.mouseHooks :\n\t\t\t\trkeyEvent.test( type ) ? this.keyHooks :\n\t\t\t\t{};\n\t\t}\n\t\tcopy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n\t\tevent = new jQuery.Event( originalEvent );\n\n\t\ti = copy.length;\n\t\twhile ( i-- ) {\n\t\t\tprop = copy[ i ];\n\t\t\tevent[ prop ] = originalEvent[ prop ];\n\t\t}\n\n\t\t// Support: Cordova 2.5 (WebKit) (#13255)\n\t\t// All events should have a target; Cordova deviceready doesn't\n\t\tif ( !event.target ) {\n\t\t\tevent.target = document;\n\t\t}\n\n\t\t// Support: Safari 6.0+, Chrome<28\n\t\t// Target should not be a text node (#504, #13143)\n\t\tif ( event.target.nodeType === 3 ) {\n\t\t\tevent.target = event.target.parentNode;\n\t\t}\n\n\t\treturn fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n\t},\n\n\tspecial: {\n\t\tload: {\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && jQuery.nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn jQuery.nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsimulate: function( type, elem, event, bubble ) {\n\t\t// Piggyback on a donor event to simulate a different one.\n\t\t// Fake originalEvent to avoid donor's stopPropagation, but if the\n\t\t// simulated event prevents default then we do the same on the donor.\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true,\n\t\t\t\toriginalEvent: {}\n\t\t\t}\n\t\t);\n\t\tif ( bubble ) {\n\t\t\tjQuery.event.trigger( e, null, elem );\n\t\t} else {\n\t\t\tjQuery.event.dispatch.call( elem, e );\n\t\t}\n\t\tif ( e.isDefaultPrevented() ) {\n\t\t\tevent.preventDefault();\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle, false );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\t// Allow instantiation without the 'new' keyword\n\tif ( !(this instanceof jQuery.Event) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\t\t\t\t// Support: Android<4.0\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || jQuery.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && e.preventDefault ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopPropagation ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && e.stopImmediatePropagation ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// Support: Chrome 15+\njQuery.each({\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mousenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n});\n\n// Support: Firefox, Chrome, Safari\n// Create \"bubbling\" focus and blur events\nif ( !support.focusinBubbles ) {\n\tjQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n\t\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdata_priv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = data_priv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdata_priv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdata_priv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n}\n\njQuery.fn.extend({\n\n\ton: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n\t\tvar origFn, type;\n\n\t\t// Types can be a map of types/handlers\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-Object, selector, data )\n\t\t\tif ( typeof selector !== \"string\" ) {\n\t\t\t\t// ( types-Object, data )\n\t\t\t\tdata = data || selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.on( type, selector, data, types[ type ], one );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( data == null && fn == null ) {\n\t\t\t// ( types, fn )\n\t\t\tfn = selector;\n\t\t\tdata = selector = undefined;\n\t\t} else if ( fn == null ) {\n\t\t\tif ( typeof selector === \"string\" ) {\n\t\t\t\t// ( types, selector, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = undefined;\n\t\t\t} else {\n\t\t\t\t// ( types, data, fn )\n\t\t\t\tfn = data;\n\t\t\t\tdata = selector;\n\t\t\t\tselector = undefined;\n\t\t\t}\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t} else if ( !fn ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif ( one === 1 ) {\n\t\t\torigFn = fn;\n\t\t\tfn = function( event ) {\n\t\t\t\t// Can use an empty set, since event contains the info\n\t\t\t\tjQuery().off( event );\n\t\t\t\treturn origFn.apply( this, arguments );\n\t\t\t};\n\t\t\t// Use same guid so caller can remove using origFn\n\t\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.add( this, types, fn, data, selector );\n\t\t});\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn this.on( types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t});\n\t},\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t});\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[0];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n});\n\n\nvar\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\trtagName = /<([\\w:]+)/,\n\trhtml = /<|&#?\\w+;/,\n\trnoInnerhtml = /<(?:script|style|link)/i,\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trscriptType = /^$|\\/(?:java|ecma)script/i,\n\trscriptTypeMasked = /^true\\/(.*)/,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n\t// We have to close these tags to support XHTML (#13200)\n\twrapMap = {\n\n\t\t// Support: IE9\n\t\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t\tthead: [ 1, \"<table>\", \"</table>\" ],\n\t\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\t\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\t\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t\t_default: [ 0, \"\", \"\" ]\n\t};\n\n// Support: IE9\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: 1.x compatibility\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n\treturn jQuery.nodeName( elem, \"table\" ) &&\n\t\tjQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ?\n\n\t\telem.getElementsByTagName(\"tbody\")[0] ||\n\t\t\telem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n\t\telem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = (elem.getAttribute(\"type\") !== null) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tvar match = rscriptTypeMasked.exec( elem.type );\n\n\tif ( match ) {\n\t\telem.type = match[ 1 ];\n\t} else {\n\t\telem.removeAttribute(\"type\");\n\t}\n\n\treturn elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdata_priv.set(\n\t\t\telems[ i ], \"globalEval\", !refElements || data_priv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( data_priv.hasData( src ) ) {\n\t\tpdataOld = data_priv.access( src );\n\t\tpdataCur = data_priv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( data_user.hasData( src ) ) {\n\t\tudataOld = data_user.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdata_user.set( dest, udataCur );\n\t}\n}\n\nfunction getAll( context, tag ) {\n\tvar ret = context.getElementsByTagName ? context.getElementsByTagName( tag || \"*\" ) :\n\t\t\tcontext.querySelectorAll ? context.querySelectorAll( tag || \"*\" ) :\n\t\t\t[];\n\n\treturn tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n\t\tjQuery.merge( [ context ], ret ) :\n\t\tret;\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\njQuery.extend({\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tbuildFragment: function( elems, context, scripts, selection ) {\n\t\tvar elem, tmp, tag, wrap, contains, j,\n\t\t\tfragment = context.createDocumentFragment(),\n\t\t\tnodes = [],\n\t\t\ti = 0,\n\t\t\tl = elems.length;\n\n\t\tfor ( ; i < l; i++ ) {\n\t\t\telem = elems[ i ];\n\n\t\t\tif ( elem || elem === 0 ) {\n\n\t\t\t\t// Add nodes directly\n\t\t\t\tif ( jQuery.type( elem ) === \"object\" ) {\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t\t// Convert non-html into a text node\n\t\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t\t// Convert html into DOM nodes\n\t\t\t\t} else {\n\t\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement(\"div\") );\n\n\t\t\t\t\t// Deserialize a standard representation\n\t\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\t\ttmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[ 2 ];\n\n\t\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\t\tj = wrap[ 0 ];\n\t\t\t\t\twhile ( j-- ) {\n\t\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: QtWebKit, PhantomJS\n\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t\t// Remember the top-level container\n\t\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\t\ttmp.textContent = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove wrapper from fragment\n\t\tfragment.textContent = \"\";\n\n\t\ti = 0;\n\t\twhile ( (elem = nodes[ i++ ]) ) {\n\n\t\t\t// #4087 - If origin and destination elements are the same, and this is\n\t\t\t// that element, do not do anything\n\t\t\tif ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t\t// Append to fragment\n\t\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t\t// Preserve script evaluation history\n\t\t\tif ( contains ) {\n\t\t\t\tsetGlobalEval( tmp );\n\t\t\t}\n\n\t\t\t// Capture executables\n\t\t\tif ( scripts ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (elem = tmp[ j++ ]) ) {\n\t\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\t\tscripts.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn fragment;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type, key,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[ i ]) !== undefined; i++ ) {\n\t\t\tif ( jQuery.acceptData( elem ) ) {\n\t\t\t\tkey = elem[ data_priv.expando ];\n\n\t\t\t\tif ( key && (data = data_priv.cache[ key ]) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( data_priv.cache[ key ] ) {\n\t\t\t\t\t\t// Discard any remaining `private` data\n\t\t\t\t\t\tdelete data_priv.cache[ key ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Discard any remaining `user` data\n\t\t\tdelete data_user.cache[ elem[ data_user.expando ] ];\n\t\t}\n\t}\n});\n\njQuery.fn.extend({\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each(function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t});\n\t},\n\n\tprepend: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t});\n\t},\n\n\tbefore: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t});\n\t},\n\n\tafter: function() {\n\t\treturn this.domManip( arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t});\n\t},\n\n\tremove: function( selector, keepData /* Internal Use Only */ ) {\n\t\tvar elem,\n\t\t\telems = selector ? jQuery.filter( selector, this ) : this,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = elems[i]) != null; i++ ) {\n\t\t\tif ( !keepData && elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem ) );\n\t\t\t}\n\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\tif ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\t\t\tsetGlobalEval( getAll( elem, \"script\" ) );\n\t\t\t\t}\n\t\t\t\telem.parentNode.removeChild( elem );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; (elem = this[i]) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map(function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t});\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar arg = arguments[ 0 ];\n\n\t\t// Make the changes, replacing each context element with the new content\n\t\tthis.domManip( arguments, function( elem ) {\n\t\t\targ = this.parentNode;\n\n\t\t\tjQuery.cleanData( getAll( this ) );\n\n\t\t\tif ( arg ) {\n\t\t\t\targ.replaceChild( elem, this );\n\t\t\t}\n\t\t});\n\n\t\t// Force removal if there was no new content (e.g., from empty arguments)\n\t\treturn arg && (arg.length || arg.nodeType) ? this : this.remove();\n\t},\n\n\tdetach: function( selector ) {\n\t\treturn this.remove( selector, true );\n\t},\n\n\tdomManip: function( args, callback ) {\n\n\t\t// Flatten any nested arrays\n\t\targs = concat.apply( [], args );\n\n\t\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tset = this,\n\t\t\tiNoClone = l - 1,\n\t\t\tvalue = args[ 0 ],\n\t\t\tisFunction = jQuery.isFunction( value );\n\n\t\t// We can't cloneNode fragments that contain checked, in WebKit\n\t\tif ( isFunction ||\n\t\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\t\treturn this.each(function( index ) {\n\t\t\t\tvar self = set.eq( index );\n\t\t\t\tif ( isFunction ) {\n\t\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t\t}\n\t\t\t\tself.domManip( args, callback );\n\t\t\t});\n\t\t}\n\n\t\tif ( l ) {\n\t\t\tfragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );\n\t\t\tfirst = fragment.firstChild;\n\n\t\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\t\tfragment = first;\n\t\t\t}\n\n\t\t\tif ( first ) {\n\t\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\t\thasScripts = scripts.length;\n\n\t\t\t\t// Use the original fragment for the last item instead of the first because it can end up\n\t\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\tnode = fragment;\n\n\t\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\t\t\t// Support: QtWebKit\n\t\t\t\t\t\t\t// jQuery.merge because push.apply(_, arraylike) throws\n\t\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback.call( this[ i ], node, i );\n\t\t\t\t}\n\n\t\t\t\tif ( hasScripts ) {\n\t\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t\t// Reenable scripts\n\t\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t\t!data_priv.access( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\t\tif ( node.src ) {\n\t\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.globalEval( node.textContent.replace( rcleanScript, \"\" ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n});\n\njQuery.each({\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: QtWebKit\n\t\t\t// .get() because push.apply(_, arraylike) throws\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n});\n\n\nvar iframe,\n\telemdisplay = {};\n\n/**\n * Retrieve the actual display of a element\n * @param {String} name nodeName of the element\n * @param {Object} doc Document object\n */\n// Called only from within defaultDisplay\nfunction actualDisplay( name, doc ) {\n\tvar style,\n\t\telem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n\n\t\t// getDefaultComputedStyle might be reliably used only on attached element\n\t\tdisplay = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?\n\n\t\t\t// Use of this method is a temporary fix (more like optimization) until something better comes along,\n\t\t\t// since it was removed from specification and supported only in FF\n\t\t\tstyle.display : jQuery.css( elem[ 0 ], \"display\" );\n\n\t// We don't have any data stored on the element,\n\t// so use \"detach\" method as fast way to get rid of the element\n\telem.detach();\n\n\treturn display;\n}\n\n/**\n * Try to determine the default display value of an element\n * @param {String} nodeName\n */\nfunction defaultDisplay( nodeName ) {\n\tvar doc = document,\n\t\tdisplay = elemdisplay[ nodeName ];\n\n\tif ( !display ) {\n\t\tdisplay = actualDisplay( nodeName, doc );\n\n\t\t// If the simple way fails, read from inside an iframe\n\t\tif ( display === \"none\" || !display ) {\n\n\t\t\t// Use the already-created iframe if possible\n\t\t\tiframe = (iframe || jQuery( \"<iframe frameborder='0' width='0' height='0'/>\" )).appendTo( doc.documentElement );\n\n\t\t\t// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n\t\t\tdoc = iframe[ 0 ].contentDocument;\n\n\t\t\t// Support: IE\n\t\t\tdoc.write();\n\t\t\tdoc.close();\n\n\t\t\tdisplay = actualDisplay( nodeName, doc );\n\t\t\tiframe.detach();\n\t\t}\n\n\t\t// Store the correct default display\n\t\telemdisplay[ nodeName ] = display;\n\t}\n\n\treturn display;\n}\nvar rmargin = (/^margin/);\n\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\t\t// Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tif ( elem.ownerDocument.defaultView.opener ) {\n\t\t\treturn elem.ownerDocument.defaultView.getComputedStyle( elem, null );\n\t\t}\n\n\t\treturn window.getComputedStyle( elem, null );\n\t};\n\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// Support: IE9\n\t// getPropertyValue is only needed for .css('filter') (#12537)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\t}\n\n\tif ( computed ) {\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// Support: iOS < 6\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n\t\t// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n\t\tif ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\t\t// Support: IE\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn (this.get = hookFn).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\n(function() {\n\tvar pixelPositionVal, boxSizingReliableVal,\n\t\tdocElem = document.documentElement,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE9-11+\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tcontainer.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;\" +\n\t\t\"position:absolute\";\n\tcontainer.appendChild( div );\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computePixelPositionAndBoxSizingReliable() {\n\t\tdiv.style.cssText =\n\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t// Vendor-prefix box-sizing\n\t\t\t\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;\" +\n\t\t\t\"box-sizing:border-box;display:block;margin-top:1%;top:1%;\" +\n\t\t\t\"border:1px;padding:1px;width:4px;position:absolute\";\n\t\tdiv.innerHTML = \"\";\n\t\tdocElem.appendChild( container );\n\n\t\tvar divStyle = window.getComputedStyle( div, null );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\t\tboxSizingReliableVal = divStyle.width === \"4px\";\n\n\t\tdocElem.removeChild( container );\n\t}\n\n\t// Support: node.js jsdom\n\t// Don't assume that getComputedStyle is a property of the global object\n\tif ( window.getComputedStyle ) {\n\t\tjQuery.extend( support, {\n\t\t\tpixelPosition: function() {\n\n\t\t\t\t// This test is executed only once but we still do memoizing\n\t\t\t\t// since we can use the boxSizingReliable pre-computing.\n\t\t\t\t// No need to check if the test was already performed, though.\n\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\treturn pixelPositionVal;\n\t\t\t},\n\t\t\tboxSizingReliable: function() {\n\t\t\t\tif ( boxSizingReliableVal == null ) {\n\t\t\t\t\tcomputePixelPositionAndBoxSizingReliable();\n\t\t\t\t}\n\t\t\t\treturn boxSizingReliableVal;\n\t\t\t},\n\t\t\treliableMarginRight: function() {\n\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Check if div with explicit width and no margin-right incorrectly\n\t\t\t\t// gets computed margin-right based on width of container. (#3333)\n\t\t\t\t// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n\t\t\t\t// This support function is only executed once so no memoizing is needed.\n\t\t\t\tvar ret,\n\t\t\t\t\tmarginDiv = div.appendChild( document.createElement( \"div\" ) );\n\n\t\t\t\t// Reset CSS: box-sizing; display; margin; border; padding\n\t\t\t\tmarginDiv.style.cssText = div.style.cssText =\n\t\t\t\t\t// Support: Firefox<29, Android 2.3\n\t\t\t\t\t// Vendor-prefix box-sizing\n\t\t\t\t\t\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;\" +\n\t\t\t\t\t\"box-sizing:content-box;display:block;margin:0;border:0;padding:0\";\n\t\t\t\tmarginDiv.style.marginRight = marginDiv.style.width = \"0\";\n\t\t\t\tdiv.style.width = \"1px\";\n\t\t\t\tdocElem.appendChild( container );\n\n\t\t\t\tret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );\n\n\t\t\t\tdocElem.removeChild( container );\n\t\t\t\tdiv.removeChild( marginDiv );\n\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t});\n\t}\n})();\n\n\n// A method for quickly swapping in/out CSS properties to get correct calculations.\njQuery.swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar\n\t// Swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trnumsplit = new RegExp( \"^(\" + pnum + \")(.*)$\", \"i\" ),\n\trrelNum = new RegExp( \"^([+-])=(\" + pnum + \")\", \"i\" ),\n\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in style ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[0].toUpperCase() + name.slice(1),\n\t\torigName = name,\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in style ) {\n\t\t\treturn name;\n\t\t}\n\t}\n\n\treturn origName;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\tvar matches = rnumsplit.exec( value );\n\treturn matches ?\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n\tvar i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n\t\t// If we already have the right measurement, avoid augmentation\n\t\t4 :\n\t\t// Otherwise initialize for horizontal or vertical properties\n\t\tname === \"width\" ? 1 : 0,\n\n\t\tval = 0;\n\n\tfor ( ; i < 4; i += 2 ) {\n\t\t// Both box models exclude margin, so add it if we want it\n\t\tif ( extra === \"margin\" ) {\n\t\t\tval += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\tif ( isBorderBox ) {\n\t\t\t// border-box includes padding, so remove it if we want content\n\t\t\tif ( extra === \"content\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// At this point, extra isn't border nor margin, so remove border\n\t\t\tif ( extra !== \"margin\" ) {\n\t\t\t\tval -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t} else {\n\t\t\t// At this point, extra isn't content, so add padding\n\t\t\tval += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// At this point, extra isn't content nor padding, so add border\n\t\t\tif ( extra !== \"padding\" ) {\n\t\t\t\tval += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n\t// Start with offset property, which is equivalent to the border-box value\n\tvar valueIsBorderBox = true,\n\t\tval = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n\t\tstyles = getStyles( elem ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t// Some non-html elements return undefined for offsetWidth, so check for null/undefined\n\t// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n\t// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n\tif ( val <= 0 || val == null ) {\n\t\t// Fall back to computed then uncomputed css if necessary\n\t\tval = curCSS( elem, name, styles );\n\t\tif ( val < 0 || val == null ) {\n\t\t\tval = elem.style[ name ];\n\t\t}\n\n\t\t// Computed unit is not pixels. Stop here and return.\n\t\tif ( rnumnonpx.test(val) ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// Check for style in case a browser which returns unreliable values\n\t\t// for getComputedStyle silently falls back to the reliable elem.style\n\t\tvalueIsBorderBox = isBorderBox &&\n\t\t\t( support.boxSizingReliable() || val === elem.style[ name ] );\n\n\t\t// Normalize \"\", auto, and prepare for extra\n\t\tval = parseFloat( val ) || 0;\n\t}\n\n\t// Use the active box-sizing model to add/subtract irrelevant styles\n\treturn ( val +\n\t\taugmentWidthOrHeight(\n\t\t\telem,\n\t\t\tname,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles\n\t\t)\n\t) + \"px\";\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem, hidden,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalues[ index ] = data_priv.get( elem, \"olddisplay\" );\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\t\t\t// Reset the inline display of this element to learn if it is\n\t\t\t// being hidden by cascaded rules or not\n\t\t\tif ( !values[ index ] && display === \"none\" ) {\n\t\t\t\telem.style.display = \"\";\n\t\t\t}\n\n\t\t\t// Set elements which have been overridden with display: none\n\t\t\t// in a stylesheet to whatever the default browser style is\n\t\t\t// for such an element\n\t\t\tif ( elem.style.display === \"\" && isHidden( elem ) ) {\n\t\t\t\tvalues[ index ] = data_priv.access( elem, \"olddisplay\", defaultDisplay(elem.nodeName) );\n\t\t\t}\n\t\t} else {\n\t\t\thidden = isHidden( elem );\n\n\t\t\tif ( display !== \"none\" || !hidden ) {\n\t\t\t\tdata_priv.set( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of most of the elements in a second loop\n\t// to avoid the constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n\t\t\telem.style.display = show ? values[ index ] || \"\" : \"none\";\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.extend({\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {\n\t\t\"float\": \"cssFloat\"\n\t},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = jQuery.camelCase( name ),\n\t\t\tstyle = elem.style;\n\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n\t\t\t\tvalue = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number, add 'px' to the (except for certain CSS properties)\n\t\t\tif ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n\t\t\t\tvalue += \"px\";\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\t\t\t\tstyle[ name ] = value;\n\t\t\t}\n\n\t\t} else {\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = jQuery.camelCase( name );\n\n\t\t// Make sure that we're working with the right name\n\t\tname = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n\t\t}\n\t\treturn val;\n\t}\n});\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n\tjQuery.cssHooks[ name ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) && elem.offsetWidth === 0 ?\n\t\t\t\t\tjQuery.swap( elem, cssShow, function() {\n\t\t\t\t\t\treturn getWidthOrHeight( elem, name, extra );\n\t\t\t\t\t}) :\n\t\t\t\t\tgetWidthOrHeight( elem, name, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar styles = extra && getStyles( elem );\n\t\t\treturn setPositiveNumber( elem, value, extra ?\n\t\t\t\taugmentWidthOrHeight(\n\t\t\t\t\telem,\n\t\t\t\t\tname,\n\t\t\t\t\textra,\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\t\tstyles\n\t\t\t\t) : 0\n\t\t\t);\n\t\t}\n\t};\n});\n\n// Support: Android 2.3\njQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn jQuery.swap( elem, { \"display\": \"inline-block\" },\n\t\t\t\tcurCSS, [ elem, \"marginRight\" ] );\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each({\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( !rmargin.test( prefix ) ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n});\n\njQuery.fn.extend({\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( jQuery.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t},\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( isHidden( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t});\n\t}\n});\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || \"swing\";\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\tif ( tween.elem[ tween.prop ] != null &&\n\t\t\t\t(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE9\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t}\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, timerId,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trfxnum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" ),\n\trrun = /queueHooks$/,\n\tanimationPrefilters = [ defaultPrefilter ],\n\ttweeners = {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value ),\n\t\t\t\ttarget = tween.cur(),\n\t\t\t\tparts = rfxnum.exec( value ),\n\t\t\t\tunit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t\t\t// Starting value computation is required for potential unit mismatches\n\t\t\t\tstart = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n\t\t\t\t\trfxnum.exec( jQuery.css( tween.elem, prop ) ),\n\t\t\t\tscale = 1,\n\t\t\t\tmaxIterations = 20;\n\n\t\t\tif ( start && start[ 3 ] !== unit ) {\n\t\t\t\t// Trust units reported by jQuery.css\n\t\t\t\tunit = unit || start[ 3 ];\n\n\t\t\t\t// Make sure we update the tween properties later on\n\t\t\t\tparts = parts || [];\n\n\t\t\t\t// Iteratively approximate from a nonzero starting point\n\t\t\t\tstart = +target || 1;\n\n\t\t\t\tdo {\n\t\t\t\t\t// If previous iteration zeroed out, double until we get *something*.\n\t\t\t\t\t// Use string for doubling so we don't accidentally see scale as unchanged below\n\t\t\t\t\tscale = scale || \".5\";\n\n\t\t\t\t\t// Adjust and apply\n\t\t\t\t\tstart = start / scale;\n\t\t\t\t\tjQuery.style( tween.elem, prop, start + unit );\n\n\t\t\t\t// Update scale, tolerating zero or NaN from tween.cur(),\n\t\t\t\t// break the loop if scale is unchanged or perfect, or if we've just had enough\n\t\t\t\t} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n\t\t\t}\n\n\t\t\t// Update tween properties\n\t\t\tif ( parts ) {\n\t\t\t\tstart = tween.start = +start || +target || 0;\n\t\t\t\ttween.unit = unit;\n\t\t\t\t// If a +=/-= token was provided, we're doing a relative animation\n\t\t\t\ttween.end = parts[ 1 ] ?\n\t\t\t\t\tstart + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n\t\t\t\t\t+parts[ 2 ];\n\t\t\t}\n\n\t\t\treturn tween;\n\t\t} ]\n\t};\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\tsetTimeout(function() {\n\t\tfxNow = undefined;\n\t});\n\treturn ( fxNow = jQuery.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4 ; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\t/* jshint validthis: true */\n\tvar prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHidden( elem ),\n\t\tdataShow = data_priv.get( elem, \"fxshow\" );\n\n\t// Handle queue: false promises\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always(function() {\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always(function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t// Height/width overflow pass\n\tif ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n\t\t// Make sure that nothing sneaks out\n\t\t// Record all 3 overflow attributes because IE9-10 do not\n\t\t// change the overflow attribute when overflowX and\n\t\t// overflowY are set to the same value\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Set display property to inline-block for height/width\n\t\t// animations on inline elements that are having width/height animated\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\n\t\t// Test default display if display is currently \"none\"\n\t\tcheckDisplay = display === \"none\" ?\n\t\t\tdata_priv.get( elem, \"olddisplay\" ) || defaultDisplay( elem.nodeName ) : display;\n\n\t\tif ( checkDisplay === \"inline\" && jQuery.css( elem, \"float\" ) === \"none\" ) {\n\t\t\tstyle.display = \"inline-block\";\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always(function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t});\n\t}\n\n\t// show/hide pass\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.exec( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\n\t\t// Any non-fx value stops us from restoring the original display value\n\t\t} else {\n\t\t\tdisplay = undefined;\n\t\t}\n\t}\n\n\tif ( !jQuery.isEmptyObject( orig ) ) {\n\t\tif ( dataShow ) {\n\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\thidden = dataShow.hidden;\n\t\t\t}\n\t\t} else {\n\t\t\tdataShow = data_priv.access( elem, \"fxshow\", {} );\n\t\t}\n\n\t\t// Store state if its toggle - enables .stop().toggle() to \"reverse\"\n\t\tif ( toggle ) {\n\t\t\tdataShow.hidden = !hidden;\n\t\t}\n\t\tif ( hidden ) {\n\t\t\tjQuery( elem ).show();\n\t\t} else {\n\t\t\tanim.done(function() {\n\t\t\t\tjQuery( elem ).hide();\n\t\t\t});\n\t\t}\n\t\tanim.done(function() {\n\t\t\tvar prop;\n\n\t\t\tdata_priv.remove( elem, \"fxshow\" );\n\t\t\tfor ( prop in orig ) {\n\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t}\n\t\t});\n\t\tfor ( prop in orig ) {\n\t\t\ttween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n\t\t\tif ( !( prop in dataShow ) ) {\n\t\t\t\tdataShow[ prop ] = tween.start;\n\t\t\t\tif ( hidden ) {\n\t\t\t\t\ttween.end = tween.start;\n\t\t\t\t\ttween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t// If this is a noop like .hide().hide(), restore an overwritten display value\n\t} else if ( (display === \"none\" ? defaultDisplay( elem.nodeName ) : display) === \"inline\" ) {\n\t\tstyle.display = display;\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = jQuery.camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( jQuery.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = animationPrefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t}),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\t\t\t\t// Support: Android 2.3\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t} else {\n\t\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\tanimation = deferred.promise({\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, { specialEasing: {} }, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length ; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length ; index++ ) {\n\t\tresult = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( jQuery.isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t})\n\t);\n\n\t// attach callbacks from options\n\treturn animation.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweener: function( props, callback ) {\n\t\tif ( jQuery.isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.split(\" \");\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length ; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\ttweeners[ prop ] = tweeners[ prop ] || [];\n\t\t\ttweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tanimationPrefilters.unshift( callback );\n\t\t} else {\n\t\t\tanimationPrefilters.push( callback );\n\t\t}\n\t}\n});\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tjQuery.isFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n\t};\n\n\topt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n\t\topt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( jQuery.isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend({\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate({ opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || data_priv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = data_priv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t});\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each(function() {\n\t\t\tvar index,\n\t\t\t\tdata = data_priv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t});\n\t}\n});\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n});\n\n// Generate shortcuts for custom animations\njQuery.each({\n\tslideDown: genFx(\"show\"),\n\tslideUp: genFx(\"hide\"),\n\tslideToggle: genFx(\"toggle\"),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n});\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = jQuery.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\t\t// Checks the timer has not already been removed\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tif ( timer() ) {\n\t\tjQuery.fx.start();\n\t} else {\n\t\tjQuery.timers.pop();\n\t}\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n\tif ( !timerId ) {\n\t\ttimerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n\t}\n};\n\njQuery.fx.stop = function() {\n\tclearInterval( timerId );\n\ttimerId = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\tclearTimeout( timeout );\n\t\t};\n\t});\n};\n\n\n(function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: iOS<=5.1, Android<=4.2+\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE<=11+\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: Android<=2.3\n\t// Options inside disabled selects are incorrectly marked as disabled\n\tselect.disabled = true;\n\tsupport.optDisabled = !opt.disabled;\n\n\t// Support: IE<=11+\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n})();\n\n\nvar nodeHook, boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend({\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tattr: function( elem, name, value ) {\n\t\tvar hooks, ret,\n\t\t\tnType = elem.nodeType;\n\n\t\t// don't get/set attributes on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === strundefined ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// All attributes are lowercase\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\tname = name.toLowerCase();\n\t\t\thooks = jQuery.attrHooks[ name ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\n\t\t\t} else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n\t\t\t\treturn ret;\n\n\t\t\t} else {\n\t\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t} else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n\t\t\treturn ret;\n\n\t\t} else {\n\t\t\tret = jQuery.find.attr( elem, name );\n\n\t\t\t// Non-existent attributes return null, we normalize to undefined\n\t\t\treturn ret == null ?\n\t\t\t\tundefined :\n\t\t\t\tret;\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name, propName,\n\t\t\ti = 0,\n\t\t\tattrNames = value && value.match( rnotwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( (name = attrNames[i++]) ) {\n\t\t\t\tpropName = jQuery.propFix[ name ] || name;\n\n\t\t\t\t// Boolean attributes get special treatment (#10870)\n\t\t\t\tif ( jQuery.expr.match.bool.test( name ) ) {\n\t\t\t\t\t// Set corresponding property to false\n\t\t\t\t\telem[ propName ] = false;\n\t\t\t\t}\n\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tjQuery.nodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle;\n\t\tif ( !isXML ) {\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ name ];\n\t\t\tattrHandle[ name ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tname.toLowerCase() :\n\t\t\t\tnull;\n\t\t\tattrHandle[ name ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n});\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i;\n\njQuery.fn.extend({\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each(function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t},\n\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks, notxml,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tnotxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n\t\tif ( notxml ) {\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\treturn hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n\t\t\t\tret :\n\t\t\t\t( elem[ name ] = value );\n\n\t\t} else {\n\t\t\treturn hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n\t\t\t\tret :\n\t\t\t\telem[ name ];\n\t\t}\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\t\t\t\treturn elem.hasAttribute( \"tabindex\" ) || rfocusable.test( elem.nodeName ) || elem.href ?\n\t\t\t\t\telem.tabIndex :\n\t\t\t\t\t-1;\n\t\t\t}\n\t\t}\n\t}\n});\n\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t};\n}\n\njQuery.each([\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n\n\n\nvar rclass = /[\\t\\r\\n\\f]/g;\n\njQuery.fn.extend({\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\n\t\tif ( proceed ) {\n\t\t\t// The disjunction here is for better compressibility (see removeClass)\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\" \"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = jQuery.trim( cur );\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, clazz, j, finalValue,\n\t\t\tproceed = arguments.length === 0 || typeof value === \"string\" && value,\n\t\t\ti = 0,\n\t\t\tlen = this.length;\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, this.className ) );\n\t\t\t});\n\t\t}\n\t\tif ( proceed ) {\n\t\t\tclasses = ( value || \"\" ).match( rnotwhite ) || [];\n\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\telem = this[ i ];\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( elem.className ?\n\t\t\t\t\t( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n\t\t\t\t\t\"\"\n\t\t\t\t);\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( (clazz = classes[j++]) ) {\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = value ? jQuery.trim( cur ) : \"\";\n\t\t\t\t\tif ( elem.className !== finalValue ) {\n\t\t\t\t\t\telem.className = finalValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value;\n\n\t\tif ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( jQuery.isFunction( value ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tif ( type === \"string\" ) {\n\t\t\t\t// Toggle individual class names\n\t\t\t\tvar className,\n\t\t\t\t\ti = 0,\n\t\t\t\t\tself = jQuery( this ),\n\t\t\t\t\tclassNames = value.match( rnotwhite ) || [];\n\n\t\t\t\twhile ( (className = classNames[ i++ ]) ) {\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( type === strundefined || type === \"boolean\" ) {\n\t\t\t\tif ( this.className ) {\n\t\t\t\t\t// store className if set\n\t\t\t\t\tdata_priv.set( this, \"__className__\", this.className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tthis.className = this.className || value === false ? \"\" : data_priv.get( this, \"__className__\" ) || \"\";\n\t\t\t}\n\t\t});\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className = \" \" + selector + \" \",\n\t\t\ti = 0,\n\t\t\tl = this.length;\n\t\tfor ( ; i < l; i++ ) {\n\t\t\tif ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n});\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend({\n\tval: function( value ) {\n\t\tvar hooks, ret, isFunction,\n\t\t\telem = this[0];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\treturn typeof ret === \"string\" ?\n\t\t\t\t\t// Handle most common string cases\n\t\t\t\t\tret.replace(rreturn, \"\") :\n\t\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\t\tret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tisFunction = jQuery.isFunction( value );\n\n\t\treturn this.each(function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( isFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( jQuery.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t});\n\t}\n});\n\njQuery.extend({\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\t\t\t\t\t// Support: IE10-11+\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\tjQuery.trim( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\" || index < 0,\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length,\n\t\t\t\t\ti = index < 0 ?\n\t\t\t\t\t\tmax :\n\t\t\t\t\t\tone ? index : 0;\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// IE6-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t( support.optDisabled ? !option.disabled : option.getAttribute( \"disabled\" ) === null ) &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\t\t\t\t\tif ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n});\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( jQuery.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n\t\t};\n\t}\n});\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n});\n\njQuery.fn.extend({\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t},\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n\t}\n});\n\n\nvar nonce = jQuery.now();\n\nvar rquery = (/\\?/);\n\n\n\n// Support: Android 2.3\n// Workaround failure to string-cast null input\njQuery.parseJSON = function( data ) {\n\treturn JSON.parse( data + \"\" );\n};\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml, tmp;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE9\n\ttry {\n\t\ttmp = new DOMParser();\n\t\txml = tmp.parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax({\n\t\turl: url,\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t});\n};\n\n\njQuery.fn.extend({\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapAll( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\tif ( this[ 0 ] ) {\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map(function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t}).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( jQuery.isFunction( html ) ) {\n\t\t\treturn this.each(function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call(this, i) );\n\t\t\t});\n\t\t}\n\n\t\treturn this.each(function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t});\n\t},\n\n\twrap: function( html ) {\n\t\tvar isFunction = jQuery.isFunction( html );\n\n\t\treturn this.each(function( i ) {\n\t\t\tjQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n\t\t});\n\t},\n\n\tunwrap: function() {\n\t\treturn this.parent().each(function() {\n\t\t\tif ( !jQuery.nodeName( this, \"body\" ) ) {\n\t\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t\t}\n\t\t}).end();\n\t}\n});\n\n\njQuery.expr.filters.hidden = function( elem ) {\n\t// Support: Opera <= 12.12\n\t// Opera reports offsetWidths and offsetHeights less than zero on some elements\n\treturn elem.offsetWidth <= 0 && elem.offsetHeight <= 0;\n};\njQuery.expr.filters.visible = function( elem ) {\n\treturn !jQuery.expr.filters.hidden( elem );\n};\n\n\n\n\nvar r20 = /%20/g,\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( jQuery.isArray( obj ) ) {\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n\t\t\t}\n\t\t});\n\n\t} else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, value ) {\n\t\t\t// If value is a function, invoke it and return its value\n\t\t\tvalue = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n\t\t};\n\n\t// Set traditional to true for jQuery <= 1.3.2 behavior.\n\tif ( traditional === undefined ) {\n\t\ttraditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t});\n\n\t} else {\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" ).replace( r20, \"+\" );\n};\n\njQuery.fn.extend({\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map(function() {\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t})\n\t\t.filter(function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t})\n\t\t.map(function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\treturn val == null ?\n\t\t\t\tnull :\n\t\t\t\tjQuery.isArray( val ) ?\n\t\t\t\t\tjQuery.map( val, function( val ) {\n\t\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t\t}) :\n\t\t\t\t\t{ name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t}).get();\n\t}\n});\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new XMLHttpRequest();\n\t} catch( e ) {}\n};\n\nvar xhrId = 0,\n\txhrCallbacks = {},\n\txhrSuccessStatus = {\n\t\t// file protocol always yields status code 0, assume 200\n\t\t0: 200,\n\t\t// Support: IE9\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\n// Support: IE9\n// Open requests must be manually aborted on unload (#5280)\n// See https://support.microsoft.com/kb/2856746 for more info\nif ( window.attachEvent ) {\n\twindow.attachEvent( \"onunload\", function() {\n\t\tfor ( var key in xhrCallbacks ) {\n\t\t\txhrCallbacks[ key ]();\n\t\t}\n\t});\n}\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport(function( options ) {\n\tvar callback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr(),\n\t\t\t\t\tid = ++xhrId;\n\n\t\t\t\txhr.open( options.type, options.url, options.async, options.username, options.password );\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[\"X-Requested-With\"] ) {\n\t\t\t\t\theaders[\"X-Requested-With\"] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tdelete xhrCallbacks[ id ];\n\t\t\t\t\t\t\tcallback = xhr.onload = xhr.onerror = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\t// file: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\t\t\t\t\t\t\t\t\t// Support: IE9\n\t\t\t\t\t\t\t\t\t// Accessing binary-data responseText throws an exception\n\t\t\t\t\t\t\t\t\t// (#11426)\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText === \"string\" ? {\n\t\t\t\t\t\t\t\t\t\ttext: xhr.responseText\n\t\t\t\t\t\t\t\t\t} : undefined,\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\txhr.onerror = callback(\"error\");\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = xhrCallbacks[ id ] = callback(\"abort\");\n\n\t\t\t\ttry {\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\n// Install script dataType\njQuery.ajaxSetup({\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /(?:java|ecma)script/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n});\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery(\"<script>\").prop({\n\t\t\t\t\tasync: true,\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t}).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n});\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[\"script json\"] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always(function() {\n\t\t\t// Restore preexisting value\n\t\t\twindow[ callbackName ] = overwritten;\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\t\t\t\t// make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && jQuery.isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t});\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n});\n\n\n\n\n// data: string of html\n// context (optional): If specified, the fragment will be created in this context, defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\tcontext = context || document;\n\n\tvar parsed = rsingleTag.exec( data ),\n\t\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[1] ) ];\n\t}\n\n\tparsed = jQuery.buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n// Keep a copy of the old load method\nvar _load = jQuery.fn.load;\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tif ( typeof url !== \"string\" && _load ) {\n\t\treturn _load.apply( this, arguments );\n\t}\n\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf(\" \");\n\n\tif ( off >= 0 ) {\n\t\tselector = jQuery.trim( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( jQuery.isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax({\n\t\t\turl: url,\n\n\t\t\t// if \"type\" variable is undefined, then \"GET\" method will be used\n\t\t\ttype: type,\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t}).done(function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t}).complete( callback && function( jqXHR, status ) {\n\t\t\tself.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t});\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n});\n\n\n\n\njQuery.expr.filters.animated = function( elem ) {\n\treturn jQuery.grep(jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t}).length;\n};\n\n\n\n\nvar docElem = window.document.documentElement;\n\n/**\n * Gets a window from an element\n */\nfunction getWindow( elem ) {\n\treturn jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;\n}\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf(\"auto\") > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( jQuery.isFunction( options ) ) {\n\t\t\toptions = options.call( elem, i, curOffset );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend({\n\toffset: function( options ) {\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each(function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t});\n\t\t}\n\n\t\tvar docElem, win,\n\t\t\telem = this[ 0 ],\n\t\t\tbox = { top: 0, left: 0 },\n\t\t\tdoc = elem && elem.ownerDocument;\n\n\t\tif ( !doc ) {\n\t\t\treturn;\n\t\t}\n\n\t\tdocElem = doc.documentElement;\n\n\t\t// Make sure it's not a disconnected DOM node\n\t\tif ( !jQuery.contains( docElem, elem ) ) {\n\t\t\treturn box;\n\t\t}\n\n\t\t// Support: BlackBerry 5, iOS 3 (original iPhone)\n\t\t// If we don't have gBCR, just use 0,0 rather than error\n\t\tif ( typeof elem.getBoundingClientRect !== strundefined ) {\n\t\t\tbox = elem.getBoundingClientRect();\n\t\t}\n\t\twin = getWindow( doc );\n\t\treturn {\n\t\t\ttop: box.top + win.pageYOffset - docElem.clientTop,\n\t\t\tleft: box.left + win.pageXOffset - docElem.clientLeft\n\t\t};\n\t},\n\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\t\t\t// Assume getBoundingClientRect is there when computed position is fixed\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\t// Get *real* offsetParent\n\t\t\toffsetParent = this.offsetParent();\n\n\t\t\t// Get correct offsets\n\t\t\toffset = this.offset();\n\t\t\tif ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n\t\t\t\tparentOffset = offsetParent.offset();\n\t\t\t}\n\n\t\t\t// Add offsetParent borders\n\t\t\tparentOffset.top += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n\t\t\tparentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\toffsetParent: function() {\n\t\treturn this.map(function() {\n\t\t\tvar offsetParent = this.offsetParent || docElem;\n\n\t\t\twhile ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\" ) === \"static\" ) ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || docElem;\n\t\t});\n\t}\n});\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\t\t\tvar win = getWindow( elem );\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : window.pageXOffset,\n\t\t\t\t\ttop ? val : window.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length, null );\n\t};\n});\n\n// Support: Safari<7+, Chrome<37+\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n});\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( jQuery.isWindow( elem ) ) {\n\t\t\t\t\t// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n\t\t\t\t\t// isn't a whole lot we can do. See pull request at this URL for discussion:\n\t\t\t\t\t// https://github.com/jquery/jquery/pull/764\n\t\t\t\t\treturn elem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable, null );\n\t\t};\n\t});\n});\n\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n\treturn this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\treturn jQuery;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === strundefined ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jquery/dist/jquery.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/jquery/dist/jquery.js?");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventConstants\n */\n\n\"use strict\";\n\nvar keyMirror = __webpack_require__(126);\n\nvar PropagationPhases = keyMirror({bubbled: null, captured: null});\n\n/**\n * Types of raw signals from the browser caught at the top level.\n */\nvar topLevelTypes = keyMirror({\n  topBlur: null,\n  topChange: null,\n  topClick: null,\n  topCompositionEnd: null,\n  topCompositionStart: null,\n  topCompositionUpdate: null,\n  topContextMenu: null,\n  topCopy: null,\n  topCut: null,\n  topDoubleClick: null,\n  topDrag: null,\n  topDragEnd: null,\n  topDragEnter: null,\n  topDragExit: null,\n  topDragLeave: null,\n  topDragOver: null,\n  topDragStart: null,\n  topDrop: null,\n  topError: null,\n  topFocus: null,\n  topInput: null,\n  topKeyDown: null,\n  topKeyPress: null,\n  topKeyUp: null,\n  topLoad: null,\n  topMouseDown: null,\n  topMouseMove: null,\n  topMouseOut: null,\n  topMouseOver: null,\n  topMouseUp: null,\n  topPaste: null,\n  topReset: null,\n  topScroll: null,\n  topSelectionChange: null,\n  topSubmit: null,\n  topTextInput: null,\n  topTouchCancel: null,\n  topTouchEnd: null,\n  topTouchMove: null,\n  topTouchStart: null,\n  topWheel: null\n});\n\nvar EventConstants = {\n  topLevelTypes: topLevelTypes,\n  PropagationPhases: PropagationPhases\n};\n\nmodule.exports = EventConstants;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventConstants.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventConstants.js?");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginHub\n */\n\n\"use strict\";\n\nvar EventPluginRegistry = __webpack_require__(48);\nvar EventPluginUtils = __webpack_require__(62);\n\nvar accumulateInto = __webpack_require__(127);\nvar forEachAccumulated = __webpack_require__(128);\nvar invariant = __webpack_require__(36);\n\n/**\n * Internal store for event listeners\n */\nvar listenerBank = {};\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @private\n */\nvar executeDispatchesAndRelease = function(event) {\n  if (event) {\n    var executeDispatch = EventPluginUtils.executeDispatch;\n    // Plugins can provide custom behavior when dispatching events.\n    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);\n    if (PluginModule && PluginModule.executeDispatch) {\n      executeDispatch = PluginModule.executeDispatch;\n    }\n    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\n\n/**\n * - `InstanceHandle`: [required] Module that performs logical traversals of DOM\n *   hierarchy given ids of the logical DOM elements involved.\n */\nvar InstanceHandle = null;\n\nfunction validateInstanceHandle() {\n  var invalid = !InstanceHandle||\n    !InstanceHandle.traverseTwoPhase ||\n    !InstanceHandle.traverseEnterLeave;\n  if (invalid) {\n    throw new Error('InstanceHandle not injected before use!');\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\nvar EventPluginHub = {\n\n  /**\n   * Methods for injecting dependencies.\n   */\n  injection: {\n\n    /**\n     * @param {object} InjectedMount\n     * @public\n     */\n    injectMount: EventPluginUtils.injection.injectMount,\n\n    /**\n     * @param {object} InjectedInstanceHandle\n     * @public\n     */\n    injectInstanceHandle: function(InjectedInstanceHandle) {\n      InstanceHandle = InjectedInstanceHandle;\n      if (\"production\" !== process.env.NODE_ENV) {\n        validateInstanceHandle();\n      }\n    },\n\n    getInstanceHandle: function() {\n      if (\"production\" !== process.env.NODE_ENV) {\n        validateInstanceHandle();\n      }\n      return InstanceHandle;\n    },\n\n    /**\n     * @param {array} InjectedEventPluginOrder\n     * @public\n     */\n    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,\n\n    /**\n     * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n     */\n    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName\n\n  },\n\n  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,\n\n  registrationNameModules: EventPluginRegistry.registrationNameModules,\n\n  /**\n   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.\n   *\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @param {?function} listener The callback to store.\n   */\n  putListener: function(id, registrationName, listener) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !listener || typeof listener === 'function',\n      'Expected %s listener to be a function, instead got type %s',\n      registrationName, typeof listener\n    ) : invariant(!listener || typeof listener === 'function'));\n\n    var bankForRegistrationName =\n      listenerBank[registrationName] || (listenerBank[registrationName] = {});\n    bankForRegistrationName[id] = listener;\n  },\n\n  /**\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   * @return {?function} The stored callback.\n   */\n  getListener: function(id, registrationName) {\n    var bankForRegistrationName = listenerBank[registrationName];\n    return bankForRegistrationName && bankForRegistrationName[id];\n  },\n\n  /**\n   * Deletes a listener from the registration bank.\n   *\n   * @param {string} id ID of the DOM element.\n   * @param {string} registrationName Name of listener (e.g. `onClick`).\n   */\n  deleteListener: function(id, registrationName) {\n    var bankForRegistrationName = listenerBank[registrationName];\n    if (bankForRegistrationName) {\n      delete bankForRegistrationName[id];\n    }\n  },\n\n  /**\n   * Deletes all listeners for the DOM element with the supplied ID.\n   *\n   * @param {string} id ID of the DOM element.\n   */\n  deleteAllListeners: function(id) {\n    for (var registrationName in listenerBank) {\n      delete listenerBank[registrationName][id];\n    }\n  },\n\n  /**\n   * Allows registered plugins an opportunity to extract events from top-level\n   * native browser events.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @internal\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var events;\n    var plugins = EventPluginRegistry.plugins;\n    for (var i = 0, l = plugins.length; i < l; i++) {\n      // Not every plugin in the ordering may be loaded at runtime.\n      var possiblePlugin = plugins[i];\n      if (possiblePlugin) {\n        var extractedEvents = possiblePlugin.extractEvents(\n          topLevelType,\n          topLevelTarget,\n          topLevelTargetID,\n          nativeEvent\n        );\n        if (extractedEvents) {\n          events = accumulateInto(events, extractedEvents);\n        }\n      }\n    }\n    return events;\n  },\n\n  /**\n   * Enqueues a synthetic event that should be dispatched when\n   * `processEventQueue` is invoked.\n   *\n   * @param {*} events An accumulation of synthetic events.\n   * @internal\n   */\n  enqueueEvents: function(events) {\n    if (events) {\n      eventQueue = accumulateInto(eventQueue, events);\n    }\n  },\n\n  /**\n   * Dispatches all synthetic events on the event queue.\n   *\n   * @internal\n   */\n  processEventQueue: function() {\n    // Set `eventQueue` to null before processing it so that we can tell if more\n    // events get enqueued while processing.\n    var processingEventQueue = eventQueue;\n    eventQueue = null;\n    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !eventQueue,\n      'processEventQueue(): Additional events were enqueued while processing ' +\n      'an event queue. Support for this has not yet been implemented.'\n    ) : invariant(!eventQueue));\n  },\n\n  /**\n   * These are needed for tests only. Do not use!\n   */\n  __purge: function() {\n    listenerBank = {};\n  },\n\n  __getListenerBank: function() {\n    return listenerBank;\n  }\n\n};\n\nmodule.exports = EventPluginHub;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginHub.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginHub.js?");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginRegistry\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Injectable ordering of event plugins.\n */\nvar EventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!EventPluginOrder) {\n    // Wait until an `EventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var PluginModule = namesToPlugins[pluginName];\n    var pluginIndex = EventPluginOrder.indexOf(pluginName);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      pluginIndex > -1,\n      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +\n      'the plugin ordering, `%s`.',\n      pluginName\n    ) : invariant(pluginIndex > -1));\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      PluginModule.extractEvents,\n      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +\n      'method, but `%s` does not.',\n      pluginName\n    ) : invariant(PluginModule.extractEvents));\n    EventPluginRegistry.plugins[pluginIndex] = PluginModule;\n    var publishedEvents = PluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        publishEventForPlugin(\n          publishedEvents[eventName],\n          PluginModule,\n          eventName\n        ),\n        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',\n        eventName,\n        pluginName\n      ) : invariant(publishEventForPlugin(\n        publishedEvents[eventName],\n        PluginModule,\n        eventName\n      )));\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, PluginModule, eventName) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),\n    'EventPluginHub: More than one plugin attempted to publish the same ' +\n    'event name, `%s`.',\n    eventName\n  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(\n          phasedRegistrationName,\n          PluginModule,\n          eventName\n        );\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(\n      dispatchConfig.registrationName,\n      PluginModule,\n      eventName\n    );\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events and\n * can be used with `EventPluginHub.putListener` to register listeners.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, PluginModule, eventName) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !EventPluginRegistry.registrationNameModules[registrationName],\n    'EventPluginHub: More than one plugin attempted to publish the same ' +\n    'registration name, `%s`.',\n    registrationName\n  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));\n  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] =\n    PluginModule.eventTypes[eventName].dependencies;\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function(InjectedEventPluginOrder) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !EventPluginOrder,\n      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +\n      'once. You are likely trying to load more than one copy of React.'\n    ) : invariant(!EventPluginOrder));\n    // Clone the ordering so it cannot be dynamically mutated.\n    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function(injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var PluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) ||\n          namesToPlugins[pluginName] !== PluginModule) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !namesToPlugins[pluginName],\n          'EventPluginRegistry: Cannot inject two different event plugins ' +\n          'using the same name, `%s`.',\n          pluginName\n        ) : invariant(!namesToPlugins[pluginName]));\n        namesToPlugins[pluginName] = PluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  },\n\n  /**\n   * Looks up the plugin for the supplied event.\n   *\n   * @param {object} event A synthetic event.\n   * @return {?object} The plugin that created the supplied event.\n   * @internal\n   */\n  getPluginModuleForEvent: function(event) {\n    var dispatchConfig = event.dispatchConfig;\n    if (dispatchConfig.registrationName) {\n      return EventPluginRegistry.registrationNameModules[\n        dispatchConfig.registrationName\n      ] || null;\n    }\n    for (var phase in dispatchConfig.phasedRegistrationNames) {\n      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {\n        continue;\n      }\n      var PluginModule = EventPluginRegistry.registrationNameModules[\n        dispatchConfig.phasedRegistrationNames[phase]\n      ];\n      if (PluginModule) {\n        return PluginModule;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _resetEventPlugins: function() {\n    EventPluginOrder = null;\n    for (var pluginName in namesToPlugins) {\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\n        delete namesToPlugins[pluginName];\n      }\n    }\n    EventPluginRegistry.plugins.length = 0;\n\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\n    for (var eventName in eventNameDispatchConfigs) {\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\n        delete eventNameDispatchConfigs[eventName];\n      }\n    }\n\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\n    for (var registrationName in registrationNameModules) {\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\n        delete registrationNameModules[registrationName];\n      }\n    }\n  }\n\n};\n\nmodule.exports = EventPluginRegistry;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginRegistry.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginRegistry.js?");

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventEmitterMixin\n */\n\n\"use strict\";\n\nvar EventPluginHub = __webpack_require__(47);\n\nfunction runEventQueueInBatch(events) {\n  EventPluginHub.enqueueEvents(events);\n  EventPluginHub.processEventQueue();\n}\n\nvar ReactEventEmitterMixin = {\n\n  /**\n   * Streams a fired top-level event to `EventPluginHub` where plugins have the\n   * opportunity to create `ReactEvent`s to be dispatched.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {object} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native environment event.\n   */\n  handleTopLevel: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var events = EventPluginHub.extractEvents(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent\n    );\n\n    runEventQueueInBatch(events);\n  }\n};\n\nmodule.exports = ReactEventEmitterMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEventEmitterMixin.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEventEmitterMixin.js?");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ViewportMetrics\n */\n\n\"use strict\";\n\nvar getUnboundedScrollPosition = __webpack_require__(129);\n\nvar ViewportMetrics = {\n\n  currentScrollLeft: 0,\n\n  currentScrollTop: 0,\n\n  refreshScrollValues: function() {\n    var scrollPosition = getUnboundedScrollPosition(window);\n    ViewportMetrics.currentScrollLeft = scrollPosition.x;\n    ViewportMetrics.currentScrollTop = scrollPosition.y;\n  }\n\n};\n\nmodule.exports = ViewportMetrics;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ViewportMetrics.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ViewportMetrics.js?");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Object.assign\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n};\n\nmodule.exports = assign;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Object.assign.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Object.assign.js?");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isEventSupported\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar useHasFeature;\nif (ExecutionEnvironment.canUseDOM) {\n  useHasFeature =\n    document.implementation &&\n    document.implementation.hasFeature &&\n    // always returns true in newer browsers as per the standard.\n    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n    document.implementation.hasFeature('', '') !== true;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @param {?boolean} capture Check if the capture phase is supported.\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix, capture) {\n  if (!ExecutionEnvironment.canUseDOM ||\n      capture && !('addEventListener' in document)) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n\n  return isSupported;\n}\n\nmodule.exports = isEventSupported;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isEventSupported.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isEventSupported.js?");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactContext\n */\n\n\"use strict\";\n\nvar assign = __webpack_require__(51);\n\n/**\n * Keeps track of the current context.\n *\n * The context is automatically passed down the component ownership hierarchy\n * and is accessible via `this.context` on ReactCompositeComponents.\n */\nvar ReactContext = {\n\n  /**\n   * @internal\n   * @type {object}\n   */\n  current: {},\n\n  /**\n   * Temporarily extends the current context while executing scopedCallback.\n   *\n   * A typical use case might look like\n   *\n   *  render: function() {\n   *    var children = ReactContext.withContext({foo: 'foo'}, () => (\n   *\n   *    ));\n   *    return <div>{children}</div>;\n   *  }\n   *\n   * @param {object} newContext New context to merge into the existing context\n   * @param {function} scopedCallback Callback to run with the new context\n   * @return {ReactComponent|array<ReactComponent>}\n   */\n  withContext: function(newContext, scopedCallback) {\n    var result;\n    var previousContext = ReactContext.current;\n    ReactContext.current = assign({}, previousContext, newContext);\n    try {\n      result = scopedCallback();\n    } finally {\n      ReactContext.current = previousContext;\n    }\n    return result;\n  }\n\n};\n\nmodule.exports = ReactContext;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactContext.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactContext.js?");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule monitorCodeUse\n */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Provides open-source compatible instrumentation for monitoring certain API\n * uses before we're ready to issue a warning or refactor. It accepts an event\n * name which may only contain the characters [a-z0-9_] and an optional data\n * object with further information.\n */\n\nfunction monitorCodeUse(eventName, data) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    eventName && !/[^a-z0-9_]/.test(eventName),\n    'You must provide an eventName using only the characters [a-z0-9_]'\n  ) : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));\n}\n\nmodule.exports = monitorCodeUse;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/monitorCodeUse.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/monitorCodeUse.js?");

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactRootIndex\n * @typechecks\n */\n\n\"use strict\";\n\nvar ReactRootIndexInjection = {\n  /**\n   * @param {function} _createReactRootIndex\n   */\n  injectCreateReactRootIndex: function(_createReactRootIndex) {\n    ReactRootIndex.createReactRootIndex = _createReactRootIndex;\n  }\n};\n\nvar ReactRootIndex = {\n  createReactRootIndex: null,\n  injection: ReactRootIndexInjection\n};\n\nmodule.exports = ReactRootIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactRootIndex.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactRootIndex.js?");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isTextNode\n * @typechecks\n */\n\nvar isNode = __webpack_require__(130);\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM text node.\n */\nfunction isTextNode(object) {\n  return isNode(object) && object.nodeType == 3;\n}\n\nmodule.exports = isTextNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isTextNode.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isTextNode.js?");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactNativeComponent\n */\n\n\"use strict\";\n\nvar assign = __webpack_require__(51);\nvar invariant = __webpack_require__(36);\n\nvar genericComponentClass = null;\n// This registry keeps track of wrapper classes around native tags\nvar tagToComponentClass = {};\n\nvar ReactNativeComponentInjection = {\n  // This accepts a class that receives the tag string. This is a catch all\n  // that can render any kind of tag.\n  injectGenericComponentClass: function(componentClass) {\n    genericComponentClass = componentClass;\n  },\n  // This accepts a keyed object with classes as values. Each key represents a\n  // tag. That particular tag will use this class instead of the generic one.\n  injectComponentClasses: function(componentClasses) {\n    assign(tagToComponentClass, componentClasses);\n  }\n};\n\n/**\n * Create an internal class for a specific tag.\n *\n * @param {string} tag The tag for which to create an internal instance.\n * @param {any} props The props passed to the instance constructor.\n * @return {ReactComponent} component The injected empty component.\n */\nfunction createInstanceForTag(tag, props, parentType) {\n  var componentClass = tagToComponentClass[tag];\n  if (componentClass == null) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      genericComponentClass,\n      'There is no registered component for the tag %s',\n      tag\n    ) : invariant(genericComponentClass));\n    return new genericComponentClass(tag, props);\n  }\n  if (parentType === tag) {\n    // Avoid recursion\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      genericComponentClass,\n      'There is no registered component for the tag %s',\n      tag\n    ) : invariant(genericComponentClass));\n    return new genericComponentClass(tag, props);\n  }\n  // Unwrap legacy factories\n  return new componentClass.type(props);\n}\n\nvar ReactNativeComponent = {\n  createInstanceForTag: createInstanceForTag,\n  injection: ReactNativeComponentInjection\n};\n\nmodule.exports = ReactNativeComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactNativeComponent.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactNativeComponent.js?");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEmptyComponent\n */\n\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\n\nvar invariant = __webpack_require__(36);\n\nvar component;\n// This registry keeps track of the React IDs of the components that rendered to\n// `null` (in reality a placeholder such as `noscript`)\nvar nullComponentIdsRegistry = {};\n\nvar ReactEmptyComponentInjection = {\n  injectEmptyComponent: function(emptyComponent) {\n    component = ReactElement.createFactory(emptyComponent);\n  }\n};\n\n/**\n * @return {ReactComponent} component The injected empty component.\n */\nfunction getEmptyComponent() {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    component,\n    'Trying to return null from a render, but no null placeholder component ' +\n    'was injected.'\n  ) : invariant(component));\n  return component();\n}\n\n/**\n * Mark the component as having rendered to null.\n * @param {string} id Component's `_rootNodeID`.\n */\nfunction registerNullComponentID(id) {\n  nullComponentIdsRegistry[id] = true;\n}\n\n/**\n * Unmark the component as having rendered to null: it renders to something now.\n * @param {string} id Component's `_rootNodeID`.\n */\nfunction deregisterNullComponentID(id) {\n  delete nullComponentIdsRegistry[id];\n}\n\n/**\n * @param {string} id Component's `_rootNodeID`.\n * @return {boolean} True if the component is rendered to null.\n */\nfunction isNullComponentID(id) {\n  return nullComponentIdsRegistry[id];\n}\n\nvar ReactEmptyComponent = {\n  deregisterNullComponentID: deregisterNullComponentID,\n  getEmptyComponent: getEmptyComponent,\n  injection: ReactEmptyComponentInjection,\n  isNullComponentID: isNullComponentID,\n  registerNullComponentID: registerNullComponentID\n};\n\nmodule.exports = ReactEmptyComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEmptyComponent.js\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEmptyComponent.js?");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyFunction\n */\n\nfunction makeEmptyFunction(arg) {\n  return function() {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nfunction emptyFunction() {}\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function() { return this; };\nemptyFunction.thatReturnsArgument = function(arg) { return arg; };\n\nmodule.exports = emptyFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/emptyFunction.js\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/emptyFunction.js?");

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar makeAssimilatePrototype = __webpack_require__(131),\n    requestForceUpdateAll = __webpack_require__(132);\n\nfunction hasNonStubTypeProperty(ReactClass) {\n  if (!ReactClass.hasOwnProperty('type')) {\n    return false;\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(ReactClass, 'type');\n  if (typeof descriptor.get === 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getPrototype(ReactClass) {\n  var prototype = ReactClass.prototype,\n      seemsLegit = prototype && typeof prototype.render === 'function';\n\n  if (!seemsLegit && hasNonStubTypeProperty(ReactClass)) {\n    prototype = ReactClass.type.prototype;\n  }\n\n  return prototype;\n}\n\n/**\n * Returns a function that will patch React class with new versions of itself\n * on subsequent invocations. Both legacy and ES6 style classes are supported.\n */\nmodule.exports = function makePatchReactClass(getRootInstances) {\n  var assimilatePrototype = makeAssimilatePrototype(),\n      FirstClass = null;\n\n  return function patchReactClass(NextClass) {\n    var nextPrototype = getPrototype(NextClass);\n    assimilatePrototype(nextPrototype);\n\n    if (FirstClass) {\n      requestForceUpdateAll(getRootInstances);\n    }\n\n    return FirstClass || (FirstClass = NextClass);\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/makePatchReactClass.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/makePatchReactClass.js?");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMPropertyOperations\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar DOMProperty = __webpack_require__(25);\n\nvar escapeTextForBrowser = __webpack_require__(133);\nvar memoizeStringOnly = __webpack_require__(134);\nvar warning = __webpack_require__(38);\n\nfunction shouldIgnoreValue(name, value) {\n  return value == null ||\n    (DOMProperty.hasBooleanValue[name] && !value) ||\n    (DOMProperty.hasNumericValue[name] && isNaN(value)) ||\n    (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) ||\n    (DOMProperty.hasOverloadedBooleanValue[name] && value === false);\n}\n\nvar processAttributeNameAndPrefix = memoizeStringOnly(function(name) {\n  return escapeTextForBrowser(name) + '=\"';\n});\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var reactProps = {\n    children: true,\n    dangerouslySetInnerHTML: true,\n    key: true,\n    ref: true\n  };\n  var warnedProperties = {};\n\n  var warnUnknownProperty = function(name) {\n    if (reactProps.hasOwnProperty(name) && reactProps[name] ||\n        warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {\n      return;\n    }\n\n    warnedProperties[name] = true;\n    var lowerCasedName = name.toLowerCase();\n\n    // data-* attributes should be lowercase; suggest the lowercase version\n    var standardName = (\n      DOMProperty.isCustomAttribute(lowerCasedName) ?\n        lowerCasedName :\n      DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ?\n        DOMProperty.getPossibleStandardName[lowerCasedName] :\n        null\n    );\n\n    // For now, only warn when we have a suggested correction. This prevents\n    // logging too much when using transferPropsTo.\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      standardName == null,\n      'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?'\n    ) : null);\n\n  };\n}\n\n/**\n * Operations for dealing with DOM properties.\n */\nvar DOMPropertyOperations = {\n\n  /**\n   * Creates markup for the ID property.\n   *\n   * @param {string} id Unescaped ID.\n   * @return {string} Markup string.\n   */\n  createMarkupForID: function(id) {\n    return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) +\n      escapeTextForBrowser(id) + '\"';\n  },\n\n  /**\n   * Creates markup for a property.\n   *\n   * @param {string} name\n   * @param {*} value\n   * @return {?string} Markup string, or null if the property was invalid.\n   */\n  createMarkupForProperty: function(name, value) {\n    if (DOMProperty.isStandardName.hasOwnProperty(name) &&\n        DOMProperty.isStandardName[name]) {\n      if (shouldIgnoreValue(name, value)) {\n        return '';\n      }\n      var attributeName = DOMProperty.getAttributeName[name];\n      if (DOMProperty.hasBooleanValue[name] ||\n          (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {\n        return escapeTextForBrowser(attributeName);\n      }\n      return processAttributeNameAndPrefix(attributeName) +\n        escapeTextForBrowser(value) + '\"';\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      if (value == null) {\n        return '';\n      }\n      return processAttributeNameAndPrefix(name) +\n        escapeTextForBrowser(value) + '\"';\n    } else if (\"production\" !== process.env.NODE_ENV) {\n      warnUnknownProperty(name);\n    }\n    return null;\n  },\n\n  /**\n   * Sets the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   * @param {*} value\n   */\n  setValueForProperty: function(node, name, value) {\n    if (DOMProperty.isStandardName.hasOwnProperty(name) &&\n        DOMProperty.isStandardName[name]) {\n      var mutationMethod = DOMProperty.getMutationMethod[name];\n      if (mutationMethod) {\n        mutationMethod(node, value);\n      } else if (shouldIgnoreValue(name, value)) {\n        this.deleteValueForProperty(node, name);\n      } else if (DOMProperty.mustUseAttribute[name]) {\n        // `setAttribute` with objects becomes only `[object]` in IE8/9,\n        // ('' + value) makes it output the correct toString()-value.\n        node.setAttribute(DOMProperty.getAttributeName[name], '' + value);\n      } else {\n        var propName = DOMProperty.getPropertyName[name];\n        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the\n        // property type before comparing; only `value` does and is string.\n        if (!DOMProperty.hasSideEffects[name] ||\n            ('' + node[propName]) !== ('' + value)) {\n          // Contrary to `setAttribute`, object properties are properly\n          // `toString`ed by IE8/9.\n          node[propName] = value;\n        }\n      }\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      if (value == null) {\n        node.removeAttribute(name);\n      } else {\n        node.setAttribute(name, '' + value);\n      }\n    } else if (\"production\" !== process.env.NODE_ENV) {\n      warnUnknownProperty(name);\n    }\n  },\n\n  /**\n   * Deletes the value for a property on a node.\n   *\n   * @param {DOMElement} node\n   * @param {string} name\n   */\n  deleteValueForProperty: function(node, name) {\n    if (DOMProperty.isStandardName.hasOwnProperty(name) &&\n        DOMProperty.isStandardName[name]) {\n      var mutationMethod = DOMProperty.getMutationMethod[name];\n      if (mutationMethod) {\n        mutationMethod(node, undefined);\n      } else if (DOMProperty.mustUseAttribute[name]) {\n        node.removeAttribute(DOMProperty.getAttributeName[name]);\n      } else {\n        var propName = DOMProperty.getPropertyName[name];\n        var defaultValue = DOMProperty.getDefaultValueForProperty(\n          node.nodeName,\n          propName\n        );\n        if (!DOMProperty.hasSideEffects[name] ||\n            ('' + node[propName]) !== defaultValue) {\n          node[propName] = defaultValue;\n        }\n      }\n    } else if (DOMProperty.isCustomAttribute(name)) {\n      node.removeAttribute(name);\n    } else if (\"production\" !== process.env.NODE_ENV) {\n      warnUnknownProperty(name);\n    }\n  }\n\n};\n\nmodule.exports = DOMPropertyOperations;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMPropertyOperations.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMPropertyOperations.js?");

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginUtils\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Injected dependencies:\n */\n\n/**\n * - `Mount`: [required] Module that can convert between React dom IDs and\n *   actual node references.\n */\nvar injection = {\n  Mount: null,\n  injectMount: function(InjectedMount) {\n    injection.Mount = InjectedMount;\n    if (\"production\" !== process.env.NODE_ENV) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        InjectedMount && InjectedMount.getNode,\n        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +\n        'is missing getNode.'\n      ) : invariant(InjectedMount && InjectedMount.getNode));\n    }\n  }\n};\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nfunction isEndish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseUp ||\n         topLevelType === topLevelTypes.topTouchEnd ||\n         topLevelType === topLevelTypes.topTouchCancel;\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseMove ||\n         topLevelType === topLevelTypes.topTouchMove;\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === topLevelTypes.topMouseDown ||\n         topLevelType === topLevelTypes.topTouchStart;\n}\n\n\nvar validateEventDispatches;\nif (\"production\" !== process.env.NODE_ENV) {\n  validateEventDispatches = function(event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchIDs = event._dispatchIDs;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var idsIsArr = Array.isArray(dispatchIDs);\n    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;\n    var listenersLen = listenersIsArr ?\n      dispatchListeners.length :\n      dispatchListeners ? 1 : 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      idsIsArr === listenersIsArr && IDsLen === listenersLen,\n      'EventPluginUtils: Invalid `event`.'\n    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));\n  };\n}\n\n/**\n * Invokes `cb(event, listener, id)`. Avoids using call if no scope is\n * provided. The `(listener,id)` pair effectively forms the \"dispatch\" but are\n * kept separate to conserve memory.\n */\nfunction forEachEventDispatch(event, cb) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (\"production\" !== process.env.NODE_ENV) {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      cb(event, dispatchListeners[i], dispatchIDs[i]);\n    }\n  } else if (dispatchListeners) {\n    cb(event, dispatchListeners, dispatchIDs);\n  }\n}\n\n/**\n * Default implementation of PluginModule.executeDispatch().\n * @param {SyntheticEvent} SyntheticEvent to handle\n * @param {function} Application-level callback\n * @param {string} domID DOM id to pass to the callback.\n */\nfunction executeDispatch(event, listener, domID) {\n  event.currentTarget = injection.Mount.getNode(domID);\n  var returnValue = listener(event, domID);\n  event.currentTarget = null;\n  return returnValue;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, executeDispatch) {\n  forEachEventDispatch(event, executeDispatch);\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return id of the first dispatch execution who's listener returns true, or\n * null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchIDs = event._dispatchIDs;\n  if (\"production\" !== process.env.NODE_ENV) {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and IDs are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchIDs[i])) {\n        return dispatchIDs[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchIDs)) {\n      return dispatchIDs;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchIDs = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchID = event._dispatchIDs;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !Array.isArray(dispatchListener),\n    'executeDirectDispatch(...): Invalid `event`.'\n  ) : invariant(!Array.isArray(dispatchListener)));\n  var res = dispatchListener ?\n    dispatchListener(event, dispatchID) :\n    null;\n  event._dispatchListeners = null;\n  event._dispatchIDs = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {bool} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n/**\n * General utilities that are useful in creating custom Event Plugins.\n */\nvar EventPluginUtils = {\n  isEndish: isEndish,\n  isMoveish: isMoveish,\n  isStartish: isStartish,\n\n  executeDirectDispatch: executeDirectDispatch,\n  executeDispatch: executeDispatch,\n  executeDispatchesInOrder: executeDispatchesInOrder,\n  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n  hasDispatches: hasDispatches,\n  injection: injection,\n  useTouchEvents: false\n};\n\nmodule.exports = EventPluginUtils;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPluginUtils.js\n ** module id = 62\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPluginUtils.js?");

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactChildren\n */\n\n\"use strict\";\n\nvar PooledClass = __webpack_require__(135);\n\nvar traverseAllChildren = __webpack_require__(136);\nvar warning = __webpack_require__(38);\n\nvar twoArgumentPooler = PooledClass.twoArgumentPooler;\nvar threeArgumentPooler = PooledClass.threeArgumentPooler;\n\n/**\n * PooledClass representing the bookkeeping associated with performing a child\n * traversal. Allows avoiding binding callbacks.\n *\n * @constructor ForEachBookKeeping\n * @param {!function} forEachFunction Function to perform traversal with.\n * @param {?*} forEachContext Context to perform context with.\n */\nfunction ForEachBookKeeping(forEachFunction, forEachContext) {\n  this.forEachFunction = forEachFunction;\n  this.forEachContext = forEachContext;\n}\nPooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);\n\nfunction forEachSingleChild(traverseContext, child, name, i) {\n  var forEachBookKeeping = traverseContext;\n  forEachBookKeeping.forEachFunction.call(\n    forEachBookKeeping.forEachContext, child, i);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc.\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n\n  var traverseContext =\n    ForEachBookKeeping.getPooled(forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  ForEachBookKeeping.release(traverseContext);\n}\n\n/**\n * PooledClass representing the bookkeeping associated with performing a child\n * mapping. Allows avoiding binding callbacks.\n *\n * @constructor MapBookKeeping\n * @param {!*} mapResult Object containing the ordered map of results.\n * @param {!function} mapFunction Function to perform mapping with.\n * @param {?*} mapContext Context to perform mapping with.\n */\nfunction MapBookKeeping(mapResult, mapFunction, mapContext) {\n  this.mapResult = mapResult;\n  this.mapFunction = mapFunction;\n  this.mapContext = mapContext;\n}\nPooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);\n\nfunction mapSingleChildIntoContext(traverseContext, child, name, i) {\n  var mapBookKeeping = traverseContext;\n  var mapResult = mapBookKeeping.mapResult;\n\n  var keyUnique = !mapResult.hasOwnProperty(name);\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    keyUnique,\n    'ReactChildren.map(...): Encountered two children with the same key, ' +\n    '`%s`. Child keys must be unique; when two children share a key, only ' +\n    'the first child will be used.',\n    name\n  ) : null);\n\n  if (keyUnique) {\n    var mappedChild =\n      mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);\n    mapResult[name] = mappedChild;\n  }\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * TODO: This may likely break any calls to `ReactChildren.map` that were\n * previously relying on the fact that we guarded against null children.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} mapFunction.\n * @param {*} mapContext Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var mapResult = {};\n  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  MapBookKeeping.release(traverseContext);\n  return mapResult;\n}\n\nfunction forEachSingleChildDummy(traverseContext, child, name, i) {\n  return null;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children, context) {\n  return traverseAllChildren(children, forEachSingleChildDummy, null);\n}\n\nvar ReactChildren = {\n  forEach: forEachChildren,\n  map: mapChildren,\n  count: countChildren\n};\n\nmodule.exports = ReactChildren;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactChildren.js\n ** module id = 63\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactChildren.js?");

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponent\n */\n\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\nvar ReactOwner = __webpack_require__(137);\nvar ReactUpdates = __webpack_require__(138);\n\nvar assign = __webpack_require__(51);\nvar invariant = __webpack_require__(36);\nvar keyMirror = __webpack_require__(126);\n\n/**\n * Every React component is in one of these life cycles.\n */\nvar ComponentLifeCycle = keyMirror({\n  /**\n   * Mounted components have a DOM node representation and are capable of\n   * receiving new props.\n   */\n  MOUNTED: null,\n  /**\n   * Unmounted components are inactive and cannot receive new props.\n   */\n  UNMOUNTED: null\n});\n\nvar injected = false;\n\n/**\n * Optionally injectable environment dependent cleanup hook. (server vs.\n * browser etc). Example: A browser system caches DOM nodes based on component\n * ID and must remove that cache entry when this instance is unmounted.\n *\n * @private\n */\nvar unmountIDFromEnvironment = null;\n\n/**\n * The \"image\" of a component tree, is the platform specific (typically\n * serialized) data that represents a tree of lower level UI building blocks.\n * On the web, this \"image\" is HTML markup which describes a construction of\n * low level `div` and `span` nodes. Other platforms may have different\n * encoding of this \"image\". This must be injected.\n *\n * @private\n */\nvar mountImageIntoNode = null;\n\n/**\n * Components are the basic units of composition in React.\n *\n * Every component accepts a set of keyed input parameters known as \"props\" that\n * are initialized by the constructor. Once a component is mounted, the props\n * can be mutated using `setProps` or `replaceProps`.\n *\n * Every component is capable of the following operations:\n *\n *   `mountComponent`\n *     Initializes the component, renders markup, and registers event listeners.\n *\n *   `receiveComponent`\n *     Updates the rendered DOM nodes to match the given component.\n *\n *   `unmountComponent`\n *     Releases any resources allocated by this component.\n *\n * Components can also be \"owned\" by other components. Being owned by another\n * component means being constructed by that component. This is different from\n * being the child of a component, which means having a DOM representation that\n * is a child of the DOM representation of that component.\n *\n * @class ReactComponent\n */\nvar ReactComponent = {\n\n  injection: {\n    injectEnvironment: function(ReactComponentEnvironment) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !injected,\n        'ReactComponent: injectEnvironment() can only be called once.'\n      ) : invariant(!injected));\n      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;\n      unmountIDFromEnvironment =\n        ReactComponentEnvironment.unmountIDFromEnvironment;\n      ReactComponent.BackendIDOperations =\n        ReactComponentEnvironment.BackendIDOperations;\n      injected = true;\n    }\n  },\n\n  /**\n   * @internal\n   */\n  LifeCycle: ComponentLifeCycle,\n\n  /**\n   * Injected module that provides ability to mutate individual properties.\n   * Injected into the base class because many different subclasses need access\n   * to this.\n   *\n   * @internal\n   */\n  BackendIDOperations: null,\n\n  /**\n   * Base functionality for every ReactComponent constructor. Mixed into the\n   * `ReactComponent` prototype, but exposed statically for easy access.\n   *\n   * @lends {ReactComponent.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Checks whether or not this component is mounted.\n     *\n     * @return {boolean} True if mounted, false otherwise.\n     * @final\n     * @protected\n     */\n    isMounted: function() {\n      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;\n    },\n\n    /**\n     * Sets a subset of the props.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    setProps: function(partialProps, callback) {\n      // Merge with the pending element if it exists, otherwise with existing\n      // element props.\n      var element = this._pendingElement || this._currentElement;\n      this.replaceProps(\n        assign({}, element.props, partialProps),\n        callback\n      );\n    },\n\n    /**\n     * Replaces all of the props.\n     *\n     * @param {object} props New props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @public\n     */\n    replaceProps: function(props, callback) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this.isMounted(),\n        'replaceProps(...): Can only update a mounted component.'\n      ) : invariant(this.isMounted()));\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this._mountDepth === 0,\n        'replaceProps(...): You called `setProps` or `replaceProps` on a ' +\n        'component with a parent. This is an anti-pattern since props will ' +\n        'get reactively updated when rendered. Instead, change the owner\\'s ' +\n        '`render` method to pass the correct value as props to the component ' +\n        'where it is created.'\n      ) : invariant(this._mountDepth === 0));\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      this._pendingElement = ReactElement.cloneAndReplaceProps(\n        this._pendingElement || this._currentElement,\n        props\n      );\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n\n    /**\n     * Schedule a partial update to the props. Only used for internal testing.\n     *\n     * @param {object} partialProps Subset of the next props.\n     * @param {?function} callback Called after props are updated.\n     * @final\n     * @internal\n     */\n    _setPropsInternal: function(partialProps, callback) {\n      // This is a deoptimized path. We optimize for always having a element.\n      // This creates an extra internal element.\n      var element = this._pendingElement || this._currentElement;\n      this._pendingElement = ReactElement.cloneAndReplaceProps(\n        element,\n        assign({}, element.props, partialProps)\n      );\n      ReactUpdates.enqueueUpdate(this, callback);\n    },\n\n    /**\n     * Base constructor for all React components.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.construct.call(this, ...)`.\n     *\n     * @param {ReactElement} element\n     * @internal\n     */\n    construct: function(element) {\n      // This is the public exposed props object after it has been processed\n      // with default props. The element's props represents the true internal\n      // state of the props.\n      this.props = element.props;\n      // Record the component responsible for creating this component.\n      // This is accessible through the element but we maintain an extra\n      // field for compatibility with devtools and as a way to make an\n      // incremental update. TODO: Consider deprecating this field.\n      this._owner = element._owner;\n\n      // All components start unmounted.\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n\n      // See ReactUpdates.\n      this._pendingCallbacks = null;\n\n      // We keep the old element and a reference to the pending element\n      // to track updates.\n      this._currentElement = element;\n      this._pendingElement = null;\n    },\n\n    /**\n     * Initializes the component, renders markup, and registers event listeners.\n     *\n     * NOTE: This does not insert any nodes into the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n     * @param {number} mountDepth number of components in the owner hierarchy.\n     * @return {?string} Rendered markup to be inserted into the DOM.\n     * @internal\n     */\n    mountComponent: function(rootID, transaction, mountDepth) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !this.isMounted(),\n        'mountComponent(%s, ...): Can only mount an unmounted component. ' +\n        'Make sure to avoid storing components between renders or reusing a ' +\n        'single component instance in multiple places.',\n        rootID\n      ) : invariant(!this.isMounted()));\n      var ref = this._currentElement.ref;\n      if (ref != null) {\n        var owner = this._currentElement._owner;\n        ReactOwner.addComponentAsRefTo(this, ref, owner);\n      }\n      this._rootNodeID = rootID;\n      this._lifeCycleState = ComponentLifeCycle.MOUNTED;\n      this._mountDepth = mountDepth;\n      // Effectively: return '';\n    },\n\n    /**\n     * Releases any resources allocated by `mountComponent`.\n     *\n     * NOTE: This does not remove any nodes from the DOM.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.unmountComponent.call(this)`.\n     *\n     * @internal\n     */\n    unmountComponent: function() {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this.isMounted(),\n        'unmountComponent(): Can only unmount a mounted component.'\n      ) : invariant(this.isMounted()));\n      var ref = this._currentElement.ref;\n      if (ref != null) {\n        ReactOwner.removeComponentAsRefFrom(this, ref, this._owner);\n      }\n      unmountIDFromEnvironment(this._rootNodeID);\n      this._rootNodeID = null;\n      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;\n    },\n\n    /**\n     * Given a new instance of this component, updates the rendered DOM nodes\n     * as if that instance was rendered instead.\n     *\n     * Subclasses that override this method should make sure to invoke\n     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.\n     *\n     * @param {object} nextComponent Next set of properties.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    receiveComponent: function(nextElement, transaction) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        this.isMounted(),\n        'receiveComponent(...): Can only update a mounted component.'\n      ) : invariant(this.isMounted()));\n      this._pendingElement = nextElement;\n      this.performUpdateIfNecessary(transaction);\n    },\n\n    /**\n     * If `_pendingElement` is set, update the component.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    performUpdateIfNecessary: function(transaction) {\n      if (this._pendingElement == null) {\n        return;\n      }\n      var prevElement = this._currentElement;\n      var nextElement = this._pendingElement;\n      this._currentElement = nextElement;\n      this.props = nextElement.props;\n      this._owner = nextElement._owner;\n      this._pendingElement = null;\n      this.updateComponent(transaction, prevElement);\n    },\n\n    /**\n     * Updates the component's currently mounted representation.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @param {object} prevElement\n     * @internal\n     */\n    updateComponent: function(transaction, prevElement) {\n      var nextElement = this._currentElement;\n\n      // If either the owner or a `ref` has changed, make sure the newest owner\n      // has stored a reference to `this`, and the previous owner (if different)\n      // has forgotten the reference to `this`. We use the element instead\n      // of the public this.props because the post processing cannot determine\n      // a ref. The ref conceptually lives on the element.\n\n      // TODO: Should this even be possible? The owner cannot change because\n      // it's forbidden by shouldUpdateReactComponent. The ref can change\n      // if you swap the keys of but not the refs. Reconsider where this check\n      // is made. It probably belongs where the key checking and\n      // instantiateReactComponent is done.\n\n      if (nextElement._owner !== prevElement._owner ||\n          nextElement.ref !== prevElement.ref) {\n        if (prevElement.ref != null) {\n          ReactOwner.removeComponentAsRefFrom(\n            this, prevElement.ref, prevElement._owner\n          );\n        }\n        // Correct, even if the owner is the same, and only the ref has changed.\n        if (nextElement.ref != null) {\n          ReactOwner.addComponentAsRefTo(\n            this,\n            nextElement.ref,\n            nextElement._owner\n          );\n        }\n      }\n    },\n\n    /**\n     * Mounts this component and inserts it into the DOM.\n     *\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @internal\n     * @see {ReactMount.render}\n     */\n    mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {\n      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n      transaction.perform(\n        this._mountComponentIntoNode,\n        this,\n        rootID,\n        container,\n        transaction,\n        shouldReuseMarkup\n      );\n      ReactUpdates.ReactReconcileTransaction.release(transaction);\n    },\n\n    /**\n     * @param {string} rootID DOM ID of the root node.\n     * @param {DOMElement} container DOM element to mount into.\n     * @param {ReactReconcileTransaction} transaction\n     * @param {boolean} shouldReuseMarkup If true, do not insert markup\n     * @final\n     * @private\n     */\n    _mountComponentIntoNode: function(\n        rootID,\n        container,\n        transaction,\n        shouldReuseMarkup) {\n      var markup = this.mountComponent(rootID, transaction, 0);\n      mountImageIntoNode(markup, container, shouldReuseMarkup);\n    },\n\n    /**\n     * Checks if this component is owned by the supplied `owner` component.\n     *\n     * @param {ReactComponent} owner Component to check.\n     * @return {boolean} True if `owners` owns this component.\n     * @final\n     * @internal\n     */\n    isOwnedBy: function(owner) {\n      return this._owner === owner;\n    },\n\n    /**\n     * Gets another component, that shares the same owner as this one, by ref.\n     *\n     * @param {string} ref of a sibling Component.\n     * @return {?ReactComponent} the actual sibling Component.\n     * @final\n     * @internal\n     */\n    getSiblingByRef: function(ref) {\n      var owner = this._owner;\n      if (!owner || !owner.refs) {\n        return null;\n      }\n      return owner.refs[ref];\n    }\n  }\n};\n\nmodule.exports = ReactComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponent.js\n ** module id = 64\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponent.js?");

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactCompositeComponent\n */\n\n\"use strict\";\n\nvar ReactComponent = __webpack_require__(64);\nvar ReactContext = __webpack_require__(53);\nvar ReactCurrentOwner = __webpack_require__(27);\nvar ReactElement = __webpack_require__(28);\nvar ReactElementValidator = __webpack_require__(66);\nvar ReactEmptyComponent = __webpack_require__(58);\nvar ReactErrorUtils = __webpack_require__(139);\nvar ReactLegacyElement = __webpack_require__(29);\nvar ReactOwner = __webpack_require__(137);\nvar ReactPerf = __webpack_require__(31);\nvar ReactPropTransferer = __webpack_require__(140);\nvar ReactPropTypeLocations = __webpack_require__(141);\nvar ReactPropTypeLocationNames = __webpack_require__(142);\nvar ReactUpdates = __webpack_require__(138);\n\nvar assign = __webpack_require__(51);\nvar instantiateReactComponent = __webpack_require__(35);\nvar invariant = __webpack_require__(36);\nvar keyMirror = __webpack_require__(126);\nvar keyOf = __webpack_require__(143);\nvar monitorCodeUse = __webpack_require__(54);\nvar mapObject = __webpack_require__(144);\nvar shouldUpdateReactComponent = __webpack_require__(37);\nvar warning = __webpack_require__(38);\n\nvar MIXINS_KEY = keyOf({mixins: null});\n\n/**\n * Policies that describe methods in `ReactCompositeComponentInterface`.\n */\nvar SpecPolicy = keyMirror({\n  /**\n   * These methods may be defined only once by the class specification or mixin.\n   */\n  DEFINE_ONCE: null,\n  /**\n   * These methods may be defined by both the class specification and mixins.\n   * Subsequent definitions will be chained. These methods must return void.\n   */\n  DEFINE_MANY: null,\n  /**\n   * These methods are overriding the base ReactCompositeComponent class.\n   */\n  OVERRIDE_BASE: null,\n  /**\n   * These methods are similar to DEFINE_MANY, except we assume they return\n   * objects. We try to merge the keys of the return values of all the mixed in\n   * functions. If there is a key conflict we throw.\n   */\n  DEFINE_MANY_MERGED: null\n});\n\n\nvar injectedMixins = [];\n\n/**\n * Composite components are higher-level components that compose other composite\n * or native components.\n *\n * To create a new type of `ReactCompositeComponent`, pass a specification of\n * your new class to `React.createClass`. The only requirement of your class\n * specification is that you implement a `render` method.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return <div>Hello World</div>;\n *     }\n *   });\n *\n * The class specification supports a specific protocol of methods that have\n * special meaning (e.g. `render`). See `ReactCompositeComponentInterface` for\n * more the comprehensive protocol. Any other properties and methods in the\n * class specification will available on the prototype.\n *\n * @interface ReactCompositeComponentInterface\n * @internal\n */\nvar ReactCompositeComponentInterface = {\n\n  /**\n   * An array of Mixin objects to include when defining your component.\n   *\n   * @type {array}\n   * @optional\n   */\n  mixins: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * An object containing properties and methods that should be defined on\n   * the component's constructor instead of its prototype (static methods).\n   *\n   * @type {object}\n   * @optional\n   */\n  statics: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of prop types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  propTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types for this component.\n   *\n   * @type {object}\n   * @optional\n   */\n  contextTypes: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Definition of context types this component sets for its children.\n   *\n   * @type {object}\n   * @optional\n   */\n  childContextTypes: SpecPolicy.DEFINE_MANY,\n\n  // ==== Definition methods ====\n\n  /**\n   * Invoked when the component is mounted. Values in the mapping will be set on\n   * `this.props` if that prop is not specified (i.e. using an `in` check).\n   *\n   * This method is invoked before `getInitialState` and therefore cannot rely\n   * on `this.state` or use `this.setState`.\n   *\n   * @return {object}\n   * @optional\n   */\n  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Invoked once before the component is mounted. The return value will be used\n   * as the initial value of `this.state`.\n   *\n   *   getInitialState: function() {\n   *     return {\n   *       isOn: false,\n   *       fooBaz: new BazFoo()\n   *     }\n   *   }\n   *\n   * @return {object}\n   * @optional\n   */\n  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * @return {object}\n   * @optional\n   */\n  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,\n\n  /**\n   * Uses props from `this.props` and state from `this.state` to render the\n   * structure of the component.\n   *\n   * No guarantees are made about when or how often this method is invoked, so\n   * it must not have side effects.\n   *\n   *   render: function() {\n   *     var name = this.props.name;\n   *     return <div>Hello, {name}!</div>;\n   *   }\n   *\n   * @return {ReactComponent}\n   * @nosideeffects\n   * @required\n   */\n  render: SpecPolicy.DEFINE_ONCE,\n\n\n\n  // ==== Delegate methods ====\n\n  /**\n   * Invoked when the component is initially created and about to be mounted.\n   * This may have side effects, but any external subscriptions or data created\n   * by this method must be cleaned up in `componentWillUnmount`.\n   *\n   * @optional\n   */\n  componentWillMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component has been mounted and has a DOM representation.\n   * However, there is no guarantee that the DOM node is in the document.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been mounted (initialized and rendered) for the first time.\n   *\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidMount: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked before the component receives new props.\n   *\n   * Use this as an opportunity to react to a prop transition by updating the\n   * state using `this.setState`. Current props are accessed via `this.props`.\n   *\n   *   componentWillReceiveProps: function(nextProps, nextContext) {\n   *     this.setState({\n   *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n   *     });\n   *   }\n   *\n   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n   * transition may cause a state change, but the opposite is not true. If you\n   * need it, you are probably looking for `componentWillUpdate`.\n   *\n   * @param {object} nextProps\n   * @optional\n   */\n  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked while deciding if the component should be updated as a result of\n   * receiving new props, state and/or context.\n   *\n   * Use this as an opportunity to `return false` when you're certain that the\n   * transition to the new props/state/context will not require a component\n   * update.\n   *\n   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n   *     return !equal(nextProps, this.props) ||\n   *       !equal(nextState, this.state) ||\n   *       !equal(nextContext, this.context);\n   *   }\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @return {boolean} True if the component should update.\n   * @optional\n   */\n  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,\n\n  /**\n   * Invoked when the component is about to update due to a transition from\n   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n   * and `nextContext`.\n   *\n   * Use this as an opportunity to perform preparation before an update occurs.\n   *\n   * NOTE: You **cannot** use `this.setState()` in this method.\n   *\n   * @param {object} nextProps\n   * @param {?object} nextState\n   * @param {?object} nextContext\n   * @param {ReactReconcileTransaction} transaction\n   * @optional\n   */\n  componentWillUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component's DOM representation has been updated.\n   *\n   * Use this as an opportunity to operate on the DOM when the component has\n   * been updated.\n   *\n   * @param {object} prevProps\n   * @param {?object} prevState\n   * @param {?object} prevContext\n   * @param {DOMElement} rootNode DOM element representing the component.\n   * @optional\n   */\n  componentDidUpdate: SpecPolicy.DEFINE_MANY,\n\n  /**\n   * Invoked when the component is about to be removed from its parent and have\n   * its DOM representation destroyed.\n   *\n   * Use this as an opportunity to deallocate any external resources.\n   *\n   * NOTE: There is no `componentDidUnmount` since your component will have been\n   * destroyed by that point.\n   *\n   * @optional\n   */\n  componentWillUnmount: SpecPolicy.DEFINE_MANY,\n\n\n\n  // ==== Advanced methods ====\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   * @overridable\n   */\n  updateComponent: SpecPolicy.OVERRIDE_BASE\n\n};\n\n/**\n * Mapping from class specification keys to special processing functions.\n *\n * Although these are declared like instance properties in the specification\n * when defining classes using `React.createClass`, they are actually static\n * and are accessible on the constructor instead of the prototype. Despite\n * being static, they must be defined outside of the \"statics\" key under\n * which all other static methods are defined.\n */\nvar RESERVED_SPEC_KEYS = {\n  displayName: function(Constructor, displayName) {\n    Constructor.displayName = displayName;\n  },\n  mixins: function(Constructor, mixins) {\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        mixSpecIntoComponent(Constructor, mixins[i]);\n      }\n    }\n  },\n  childContextTypes: function(Constructor, childContextTypes) {\n    validateTypeDef(\n      Constructor,\n      childContextTypes,\n      ReactPropTypeLocations.childContext\n    );\n    Constructor.childContextTypes = assign(\n      {},\n      Constructor.childContextTypes,\n      childContextTypes\n    );\n  },\n  contextTypes: function(Constructor, contextTypes) {\n    validateTypeDef(\n      Constructor,\n      contextTypes,\n      ReactPropTypeLocations.context\n    );\n    Constructor.contextTypes = assign(\n      {},\n      Constructor.contextTypes,\n      contextTypes\n    );\n  },\n  /**\n   * Special case getDefaultProps which should move into statics but requires\n   * automatic merging.\n   */\n  getDefaultProps: function(Constructor, getDefaultProps) {\n    if (Constructor.getDefaultProps) {\n      Constructor.getDefaultProps = createMergedResultFunction(\n        Constructor.getDefaultProps,\n        getDefaultProps\n      );\n    } else {\n      Constructor.getDefaultProps = getDefaultProps;\n    }\n  },\n  propTypes: function(Constructor, propTypes) {\n    validateTypeDef(\n      Constructor,\n      propTypes,\n      ReactPropTypeLocations.prop\n    );\n    Constructor.propTypes = assign(\n      {},\n      Constructor.propTypes,\n      propTypes\n    );\n  },\n  statics: function(Constructor, statics) {\n    mixStaticSpecIntoComponent(Constructor, statics);\n  }\n};\n\nfunction getDeclarationErrorAddendum(component) {\n  var owner = component._owner || null;\n  if (owner && owner.constructor && owner.constructor.displayName) {\n    return ' Check the render method of `' + owner.constructor.displayName +\n      '`.';\n  }\n  return '';\n}\n\nfunction validateTypeDef(Constructor, typeDef, location) {\n  for (var propName in typeDef) {\n    if (typeDef.hasOwnProperty(propName)) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        typeof typeDef[propName] == 'function',\n        '%s: %s type `%s` is invalid; it must be a function, usually from ' +\n        'React.PropTypes.',\n        Constructor.displayName || 'ReactCompositeComponent',\n        ReactPropTypeLocationNames[location],\n        propName\n      ) : invariant(typeof typeDef[propName] == 'function'));\n    }\n  }\n}\n\nfunction validateMethodOverride(proto, name) {\n  var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ?\n    ReactCompositeComponentInterface[name] :\n    null;\n\n  // Disallow overriding of base class methods unless explicitly allowed.\n  if (ReactCompositeComponentMixin.hasOwnProperty(name)) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      specPolicy === SpecPolicy.OVERRIDE_BASE,\n      'ReactCompositeComponentInterface: You are attempting to override ' +\n      '`%s` from your class specification. Ensure that your method names ' +\n      'do not overlap with React methods.',\n      name\n    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));\n  }\n\n  // Disallow defining methods more than once unless explicitly allowed.\n  if (proto.hasOwnProperty(name)) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      specPolicy === SpecPolicy.DEFINE_MANY ||\n      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,\n      'ReactCompositeComponentInterface: You are attempting to define ' +\n      '`%s` on your component more than once. This conflict may be due ' +\n      'to a mixin.',\n      name\n    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||\n    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));\n  }\n}\n\nfunction validateLifeCycleOnReplaceState(instance) {\n  var compositeLifeCycleState = instance._compositeLifeCycleState;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    instance.isMounted() ||\n      compositeLifeCycleState === CompositeLifeCycle.MOUNTING,\n    'replaceState(...): Can only update a mounted or mounting component.'\n  ) : invariant(instance.isMounted() ||\n    compositeLifeCycleState === CompositeLifeCycle.MOUNTING));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactCurrentOwner.current == null,\n    'replaceState(...): Cannot update during an existing state transition ' +\n    '(such as within `render`). Render methods should be a pure function ' +\n    'of props and state.'\n  ) : invariant(ReactCurrentOwner.current == null));\n  (\"production\" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,\n    'replaceState(...): Cannot update while unmounting component. This ' +\n    'usually means you called setState() on an unmounted component.'\n  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));\n}\n\n/**\n * Mixin helper which handles policy validation and reserved\n * specification keys when building `ReactCompositeComponent` classses.\n */\nfunction mixSpecIntoComponent(Constructor, spec) {\n  if (!spec) {\n    return;\n  }\n\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !ReactLegacyElement.isValidFactory(spec),\n    'ReactCompositeComponent: You\\'re attempting to ' +\n    'use a component class as a mixin. Instead, just use a regular object.'\n  ) : invariant(!ReactLegacyElement.isValidFactory(spec)));\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !ReactElement.isValidElement(spec),\n    'ReactCompositeComponent: You\\'re attempting to ' +\n    'use a component as a mixin. Instead, just use a regular object.'\n  ) : invariant(!ReactElement.isValidElement(spec)));\n\n  var proto = Constructor.prototype;\n\n  // By handling mixins before any other properties, we ensure the same\n  // chaining order is applied to methods with DEFINE_MANY policy, whether\n  // mixins are listed before or after these methods in the spec.\n  if (spec.hasOwnProperty(MIXINS_KEY)) {\n    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n  }\n\n  for (var name in spec) {\n    if (!spec.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (name === MIXINS_KEY) {\n      // We have already handled mixins in a special case above\n      continue;\n    }\n\n    var property = spec[name];\n    validateMethodOverride(proto, name);\n\n    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n      RESERVED_SPEC_KEYS[name](Constructor, property);\n    } else {\n      // Setup methods on prototype:\n      // The following member methods should not be automatically bound:\n      // 1. Expected ReactCompositeComponent methods (in the \"interface\").\n      // 2. Overridden methods (that were mixed in).\n      var isCompositeComponentMethod =\n        ReactCompositeComponentInterface.hasOwnProperty(name);\n      var isAlreadyDefined = proto.hasOwnProperty(name);\n      var markedDontBind = property && property.__reactDontBind;\n      var isFunction = typeof property === 'function';\n      var shouldAutoBind =\n        isFunction &&\n        !isCompositeComponentMethod &&\n        !isAlreadyDefined &&\n        !markedDontBind;\n\n      if (shouldAutoBind) {\n        if (!proto.__reactAutoBindMap) {\n          proto.__reactAutoBindMap = {};\n        }\n        proto.__reactAutoBindMap[name] = property;\n        proto[name] = property;\n      } else {\n        if (isAlreadyDefined) {\n          var specPolicy = ReactCompositeComponentInterface[name];\n\n          // These cases should already be caught by validateMethodOverride\n          (\"production\" !== process.env.NODE_ENV ? invariant(\n            isCompositeComponentMethod && (\n              specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||\n              specPolicy === SpecPolicy.DEFINE_MANY\n            ),\n            'ReactCompositeComponent: Unexpected spec policy %s for key %s ' +\n            'when mixing in component specs.',\n            specPolicy,\n            name\n          ) : invariant(isCompositeComponentMethod && (\n            specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||\n            specPolicy === SpecPolicy.DEFINE_MANY\n          )));\n\n          // For methods which are defined more than once, call the existing\n          // methods before calling the new property, merging if appropriate.\n          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {\n            proto[name] = createMergedResultFunction(proto[name], property);\n          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {\n            proto[name] = createChainedFunction(proto[name], property);\n          }\n        } else {\n          proto[name] = property;\n          if (\"production\" !== process.env.NODE_ENV) {\n            // Add verbose displayName to the function, which helps when looking\n            // at profiling tools.\n            if (typeof property === 'function' && spec.displayName) {\n              proto[name].displayName = spec.displayName + '_' + name;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction mixStaticSpecIntoComponent(Constructor, statics) {\n  if (!statics) {\n    return;\n  }\n  for (var name in statics) {\n    var property = statics[name];\n    if (!statics.hasOwnProperty(name)) {\n      continue;\n    }\n\n    var isReserved = name in RESERVED_SPEC_KEYS;\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !isReserved,\n      'ReactCompositeComponent: You are attempting to define a reserved ' +\n      'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' +\n      'as an instance property instead; it will still be accessible on the ' +\n      'constructor.',\n      name\n    ) : invariant(!isReserved));\n\n    var isInherited = name in Constructor;\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !isInherited,\n      'ReactCompositeComponent: You are attempting to define ' +\n      '`%s` on your component more than once. This conflict may be ' +\n      'due to a mixin.',\n      name\n    ) : invariant(!isInherited));\n    Constructor[name] = property;\n  }\n}\n\n/**\n * Merge two objects, but throw if both contain the same key.\n *\n * @param {object} one The first object, which is mutated.\n * @param {object} two The second object\n * @return {object} one after it has been mutated to contain everything in two.\n */\nfunction mergeObjectsWithNoDuplicateKeys(one, two) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    one && two && typeof one === 'object' && typeof two === 'object',\n    'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects'\n  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));\n\n  mapObject(two, function(value, key) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      one[key] === undefined,\n      'mergeObjectsWithNoDuplicateKeys(): ' +\n      'Tried to merge two objects with the same key: `%s`. This conflict ' +\n      'may be due to a mixin; in particular, this may be caused by two ' +\n      'getInitialState() or getDefaultProps() methods returning objects ' +\n      'with clashing keys.',\n      key\n    ) : invariant(one[key] === undefined));\n    one[key] = value;\n  });\n  return one;\n}\n\n/**\n * Creates a function that invokes two functions and merges their return values.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createMergedResultFunction(one, two) {\n  return function mergedResult() {\n    var a = one.apply(this, arguments);\n    var b = two.apply(this, arguments);\n    if (a == null) {\n      return b;\n    } else if (b == null) {\n      return a;\n    }\n    return mergeObjectsWithNoDuplicateKeys(a, b);\n  };\n}\n\n/**\n * Creates a function that invokes two functions and ignores their return vales.\n *\n * @param {function} one Function to invoke first.\n * @param {function} two Function to invoke second.\n * @return {function} Function that invokes the two argument functions.\n * @private\n */\nfunction createChainedFunction(one, two) {\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n\n/**\n * `ReactCompositeComponent` maintains an auxiliary life cycle state in\n * `this._compositeLifeCycleState` (which can be null).\n *\n * This is different from the life cycle state maintained by `ReactComponent` in\n * `this._lifeCycleState`. The following diagram shows how the states overlap in\n * time. There are times when the CompositeLifeCycle is null - at those times it\n * is only meaningful to look at ComponentLifeCycle alone.\n *\n * Top Row: ReactComponent.ComponentLifeCycle\n * Low Row: ReactComponent.CompositeLifeCycle\n *\n * +-------+---------------------------------+--------+\n * |  UN   |             MOUNTED             |   UN   |\n * |MOUNTED|                                 | MOUNTED|\n * +-------+---------------------------------+--------+\n * |       ^--------+   +-------+   +--------^        |\n * |       |        |   |       |   |        |        |\n * |    0--|MOUNTING|-0-|RECEIVE|-0-|   UN   |--->0   |\n * |       |        |   |PROPS  |   |MOUNTING|        |\n * |       |        |   |       |   |        |        |\n * |       |        |   |       |   |        |        |\n * |       +--------+   +-------+   +--------+        |\n * |       |                                 |        |\n * +-------+---------------------------------+--------+\n */\nvar CompositeLifeCycle = keyMirror({\n  /**\n   * Components in the process of being mounted respond to state changes\n   * differently.\n   */\n  MOUNTING: null,\n  /**\n   * Components in the process of being unmounted are guarded against state\n   * changes.\n   */\n  UNMOUNTING: null,\n  /**\n   * Components that are mounted and receiving new props respond to state\n   * changes differently.\n   */\n  RECEIVING_PROPS: null\n});\n\n/**\n * @lends {ReactCompositeComponent.prototype}\n */\nvar ReactCompositeComponentMixin = {\n\n  /**\n   * Base constructor for all composite component.\n   *\n   * @param {ReactElement} element\n   * @final\n   * @internal\n   */\n  construct: function(element) {\n    // Children can be either an array or more than one argument\n    ReactComponent.Mixin.construct.apply(this, arguments);\n    ReactOwner.Mixin.construct.apply(this, arguments);\n\n    this.state = null;\n    this._pendingState = null;\n\n    // This is the public post-processed context. The real context and pending\n    // context lives on the element.\n    this.context = null;\n\n    this._compositeLifeCycleState = null;\n  },\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function() {\n    return ReactComponent.Mixin.isMounted.call(this) &&\n      this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;\n  },\n\n  /**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {number} mountDepth number of components in the owner hierarchy\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: ReactPerf.measure(\n    'ReactCompositeComponent',\n    'mountComponent',\n    function(rootID, transaction, mountDepth) {\n      ReactComponent.Mixin.mountComponent.call(\n        this,\n        rootID,\n        transaction,\n        mountDepth\n      );\n      this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;\n\n      if (this.__reactAutoBindMap) {\n        this._bindAutoBindMethods();\n      }\n\n      this.context = this._processContext(this._currentElement._context);\n      this.props = this._processProps(this.props);\n\n      this.state = this.getInitialState ? this.getInitialState() : null;\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        typeof this.state === 'object' && !Array.isArray(this.state),\n        '%s.getInitialState(): must return an object or null',\n        this.constructor.displayName || 'ReactCompositeComponent'\n      ) : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));\n\n      this._pendingState = null;\n      this._pendingForceUpdate = false;\n\n      if (this.componentWillMount) {\n        this.componentWillMount();\n        // When mounting, calls to `setState` by `componentWillMount` will set\n        // `this._pendingState` without triggering a re-render.\n        if (this._pendingState) {\n          this.state = this._pendingState;\n          this._pendingState = null;\n        }\n      }\n\n      this._renderedComponent = instantiateReactComponent(\n        this._renderValidatedComponent(),\n        this._currentElement.type // The wrapping type\n      );\n\n      // Done with mounting, `setState` will now trigger UI changes.\n      this._compositeLifeCycleState = null;\n      var markup = this._renderedComponent.mountComponent(\n        rootID,\n        transaction,\n        mountDepth + 1\n      );\n      if (this.componentDidMount) {\n        transaction.getReactMountReady().enqueue(this.componentDidMount, this);\n      }\n      return markup;\n    }\n  ),\n\n  /**\n   * Releases any resources allocated by `mountComponent`.\n   *\n   * @final\n   * @internal\n   */\n  unmountComponent: function() {\n    this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;\n    if (this.componentWillUnmount) {\n      this.componentWillUnmount();\n    }\n    this._compositeLifeCycleState = null;\n\n    this._renderedComponent.unmountComponent();\n    this._renderedComponent = null;\n\n    ReactComponent.Mixin.unmountComponent.call(this);\n\n    // Some existing components rely on this.props even after they've been\n    // destroyed (in event handlers).\n    // TODO: this.props = null;\n    // TODO: this.state = null;\n  },\n\n  /**\n   * Sets a subset of the state. Always use this or `replaceState` to mutate\n   * state. You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * There is no guarantee that calls to `setState` will run synchronously,\n   * as they may eventually be batched together.  You can provide an optional\n   * callback that will be executed when the call to setState is actually\n   * completed.\n   *\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after state is updated.\n   * @final\n   * @protected\n   */\n  setState: function(partialState, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof partialState === 'object' || partialState == null,\n      'setState(...): takes an object of state variables to update.'\n    ) : invariant(typeof partialState === 'object' || partialState == null));\n    if (\"production\" !== process.env.NODE_ENV){\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        partialState != null,\n        'setState(...): You passed an undefined or null state object; ' +\n        'instead, use forceUpdate().'\n      ) : null);\n    }\n    // Merge with `_pendingState` if it exists, otherwise with existing state.\n    this.replaceState(\n      assign({}, this._pendingState || this.state, partialState),\n      callback\n    );\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after state is updated.\n   * @final\n   * @protected\n   */\n  replaceState: function(completeState, callback) {\n    validateLifeCycleOnReplaceState(this);\n    this._pendingState = completeState;\n    if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {\n      // If we're in a componentWillMount handler, don't enqueue a rerender\n      // because ReactUpdates assumes we're in a browser context (which is wrong\n      // for server rendering) and we're about to do a render anyway.\n      // TODO: The callback here is ignored when setState is called from\n      // componentWillMount. Either fix it or disallow doing so completely in\n      // favor of getInitialState.\n      ReactUpdates.enqueueUpdate(this, callback);\n    }\n  },\n\n  /**\n   * Filters the context object to only contain keys specified in\n   * `contextTypes`, and asserts that they are valid.\n   *\n   * @param {object} context\n   * @return {?object}\n   * @private\n   */\n  _processContext: function(context) {\n    var maskedContext = null;\n    var contextTypes = this.constructor.contextTypes;\n    if (contextTypes) {\n      maskedContext = {};\n      for (var contextName in contextTypes) {\n        maskedContext[contextName] = context[contextName];\n      }\n      if (\"production\" !== process.env.NODE_ENV) {\n        this._checkPropTypes(\n          contextTypes,\n          maskedContext,\n          ReactPropTypeLocations.context\n        );\n      }\n    }\n    return maskedContext;\n  },\n\n  /**\n   * @param {object} currentContext\n   * @return {object}\n   * @private\n   */\n  _processChildContext: function(currentContext) {\n    var childContext = this.getChildContext && this.getChildContext();\n    var displayName = this.constructor.displayName || 'ReactCompositeComponent';\n    if (childContext) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        typeof this.constructor.childContextTypes === 'object',\n        '%s.getChildContext(): childContextTypes must be defined in order to ' +\n        'use getChildContext().',\n        displayName\n      ) : invariant(typeof this.constructor.childContextTypes === 'object'));\n      if (\"production\" !== process.env.NODE_ENV) {\n        this._checkPropTypes(\n          this.constructor.childContextTypes,\n          childContext,\n          ReactPropTypeLocations.childContext\n        );\n      }\n      for (var name in childContext) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          name in this.constructor.childContextTypes,\n          '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.',\n          displayName,\n          name\n        ) : invariant(name in this.constructor.childContextTypes));\n      }\n      return assign({}, currentContext, childContext);\n    }\n    return currentContext;\n  },\n\n  /**\n   * Processes props by setting default values for unspecified props and\n   * asserting that the props are valid. Does not mutate its argument; returns\n   * a new props object with defaults merged in.\n   *\n   * @param {object} newProps\n   * @return {object}\n   * @private\n   */\n  _processProps: function(newProps) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      var propTypes = this.constructor.propTypes;\n      if (propTypes) {\n        this._checkPropTypes(propTypes, newProps, ReactPropTypeLocations.prop);\n      }\n    }\n    return newProps;\n  },\n\n  /**\n   * Assert that the props are valid\n   *\n   * @param {object} propTypes Map of prop name to a ReactPropType\n   * @param {object} props\n   * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n   * @private\n   */\n  _checkPropTypes: function(propTypes, props, location) {\n    // TODO: Stop validating prop types here and only use the element\n    // validation.\n    var componentName = this.constructor.displayName;\n    for (var propName in propTypes) {\n      if (propTypes.hasOwnProperty(propName)) {\n        var error =\n          propTypes[propName](props, propName, componentName, location);\n        if (error instanceof Error) {\n          // We may want to extend this logic for similar errors in\n          // renderComponent calls, so I'm abstracting it away into\n          // a function to minimize refactoring in the future\n          var addendum = getDeclarationErrorAddendum(this);\n          (\"production\" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);\n        }\n      }\n    }\n  },\n\n  /**\n   * If any of `_pendingElement`, `_pendingState`, or `_pendingForceUpdate`\n   * is set, update the component.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  performUpdateIfNecessary: function(transaction) {\n    var compositeLifeCycleState = this._compositeLifeCycleState;\n    // Do not trigger a state transition if we are in the middle of mounting or\n    // receiving props because both of those will already be doing this.\n    if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING ||\n        compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {\n      return;\n    }\n\n    if (this._pendingElement == null &&\n        this._pendingState == null &&\n        !this._pendingForceUpdate) {\n      return;\n    }\n\n    var nextContext = this.context;\n    var nextProps = this.props;\n    var nextElement = this._currentElement;\n    if (this._pendingElement != null) {\n      nextElement = this._pendingElement;\n      nextContext = this._processContext(nextElement._context);\n      nextProps = this._processProps(nextElement.props);\n      this._pendingElement = null;\n\n      this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;\n      if (this.componentWillReceiveProps) {\n        this.componentWillReceiveProps(nextProps, nextContext);\n      }\n    }\n\n    this._compositeLifeCycleState = null;\n\n    var nextState = this._pendingState || this.state;\n    this._pendingState = null;\n\n    var shouldUpdate =\n      this._pendingForceUpdate ||\n      !this.shouldComponentUpdate ||\n      this.shouldComponentUpdate(nextProps, nextState, nextContext);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof shouldUpdate === \"undefined\") {\n        console.warn(\n          (this.constructor.displayName || 'ReactCompositeComponent') +\n          '.shouldComponentUpdate(): Returned undefined instead of a ' +\n          'boolean value. Make sure to return true or false.'\n        );\n      }\n    }\n\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(\n        nextElement,\n        nextProps,\n        nextState,\n        nextContext,\n        transaction\n      );\n    } else {\n      // If it's determined that a component should not update, we still want\n      // to set props and state.\n      this._currentElement = nextElement;\n      this.props = nextProps;\n      this.state = nextState;\n      this.context = nextContext;\n\n      // Owner cannot change because shouldUpdateReactComponent doesn't allow\n      // it. TODO: Remove this._owner completely.\n      this._owner = nextElement._owner;\n    }\n  },\n\n  /**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @private\n   */\n  _performComponentUpdate: function(\n    nextElement,\n    nextProps,\n    nextState,\n    nextContext,\n    transaction\n  ) {\n    var prevElement = this._currentElement;\n    var prevProps = this.props;\n    var prevState = this.state;\n    var prevContext = this.context;\n\n    if (this.componentWillUpdate) {\n      this.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n\n    this._currentElement = nextElement;\n    this.props = nextProps;\n    this.state = nextState;\n    this.context = nextContext;\n\n    // Owner cannot change because shouldUpdateReactComponent doesn't allow\n    // it. TODO: Remove this._owner completely.\n    this._owner = nextElement._owner;\n\n    this.updateComponent(\n      transaction,\n      prevElement\n    );\n\n    if (this.componentDidUpdate) {\n      transaction.getReactMountReady().enqueue(\n        this.componentDidUpdate.bind(this, prevProps, prevState, prevContext),\n        this\n      );\n    }\n  },\n\n  receiveComponent: function(nextElement, transaction) {\n    if (nextElement === this._currentElement &&\n        nextElement._owner != null) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for a element created outside a composite to be\n      // deeply mutated and reused.\n      return;\n    }\n\n    ReactComponent.Mixin.receiveComponent.call(\n      this,\n      nextElement,\n      transaction\n    );\n  },\n\n  /**\n   * Updates the component's currently mounted DOM representation.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: ReactPerf.measure(\n    'ReactCompositeComponent',\n    'updateComponent',\n    function(transaction, prevParentElement) {\n      ReactComponent.Mixin.updateComponent.call(\n        this,\n        transaction,\n        prevParentElement\n      );\n\n      var prevComponentInstance = this._renderedComponent;\n      var prevElement = prevComponentInstance._currentElement;\n      var nextElement = this._renderValidatedComponent();\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        prevComponentInstance.receiveComponent(nextElement, transaction);\n      } else {\n        // These two IDs are actually the same! But nothing should rely on that.\n        var thisID = this._rootNodeID;\n        var prevComponentID = prevComponentInstance._rootNodeID;\n        prevComponentInstance.unmountComponent();\n        this._renderedComponent = instantiateReactComponent(\n          nextElement,\n          this._currentElement.type\n        );\n        var nextMarkup = this._renderedComponent.mountComponent(\n          thisID,\n          transaction,\n          this._mountDepth + 1\n        );\n        ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(\n          prevComponentID,\n          nextMarkup\n        );\n      }\n    }\n  ),\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldUpdateComponent`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {?function} callback Called after update is complete.\n   * @final\n   * @protected\n   */\n  forceUpdate: function(callback) {\n    var compositeLifeCycleState = this._compositeLifeCycleState;\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      this.isMounted() ||\n        compositeLifeCycleState === CompositeLifeCycle.MOUNTING,\n      'forceUpdate(...): Can only force an update on mounted or mounting ' +\n        'components.'\n    ) : invariant(this.isMounted() ||\n      compositeLifeCycleState === CompositeLifeCycle.MOUNTING));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING &&\n      ReactCurrentOwner.current == null,\n      'forceUpdate(...): Cannot force an update while unmounting component ' +\n      'or within a `render` function.'\n    ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING &&\n    ReactCurrentOwner.current == null));\n    this._pendingForceUpdate = true;\n    ReactUpdates.enqueueUpdate(this, callback);\n  },\n\n  /**\n   * @private\n   */\n  _renderValidatedComponent: ReactPerf.measure(\n    'ReactCompositeComponent',\n    '_renderValidatedComponent',\n    function() {\n      var renderedComponent;\n      var previousContext = ReactContext.current;\n      ReactContext.current = this._processChildContext(\n        this._currentElement._context\n      );\n      ReactCurrentOwner.current = this;\n      try {\n        renderedComponent = this.render();\n        if (renderedComponent === null || renderedComponent === false) {\n          renderedComponent = ReactEmptyComponent.getEmptyComponent();\n          ReactEmptyComponent.registerNullComponentID(this._rootNodeID);\n        } else {\n          ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);\n        }\n      } finally {\n        ReactContext.current = previousContext;\n        ReactCurrentOwner.current = null;\n      }\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        ReactElement.isValidElement(renderedComponent),\n        '%s.render(): A valid ReactComponent must be returned. You may have ' +\n          'returned undefined, an array or some other invalid object.',\n        this.constructor.displayName || 'ReactCompositeComponent'\n      ) : invariant(ReactElement.isValidElement(renderedComponent)));\n      return renderedComponent;\n    }\n  ),\n\n  /**\n   * @private\n   */\n  _bindAutoBindMethods: function() {\n    for (var autoBindKey in this.__reactAutoBindMap) {\n      if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n        continue;\n      }\n      var method = this.__reactAutoBindMap[autoBindKey];\n      this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(\n        method,\n        this.constructor.displayName + '.' + autoBindKey\n      ));\n    }\n  },\n\n  /**\n   * Binds a method to the component.\n   *\n   * @param {function} method Method to be bound.\n   * @private\n   */\n  _bindAutoBindMethod: function(method) {\n    var component = this;\n    var boundMethod = method.bind(component);\n    if (\"production\" !== process.env.NODE_ENV) {\n      boundMethod.__reactBoundContext = component;\n      boundMethod.__reactBoundMethod = method;\n      boundMethod.__reactBoundArguments = null;\n      var componentName = component.constructor.displayName;\n      var _bind = boundMethod.bind;\n      boundMethod.bind = function(newThis ) {for (var args=[],$__0=1,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n        // User is trying to bind() an autobound method; we effectively will\n        // ignore the value of \"this\" that the user is trying to use, so\n        // let's warn.\n        if (newThis !== component && newThis !== null) {\n          monitorCodeUse('react_bind_warning', { component: componentName });\n          console.warn(\n            'bind(): React component methods may only be bound to the ' +\n            'component instance. See ' + componentName\n          );\n        } else if (!args.length) {\n          monitorCodeUse('react_bind_warning', { component: componentName });\n          console.warn(\n            'bind(): You are binding a component method to the component. ' +\n            'React does this for you automatically in a high-performance ' +\n            'way, so you can safely remove this call. See ' + componentName\n          );\n          return boundMethod;\n        }\n        var reboundMethod = _bind.apply(boundMethod, arguments);\n        reboundMethod.__reactBoundContext = component;\n        reboundMethod.__reactBoundMethod = method;\n        reboundMethod.__reactBoundArguments = args;\n        return reboundMethod;\n      };\n    }\n    return boundMethod;\n  }\n};\n\nvar ReactCompositeComponentBase = function() {};\nassign(\n  ReactCompositeComponentBase.prototype,\n  ReactComponent.Mixin,\n  ReactOwner.Mixin,\n  ReactPropTransferer.Mixin,\n  ReactCompositeComponentMixin\n);\n\n/**\n * Module for creating composite components.\n *\n * @class ReactCompositeComponent\n * @extends ReactComponent\n * @extends ReactOwner\n * @extends ReactPropTransferer\n */\nvar ReactCompositeComponent = {\n\n  LifeCycle: CompositeLifeCycle,\n\n  Base: ReactCompositeComponentBase,\n\n  /**\n   * Creates a composite component class given a class specification.\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */\n  createClass: function(spec) {\n    var Constructor = function(props) {\n      // This constructor is overridden by mocks. The argument is used\n      // by mocks to assert on what gets mounted. This will later be used\n      // by the stand-alone class implementation.\n    };\n    Constructor.prototype = new ReactCompositeComponentBase();\n    Constructor.prototype.constructor = Constructor;\n\n    injectedMixins.forEach(\n      mixSpecIntoComponent.bind(null, Constructor)\n    );\n\n    mixSpecIntoComponent(Constructor, spec);\n\n    // Initialize the defaultProps property after all mixins have been merged\n    if (Constructor.getDefaultProps) {\n      Constructor.defaultProps = Constructor.getDefaultProps();\n    }\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      Constructor.prototype.render,\n      'createClass(...): Class specification must implement a `render` method.'\n    ) : invariant(Constructor.prototype.render));\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (Constructor.prototype.componentShouldUpdate) {\n        monitorCodeUse(\n          'react_component_should_update_warning',\n          { component: spec.displayName }\n        );\n        console.warn(\n          (spec.displayName || 'A component') + ' has a method called ' +\n          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +\n          'The name is phrased as a question because the function is ' +\n          'expected to return a value.'\n         );\n      }\n    }\n\n    // Reduce time spent doing lookups by setting these on the prototype.\n    for (var methodName in ReactCompositeComponentInterface) {\n      if (!Constructor.prototype[methodName]) {\n        Constructor.prototype[methodName] = null;\n      }\n    }\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      return ReactLegacyElement.wrapFactory(\n        ReactElementValidator.createFactory(Constructor)\n      );\n    }\n    return ReactLegacyElement.wrapFactory(\n      ReactElement.createFactory(Constructor)\n    );\n  },\n\n  injection: {\n    injectMixin: function(mixin) {\n      injectedMixins.push(mixin);\n    }\n  }\n};\n\nmodule.exports = ReactCompositeComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactCompositeComponent.js\n ** module id = 65\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactCompositeComponent.js?");

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactElementValidator\n */\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\nvar ReactPropTypeLocations = __webpack_require__(141);\nvar ReactCurrentOwner = __webpack_require__(27);\n\nvar monitorCodeUse = __webpack_require__(54);\nvar warning = __webpack_require__(38);\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {\n  'react_key_warning': {},\n  'react_numeric_key_warning': {}\n};\nvar ownerHasMonitoredObjectMap = {};\n\nvar loggedTypeFailures = {};\n\nvar NUMERIC_PROPERTY_REGEX = /^\\d+$/;\n\n/**\n * Gets the current owner's displayName for use in warnings.\n *\n * @internal\n * @return {?string} Display name or undefined\n */\nfunction getCurrentOwnerDisplayName() {\n  var current = ReactCurrentOwner.current;\n  return current && current.constructor.displayName || undefined;\n}\n\n/**\n * Warn if the component doesn't have an explicit key assigned to it.\n * This component is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it.\n *\n * @internal\n * @param {ReactComponent} component Component that requires a key.\n * @param {*} parentType component's parent's type.\n */\nfunction validateExplicitKey(component, parentType) {\n  if (component._store.validated || component.key != null) {\n    return;\n  }\n  component._store.validated = true;\n\n  warnAndMonitorForKeyUse(\n    'react_key_warning',\n    'Each child in an array should have a unique \"key\" prop.',\n    component,\n    parentType\n  );\n}\n\n/**\n * Warn if the key is being defined as an object property but has an incorrect\n * value.\n *\n * @internal\n * @param {string} name Property name of the key.\n * @param {ReactComponent} component Component that requires a key.\n * @param {*} parentType component's parent's type.\n */\nfunction validatePropertyKey(name, component, parentType) {\n  if (!NUMERIC_PROPERTY_REGEX.test(name)) {\n    return;\n  }\n  warnAndMonitorForKeyUse(\n    'react_numeric_key_warning',\n    'Child objects should have non-numeric keys so ordering is preserved.',\n    component,\n    parentType\n  );\n}\n\n/**\n * Shared warning and monitoring code for the key warnings.\n *\n * @internal\n * @param {string} warningID The id used when logging.\n * @param {string} message The base warning that gets output.\n * @param {ReactComponent} component Component that requires a key.\n * @param {*} parentType component's parent's type.\n */\nfunction warnAndMonitorForKeyUse(warningID, message, component, parentType) {\n  var ownerName = getCurrentOwnerDisplayName();\n  var parentName = parentType.displayName;\n\n  var useName = ownerName || parentName;\n  var memoizer = ownerHasKeyUseWarning[warningID];\n  if (memoizer.hasOwnProperty(useName)) {\n    return;\n  }\n  memoizer[useName] = true;\n\n  message += ownerName ?\n    (\" Check the render method of \" + ownerName + \".\") :\n    (\" Check the renderComponent call using <\" + parentName + \">.\");\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwnerName = null;\n  if (component._owner && component._owner !== ReactCurrentOwner.current) {\n    // Name of the component that originally created this child.\n    childOwnerName = component._owner.constructor.displayName;\n\n    message += (\" It was passed a child from \" + childOwnerName + \".\");\n  }\n\n  message += ' See http://fb.me/react-warning-keys for more information.';\n  monitorCodeUse(warningID, {\n    component: useName,\n    componentOwner: childOwnerName\n  });\n  console.warn(message);\n}\n\n/**\n * Log that we're using an object map. We're considering deprecating this\n * feature and replace it with proper Map and ImmutableMap data structures.\n *\n * @internal\n */\nfunction monitorUseOfObjectMap() {\n  var currentName = getCurrentOwnerDisplayName() || '';\n  if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {\n    return;\n  }\n  ownerHasMonitoredObjectMap[currentName] = true;\n  monitorCodeUse('react_object_map_children');\n}\n\n/**\n * Ensure that every component either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {*} component Statically passed child of any type.\n * @param {*} parentType component's parent's type.\n * @return {boolean}\n */\nfunction validateChildKeys(component, parentType) {\n  if (Array.isArray(component)) {\n    for (var i = 0; i < component.length; i++) {\n      var child = component[i];\n      if (ReactElement.isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (ReactElement.isValidElement(component)) {\n    // This component was passed in a valid location.\n    component._store.validated = true;\n  } else if (component && typeof component === 'object') {\n    monitorUseOfObjectMap();\n    for (var name in component) {\n      validatePropertyKey(name, component[name], parentType);\n    }\n  }\n}\n\n/**\n * Assert that the props are valid\n *\n * @param {string} componentName Name of the component for error messages.\n * @param {object} propTypes Map of prop name to a ReactPropType\n * @param {object} props\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @private\n */\nfunction checkPropTypes(componentName, propTypes, props, location) {\n  for (var propName in propTypes) {\n    if (propTypes.hasOwnProperty(propName)) {\n      var error;\n      // Prop type validation may throw. In case they do, we don't want to\n      // fail the render phase where it didn't fail before. So we log it.\n      // After these have been cleaned up, we'll let them throw.\n      try {\n        error = propTypes[propName](props, propName, componentName, location);\n      } catch (ex) {\n        error = ex;\n      }\n      if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n        // Only monitor this failure once because there tends to be a lot of the\n        // same error.\n        loggedTypeFailures[error.message] = true;\n        // This will soon use the warning module\n        monitorCodeUse(\n          'react_failed_descriptor_type_check',\n          { message: error.message }\n        );\n      }\n    }\n  }\n}\n\nvar ReactElementValidator = {\n\n  createElement: function(type, props, children) {\n    // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      type != null,\n      'React.createElement: type should not be null or undefined. It should ' +\n        'be a string (for DOM elements) or a ReactClass (for composite ' +\n        'components).'\n    ) : null);\n\n    var element = ReactElement.createElement.apply(this, arguments);\n\n    // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n    if (element == null) {\n      return element;\n    }\n\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n\n    if (type) {\n      var name = type.displayName;\n      if (type.propTypes) {\n        checkPropTypes(\n          name,\n          type.propTypes,\n          element.props,\n          ReactPropTypeLocations.prop\n        );\n      }\n      if (type.contextTypes) {\n        checkPropTypes(\n          name,\n          type.contextTypes,\n          element._context,\n          ReactPropTypeLocations.context\n        );\n      }\n    }\n    return element;\n  },\n\n  createFactory: function(type) {\n    var validatedFactory = ReactElementValidator.createElement.bind(\n      null,\n      type\n    );\n    validatedFactory.type = type;\n    return validatedFactory;\n  }\n\n};\n\nmodule.exports = ReactElementValidator;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactElementValidator.js\n ** module id = 66\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactElementValidator.js?");

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOM\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\nvar ReactElementValidator = __webpack_require__(66);\nvar ReactLegacyElement = __webpack_require__(29);\n\nvar mapObject = __webpack_require__(144);\n\n/**\n * Create a factory that creates HTML tag elements.\n *\n * @param {string} tag Tag name (e.g. `div`).\n * @private\n */\nfunction createDOMFactory(tag) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    return ReactLegacyElement.markNonLegacyFactory(\n      ReactElementValidator.createFactory(tag)\n    );\n  }\n  return ReactLegacyElement.markNonLegacyFactory(\n    ReactElement.createFactory(tag)\n  );\n}\n\n/**\n * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.\n * This is also accessible via `React.DOM`.\n *\n * @public\n */\nvar ReactDOM = mapObject({\n  a: 'a',\n  abbr: 'abbr',\n  address: 'address',\n  area: 'area',\n  article: 'article',\n  aside: 'aside',\n  audio: 'audio',\n  b: 'b',\n  base: 'base',\n  bdi: 'bdi',\n  bdo: 'bdo',\n  big: 'big',\n  blockquote: 'blockquote',\n  body: 'body',\n  br: 'br',\n  button: 'button',\n  canvas: 'canvas',\n  caption: 'caption',\n  cite: 'cite',\n  code: 'code',\n  col: 'col',\n  colgroup: 'colgroup',\n  data: 'data',\n  datalist: 'datalist',\n  dd: 'dd',\n  del: 'del',\n  details: 'details',\n  dfn: 'dfn',\n  dialog: 'dialog',\n  div: 'div',\n  dl: 'dl',\n  dt: 'dt',\n  em: 'em',\n  embed: 'embed',\n  fieldset: 'fieldset',\n  figcaption: 'figcaption',\n  figure: 'figure',\n  footer: 'footer',\n  form: 'form',\n  h1: 'h1',\n  h2: 'h2',\n  h3: 'h3',\n  h4: 'h4',\n  h5: 'h5',\n  h6: 'h6',\n  head: 'head',\n  header: 'header',\n  hr: 'hr',\n  html: 'html',\n  i: 'i',\n  iframe: 'iframe',\n  img: 'img',\n  input: 'input',\n  ins: 'ins',\n  kbd: 'kbd',\n  keygen: 'keygen',\n  label: 'label',\n  legend: 'legend',\n  li: 'li',\n  link: 'link',\n  main: 'main',\n  map: 'map',\n  mark: 'mark',\n  menu: 'menu',\n  menuitem: 'menuitem',\n  meta: 'meta',\n  meter: 'meter',\n  nav: 'nav',\n  noscript: 'noscript',\n  object: 'object',\n  ol: 'ol',\n  optgroup: 'optgroup',\n  option: 'option',\n  output: 'output',\n  p: 'p',\n  param: 'param',\n  picture: 'picture',\n  pre: 'pre',\n  progress: 'progress',\n  q: 'q',\n  rp: 'rp',\n  rt: 'rt',\n  ruby: 'ruby',\n  s: 's',\n  samp: 'samp',\n  script: 'script',\n  section: 'section',\n  select: 'select',\n  small: 'small',\n  source: 'source',\n  span: 'span',\n  strong: 'strong',\n  style: 'style',\n  sub: 'sub',\n  summary: 'summary',\n  sup: 'sup',\n  table: 'table',\n  tbody: 'tbody',\n  td: 'td',\n  textarea: 'textarea',\n  tfoot: 'tfoot',\n  th: 'th',\n  thead: 'thead',\n  time: 'time',\n  title: 'title',\n  tr: 'tr',\n  track: 'track',\n  u: 'u',\n  ul: 'ul',\n  'var': 'var',\n  video: 'video',\n  wbr: 'wbr',\n\n  // SVG\n  circle: 'circle',\n  defs: 'defs',\n  ellipse: 'ellipse',\n  g: 'g',\n  line: 'line',\n  linearGradient: 'linearGradient',\n  mask: 'mask',\n  path: 'path',\n  pattern: 'pattern',\n  polygon: 'polygon',\n  polyline: 'polyline',\n  radialGradient: 'radialGradient',\n  rect: 'rect',\n  stop: 'stop',\n  svg: 'svg',\n  text: 'text',\n  tspan: 'tspan'\n\n}, createDOMFactory);\n\nmodule.exports = ReactDOM;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOM.js\n ** module id = 67\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOM.js?");

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMComponent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar CSSPropertyOperations = __webpack_require__(145);\nvar DOMProperty = __webpack_require__(25);\nvar DOMPropertyOperations = __webpack_require__(61);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactComponent = __webpack_require__(64);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactMount = __webpack_require__(10);\nvar ReactMultiChild = __webpack_require__(70);\nvar ReactPerf = __webpack_require__(31);\n\nvar assign = __webpack_require__(51);\nvar escapeTextForBrowser = __webpack_require__(133);\nvar invariant = __webpack_require__(36);\nvar isEventSupported = __webpack_require__(52);\nvar keyOf = __webpack_require__(143);\nvar monitorCodeUse = __webpack_require__(54);\n\nvar deleteListener = ReactBrowserEventEmitter.deleteListener;\nvar listenTo = ReactBrowserEventEmitter.listenTo;\nvar registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;\n\n// For quickly matching children type, to test if can be treated as content.\nvar CONTENT_TYPES = {'string': true, 'number': true};\n\nvar STYLE = keyOf({style: null});\n\nvar ELEMENT_NODE_TYPE = 1;\n\n/**\n * @param {?object} props\n */\nfunction assertValidProps(props) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    props.children == null || props.dangerouslySetInnerHTML == null,\n    'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'\n  ) : invariant(props.children == null || props.dangerouslySetInnerHTML == null));\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (props.contentEditable && props.children != null) {\n      console.warn(\n        'A component is `contentEditable` and contains `children` managed by ' +\n        'React. It is now your responsibility to guarantee that none of those '+\n        'nodes are unexpectedly modified or duplicated. This is probably not ' +\n        'intentional.'\n      );\n    }\n  }\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    props.style == null || typeof props.style === 'object',\n    'The `style` prop expects a mapping from style properties to values, ' +\n    'not a string.'\n  ) : invariant(props.style == null || typeof props.style === 'object'));\n}\n\nfunction putListener(id, registrationName, listener, transaction) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    // IE8 has no API for event capturing and the `onScroll` event doesn't\n    // bubble.\n    if (registrationName === 'onScroll' &&\n        !isEventSupported('scroll', true)) {\n      monitorCodeUse('react_no_scroll_event');\n      console.warn('This browser doesn\\'t support the `onScroll` event');\n    }\n  }\n  var container = ReactMount.findReactContainerForID(id);\n  if (container) {\n    var doc = container.nodeType === ELEMENT_NODE_TYPE ?\n      container.ownerDocument :\n      container;\n    listenTo(registrationName, doc);\n  }\n  transaction.getPutListenerQueue().enqueuePutListener(\n    id,\n    registrationName,\n    listener\n  );\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special cased tags.\n\nvar omittedCloseTags = {\n  'area': true,\n  'base': true,\n  'br': true,\n  'col': true,\n  'embed': true,\n  'hr': true,\n  'img': true,\n  'input': true,\n  'keygen': true,\n  'link': true,\n  'meta': true,\n  'param': true,\n  'source': true,\n  'track': true,\n  'wbr': true\n  // NOTE: menuitem's close tag should be omitted, but that causes problems.\n};\n\n// We accept any tag to be rendered but since this gets injected into abitrary\n// HTML, we want to make sure that it's a safe tag.\n// http://www.w3.org/TR/REC-xml/#NT-Name\n\nvar VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/; // Simplified subset\nvar validatedTagCache = {};\nvar hasOwnProperty = {}.hasOwnProperty;\n\nfunction validateDangerousTag(tag) {\n  if (!hasOwnProperty.call(validatedTagCache, tag)) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(VALID_TAG_REGEX.test(tag), 'Invalid tag: %s', tag) : invariant(VALID_TAG_REGEX.test(tag)));\n    validatedTagCache[tag] = true;\n  }\n}\n\n/**\n * Creates a new React class that is idempotent and capable of containing other\n * React components. It accepts event listeners and DOM properties that are\n * valid according to `DOMProperty`.\n *\n *  - Event listeners: `onClick`, `onMouseDown`, etc.\n *  - DOM properties: `className`, `name`, `title`, etc.\n *\n * The `style` property functions differently from the DOM API. It accepts an\n * object mapping of style properties to values.\n *\n * @constructor ReactDOMComponent\n * @extends ReactComponent\n * @extends ReactMultiChild\n */\nfunction ReactDOMComponent(tag) {\n  validateDangerousTag(tag);\n  this._tag = tag;\n  this.tagName = tag.toUpperCase();\n}\n\nReactDOMComponent.displayName = 'ReactDOMComponent';\n\nReactDOMComponent.Mixin = {\n\n  /**\n   * Generates root tag markup then recurses. This method has side effects and\n   * is not idempotent.\n   *\n   * @internal\n   * @param {string} rootID The root DOM ID for this node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {number} mountDepth number of components in the owner hierarchy\n   * @return {string} The computed markup.\n   */\n  mountComponent: ReactPerf.measure(\n    'ReactDOMComponent',\n    'mountComponent',\n    function(rootID, transaction, mountDepth) {\n      ReactComponent.Mixin.mountComponent.call(\n        this,\n        rootID,\n        transaction,\n        mountDepth\n      );\n      assertValidProps(this.props);\n      var closeTag = omittedCloseTags[this._tag] ? '' : '</' + this._tag + '>';\n      return (\n        this._createOpenTagMarkupAndPutListeners(transaction) +\n        this._createContentMarkup(transaction) +\n        closeTag\n      );\n    }\n  ),\n\n  /**\n   * Creates markup for the open tag and all attributes.\n   *\n   * This method has side effects because events get registered.\n   *\n   * Iterating over object properties is faster than iterating over arrays.\n   * @see http://jsperf.com/obj-vs-arr-iteration\n   *\n   * @private\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Markup of opening tag.\n   */\n  _createOpenTagMarkupAndPutListeners: function(transaction) {\n    var props = this.props;\n    var ret = '<' + this._tag;\n\n    for (var propKey in props) {\n      if (!props.hasOwnProperty(propKey)) {\n        continue;\n      }\n      var propValue = props[propKey];\n      if (propValue == null) {\n        continue;\n      }\n      if (registrationNameModules.hasOwnProperty(propKey)) {\n        putListener(this._rootNodeID, propKey, propValue, transaction);\n      } else {\n        if (propKey === STYLE) {\n          if (propValue) {\n            propValue = props.style = assign({}, props.style);\n          }\n          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);\n        }\n        var markup =\n          DOMPropertyOperations.createMarkupForProperty(propKey, propValue);\n        if (markup) {\n          ret += ' ' + markup;\n        }\n      }\n    }\n\n    // For static pages, no need to put React ID and checksum. Saves lots of\n    // bytes.\n    if (transaction.renderToStaticMarkup) {\n      return ret + '>';\n    }\n\n    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);\n    return ret + ' ' + markupForID + '>';\n  },\n\n  /**\n   * Creates markup for the content between the tags.\n   *\n   * @private\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @return {string} Content markup.\n   */\n  _createContentMarkup: function(transaction) {\n    // Intentional use of != to avoid catching zero/false.\n    var innerHTML = this.props.dangerouslySetInnerHTML;\n    if (innerHTML != null) {\n      if (innerHTML.__html != null) {\n        return innerHTML.__html;\n      }\n    } else {\n      var contentToUse =\n        CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;\n      var childrenToUse = contentToUse != null ? null : this.props.children;\n      if (contentToUse != null) {\n        return escapeTextForBrowser(contentToUse);\n      } else if (childrenToUse != null) {\n        var mountImages = this.mountChildren(\n          childrenToUse,\n          transaction\n        );\n        return mountImages.join('');\n      }\n    }\n    return '';\n  },\n\n  receiveComponent: function(nextElement, transaction) {\n    if (nextElement === this._currentElement &&\n        nextElement._owner != null) {\n      // Since elements are immutable after the owner is rendered,\n      // we can do a cheap identity compare here to determine if this is a\n      // superfluous reconcile. It's possible for state to be mutable but such\n      // change should trigger an update of the owner which would recreate\n      // the element. We explicitly check for the existence of an owner since\n      // it's possible for a element created outside a composite to be\n      // deeply mutated and reused.\n      return;\n    }\n\n    ReactComponent.Mixin.receiveComponent.call(\n      this,\n      nextElement,\n      transaction\n    );\n  },\n\n  /**\n   * Updates a native DOM component after it has already been allocated and\n   * attached to the DOM. Reconciles the root DOM node, then recurses.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: ReactPerf.measure(\n    'ReactDOMComponent',\n    'updateComponent',\n    function(transaction, prevElement) {\n      assertValidProps(this._currentElement.props);\n      ReactComponent.Mixin.updateComponent.call(\n        this,\n        transaction,\n        prevElement\n      );\n      this._updateDOMProperties(prevElement.props, transaction);\n      this._updateDOMChildren(prevElement.props, transaction);\n    }\n  ),\n\n  /**\n   * Reconciles the properties by detecting differences in property values and\n   * updating the DOM as necessary. This function is probably the single most\n   * critical path for performance optimization.\n   *\n   * TODO: Benchmark whether checking for changed values in memory actually\n   *       improves performance (especially statically positioned elements).\n   * TODO: Benchmark the effects of putting this at the top since 99% of props\n   *       do not change for a given reconciliation.\n   * TODO: Benchmark areas that can be improved with caching.\n   *\n   * @private\n   * @param {object} lastProps\n   * @param {ReactReconcileTransaction} transaction\n   */\n  _updateDOMProperties: function(lastProps, transaction) {\n    var nextProps = this.props;\n    var propKey;\n    var styleName;\n    var styleUpdates;\n    for (propKey in lastProps) {\n      if (nextProps.hasOwnProperty(propKey) ||\n         !lastProps.hasOwnProperty(propKey)) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        var lastStyle = lastProps[propKey];\n        for (styleName in lastStyle) {\n          if (lastStyle.hasOwnProperty(styleName)) {\n            styleUpdates = styleUpdates || {};\n            styleUpdates[styleName] = '';\n          }\n        }\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        deleteListener(this._rootNodeID, propKey);\n      } else if (\n          DOMProperty.isStandardName[propKey] ||\n          DOMProperty.isCustomAttribute(propKey)) {\n        ReactComponent.BackendIDOperations.deletePropertyByID(\n          this._rootNodeID,\n          propKey\n        );\n      }\n    }\n    for (propKey in nextProps) {\n      var nextProp = nextProps[propKey];\n      var lastProp = lastProps[propKey];\n      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {\n        continue;\n      }\n      if (propKey === STYLE) {\n        if (nextProp) {\n          nextProp = nextProps.style = assign({}, nextProp);\n        }\n        if (lastProp) {\n          // Unset styles on `lastProp` but not on `nextProp`.\n          for (styleName in lastProp) {\n            if (lastProp.hasOwnProperty(styleName) &&\n                (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = '';\n            }\n          }\n          // Update styles that changed since `lastProp`.\n          for (styleName in nextProp) {\n            if (nextProp.hasOwnProperty(styleName) &&\n                lastProp[styleName] !== nextProp[styleName]) {\n              styleUpdates = styleUpdates || {};\n              styleUpdates[styleName] = nextProp[styleName];\n            }\n          }\n        } else {\n          // Relies on `updateStylesByID` not mutating `styleUpdates`.\n          styleUpdates = nextProp;\n        }\n      } else if (registrationNameModules.hasOwnProperty(propKey)) {\n        putListener(this._rootNodeID, propKey, nextProp, transaction);\n      } else if (\n          DOMProperty.isStandardName[propKey] ||\n          DOMProperty.isCustomAttribute(propKey)) {\n        ReactComponent.BackendIDOperations.updatePropertyByID(\n          this._rootNodeID,\n          propKey,\n          nextProp\n        );\n      }\n    }\n    if (styleUpdates) {\n      ReactComponent.BackendIDOperations.updateStylesByID(\n        this._rootNodeID,\n        styleUpdates\n      );\n    }\n  },\n\n  /**\n   * Reconciles the children with the various properties that affect the\n   * children content.\n   *\n   * @param {object} lastProps\n   * @param {ReactReconcileTransaction} transaction\n   */\n  _updateDOMChildren: function(lastProps, transaction) {\n    var nextProps = this.props;\n\n    var lastContent =\n      CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;\n    var nextContent =\n      CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;\n\n    var lastHtml =\n      lastProps.dangerouslySetInnerHTML &&\n      lastProps.dangerouslySetInnerHTML.__html;\n    var nextHtml =\n      nextProps.dangerouslySetInnerHTML &&\n      nextProps.dangerouslySetInnerHTML.__html;\n\n    // Note the use of `!=` which checks for null or undefined.\n    var lastChildren = lastContent != null ? null : lastProps.children;\n    var nextChildren = nextContent != null ? null : nextProps.children;\n\n    // If we're switching from children to content/html or vice versa, remove\n    // the old content\n    var lastHasContentOrHtml = lastContent != null || lastHtml != null;\n    var nextHasContentOrHtml = nextContent != null || nextHtml != null;\n    if (lastChildren != null && nextChildren == null) {\n      this.updateChildren(null, transaction);\n    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {\n      this.updateTextContent('');\n    }\n\n    if (nextContent != null) {\n      if (lastContent !== nextContent) {\n        this.updateTextContent('' + nextContent);\n      }\n    } else if (nextHtml != null) {\n      if (lastHtml !== nextHtml) {\n        ReactComponent.BackendIDOperations.updateInnerHTMLByID(\n          this._rootNodeID,\n          nextHtml\n        );\n      }\n    } else if (nextChildren != null) {\n      this.updateChildren(nextChildren, transaction);\n    }\n  },\n\n  /**\n   * Destroys all event registrations for this instance. Does not remove from\n   * the DOM. That must be done by the parent.\n   *\n   * @internal\n   */\n  unmountComponent: function() {\n    this.unmountChildren();\n    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);\n    ReactComponent.Mixin.unmountComponent.call(this);\n  }\n\n};\n\nassign(\n  ReactDOMComponent.prototype,\n  ReactComponent.Mixin,\n  ReactDOMComponent.Mixin,\n  ReactMultiChild.Mixin,\n  ReactBrowserComponentMixin\n);\n\nmodule.exports = ReactDOMComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMComponent.js\n ** module id = 68\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMComponent.js?");

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultInjection\n */\n\n\"use strict\";\n\nvar BeforeInputEventPlugin = __webpack_require__(147);\nvar ChangeEventPlugin = __webpack_require__(148);\nvar ClientReactRootIndex = __webpack_require__(149);\nvar CompositionEventPlugin = __webpack_require__(150);\nvar DefaultEventPluginOrder = __webpack_require__(151);\nvar EnterLeaveEventPlugin = __webpack_require__(152);\nvar ExecutionEnvironment = __webpack_require__(75);\nvar HTMLDOMPropertyConfig = __webpack_require__(153);\nvar MobileSafariClickEventPlugin = __webpack_require__(154);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactComponentBrowserEnvironment =\n  __webpack_require__(155);\nvar ReactDefaultBatchingStrategy = __webpack_require__(156);\nvar ReactDOMComponent = __webpack_require__(68);\nvar ReactDOMButton = __webpack_require__(157);\nvar ReactDOMForm = __webpack_require__(158);\nvar ReactDOMImg = __webpack_require__(159);\nvar ReactDOMInput = __webpack_require__(160);\nvar ReactDOMOption = __webpack_require__(161);\nvar ReactDOMSelect = __webpack_require__(162);\nvar ReactDOMTextarea = __webpack_require__(163);\nvar ReactEventListener = __webpack_require__(164);\nvar ReactInjection = __webpack_require__(165);\nvar ReactInstanceHandles = __webpack_require__(30);\nvar ReactMount = __webpack_require__(10);\nvar SelectEventPlugin = __webpack_require__(166);\nvar ServerReactRootIndex = __webpack_require__(167);\nvar SimpleEventPlugin = __webpack_require__(168);\nvar SVGDOMPropertyConfig = __webpack_require__(169);\n\nvar createFullPageComponent = __webpack_require__(170);\n\nfunction inject() {\n  ReactInjection.EventEmitter.injectReactEventListener(\n    ReactEventListener\n  );\n\n  /**\n   * Inject modules for resolving DOM hierarchy and plugin ordering.\n   */\n  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);\n  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);\n  ReactInjection.EventPluginHub.injectMount(ReactMount);\n\n  /**\n   * Some important event plugins included by default (without having to require\n   * them).\n   */\n  ReactInjection.EventPluginHub.injectEventPluginsByName({\n    SimpleEventPlugin: SimpleEventPlugin,\n    EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n    ChangeEventPlugin: ChangeEventPlugin,\n    CompositionEventPlugin: CompositionEventPlugin,\n    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,\n    SelectEventPlugin: SelectEventPlugin,\n    BeforeInputEventPlugin: BeforeInputEventPlugin\n  });\n\n  ReactInjection.NativeComponent.injectGenericComponentClass(\n    ReactDOMComponent\n  );\n\n  ReactInjection.NativeComponent.injectComponentClasses({\n    'button': ReactDOMButton,\n    'form': ReactDOMForm,\n    'img': ReactDOMImg,\n    'input': ReactDOMInput,\n    'option': ReactDOMOption,\n    'select': ReactDOMSelect,\n    'textarea': ReactDOMTextarea,\n\n    'html': createFullPageComponent('html'),\n    'head': createFullPageComponent('head'),\n    'body': createFullPageComponent('body')\n  });\n\n  // This needs to happen after createFullPageComponent() otherwise the mixin\n  // gets double injected.\n  ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);\n\n  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);\n  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);\n\n  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');\n\n  ReactInjection.Updates.injectReconcileTransaction(\n    ReactComponentBrowserEnvironment.ReactReconcileTransaction\n  );\n  ReactInjection.Updates.injectBatchingStrategy(\n    ReactDefaultBatchingStrategy\n  );\n\n  ReactInjection.RootIndex.injectCreateReactRootIndex(\n    ExecutionEnvironment.canUseDOM ?\n      ClientReactRootIndex.createReactRootIndex :\n      ServerReactRootIndex.createReactRootIndex\n  );\n\n  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';\n    if ((/[?&]react_perf\\b/).test(url)) {\n      var ReactDefaultPerf = __webpack_require__(171);\n      ReactDefaultPerf.start();\n    }\n  }\n}\n\nmodule.exports = {\n  inject: inject\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultInjection.js\n ** module id = 69\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultInjection.js?");

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChild\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar ReactComponent = __webpack_require__(64);\nvar ReactMultiChildUpdateTypes = __webpack_require__(172);\n\nvar flattenChildren = __webpack_require__(173);\nvar instantiateReactComponent = __webpack_require__(35);\nvar shouldUpdateReactComponent = __webpack_require__(37);\n\n/**\n * Updating children of a component may trigger recursive updates. The depth is\n * used to batch recursive updates to render markup more efficiently.\n *\n * @type {number}\n * @private\n */\nvar updateDepth = 0;\n\n/**\n * Queue of update configuration objects.\n *\n * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.\n *\n * @type {array<object>}\n * @private\n */\nvar updateQueue = [];\n\n/**\n * Queue of markup to be rendered.\n *\n * @type {array<string>}\n * @private\n */\nvar markupQueue = [];\n\n/**\n * Enqueues markup to be rendered and inserted at a supplied index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} markup Markup that renders into an element.\n * @param {number} toIndex Destination index.\n * @private\n */\nfunction enqueueMarkup(parentID, markup, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,\n    markupIndex: markupQueue.push(markup) - 1,\n    textContent: null,\n    fromIndex: null,\n    toIndex: toIndex\n  });\n}\n\n/**\n * Enqueues moving an existing element to another index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {number} fromIndex Source index of the existing element.\n * @param {number} toIndex Destination index of the element.\n * @private\n */\nfunction enqueueMove(parentID, fromIndex, toIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,\n    markupIndex: null,\n    textContent: null,\n    fromIndex: fromIndex,\n    toIndex: toIndex\n  });\n}\n\n/**\n * Enqueues removing an element at an index.\n *\n * @param {string} parentID ID of the parent component.\n * @param {number} fromIndex Index of the element to remove.\n * @private\n */\nfunction enqueueRemove(parentID, fromIndex) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.REMOVE_NODE,\n    markupIndex: null,\n    textContent: null,\n    fromIndex: fromIndex,\n    toIndex: null\n  });\n}\n\n/**\n * Enqueues setting the text content.\n *\n * @param {string} parentID ID of the parent component.\n * @param {string} textContent Text content to set.\n * @private\n */\nfunction enqueueTextContent(parentID, textContent) {\n  // NOTE: Null values reduce hidden classes.\n  updateQueue.push({\n    parentID: parentID,\n    parentNode: null,\n    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,\n    markupIndex: null,\n    textContent: textContent,\n    fromIndex: null,\n    toIndex: null\n  });\n}\n\n/**\n * Processes any enqueued updates.\n *\n * @private\n */\nfunction processQueue() {\n  if (updateQueue.length) {\n    ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(\n      updateQueue,\n      markupQueue\n    );\n    clearQueue();\n  }\n}\n\n/**\n * Clears any enqueued updates.\n *\n * @private\n */\nfunction clearQueue() {\n  updateQueue.length = 0;\n  markupQueue.length = 0;\n}\n\n/**\n * ReactMultiChild are capable of reconciling multiple children.\n *\n * @class ReactMultiChild\n * @internal\n */\nvar ReactMultiChild = {\n\n  /**\n   * Provides common functionality for components that must reconcile multiple\n   * children. This is used by `ReactDOMComponent` to mount, update, and\n   * unmount child components.\n   *\n   * @lends {ReactMultiChild.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Generates a \"mount image\" for each of the supplied children. In the case\n     * of `ReactDOMComponent`, a mount image is a string of markup.\n     *\n     * @param {?object} nestedChildren Nested child maps.\n     * @return {array} An array of mounted representations.\n     * @internal\n     */\n    mountChildren: function(nestedChildren, transaction) {\n      var children = flattenChildren(nestedChildren);\n      var mountImages = [];\n      var index = 0;\n      this._renderedChildren = children;\n      for (var name in children) {\n        var child = children[name];\n        if (children.hasOwnProperty(name)) {\n          // The rendered children must be turned into instances as they're\n          // mounted.\n          var childInstance = instantiateReactComponent(child, null);\n          children[name] = childInstance;\n          // Inlined for performance, see `ReactInstanceHandles.createReactID`.\n          var rootID = this._rootNodeID + name;\n          var mountImage = childInstance.mountComponent(\n            rootID,\n            transaction,\n            this._mountDepth + 1\n          );\n          childInstance._mountIndex = index;\n          mountImages.push(mountImage);\n          index++;\n        }\n      }\n      return mountImages;\n    },\n\n    /**\n     * Replaces any rendered children with a text content string.\n     *\n     * @param {string} nextContent String of content.\n     * @internal\n     */\n    updateTextContent: function(nextContent) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        var prevChildren = this._renderedChildren;\n        // Remove any rendered children.\n        for (var name in prevChildren) {\n          if (prevChildren.hasOwnProperty(name)) {\n            this._unmountChildByName(prevChildren[name], name);\n          }\n        }\n        // Set new text content.\n        this.setTextContent(nextContent);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          errorThrown ? clearQueue() : processQueue();\n        }\n      }\n    },\n\n    /**\n     * Updates the rendered children with new children.\n     *\n     * @param {?object} nextNestedChildren Nested child maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     */\n    updateChildren: function(nextNestedChildren, transaction) {\n      updateDepth++;\n      var errorThrown = true;\n      try {\n        this._updateChildren(nextNestedChildren, transaction);\n        errorThrown = false;\n      } finally {\n        updateDepth--;\n        if (!updateDepth) {\n          errorThrown ? clearQueue() : processQueue();\n        }\n      }\n    },\n\n    /**\n     * Improve performance by isolating this hot code path from the try/catch\n     * block in `updateChildren`.\n     *\n     * @param {?object} nextNestedChildren Nested child maps.\n     * @param {ReactReconcileTransaction} transaction\n     * @final\n     * @protected\n     */\n    _updateChildren: function(nextNestedChildren, transaction) {\n      var nextChildren = flattenChildren(nextNestedChildren);\n      var prevChildren = this._renderedChildren;\n      if (!nextChildren && !prevChildren) {\n        return;\n      }\n      var name;\n      // `nextIndex` will increment for each child in `nextChildren`, but\n      // `lastIndex` will be the last index visited in `prevChildren`.\n      var lastIndex = 0;\n      var nextIndex = 0;\n      for (name in nextChildren) {\n        if (!nextChildren.hasOwnProperty(name)) {\n          continue;\n        }\n        var prevChild = prevChildren && prevChildren[name];\n        var prevElement = prevChild && prevChild._currentElement;\n        var nextElement = nextChildren[name];\n        if (shouldUpdateReactComponent(prevElement, nextElement)) {\n          this.moveChild(prevChild, nextIndex, lastIndex);\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          prevChild.receiveComponent(nextElement, transaction);\n          prevChild._mountIndex = nextIndex;\n        } else {\n          if (prevChild) {\n            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n            lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n            this._unmountChildByName(prevChild, name);\n          }\n          // The child must be instantiated before it's mounted.\n          var nextChildInstance = instantiateReactComponent(\n            nextElement,\n            null\n          );\n          this._mountChildByNameAtIndex(\n            nextChildInstance, name, nextIndex, transaction\n          );\n        }\n        nextIndex++;\n      }\n      // Remove children that are no longer present.\n      for (name in prevChildren) {\n        if (prevChildren.hasOwnProperty(name) &&\n            !(nextChildren && nextChildren[name])) {\n          this._unmountChildByName(prevChildren[name], name);\n        }\n      }\n    },\n\n    /**\n     * Unmounts all rendered children. This should be used to clean up children\n     * when this component is unmounted.\n     *\n     * @internal\n     */\n    unmountChildren: function() {\n      var renderedChildren = this._renderedChildren;\n      for (var name in renderedChildren) {\n        var renderedChild = renderedChildren[name];\n        // TODO: When is this not true?\n        if (renderedChild.unmountComponent) {\n          renderedChild.unmountComponent();\n        }\n      }\n      this._renderedChildren = null;\n    },\n\n    /**\n     * Moves a child component to the supplied index.\n     *\n     * @param {ReactComponent} child Component to move.\n     * @param {number} toIndex Destination index of the element.\n     * @param {number} lastIndex Last index visited of the siblings of `child`.\n     * @protected\n     */\n    moveChild: function(child, toIndex, lastIndex) {\n      // If the index of `child` is less than `lastIndex`, then it needs to\n      // be moved. Otherwise, we do not need to move it because a child will be\n      // inserted or moved before `child`.\n      if (child._mountIndex < lastIndex) {\n        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);\n      }\n    },\n\n    /**\n     * Creates a child component.\n     *\n     * @param {ReactComponent} child Component to create.\n     * @param {string} mountImage Markup to insert.\n     * @protected\n     */\n    createChild: function(child, mountImage) {\n      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);\n    },\n\n    /**\n     * Removes a child component.\n     *\n     * @param {ReactComponent} child Child to remove.\n     * @protected\n     */\n    removeChild: function(child) {\n      enqueueRemove(this._rootNodeID, child._mountIndex);\n    },\n\n    /**\n     * Sets this text content string.\n     *\n     * @param {string} textContent Text content to set.\n     * @protected\n     */\n    setTextContent: function(textContent) {\n      enqueueTextContent(this._rootNodeID, textContent);\n    },\n\n    /**\n     * Mounts a child with the supplied name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to mount.\n     * @param {string} name Name of the child.\n     * @param {number} index Index at which to insert the child.\n     * @param {ReactReconcileTransaction} transaction\n     * @private\n     */\n    _mountChildByNameAtIndex: function(child, name, index, transaction) {\n      // Inlined for performance, see `ReactInstanceHandles.createReactID`.\n      var rootID = this._rootNodeID + name;\n      var mountImage = child.mountComponent(\n        rootID,\n        transaction,\n        this._mountDepth + 1\n      );\n      child._mountIndex = index;\n      this.createChild(child, mountImage);\n      this._renderedChildren = this._renderedChildren || {};\n      this._renderedChildren[name] = child;\n    },\n\n    /**\n     * Unmounts a rendered child by name.\n     *\n     * NOTE: This is part of `updateChildren` and is here for readability.\n     *\n     * @param {ReactComponent} child Component to unmount.\n     * @param {string} name Name of the child in `this._renderedChildren`.\n     * @private\n     */\n    _unmountChildByName: function(child, name) {\n      this.removeChild(child);\n      child._mountIndex = null;\n      child.unmountComponent();\n      delete this._renderedChildren[name];\n    }\n\n  }\n\n};\n\nmodule.exports = ReactMultiChild;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMultiChild.js\n ** module id = 70\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMultiChild.js?");

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypes\n */\n\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\nvar ReactPropTypeLocationNames = __webpack_require__(142);\n\nvar deprecated = __webpack_require__(33);\nvar emptyFunction = __webpack_require__(59);\n\n/**\n * Collection of methods that allow declaration and validation of props that are\n * supplied to React components. Example usage:\n *\n *   var Props = require('ReactPropTypes');\n *   var MyArticle = React.createClass({\n *     propTypes: {\n *       // An optional string prop named \"description\".\n *       description: Props.string,\n *\n *       // A required enum prop named \"category\".\n *       category: Props.oneOf(['News','Photos']).isRequired,\n *\n *       // A prop named \"dialog\" that requires an instance of Dialog.\n *       dialog: Props.instanceOf(Dialog).isRequired\n *     },\n *     render: function() { ... }\n *   });\n *\n * A more formal specification of how these methods are used:\n *\n *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n *   decl := ReactPropTypes.{type}(.isRequired)?\n *\n * Each and every declaration produces a function with the same signature. This\n * allows the creation of custom validation functions. For example:\n *\n *  var MyLink = React.createClass({\n *    propTypes: {\n *      // An optional string or URI prop named \"href\".\n *      href: function(props, propName, componentName) {\n *        var propValue = props[propName];\n *        if (propValue != null && typeof propValue !== 'string' &&\n *            !(propValue instanceof URI)) {\n *          return new Error(\n *            'Expected a string or an URI for ' + propName + ' in ' +\n *            componentName\n *          );\n *        }\n *      }\n *    },\n *    render: function() {...}\n *  });\n *\n * @internal\n */\n\nvar ANONYMOUS = '<<anonymous>>';\n\nvar elementTypeChecker = createElementTypeChecker();\nvar nodeTypeChecker = createNodeChecker();\n\nvar ReactPropTypes = {\n  array: createPrimitiveTypeChecker('array'),\n  bool: createPrimitiveTypeChecker('boolean'),\n  func: createPrimitiveTypeChecker('function'),\n  number: createPrimitiveTypeChecker('number'),\n  object: createPrimitiveTypeChecker('object'),\n  string: createPrimitiveTypeChecker('string'),\n\n  any: createAnyTypeChecker(),\n  arrayOf: createArrayOfTypeChecker,\n  element: elementTypeChecker,\n  instanceOf: createInstanceTypeChecker,\n  node: nodeTypeChecker,\n  objectOf: createObjectOfTypeChecker,\n  oneOf: createEnumTypeChecker,\n  oneOfType: createUnionTypeChecker,\n  shape: createShapeTypeChecker,\n\n  component: deprecated(\n    'React.PropTypes',\n    'component',\n    'element',\n    this,\n    elementTypeChecker\n  ),\n  renderable: deprecated(\n    'React.PropTypes',\n    'renderable',\n    'node',\n    this,\n    nodeTypeChecker\n  )\n};\n\nfunction createChainableTypeChecker(validate) {\n  function checkType(isRequired, props, propName, componentName, location) {\n    componentName = componentName || ANONYMOUS;\n    if (props[propName] == null) {\n      var locationName = ReactPropTypeLocationNames[location];\n      if (isRequired) {\n        return new Error(\n          (\"Required \" + locationName + \" `\" + propName + \"` was not specified in \")+\n          (\"`\" + componentName + \"`.\")\n        );\n      }\n    } else {\n      return validate(props, propName, componentName, location);\n    }\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nfunction createPrimitiveTypeChecker(expectedType) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== expectedType) {\n      var locationName = ReactPropTypeLocationNames[location];\n      // `propValue` being instance of, say, date/regexp, pass the 'object'\n      // check, but we can offer a more precise error message here rather than\n      // 'of type `object`'.\n      var preciseType = getPreciseType(propValue);\n\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` of type `\" + preciseType + \"` \") +\n        (\"supplied to `\" + componentName + \"`, expected `\" + expectedType + \"`.\")\n      );\n    }\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createAnyTypeChecker() {\n  return createChainableTypeChecker(emptyFunction.thatReturns());\n}\n\nfunction createArrayOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    if (!Array.isArray(propValue)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var propType = getPropType(propValue);\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` of type \") +\n        (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\")\n      );\n    }\n    for (var i = 0; i < propValue.length; i++) {\n      var error = typeChecker(propValue, i, componentName, location);\n      if (error instanceof Error) {\n        return error;\n      }\n    }\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createElementTypeChecker() {\n  function validate(props, propName, componentName, location) {\n    if (!ReactElement.isValidElement(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` supplied to \") +\n        (\"`\" + componentName + \"`, expected a ReactElement.\")\n      );\n    }\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createInstanceTypeChecker(expectedClass) {\n  function validate(props, propName, componentName, location) {\n    if (!(props[propName] instanceof expectedClass)) {\n      var locationName = ReactPropTypeLocationNames[location];\n      var expectedClassName = expectedClass.name || ANONYMOUS;\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` supplied to \") +\n        (\"`\" + componentName + \"`, expected instance of `\" + expectedClassName + \"`.\")\n      );\n    }\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createEnumTypeChecker(expectedValues) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    for (var i = 0; i < expectedValues.length; i++) {\n      if (propValue === expectedValues[i]) {\n        return;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    var valuesString = JSON.stringify(expectedValues);\n    return new Error(\n      (\"Invalid \" + locationName + \" `\" + propName + \"` of value `\" + propValue + \"` \") +\n      (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\")\n    );\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createObjectOfTypeChecker(typeChecker) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== 'object') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` of type \") +\n        (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\")\n      );\n    }\n    for (var key in propValue) {\n      if (propValue.hasOwnProperty(key)) {\n        var error = typeChecker(propValue, key, componentName, location);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n    }\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createUnionTypeChecker(arrayOfTypeCheckers) {\n  function validate(props, propName, componentName, location) {\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (checker(props, propName, componentName, location) == null) {\n        return;\n      }\n    }\n\n    var locationName = ReactPropTypeLocationNames[location];\n    return new Error(\n      (\"Invalid \" + locationName + \" `\" + propName + \"` supplied to \") +\n      (\"`\" + componentName + \"`.\")\n    );\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createNodeChecker() {\n  function validate(props, propName, componentName, location) {\n    if (!isNode(props[propName])) {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` supplied to \") +\n        (\"`\" + componentName + \"`, expected a ReactNode.\")\n      );\n    }\n  }\n  return createChainableTypeChecker(validate);\n}\n\nfunction createShapeTypeChecker(shapeTypes) {\n  function validate(props, propName, componentName, location) {\n    var propValue = props[propName];\n    var propType = getPropType(propValue);\n    if (propType !== 'object') {\n      var locationName = ReactPropTypeLocationNames[location];\n      return new Error(\n        (\"Invalid \" + locationName + \" `\" + propName + \"` of type `\" + propType + \"` \") +\n        (\"supplied to `\" + componentName + \"`, expected `object`.\")\n      );\n    }\n    for (var key in shapeTypes) {\n      var checker = shapeTypes[key];\n      if (!checker) {\n        continue;\n      }\n      var error = checker(propValue, key, componentName, location);\n      if (error) {\n        return error;\n      }\n    }\n  }\n  return createChainableTypeChecker(validate, 'expected `object`');\n}\n\nfunction isNode(propValue) {\n  switch(typeof propValue) {\n    case 'number':\n    case 'string':\n      return true;\n    case 'boolean':\n      return !propValue;\n    case 'object':\n      if (Array.isArray(propValue)) {\n        return propValue.every(isNode);\n      }\n      if (ReactElement.isValidElement(propValue)) {\n        return true;\n      }\n      for (var k in propValue) {\n        if (!isNode(propValue[k])) {\n          return false;\n        }\n      }\n      return true;\n    default:\n      return false;\n  }\n}\n\n// Equivalent of `typeof` but with special handling for array and regexp.\nfunction getPropType(propValue) {\n  var propType = typeof propValue;\n  if (Array.isArray(propValue)) {\n    return 'array';\n  }\n  if (propValue instanceof RegExp) {\n    // Old webkits (at least until Android 4.0) return 'function' rather than\n    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n    // passes PropTypes.object.\n    return 'object';\n  }\n  return propType;\n}\n\n// This handles more types than `getPropType`. Only used for error messages.\n// See `createPrimitiveTypeChecker`.\nfunction getPreciseType(propValue) {\n  var propType = getPropType(propValue);\n  if (propType === 'object') {\n    if (propValue instanceof Date) {\n      return 'date';\n    } else if (propValue instanceof RegExp) {\n      return 'regexp';\n    }\n  }\n  return propType;\n}\n\nmodule.exports = ReactPropTypes;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypes.js\n ** module id = 71\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypes.js?");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @typechecks static-only\n * @providesModule ReactServerRendering\n */\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\nvar ReactInstanceHandles = __webpack_require__(30);\nvar ReactMarkupChecksum = __webpack_require__(174);\nvar ReactServerRenderingTransaction =\n  __webpack_require__(175);\n\nvar instantiateReactComponent = __webpack_require__(35);\nvar invariant = __webpack_require__(36);\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup\n */\nfunction renderToString(element) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactElement.isValidElement(element),\n    'renderToString(): You must pass a valid ReactElement.'\n  ) : invariant(ReactElement.isValidElement(element)));\n\n  var transaction;\n  try {\n    var id = ReactInstanceHandles.createReactRootID();\n    transaction = ReactServerRenderingTransaction.getPooled(false);\n\n    return transaction.perform(function() {\n      var componentInstance = instantiateReactComponent(element, null);\n      var markup = componentInstance.mountComponent(id, transaction, 0);\n      return ReactMarkupChecksum.addChecksumToMarkup(markup);\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n  }\n}\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup, without the extra React ID and checksum\n * (for generating static pages)\n */\nfunction renderToStaticMarkup(element) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactElement.isValidElement(element),\n    'renderToStaticMarkup(): You must pass a valid ReactElement.'\n  ) : invariant(ReactElement.isValidElement(element)));\n\n  var transaction;\n  try {\n    var id = ReactInstanceHandles.createReactRootID();\n    transaction = ReactServerRenderingTransaction.getPooled(true);\n\n    return transaction.perform(function() {\n      var componentInstance = instantiateReactComponent(element, null);\n      return componentInstance.mountComponent(id, transaction, 0);\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n  }\n}\n\nmodule.exports = {\n  renderToString: renderToString,\n  renderToStaticMarkup: renderToStaticMarkup\n};\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerRendering.js\n ** module id = 72\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerRendering.js?");

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactTextComponent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar DOMPropertyOperations = __webpack_require__(61);\nvar ReactComponent = __webpack_require__(64);\nvar ReactElement = __webpack_require__(28);\n\nvar assign = __webpack_require__(51);\nvar escapeTextForBrowser = __webpack_require__(133);\n\n/**\n * Text nodes violate a couple assumptions that React makes about components:\n *\n *  - When mounting text into the DOM, adjacent text nodes are merged.\n *  - Text nodes cannot be assigned a React root ID.\n *\n * This component is used to wrap strings in elements so that they can undergo\n * the same reconciliation that is applied to elements.\n *\n * TODO: Investigate representing React components in the DOM with text nodes.\n *\n * @class ReactTextComponent\n * @extends ReactComponent\n * @internal\n */\nvar ReactTextComponent = function(props) {\n  // This constructor and it's argument is currently used by mocks.\n};\n\nassign(ReactTextComponent.prototype, ReactComponent.Mixin, {\n\n  /**\n   * Creates the markup for this text node. This node is not intended to have\n   * any features besides containing text content.\n   *\n   * @param {string} rootID DOM ID of the root node.\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {number} mountDepth number of components in the owner hierarchy\n   * @return {string} Markup for this text node.\n   * @internal\n   */\n  mountComponent: function(rootID, transaction, mountDepth) {\n    ReactComponent.Mixin.mountComponent.call(\n      this,\n      rootID,\n      transaction,\n      mountDepth\n    );\n\n    var escapedText = escapeTextForBrowser(this.props);\n\n    if (transaction.renderToStaticMarkup) {\n      // Normally we'd wrap this in a `span` for the reasons stated above, but\n      // since this is a situation where React won't take over (static pages),\n      // we can simply return the text as it is.\n      return escapedText;\n    }\n\n    return (\n      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +\n        escapedText +\n      '</span>'\n    );\n  },\n\n  /**\n   * Updates this component by updating the text content.\n   *\n   * @param {object} nextComponent Contains the next text content.\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  receiveComponent: function(nextComponent, transaction) {\n    var nextProps = nextComponent.props;\n    if (nextProps !== this.props) {\n      this.props = nextProps;\n      ReactComponent.BackendIDOperations.updateTextContentByID(\n        this._rootNodeID,\n        nextProps\n      );\n    }\n  }\n\n});\n\nvar ReactTextComponentFactory = function(text) {\n  // Bypass validation and configuration\n  return new ReactElement(ReactTextComponent, null, null, null, null, text);\n};\n\nReactTextComponentFactory.type = ReactTextComponent;\n\nmodule.exports = ReactTextComponentFactory;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactTextComponent.js\n ** module id = 73\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactTextComponent.js?");

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule onlyChild\n */\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection. The current implementation of this\n * function assumes that a single child gets passed without a wrapper, but the\n * purpose of this helper function is to abstract away the particular structure\n * of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactComponent} The first and only `ReactComponent` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactElement.isValidElement(children),\n    'onlyChild must be passed a children with exactly one child.'\n  ) : invariant(ReactElement.isValidElement(children)));\n  return children;\n}\n\nmodule.exports = onlyChild;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/onlyChild.js\n ** module id = 74\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/onlyChild.js?");

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ExecutionEnvironment\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n);\n\n/**\n * Simple, lightweight module assisting with the detection and context of\n * Worker. Helps avoid circular dependencies and allows code to reason about\n * whether or not they are in a Worker, even if they never include the main\n * `ReactWorker` dependency.\n */\nvar ExecutionEnvironment = {\n\n  canUseDOM: canUseDOM,\n\n  canUseWorkers: typeof Worker !== 'undefined',\n\n  canUseEventListeners:\n    canUseDOM && !!(window.addEventListener || window.attachEvent),\n\n  canUseViewport: canUseDOM && !!window.screen,\n\n  isInWorker: !canUseDOM // For now, this is true - might change in the future.\n\n};\n\nmodule.exports = ExecutionEnvironment;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ExecutionEnvironment.js\n ** module id = 75\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ExecutionEnvironment.js?");

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports.ActionMethods = __webpack_require__(176);\n\nexports.ListenerMethods = __webpack_require__(177);\n\nexports.PublisherMethods = __webpack_require__(178);\n\nexports.StoreMethods = __webpack_require__(179);\n\nexports.createAction = __webpack_require__(180);\n\nexports.createStore = __webpack_require__(181);\n\nexports.connect = __webpack_require__(182);\n\nexports.connectFilter = __webpack_require__(183);\n\nexports.ListenerMixin = __webpack_require__(184);\n\nexports.listenTo = __webpack_require__(185);\n\nexports.listenToMany = __webpack_require__(186);\n\n\nvar maker = __webpack_require__(187).staticJoinCreator;\n\nexports.joinTrailing = exports.all = maker(\"last\"); // Reflux.all alias for backward compatibility\n\nexports.joinLeading = maker(\"first\");\n\nexports.joinStrict = maker(\"strict\");\n\nexports.joinConcat = maker(\"all\");\n\nvar _ = __webpack_require__(188);\n\n/**\n * Convenience function for creating a set of actions\n *\n * @param definitions the definitions for the actions to be created\n * @returns an object with actions of corresponding action names\n */\nexports.createActions = function(definitions) {\n    var actions = {};\n    for (var k in definitions){\n        var val = definitions[k],\n            actionName = _.isObject(val) ? k : val;\n\n        actions[actionName] = exports.createAction(val);\n    }\n    return actions;\n};\n\n/**\n * Sets the eventmitter that Reflux uses\n */\nexports.setEventEmitter = function(ctx) {\n    var _ = __webpack_require__(188);\n    _.EventEmitter = ctx;\n};\n\n\n/**\n * Sets the Promise library that Reflux uses\n */\nexports.setPromise = function(ctx) {\n    var _ = __webpack_require__(188);\n    _.Promise = ctx;\n};\n\n/**\n * Sets the Promise factory that creates new promises\n * @param {Function} factory has the signature `function(resolver) { return [new Promise]; }`\n */\nexports.setPromiseFactory = function(factory) {\n    var _ = __webpack_require__(188);\n    _.createPromise = factory;\n};\n\n\n/**\n * Sets the method used for deferring actions and stores\n */\nexports.nextTick = function(nextTick) {\n    var _ = __webpack_require__(188);\n    _.nextTick = nextTick;\n};\n\n/**\n * Provides the set of created actions and stores for introspection\n */\nexports.__keep = __webpack_require__(189);\n\n/**\n * Warn if Function.prototype.bind not available\n */\nif (!Function.prototype.bind) {\n  console.error(\n    'Function.prototype.bind not available. ' +\n    'ES5 shim required. ' +\n    'https://github.com/spoike/refluxjs#es5'\n  );\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/index.js\n ** module id = 76\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/index.js?");

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar PanelGroup = __webpack_require__(112);\n\nvar Accordion = React.createClass({displayName: \"Accordion\",\n  render: function () {\n    return (\n      React.createElement(PanelGroup, React.__spread({},  this.props, {accordion: true}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Accordion;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Accordion.js\n ** module id = 77\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Accordion.js?");

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar AffixMixin = __webpack_require__(79);\nvar domUtils = __webpack_require__(192);\n\nvar Affix = React.createClass({displayName: \"Affix\",\n  statics: {\n    domUtils: domUtils\n  },\n\n  mixins: [AffixMixin],\n\n  render: function () {\n    var holderStyle = {top: this.state.affixPositionTop};\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, this.state.affixClass), style: holderStyle}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Affix;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Affix.js\n ** module id = 78\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Affix.js?");

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* global window, document */\n\nvar React = __webpack_require__(12);\nvar domUtils = __webpack_require__(192);\nvar EventListener = __webpack_require__(193);\n\nvar AffixMixin = {\n  propTypes: {\n    offset: React.PropTypes.number,\n    offsetTop: React.PropTypes.number,\n    offsetBottom: React.PropTypes.number\n  },\n\n  getInitialState: function () {\n    return {\n      affixClass: 'affix-top'\n    };\n  },\n\n  getPinnedOffset: function (DOMNode) {\n    if (this.pinnedOffset) {\n      return this.pinnedOffset;\n    }\n\n    DOMNode.className = DOMNode.className.replace(/affix-top|affix-bottom|affix/, '');\n    DOMNode.className += DOMNode.className.length ? ' affix' : 'affix';\n\n    this.pinnedOffset = domUtils.getOffset(DOMNode).top - window.pageYOffset;\n\n    return this.pinnedOffset;\n  },\n\n  checkPosition: function () {\n    var DOMNode, scrollHeight, scrollTop, position, offsetTop, offsetBottom,\n        affix, affixType, affixPositionTop;\n\n    // TODO: or not visible\n    if (!this.isMounted()) {\n      return;\n    }\n\n    DOMNode = this.getDOMNode();\n    scrollHeight = document.documentElement.offsetHeight;\n    scrollTop = window.pageYOffset;\n    position = domUtils.getOffset(DOMNode);\n    offsetTop;\n    offsetBottom;\n\n    if (this.affixed === 'top') {\n      position.top += scrollTop;\n    }\n\n    offsetTop = this.props.offsetTop != null ?\n      this.props.offsetTop : this.props.offset;\n    offsetBottom = this.props.offsetBottom != null ?\n      this.props.offsetBottom : this.props.offset;\n\n    if (offsetTop == null && offsetBottom == null) {\n      return;\n    }\n    if (offsetTop == null) {\n      offsetTop = 0;\n    }\n    if (offsetBottom == null) {\n      offsetBottom = 0;\n    }\n\n    if (this.unpin != null && (scrollTop + this.unpin <= position.top)) {\n      affix = false;\n    } else if (offsetBottom != null && (position.top + DOMNode.offsetHeight >= scrollHeight - offsetBottom)) {\n      affix = 'bottom';\n    } else if (offsetTop != null && (scrollTop <= offsetTop)) {\n      affix = 'top';\n    } else {\n      affix = false;\n    }\n\n    if (this.affixed === affix) {\n      return;\n    }\n\n    if (this.unpin != null) {\n      DOMNode.style.top = '';\n    }\n\n    affixType = 'affix' + (affix ? '-' + affix : '');\n\n    this.affixed = affix;\n    this.unpin = affix === 'bottom' ?\n      this.getPinnedOffset(DOMNode) : null;\n\n    if (affix === 'bottom') {\n      DOMNode.className = DOMNode.className.replace(/affix-top|affix-bottom|affix/, 'affix-bottom');\n      affixPositionTop = scrollHeight - offsetBottom - DOMNode.offsetHeight - domUtils.getOffset(DOMNode).top;\n    }\n\n    this.setState({\n      affixClass: affixType,\n      affixPositionTop: affixPositionTop\n    });\n  },\n\n  checkPositionWithEventLoop: function () {\n    setTimeout(this.checkPosition, 0);\n  },\n\n  componentDidMount: function () {\n    this._onWindowScrollListener =\n      EventListener.listen(window, 'scroll', this.checkPosition);\n    this._onDocumentClickListener =\n      EventListener.listen(document, 'click', this.checkPositionWithEventLoop);\n  },\n\n  componentWillUnmount: function () {\n    if (this._onWindowScrollListener) {\n      this._onWindowScrollListener.remove();\n    }\n\n    if (this._onDocumentClickListener) {\n      this._onDocumentClickListener.remove();\n    }\n  },\n\n  componentDidUpdate: function (prevProps, prevState) {\n    if (prevState.affixClass === this.state.affixClass) {\n      this.checkPositionWithEventLoop();\n    }\n  }\n};\n\nmodule.exports = AffixMixin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/AffixMixin.js\n ** module id = 79\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/AffixMixin.js?");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\n\nvar Alert = React.createClass({displayName: \"Alert\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    onDismiss: React.PropTypes.func,\n    dismissAfter: React.PropTypes.number\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'alert',\n      bsStyle: 'info'\n    };\n  },\n\n  renderDismissButton: function () {\n    return (\n      React.createElement(\"button\", {\n        type: \"button\", \n        className: \"close\", \n        onClick: this.props.onDismiss, \n        \"aria-hidden\": \"true\"}, \n        \"×\"\n      )\n    );\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n    var isDismissable = !!this.props.onDismiss;\n\n    classes['alert-dismissable'] = isDismissable;\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        isDismissable ? this.renderDismissButton() : null, \n        this.props.children\n      )\n    );\n  },\n\n  componentDidMount: function() {\n    if (this.props.dismissAfter && this.props.onDismiss) {\n      this.dismissTimer = setTimeout(this.props.onDismiss, this.props.dismissAfter);\n    }\n  },\n\n  componentWillUnmount: function() {\n    clearTimeout(this.dismissTimer);\n  }\n});\n\nmodule.exports = Alert;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Alert.js\n ** module id = 80\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Alert.js?");

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar constants = __webpack_require__(194);\n\nvar BootstrapMixin = {\n  propTypes: {\n    bsClass: React.PropTypes.oneOf(Object.keys(constants.CLASSES)),\n    bsStyle: React.PropTypes.oneOf(Object.keys(constants.STYLES)),\n    bsSize: React.PropTypes.oneOf(Object.keys(constants.SIZES))\n  },\n\n  getBsClassSet: function () {\n    var classes = {};\n\n    var bsClass = this.props.bsClass && constants.CLASSES[this.props.bsClass];\n    if (bsClass) {\n      classes[bsClass] = true;\n\n      var prefix = bsClass + '-';\n\n      var bsSize = this.props.bsSize && constants.SIZES[this.props.bsSize];\n      if (bsSize) {\n        classes[prefix + bsSize] = true;\n      }\n\n      var bsStyle = this.props.bsStyle && constants.STYLES[this.props.bsStyle];\n      if (this.props.bsStyle) {\n        classes[prefix + bsStyle] = true;\n      }\n    }\n\n    return classes;\n  }\n};\n\nmodule.exports = BootstrapMixin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/BootstrapMixin.js\n ** module id = 81\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/BootstrapMixin.js?");

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar ValidComponentChildren = __webpack_require__(196);\nvar classSet = __webpack_require__(195);\n\nvar Badge = React.createClass({displayName: \"Badge\",\n  propTypes: {\n    pullRight: React.PropTypes.bool\n  },\n\n  hasContent: function () {\n    return ValidComponentChildren.hasValidComponent(this.props.children) ||\n      (typeof this.props.children === 'string') ||\n      (typeof this.props.children === 'number')\n  },\n\n  render: function () {\n    var classes = {\n      'pull-right': this.props.pullRight,\n      'badge': this.hasContent()\n    };\n    return (\n      React.createElement(\"span\", React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Badge;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Badge.js\n ** module id = 82\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Badge.js?");

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\nvar Button = React.createClass({displayName: \"Button\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    active:   React.PropTypes.bool,\n    disabled: React.PropTypes.bool,\n    block:    React.PropTypes.bool,\n    navItem:    React.PropTypes.bool,\n    navDropdown: React.PropTypes.bool,\n    componentClass: React.PropTypes.node,\n    href: React.PropTypes.string,\n    target: React.PropTypes.string\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'button',\n      bsStyle: 'default',\n      type: 'button'\n    };\n  },\n\n  render: function () {\n    var classes = this.props.navDropdown ? {} : this.getBsClassSet();\n    var renderFuncName;\n\n    classes['active'] = this.props.active;\n    classes['btn-block'] = this.props.block;\n\n    if (this.props.navItem) {\n      return this.renderNavItem(classes);\n    }\n\n    renderFuncName = this.props.href || this.props.target || this.props.navDropdown ?\n      'renderAnchor' : 'renderButton';\n\n    return this[renderFuncName](classes);\n  },\n\n  renderAnchor: function (classes) {\n\n    var Component = this.props.componentClass || 'a';\n    var href = this.props.href || '#';\n    classes['disabled'] = this.props.disabled;\n\n    return (\n      React.createElement(Component, React.__spread({}, \n        this.props, \n        {href: href, \n        className: joinClasses(this.props.className, classSet(classes)), \n        role: \"button\"}), \n        this.props.children\n      )\n    );\n  },\n\n  renderButton: function (classes) {\n    var Component = this.props.componentClass || 'button';\n\n    return (\n      React.createElement(Component, React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  },\n\n  renderNavItem: function (classes) {\n    var liClasses = {\n      active: this.props.active\n    };\n\n    return (\n      React.createElement(\"li\", {className: classSet(liClasses)}, \n        this.renderAnchor(classes)\n      )\n    );\n  }\n});\n\nmodule.exports = Button;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Button.js\n ** module id = 83\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Button.js?");

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\nvar Button = __webpack_require__(83);\n\nvar ButtonGroup = React.createClass({displayName: \"ButtonGroup\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    vertical:  React.PropTypes.bool,\n    justified: React.PropTypes.bool\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'button-group'\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n    classes['btn-group'] = !this.props.vertical;\n    classes['btn-group-vertical'] = this.props.vertical;\n    classes['btn-group-justified'] = this.props.justified;\n\n    return (\n      React.createElement(\"div\", React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = ButtonGroup;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/ButtonGroup.js\n ** module id = 84\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/ButtonGroup.js?");

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\nvar Button = __webpack_require__(83);\n\nvar ButtonToolbar = React.createClass({displayName: \"ButtonToolbar\",\n  mixins: [BootstrapMixin],\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'button-toolbar'\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n\n    return (\n      React.createElement(\"div\", React.__spread({}, \n        this.props, \n        {role: \"toolbar\", \n        className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = ButtonToolbar;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/ButtonToolbar.js\n ** module id = 85\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/ButtonToolbar.js?");

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\nvar BootstrapMixin = __webpack_require__(81);\nvar ValidComponentChildren = __webpack_require__(196);\n\nvar Carousel = React.createClass({displayName: \"Carousel\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    slide: React.PropTypes.bool,\n    indicators: React.PropTypes.bool,\n    controls: React.PropTypes.bool,\n    pauseOnHover: React.PropTypes.bool,\n    wrap: React.PropTypes.bool,\n    onSelect: React.PropTypes.func,\n    onSlideEnd: React.PropTypes.func,\n    activeIndex: React.PropTypes.number,\n    defaultActiveIndex: React.PropTypes.number,\n    direction: React.PropTypes.oneOf(['prev', 'next'])\n  },\n\n  getDefaultProps: function () {\n    return {\n      slide: true,\n      interval: 5000,\n      pauseOnHover: true,\n      wrap: true,\n      indicators: true,\n      controls: true\n    };\n  },\n\n  getInitialState: function () {\n    return {\n      activeIndex: this.props.defaultActiveIndex == null ?\n        0 : this.props.defaultActiveIndex,\n      previousActiveIndex: null,\n      direction: null\n    };\n  },\n\n  getDirection: function (prevIndex, index) {\n    if (prevIndex === index) {\n      return null;\n    }\n\n    return prevIndex > index ?\n      'prev' : 'next';\n  },\n\n  componentWillReceiveProps: function (nextProps) {\n    var activeIndex = this.getActiveIndex();\n\n    if (nextProps.activeIndex != null && nextProps.activeIndex !== activeIndex) {\n      clearTimeout(this.timeout);\n      this.setState({\n        previousActiveIndex: activeIndex,\n        direction: nextProps.direction != null ?\n          nextProps.direction : this.getDirection(activeIndex, nextProps.activeIndex)\n      });\n    }\n  },\n\n  componentDidMount: function () {\n    this.waitForNext();\n  },\n\n  componentWillUnmount: function() {\n    clearTimeout(this.timeout);\n  },\n\n  next: function (e) {\n    if (e) {\n      e.preventDefault();\n    }\n\n    var index = this.getActiveIndex() + 1;\n    var count = ValidComponentChildren.numberOf(this.props.children);\n\n    if (index > count - 1) {\n      if (!this.props.wrap) {\n        return;\n      }\n      index = 0;\n    }\n\n    this.handleSelect(index, 'next');\n  },\n\n  prev: function (e) {\n    if (e) {\n      e.preventDefault();\n    }\n\n    var index = this.getActiveIndex() - 1;\n\n    if (index < 0) {\n      if (!this.props.wrap) {\n        return;\n      }\n      index = ValidComponentChildren.numberOf(this.props.children) - 1;\n    }\n\n    this.handleSelect(index, 'prev');\n  },\n\n  pause: function () {\n    this.isPaused = true;\n    clearTimeout(this.timeout);\n  },\n\n  play: function () {\n    this.isPaused = false;\n    this.waitForNext();\n  },\n\n  waitForNext: function () {\n    if (!this.isPaused && this.props.slide && this.props.interval &&\n        this.props.activeIndex == null) {\n      this.timeout = setTimeout(this.next, this.props.interval);\n    }\n  },\n\n  handleMouseOver: function () {\n    if (this.props.pauseOnHover) {\n      this.pause();\n    }\n  },\n\n  handleMouseOut: function () {\n    if (this.isPaused) {\n      this.play();\n    }\n  },\n\n  render: function () {\n    var classes = {\n      carousel: true,\n      slide: this.props.slide\n    };\n\n    return (\n      React.createElement(\"div\", React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, classSet(classes)), \n        onMouseOver: this.handleMouseOver, \n        onMouseOut: this.handleMouseOut}), \n        this.props.indicators ? this.renderIndicators() : null, \n        React.createElement(\"div\", {className: \"carousel-inner\", ref: \"inner\"}, \n          ValidComponentChildren.map(this.props.children, this.renderItem)\n        ), \n        this.props.controls ? this.renderControls() : null\n      )\n    );\n  },\n\n  renderPrev: function () {\n    return (\n      React.createElement(\"a\", {className: \"left carousel-control\", href: \"#prev\", key: 0, onClick: this.prev}, \n        React.createElement(\"span\", {className: \"glyphicon glyphicon-chevron-left\"})\n      )\n    );\n  },\n\n  renderNext: function () {\n    return (\n      React.createElement(\"a\", {className: \"right carousel-control\", href: \"#next\", key: 1, onClick: this.next}, \n        React.createElement(\"span\", {className: \"glyphicon glyphicon-chevron-right\"})\n      )\n    );\n  },\n\n  renderControls: function () {\n    if (this.props.wrap) {\n      var activeIndex = this.getActiveIndex();\n      var count = ValidComponentChildren.numberOf(this.props.children);\n\n      return [\n        (activeIndex !== 0) ? this.renderPrev() : null,\n        (activeIndex !== count - 1) ? this.renderNext() : null\n      ];\n    }\n\n    return [\n      this.renderPrev(),\n      this.renderNext()\n    ];\n  },\n\n  renderIndicator: function (child, index) {\n    var className = (index === this.getActiveIndex()) ?\n      'active' : null;\n\n    return (\n      React.createElement(\"li\", {\n        key: index, \n        className: className, \n        onClick: this.handleSelect.bind(this, index, null)})\n    );\n  },\n\n  renderIndicators: function () {\n    var indicators = [];\n    ValidComponentChildren\n      .forEach(this.props.children, function(child, index) {\n        indicators.push(\n          this.renderIndicator(child, index),\n\n          // Force whitespace between indicator elements, bootstrap\n          // requires this for correct spacing of elements.\n          ' '\n        );\n      }, this);\n\n    return (\n      React.createElement(\"ol\", {className: \"carousel-indicators\"}, \n        indicators\n      )\n    );\n  },\n\n  getActiveIndex: function () {\n    return this.props.activeIndex != null ? this.props.activeIndex : this.state.activeIndex;\n  },\n\n  handleItemAnimateOutEnd: function () {\n    this.setState({\n      previousActiveIndex: null,\n      direction: null\n    }, function() {\n      this.waitForNext();\n\n      if (this.props.onSlideEnd) {\n        this.props.onSlideEnd();\n      }\n    });\n  },\n\n  renderItem: function (child, index) {\n    var activeIndex = this.getActiveIndex();\n    var isActive = (index === activeIndex);\n    var isPreviousActive = this.state.previousActiveIndex != null &&\n            this.state.previousActiveIndex === index && this.props.slide;\n\n    return cloneWithProps(\n        child,\n        {\n          active: isActive,\n          ref: child.ref,\n          key: child.key ? child.key : index,\n          index: index,\n          animateOut: isPreviousActive,\n          animateIn: isActive && this.state.previousActiveIndex != null && this.props.slide,\n          direction: this.state.direction,\n          onAnimateOutEnd: isPreviousActive ? this.handleItemAnimateOutEnd: null\n        }\n      );\n  },\n\n  handleSelect: function (index, direction) {\n    clearTimeout(this.timeout);\n\n    var previousActiveIndex = this.getActiveIndex();\n    direction = direction || this.getDirection(previousActiveIndex, index);\n\n    if (this.props.onSelect) {\n      this.props.onSelect(index, direction);\n    }\n\n    if (this.props.activeIndex == null && index !== previousActiveIndex) {\n      if (this.state.previousActiveIndex != null) {\n        // If currently animating don't activate the new index.\n        // TODO: look into queuing this canceled call and\n        // animating after the current animation has ended.\n        return;\n      }\n\n      this.setState({\n        activeIndex: index,\n        previousActiveIndex: previousActiveIndex,\n        direction: direction\n      });\n    }\n  }\n});\n\nmodule.exports = Carousel;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Carousel.js\n ** module id = 86\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Carousel.js?");

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar TransitionEvents = __webpack_require__(198);\n\nvar CarouselItem = React.createClass({displayName: \"CarouselItem\",\n  propTypes: {\n    direction: React.PropTypes.oneOf(['prev', 'next']),\n    onAnimateOutEnd: React.PropTypes.func,\n    active: React.PropTypes.bool,\n    caption: React.PropTypes.node\n  },\n\n  getInitialState: function () {\n    return {\n      direction: null\n    };\n  },\n\n  getDefaultProps: function () {\n    return {\n      animation: true\n    };\n  },\n\n  handleAnimateOutEnd: function () {\n    if (this.props.onAnimateOutEnd && this.isMounted()) {\n      this.props.onAnimateOutEnd(this.props.index);\n    }\n  },\n\n  componentWillReceiveProps: function (nextProps) {\n    if (this.props.active !== nextProps.active) {\n      this.setState({\n        direction: null\n      });\n    }\n  },\n\n  componentDidUpdate: function (prevProps) {\n    if (!this.props.active && prevProps.active) {\n      TransitionEvents.addEndEventListener(\n        this.getDOMNode(),\n        this.handleAnimateOutEnd\n      );\n    }\n\n    if (this.props.active !== prevProps.active) {\n      setTimeout(this.startAnimation, 20);\n    }\n  },\n\n  startAnimation: function () {\n    if (!this.isMounted()) {\n      return;\n    }\n\n    this.setState({\n      direction: this.props.direction === 'prev' ?\n        'right' : 'left'\n    });\n  },\n\n  render: function () {\n    var classes = {\n      item: true,\n      active: (this.props.active && !this.props.animateIn) || this.props.animateOut,\n      next: this.props.active && this.props.animateIn && this.props.direction === 'next',\n      prev: this.props.active && this.props.animateIn && this.props.direction === 'prev'\n    };\n\n    if (this.state.direction && (this.props.animateIn || this.props.animateOut)) {\n      classes[this.state.direction] = true;\n    }\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children, \n        this.props.caption ? this.renderCaption() : null\n      )\n    );\n  },\n\n  renderCaption: function () {\n    return (\n      React.createElement(\"div\", {className: \"carousel-caption\"}, \n        this.props.caption\n      )\n    );\n  }\n});\n\nmodule.exports = CarouselItem;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/CarouselItem.js\n ** module id = 87\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/CarouselItem.js?");

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar constants = __webpack_require__(194);\n\n\nvar Col = React.createClass({displayName: \"Col\",\n  propTypes: {\n    xs: React.PropTypes.number,\n    sm: React.PropTypes.number,\n    md: React.PropTypes.number,\n    lg: React.PropTypes.number,\n    xsOffset: React.PropTypes.number,\n    smOffset: React.PropTypes.number,\n    mdOffset: React.PropTypes.number,\n    lgOffset: React.PropTypes.number,\n    xsPush: React.PropTypes.number,\n    smPush: React.PropTypes.number,\n    mdPush: React.PropTypes.number,\n    lgPush: React.PropTypes.number,\n    xsPull: React.PropTypes.number,\n    smPull: React.PropTypes.number,\n    mdPull: React.PropTypes.number,\n    lgPull: React.PropTypes.number,\n    componentClass: React.PropTypes.node.isRequired\n  },\n\n  getDefaultProps: function () {\n    return {\n      componentClass: 'div'\n    };\n  },\n\n  render: function () {\n    var ComponentClass = this.props.componentClass;\n    var classes = {};\n\n    Object.keys(constants.SIZES).forEach(function (key) {\n      var size = constants.SIZES[key];\n      var prop = size;\n      var classPart = size + '-';\n\n      if (this.props[prop]) {\n        classes['col-' + classPart + this.props[prop]] = true;\n      }\n\n      prop = size + 'Offset';\n      classPart = size + '-offset-';\n      if (this.props[prop]) {\n        classes['col-' + classPart + this.props[prop]] = true;\n      }\n\n      prop = size + 'Push';\n      classPart = size + '-push-';\n      if (this.props[prop]) {\n        classes['col-' + classPart + this.props[prop]] = true;\n      }\n\n      prop = size + 'Pull';\n      classPart = size + '-pull-';\n      if (this.props[prop]) {\n        classes['col-' + classPart + this.props[prop]] = true;\n      }\n    }, this);\n\n    return (\n      React.createElement(ComponentClass, React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Col;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Col.js\n ** module id = 88\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Col.js?");

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar TransitionEvents = __webpack_require__(198);\n\nvar CollapsableMixin = {\n\n  propTypes: {\n    collapsable: React.PropTypes.bool,\n    defaultExpanded: React.PropTypes.bool,\n    expanded: React.PropTypes.bool\n  },\n\n  getInitialState: function () {\n    return {\n      expanded: this.props.defaultExpanded != null ? this.props.defaultExpanded : null,\n      collapsing: false\n    };\n  },\n\n  handleTransitionEnd: function () {\n    this._collapseEnd = true;\n    this.setState({\n      collapsing: false\n    });\n  },\n\n  componentWillReceiveProps: function (newProps) {\n    if (this.props.collapsable && newProps.expanded !== this.props.expanded) {\n      this._collapseEnd = false;\n      this.setState({\n        collapsing: true\n      });\n    }\n  },\n\n  _addEndTransitionListener: function () {\n    var node = this.getCollapsableDOMNode();\n\n    if (node) {\n      TransitionEvents.addEndEventListener(\n        node,\n        this.handleTransitionEnd\n      );\n    }\n  },\n\n  _removeEndTransitionListener: function () {\n    var node = this.getCollapsableDOMNode();\n\n    if (node) {\n      TransitionEvents.removeEndEventListener(\n        node,\n        this.handleTransitionEnd\n      );\n    }\n  },\n\n  componentDidMount: function () {\n    this._afterRender();\n  },\n\n  componentWillUnmount: function () {\n    this._removeEndTransitionListener();\n  },\n\n  componentWillUpdate: function (nextProps) {\n    var dimension = (typeof this.getCollapsableDimension === 'function') ?\n      this.getCollapsableDimension() : 'height';\n    var node = this.getCollapsableDOMNode();\n\n    this._removeEndTransitionListener();\n  },\n\n  componentDidUpdate: function (prevProps, prevState) {\n    this._afterRender();\n  },\n\n  _afterRender: function () {\n    if (!this.props.collapsable) {\n      return;\n    }\n\n    this._addEndTransitionListener();\n    setTimeout(this._updateDimensionAfterRender, 0);\n  },\n\n  _updateDimensionAfterRender: function () {\n    var node = this.getCollapsableDOMNode();\n    if (node) {\n        var dimension = (typeof this.getCollapsableDimension === 'function') ?\n            this.getCollapsableDimension() : 'height';\n        node.style[dimension] = this.isExpanded() ?\n            this.getCollapsableDimensionValue() + 'px' : '0px';\n    }\n  },\n\n  isExpanded: function () {\n    return (this.props.expanded != null) ?\n      this.props.expanded : this.state.expanded;\n  },\n\n  getCollapsableClassSet: function (className) {\n    var classes = {};\n\n    if (typeof className === 'string') {\n      className.split(' ').forEach(function (className) {\n        if (className) {\n          classes[className] = true;\n        }\n      });\n    }\n\n    classes.collapsing = this.state.collapsing;\n    classes.collapse = !this.state.collapsing;\n    classes['in'] = this.isExpanded() && !this.state.collapsing;\n\n    return classes;\n  }\n};\n\nmodule.exports = CollapsableMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/CollapsableMixin.js\n ** module id = 89\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/CollapsableMixin.js?");

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar createChainedFunction = __webpack_require__(199);\nvar BootstrapMixin = __webpack_require__(81);\nvar DropdownStateMixin = __webpack_require__(92);\nvar Button = __webpack_require__(83);\nvar ButtonGroup = __webpack_require__(84);\nvar DropdownMenu = __webpack_require__(91);\nvar ValidComponentChildren = __webpack_require__(196);\n\n\nvar DropdownButton = React.createClass({displayName: \"DropdownButton\",\n  mixins: [BootstrapMixin, DropdownStateMixin],\n\n  propTypes: {\n    pullRight: React.PropTypes.bool,\n    dropup:    React.PropTypes.bool,\n    title:     React.PropTypes.node,\n    href:      React.PropTypes.string,\n    onClick:   React.PropTypes.func,\n    onSelect:  React.PropTypes.func,\n    navItem:   React.PropTypes.bool\n  },\n\n  render: function () {\n    var className = 'dropdown-toggle';\n\n    var renderMethod = this.props.navItem ?\n      'renderNavItem' : 'renderButtonGroup';\n\n    return this[renderMethod]([\n      React.createElement(Button, React.__spread({}, \n        this.props, \n        {ref: \"dropdownButton\", \n        className: joinClasses(this.props.className, className), \n        onClick: this.handleDropdownClick, \n        key: 0, \n        navDropdown: this.props.navItem, \n        navItem: null, \n        title: null, \n        pullRight: null, \n        dropup: null}), \n        this.props.title, ' ', \n        React.createElement(\"span\", {className: \"caret\"})\n      ),\n      React.createElement(DropdownMenu, {\n        ref: \"menu\", \n        \"aria-labelledby\": this.props.id, \n        pullRight: this.props.pullRight, \n        key: 1}, \n        ValidComponentChildren.map(this.props.children, this.renderMenuItem)\n      )\n    ]);\n  },\n\n  renderButtonGroup: function (children) {\n    var groupClasses = {\n        'open': this.state.open,\n        'dropup': this.props.dropup\n      };\n\n    return (\n      React.createElement(ButtonGroup, {\n        bsSize: this.props.bsSize, \n        className: classSet(groupClasses)}, \n        children\n      )\n    );\n  },\n\n  renderNavItem: function (children) {\n    var classes = {\n        'dropdown': true,\n        'open': this.state.open,\n        'dropup': this.props.dropup\n      };\n\n    return (\n      React.createElement(\"li\", {className: classSet(classes)}, \n        children\n      )\n    );\n  },\n\n  renderMenuItem: function (child, index) {\n    // Only handle the option selection if an onSelect prop has been set on the\n    // component or it's child, this allows a user not to pass an onSelect\n    // handler and have the browser preform the default action.\n    var handleOptionSelect = this.props.onSelect || child.props.onSelect ?\n      this.handleOptionSelect : null;\n\n    return cloneWithProps(\n      child,\n      {\n        // Capture onSelect events\n        onSelect: createChainedFunction(child.props.onSelect, handleOptionSelect),\n\n        // Force special props to be transferred\n        key: child.key ? child.key : index,\n        ref: child.ref\n      }\n    );\n  },\n\n  handleDropdownClick: function (e) {\n    e.preventDefault();\n\n    this.setDropdownState(!this.state.open);\n  },\n\n  handleOptionSelect: function (key) {\n    if (this.props.onSelect) {\n      this.props.onSelect(key);\n    }\n\n    this.setDropdownState(false);\n  }\n});\n\nmodule.exports = DropdownButton;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/DropdownButton.js\n ** module id = 90\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/DropdownButton.js?");

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar createChainedFunction = __webpack_require__(199);\nvar ValidComponentChildren = __webpack_require__(196);\n\nvar DropdownMenu = React.createClass({displayName: \"DropdownMenu\",\n  propTypes: {\n    pullRight: React.PropTypes.bool,\n    onSelect: React.PropTypes.func\n  },\n\n  render: function () {\n    var classes = {\n        'dropdown-menu': true,\n        'dropdown-menu-right': this.props.pullRight\n      };\n\n    return (\n        React.createElement(\"ul\", React.__spread({}, \n          this.props, \n          {className: joinClasses(this.props.className, classSet(classes)), \n          role: \"menu\"}), \n          ValidComponentChildren.map(this.props.children, this.renderMenuItem)\n        )\n      );\n  },\n\n  renderMenuItem: function (child, index) {\n    return cloneWithProps(\n      child,\n      {\n        // Capture onSelect events\n        onSelect: createChainedFunction(child.props.onSelect, this.props.onSelect),\n\n        // Force special props to be transferred\n        key: child.key ? child.key : index,\n        ref: child.ref\n      }\n    );\n  }\n});\n\nmodule.exports = DropdownMenu;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/DropdownMenu.js\n ** module id = 91\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/DropdownMenu.js?");

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar EventListener = __webpack_require__(193);\n\n/**\n * Checks whether a node is within\n * a root nodes tree\n *\n * @param {DOMElement} node\n * @param {DOMElement} root\n * @returns {boolean}\n */\nfunction isNodeInRoot(node, root) {\n  while (node) {\n    if (node === root) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\nvar DropdownStateMixin = {\n  getInitialState: function () {\n    return {\n      open: false\n    };\n  },\n\n  setDropdownState: function (newState, onStateChangeComplete) {\n    if (newState) {\n      this.bindRootCloseHandlers();\n    } else {\n      this.unbindRootCloseHandlers();\n    }\n\n    this.setState({\n      open: newState\n    }, onStateChangeComplete);\n  },\n\n  handleDocumentKeyUp: function (e) {\n    if (e.keyCode === 27) {\n      this.setDropdownState(false);\n    }\n  },\n\n  handleDocumentClick: function (e) {\n    // If the click originated from within this component\n    // don't do anything.\n    if (isNodeInRoot(e.target, this.getDOMNode())) {\n      return;\n    }\n\n    this.setDropdownState(false);\n  },\n\n  bindRootCloseHandlers: function () {\n    this._onDocumentClickListener =\n      EventListener.listen(document, 'click', this.handleDocumentClick);\n    this._onDocumentKeyupListener =\n      EventListener.listen(document, 'keyup', this.handleDocumentKeyUp);\n  },\n\n  unbindRootCloseHandlers: function () {\n    if (this._onDocumentClickListener) {\n      this._onDocumentClickListener.remove();\n    }\n\n    if (this._onDocumentKeyupListener) {\n      this._onDocumentKeyupListener.remove();\n    }\n  },\n\n  componentWillUnmount: function () {\n    this.unbindRootCloseHandlers();\n  }\n};\n\nmodule.exports = DropdownStateMixin;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/DropdownStateMixin.js\n ** module id = 92\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/DropdownStateMixin.js?");

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*global document */\n// TODO: listen for onTransitionEnd to remove el\nfunction getElementsAndSelf (root, classes){\n  var els = root.querySelectorAll('.' + classes.join('.'));\n\n  els = [].map.call(els, function(e){ return e; });\n\n  for(var i = 0; i < classes.length; i++){\n    if( !root.className.match(new RegExp('\\\\b' +  classes[i] + '\\\\b'))){\n      return els;\n    }\n  }\n  els.unshift(root);\n  return els;\n}\n\nmodule.exports = {\n  _fadeIn: function () {\n    var els;\n\n    if (this.isMounted()) {\n      els = getElementsAndSelf(this.getDOMNode(), ['fade']);\n\n      if (els.length) {\n        els.forEach(function (el) {\n          el.className += ' in';\n        });\n      }\n    }\n  },\n\n  _fadeOut: function () {\n    var els = getElementsAndSelf(this._fadeOutEl, ['fade', 'in']);\n\n    if (els.length) {\n      els.forEach(function (el) {\n        el.className = el.className.replace(/\\bin\\b/, '');\n      });\n    }\n\n    setTimeout(this._handleFadeOutEnd, 300);\n  },\n\n  _handleFadeOutEnd: function () {\n    if (this._fadeOutEl && this._fadeOutEl.parentNode) {\n      this._fadeOutEl.parentNode.removeChild(this._fadeOutEl);\n    }\n  },\n\n  componentDidMount: function () {\n    if (document.querySelectorAll) {\n      // Firefox needs delay for transition to be triggered\n      setTimeout(this._fadeIn, 20);\n    }\n  },\n\n  componentWillUnmount: function () {\n    var els = getElementsAndSelf(this.getDOMNode(), ['fade']),\n        container = (this.props.container && this.props.container.getDOMNode()) || document.body;\n\n    if (els.length) {\n      this._fadeOutEl = document.createElement('div');\n      container.appendChild(this._fadeOutEl);\n      this._fadeOutEl.appendChild(this.getDOMNode().cloneNode(true));\n      // Firefox needs delay for transition to be triggered\n      setTimeout(this._fadeOut, 20);\n    }\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/FadeMixin.js\n ** module id = 93\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/FadeMixin.js?");

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\nvar constants = __webpack_require__(194);\n\nvar Glyphicon = React.createClass({displayName: \"Glyphicon\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    glyph: React.PropTypes.oneOf(constants.GLYPHS).isRequired\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'glyphicon'\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n\n    classes['glyphicon-' + this.props.glyph] = true;\n\n    return (\n      React.createElement(\"span\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Glyphicon;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Glyphicon.js\n ** module id = 94\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Glyphicon.js?");

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\n\nvar Grid = React.createClass({displayName: \"Grid\",\n  propTypes: {\n    fluid: React.PropTypes.bool,\n    componentClass: React.PropTypes.node.isRequired\n  },\n\n  getDefaultProps: function () {\n    return {\n      componentClass: 'div'\n    };\n  },\n\n  render: function () {\n    var ComponentClass = this.props.componentClass;\n    var className = this.props.fluid ? 'container-fluid' : 'container';\n\n    return (\n      React.createElement(ComponentClass, React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, className)}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Grid;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Grid.js\n ** module id = 95\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Grid.js?");

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar Button = __webpack_require__(83);\n\nvar Input = React.createClass({displayName: \"Input\",\n  propTypes: {\n    type: React.PropTypes.string,\n    label: React.PropTypes.node,\n    help: React.PropTypes.node,\n    addonBefore: React.PropTypes.node,\n    addonAfter: React.PropTypes.node,\n    buttonBefore: React.PropTypes.node,\n    buttonAfter: React.PropTypes.node,\n    bsStyle: function(props) {\n      if (props.type === 'submit') {\n        // Return early if `type=submit` as the `Button` component\n        // it transfers these props to has its own propType checks.\n        return;\n      }\n\n      return React.PropTypes.oneOf(['success', 'warning', 'error']).apply(null, arguments);\n    },\n    hasFeedback: React.PropTypes.bool,\n    groupClassName: React.PropTypes.string,\n    wrapperClassName: React.PropTypes.string,\n    labelClassName: React.PropTypes.string,\n    disabled: React.PropTypes.bool\n  },\n\n  getInputDOMNode: function () {\n    return this.refs.input.getDOMNode();\n  },\n\n  getValue: function () {\n    if (this.props.type === 'static') {\n      return this.props.value;\n    }\n    else if (this.props.type) {\n      return this.getInputDOMNode().value;\n    }\n    else {\n      throw Error('Cannot use getValue without specifying input type.');\n    }\n  },\n\n  getChecked: function () {\n    return this.getInputDOMNode().checked;\n  },\n\n  isCheckboxOrRadio: function () {\n    return this.props.type === 'radio' || this.props.type === 'checkbox';\n  },\n\n  isFile: function () {\n    return this.props.type === 'file';\n  },\n\n  renderInput: function () {\n    var input = null;\n\n    if (!this.props.type) {\n      return this.props.children\n    }\n\n    switch (this.props.type) {\n      case 'select':\n        input = (\n          React.createElement(\"select\", React.__spread({},  this.props, {className: joinClasses(this.props.className, 'form-control'), ref: \"input\", key: \"input\"}), \n            this.props.children\n          )\n        );\n        break;\n      case 'textarea':\n        input = React.createElement(\"textarea\", React.__spread({},  this.props, {className: joinClasses(this.props.className, 'form-control'), ref: \"input\", key: \"input\"}));\n        break;\n      case 'static':\n        input = (\n          React.createElement(\"p\", React.__spread({},  this.props, {className: joinClasses(this.props.className, 'form-control-static'), ref: \"input\", key: \"input\"}), \n            this.props.value\n          )\n        );\n        break;\n      case 'submit':\n        input = (\n          React.createElement(Button, React.__spread({},  this.props, {componentClass: \"input\", ref: \"input\", key: \"input\"}))\n        );\n        break;\n      default:\n        var className = this.isCheckboxOrRadio() || this.isFile() ? '' : 'form-control';\n        input = React.createElement(\"input\", React.__spread({},  this.props, {className: joinClasses(this.props.className, className), ref: \"input\", key: \"input\"}));\n    }\n\n    return input;\n  },\n\n  renderInputGroup: function (children) {\n    var addonBefore = this.props.addonBefore ? (\n      React.createElement(\"span\", {className: \"input-group-addon\", key: \"addonBefore\"}, \n        this.props.addonBefore\n      )\n    ) : null;\n\n    var addonAfter = this.props.addonAfter ? (\n      React.createElement(\"span\", {className: \"input-group-addon\", key: \"addonAfter\"}, \n        this.props.addonAfter\n      )\n    ) : null;\n\n    var buttonBefore = this.props.buttonBefore ? (\n      React.createElement(\"span\", {className: \"input-group-btn\"}, \n        this.props.buttonBefore\n      )\n    ) : null;\n\n    var buttonAfter = this.props.buttonAfter ? (\n      React.createElement(\"span\", {className: \"input-group-btn\"}, \n        this.props.buttonAfter\n      )\n    ) : null;\n\n    return addonBefore || addonAfter || buttonBefore || buttonAfter ? (\n      React.createElement(\"div\", {className: \"input-group\", key: \"input-group\"}, \n        addonBefore, \n        buttonBefore, \n        children, \n        addonAfter, \n        buttonAfter\n      )\n    ) : children;\n  },\n\n  renderIcon: function () {\n    var classes = {\n      'glyphicon': true,\n      'form-control-feedback': true,\n      'glyphicon-ok': this.props.bsStyle === 'success',\n      'glyphicon-warning-sign': this.props.bsStyle === 'warning',\n      'glyphicon-remove': this.props.bsStyle === 'error'\n    };\n\n    return this.props.hasFeedback ? (\n      React.createElement(\"span\", {className: classSet(classes), key: \"icon\"})\n    ) : null;\n  },\n\n  renderHelp: function () {\n    return this.props.help ? (\n      React.createElement(\"span\", {className: \"help-block\", key: \"help\"}, \n        this.props.help\n      )\n    ) : null;\n  },\n\n  renderCheckboxandRadioWrapper: function (children) {\n    var classes = {\n      'checkbox': this.props.type === 'checkbox',\n      'radio': this.props.type === 'radio'\n    };\n\n    return (\n      React.createElement(\"div\", {className: classSet(classes), key: \"checkboxRadioWrapper\"}, \n        children\n      )\n    );\n  },\n\n  renderWrapper: function (children) {\n    return this.props.wrapperClassName ? (\n      React.createElement(\"div\", {className: this.props.wrapperClassName, key: \"wrapper\"}, \n        children\n      )\n    ) : children;\n  },\n\n  renderLabel: function (children) {\n    var classes = {\n      'control-label': !this.isCheckboxOrRadio()\n    };\n    classes[this.props.labelClassName] = this.props.labelClassName;\n\n    return this.props.label ? (\n      React.createElement(\"label\", {htmlFor: this.props.id, className: classSet(classes), key: \"label\"}, \n        children, \n        this.props.label\n      )\n    ) : children;\n  },\n\n  renderFormGroup: function (children) {\n    var classes = {\n      'form-group': true,\n      'has-feedback': this.props.hasFeedback,\n      'has-success': this.props.bsStyle === 'success',\n      'has-warning': this.props.bsStyle === 'warning',\n      'has-error': this.props.bsStyle === 'error'\n    };\n    classes[this.props.groupClassName] = this.props.groupClassName;\n\n    return (\n      React.createElement(\"div\", {className: classSet(classes)}, \n        children\n      )\n    );\n  },\n\n  render: function () {\n    if (this.isCheckboxOrRadio()) {\n      return this.renderFormGroup(\n        this.renderWrapper([\n          this.renderCheckboxandRadioWrapper(\n            this.renderLabel(\n              this.renderInput()\n            )\n          ),\n          this.renderHelp()\n        ])\n      );\n    }\n    else {\n      return this.renderFormGroup([\n        this.renderLabel(),\n        this.renderWrapper([\n          this.renderInputGroup(\n            this.renderInput()\n          ),\n          this.renderIcon(),\n          this.renderHelp()\n        ])\n      ]);\n    }\n  }\n});\n\nmodule.exports = Input;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Input.js\n ** module id = 96\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Input.js?");

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	eval("// https://www.npmjs.org/package/react-interpolate-component\n'use strict';\n\nvar React = __webpack_require__(12);\nvar ValidComponentChildren = __webpack_require__(196);\nvar assign = __webpack_require__(201);\n\nvar REGEXP = /\\%\\((.+?)\\)s/;\n\nvar Interpolate = React.createClass({\n  displayName: 'Interpolate',\n\n  propTypes: {\n    format: React.PropTypes.string\n  },\n\n  getDefaultProps: function() {\n    return { component: 'span' };\n  },\n\n  render: function() {\n    var format = (ValidComponentChildren.hasValidComponent(this.props.children) ||\n        (typeof this.props.children === 'string')) ?\n        this.props.children : this.props.format;\n    var parent = this.props.component;\n    var unsafe = this.props.unsafe === true;\n    var props = assign({}, this.props);\n\n    delete props.children;\n    delete props.format;\n    delete props.component;\n    delete props.unsafe;\n\n    if (unsafe) {\n      var content = format.split(REGEXP).reduce(function(memo, match, index) {\n        var html;\n\n        if (index % 2 === 0) {\n          html = match;\n        } else {\n          html = props[match];\n          delete props[match];\n        }\n\n        if (React.isValidElement(html)) {\n          throw new Error('cannot interpolate a React component into unsafe text');\n        }\n\n        memo += html;\n\n        return memo;\n      }, '');\n\n      props.dangerouslySetInnerHTML = { __html: content };\n\n      return React.createElement(parent, props);\n    } else {\n      var kids = format.split(REGEXP).reduce(function(memo, match, index) {\n        var child;\n\n        if (index % 2 === 0) {\n          if (match.length === 0) {\n            return memo;\n          }\n\n          child = match;\n        } else {\n          child = props[match];\n          delete props[match];\n        }\n\n        memo.push(child);\n\n        return memo;\n      }, []);\n\n      return React.createElement(parent, props, kids);\n    }\n  }\n});\n\nmodule.exports = Interpolate;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Interpolate.js\n ** module id = 97\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Interpolate.js?");

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\n\nvar Jumbotron = React.createClass({displayName: \"Jumbotron\",\n\n  render: function () {\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, 'jumbotron')}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Jumbotron;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Jumbotron.js\n ** module id = 98\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Jumbotron.js?");

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\nvar Label = React.createClass({displayName: \"Label\",\n  mixins: [BootstrapMixin],\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'label',\n      bsStyle: 'default'\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n\n    return (\n      React.createElement(\"span\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Label;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Label.js\n ** module id = 99\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Label.js?");

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\nvar createChainedFunction = __webpack_require__(199);\n\nvar ListGroup = React.createClass({displayName: \"ListGroup\",\n  propTypes: {\n    onClick: React.PropTypes.func\n  },\n\n  render: function () {\n    return (\n      React.createElement(\"div\", {className: \"list-group\"}, \n        ValidComponentChildren.map(this.props.children, this.renderListItem)\n      )\n    );\n  },\n\n  renderListItem: function (child, index) {\n    return cloneWithProps(child, {\n      onClick: createChainedFunction(child.props.onClick, this.props.onClick),\n      ref: child.ref,\n      key: child.key ? child.key : index\n    });\n  }\n});\n\nmodule.exports = ListGroup;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/ListGroup.js\n ** module id = 100\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/ListGroup.js?");

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar BootstrapMixin = __webpack_require__(81);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\n\nvar ListGroupItem = React.createClass({displayName: \"ListGroupItem\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    bsStyle: React.PropTypes.oneOf(['danger','info','success','warning']),\n    active: React.PropTypes.any,\n    disabled: React.PropTypes.any,\n    header: React.PropTypes.node,\n    onClick: React.PropTypes.func,\n    eventKey: React.PropTypes.any,\n    href: React.PropTypes.string,\n    target: React.PropTypes.string\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'list-group-item'\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n\n    classes['active'] = this.props.active;\n    classes['disabled'] = this.props.disabled;\n\n    if (this.props.href || this.props.target || this.props.onClick) {\n      return this.renderAnchor(classes);\n    } else {\n      return this.renderSpan(classes);\n    }\n  },\n\n  renderSpan: function (classes) {\n    return (\n      React.createElement(\"span\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.header ? this.renderStructuredContent() : this.props.children\n      )\n    );\n  },\n\n  renderAnchor: function (classes) {\n    return (\n      React.createElement(\"a\", React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, classSet(classes)), \n        onClick: this.handleClick}), \n        this.props.header ? this.renderStructuredContent() : this.props.children\n      )\n    );\n  },\n\n  renderStructuredContent: function () {\n    var header;\n    if (React.isValidElement(this.props.header)) {\n      header = cloneWithProps(this.props.header, {\n        className: 'list-group-item-heading'\n      });\n    } else {\n      header = (\n        React.createElement(\"h4\", {className: \"list-group-item-heading\"}, \n          this.props.header\n        )\n      );\n    }\n\n    var content = (\n      React.createElement(\"p\", {className: \"list-group-item-text\"}, \n        this.props.children\n      )\n    );\n\n    return {\n      header: header,\n      content: content\n    };\n  },\n\n  handleClick: function (e) {\n    if (this.props.onClick) {\n      e.preventDefault();\n      this.props.onClick(this.props.eventKey, this.props.href, this.props.target);\n    }\n  }\n});\n\nmodule.exports = ListGroupItem;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/ListGroupItem.js\n ** module id = 101\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/ListGroupItem.js?");

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\n\nvar MenuItem = React.createClass({displayName: \"MenuItem\",\n  propTypes: {\n    header:    React.PropTypes.bool,\n    divider:   React.PropTypes.bool,\n    href:      React.PropTypes.string,\n    title:     React.PropTypes.string,\n    target:    React.PropTypes.string,\n    onSelect:  React.PropTypes.func,\n    eventKey:  React.PropTypes.any\n  },\n\n  getDefaultProps: function () {\n    return {\n      href: '#'\n    };\n  },\n\n  handleClick: function (e) {\n    if (this.props.onSelect) {\n      e.preventDefault();\n      this.props.onSelect(this.props.eventKey, this.props.href, this.props.target);\n    }\n  },\n\n  renderAnchor: function () {\n    return (\n      React.createElement(\"a\", {onClick: this.handleClick, href: this.props.href, target: this.props.target, title: this.props.title, tabIndex: \"-1\"}, \n        this.props.children\n      )\n    );\n  },\n\n  render: function () {\n    var classes = {\n        'dropdown-header': this.props.header,\n        'divider': this.props.divider\n      };\n\n    var children = null;\n    if (this.props.header) {\n      children = this.props.children;\n    } else if (!this.props.divider) {\n      children = this.renderAnchor();\n    }\n\n    return (\n      React.createElement(\"li\", React.__spread({},  this.props, {role: \"presentation\", title: null, href: null, \n        className: joinClasses(this.props.className, classSet(classes))}), \n        children\n      )\n    );\n  }\n});\n\nmodule.exports = MenuItem;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/MenuItem.js\n ** module id = 102\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/MenuItem.js?");

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* global document:false */\n\nvar React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\nvar FadeMixin = __webpack_require__(93);\nvar EventListener = __webpack_require__(193);\n\n\n// TODO:\n// - aria-labelledby\n// - Add `modal-body` div if only one child passed in that doesn't already have it\n// - Tests\n\nvar Modal = React.createClass({displayName: \"Modal\",\n  mixins: [BootstrapMixin, FadeMixin],\n\n  propTypes: {\n    title: React.PropTypes.node,\n    backdrop: React.PropTypes.oneOf(['static', true, false]),\n    keyboard: React.PropTypes.bool,\n    closeButton: React.PropTypes.bool,\n    animation: React.PropTypes.bool,\n    onRequestHide: React.PropTypes.func.isRequired\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'modal',\n      backdrop: true,\n      keyboard: true,\n      animation: true,\n      closeButton: true\n    };\n  },\n\n  render: function () {\n    var modalStyle = {display: 'block'};\n    var dialogClasses = this.getBsClassSet();\n    delete dialogClasses.modal;\n    dialogClasses['modal-dialog'] = true;\n\n    var classes = {\n      modal: true,\n      fade: this.props.animation,\n      'in': !this.props.animation || !document.querySelectorAll\n    };\n\n    var modal = (\n      React.createElement(\"div\", React.__spread({}, \n        this.props, \n        {title: null, \n        tabIndex: \"-1\", \n        role: \"dialog\", \n        style: modalStyle, \n        className: joinClasses(this.props.className, classSet(classes)), \n        onClick: this.props.backdrop === true ? this.handleBackdropClick : null, \n        ref: \"modal\"}), \n        React.createElement(\"div\", {className: classSet(dialogClasses)}, \n          React.createElement(\"div\", {className: \"modal-content\"}, \n            this.props.title ? this.renderHeader() : null, \n            this.props.children\n          )\n        )\n      )\n    );\n\n    return this.props.backdrop ?\n      this.renderBackdrop(modal) : modal;\n  },\n\n  renderBackdrop: function (modal) {\n    var classes = {\n      'modal-backdrop': true,\n      'fade': this.props.animation\n    };\n\n    classes['in'] = !this.props.animation || !document.querySelectorAll;\n\n    var onClick = this.props.backdrop === true ?\n      this.handleBackdropClick : null;\n\n    return (\n      React.createElement(\"div\", null, \n        React.createElement(\"div\", {className: classSet(classes), ref: \"backdrop\", onClick: onClick}), \n        modal\n      )\n    );\n  },\n\n  renderHeader: function () {\n    var closeButton;\n    if (this.props.closeButton) {\n      closeButton = (\n          React.createElement(\"button\", {type: \"button\", className: \"close\", \"aria-hidden\": \"true\", onClick: this.props.onRequestHide}, \"×\")\n        );\n    }\n\n    return (\n      React.createElement(\"div\", {className: \"modal-header\"}, \n        closeButton, \n        this.renderTitle()\n      )\n    );\n  },\n\n  renderTitle: function () {\n    return (\n      React.isValidElement(this.props.title) ?\n        this.props.title : React.createElement(\"h4\", {className: \"modal-title\"}, this.props.title)\n    );\n  },\n\n  iosClickHack: function () {\n    // IOS only allows click events to be delegated to the document on elements\n    // it considers 'clickable' - anchors, buttons, etc. We fake a click handler on the\n    // DOM nodes themselves. Remove if handled by React: https://github.com/facebook/react/issues/1169\n    this.refs.modal.getDOMNode().onclick = function () {};\n    this.refs.backdrop.getDOMNode().onclick = function () {};\n  },\n\n  componentDidMount: function () {\n    this._onDocumentKeyupListener =\n      EventListener.listen(document, 'keyup', this.handleDocumentKeyUp);\n\n    var container = (this.props.container && this.props.container.getDOMNode()) || document.body;\n    container.className += container.className.length ? ' modal-open' : 'modal-open';\n\n    if (this.props.backdrop) {\n      this.iosClickHack();\n    }\n  },\n\n  componentDidUpdate: function (prevProps) {\n    if (this.props.backdrop && this.props.backdrop !== prevProps.backdrop) {\n      this.iosClickHack();\n    }\n  },\n\n  componentWillUnmount: function () {\n    this._onDocumentKeyupListener.remove();\n    var container = (this.props.container && this.props.container.getDOMNode()) || document.body;\n    container.className = container.className.replace(/ ?modal-open/, '');\n  },\n\n  handleBackdropClick: function (e) {\n    if (e.target !== e.currentTarget) {\n      return;\n    }\n\n    this.props.onRequestHide();\n  },\n\n  handleDocumentKeyUp: function (e) {\n    if (this.props.keyboard && e.keyCode === 27) {\n      this.props.onRequestHide();\n    }\n  }\n});\n\nmodule.exports = Modal;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Modal.js\n ** module id = 103\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Modal.js?");

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar BootstrapMixin = __webpack_require__(81);\nvar CollapsableMixin = __webpack_require__(89);\nvar classSet = __webpack_require__(195);\nvar domUtils = __webpack_require__(192);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\nvar createChainedFunction = __webpack_require__(199);\n\n\nvar Nav = React.createClass({displayName: \"Nav\",\n  mixins: [BootstrapMixin, CollapsableMixin],\n\n  propTypes: {\n    bsStyle: React.PropTypes.oneOf(['tabs','pills']),\n    stacked: React.PropTypes.bool,\n    justified: React.PropTypes.bool,\n    onSelect: React.PropTypes.func,\n    collapsable: React.PropTypes.bool,\n    expanded: React.PropTypes.bool,\n    navbar: React.PropTypes.bool,\n    eventKey: React.PropTypes.any,\n    right: React.PropTypes.bool\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'nav'\n    };\n  },\n\n  getCollapsableDOMNode: function () {\n    return this.getDOMNode();\n  },\n\n  getCollapsableDimensionValue: function () {\n    var node = this.refs.ul.getDOMNode(),\n        height = node.offsetHeight,\n        computedStyles = domUtils.getComputedStyles(node);\n\n    return height + parseInt(computedStyles.marginTop, 10) + parseInt(computedStyles.marginBottom, 10);\n  },\n\n  render: function () {\n    var classes = this.props.collapsable ? this.getCollapsableClassSet() : {};\n\n    classes['navbar-collapse'] = this.props.collapsable;\n\n    if (this.props.navbar && !this.props.collapsable) {\n      return (this.renderUl());\n    }\n\n    return (\n      React.createElement(\"nav\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.renderUl()\n      )\n    );\n  },\n\n  renderUl: function () {\n    var classes = this.getBsClassSet();\n\n    classes['nav-stacked'] = this.props.stacked;\n    classes['nav-justified'] = this.props.justified;\n    classes['navbar-nav'] = this.props.navbar;\n    classes['pull-right'] = this.props.pullRight;\n    classes['navbar-right'] = this.props.right;\n\n    return (\n      React.createElement(\"ul\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes)), ref: \"ul\"}), \n        ValidComponentChildren.map(this.props.children, this.renderNavItem)\n      )\n    );\n  },\n\n  getChildActiveProp: function (child) {\n    if (child.props.active) {\n      return true;\n    }\n    if (this.props.activeKey != null) {\n      if (child.props.eventKey == this.props.activeKey) {\n        return true;\n      }\n    }\n    if (this.props.activeHref != null) {\n      if (child.props.href === this.props.activeHref) {\n        return true;\n      }\n    }\n\n    return child.props.active;\n  },\n\n  renderNavItem: function (child, index) {\n    return cloneWithProps(\n      child,\n      {\n        active: this.getChildActiveProp(child),\n        activeKey: this.props.activeKey,\n        activeHref: this.props.activeHref,\n        onSelect: createChainedFunction(child.props.onSelect, this.props.onSelect),\n        ref: child.ref,\n        key: child.key ? child.key : index,\n        navItem: true\n      }\n    );\n  }\n});\n\nmodule.exports = Nav;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Nav.js\n ** module id = 104\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Nav.js?");

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar BootstrapMixin = __webpack_require__(81);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\nvar createChainedFunction = __webpack_require__(199);\nvar Nav = __webpack_require__(104);\n\n\nvar Navbar = React.createClass({displayName: \"Navbar\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    fixedTop: React.PropTypes.bool,\n    fixedBottom: React.PropTypes.bool,\n    staticTop: React.PropTypes.bool,\n    inverse: React.PropTypes.bool,\n    fluid: React.PropTypes.bool,\n    role: React.PropTypes.string,\n    componentClass: React.PropTypes.node.isRequired,\n    brand: React.PropTypes.node,\n    toggleButton: React.PropTypes.node,\n    onToggle: React.PropTypes.func,\n    navExpanded: React.PropTypes.bool,\n    defaultNavExpanded: React.PropTypes.bool\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'navbar',\n      bsStyle: 'default',\n      role: 'navigation',\n      componentClass: 'Nav'\n    };\n  },\n\n  getInitialState: function () {\n    return {\n      navExpanded: this.props.defaultNavExpanded\n    };\n  },\n\n  shouldComponentUpdate: function() {\n    // Defer any updates to this component during the `onSelect` handler.\n    return !this._isChanging;\n  },\n\n  handleToggle: function () {\n    if (this.props.onToggle) {\n      this._isChanging = true;\n      this.props.onToggle();\n      this._isChanging = false;\n    }\n\n    this.setState({\n      navExpanded: !this.state.navExpanded\n    });\n  },\n\n  isNavExpanded: function () {\n    return this.props.navExpanded != null ? this.props.navExpanded : this.state.navExpanded;\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n    var ComponentClass = this.props.componentClass;\n\n    classes['navbar-fixed-top'] = this.props.fixedTop;\n    classes['navbar-fixed-bottom'] = this.props.fixedBottom;\n    classes['navbar-static-top'] = this.props.staticTop;\n    classes['navbar-inverse'] = this.props.inverse;\n\n    return (\n      React.createElement(ComponentClass, React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        React.createElement(\"div\", {className: this.props.fluid ? 'container-fluid' : 'container'}, \n          (this.props.brand || this.props.toggleButton || this.props.toggleNavKey) ? this.renderHeader() : null, \n          ValidComponentChildren.map(this.props.children, this.renderChild)\n        )\n      )\n    );\n  },\n\n  renderChild: function (child, index) {\n    return cloneWithProps(child, {\n      navbar: true,\n      collapsable: this.props.toggleNavKey != null && this.props.toggleNavKey === child.props.eventKey,\n      expanded: this.props.toggleNavKey != null && this.props.toggleNavKey === child.props.eventKey && this.isNavExpanded(),\n      key: child.key ? child.key : index,\n      ref: child.ref\n    });\n  },\n\n  renderHeader: function () {\n    var brand;\n\n    if (this.props.brand) {\n      brand = React.isValidElement(this.props.brand) ?\n        cloneWithProps(this.props.brand, {\n          className: 'navbar-brand'\n        }) : React.createElement(\"span\", {className: \"navbar-brand\"}, this.props.brand);\n    }\n\n    return (\n      React.createElement(\"div\", {className: \"navbar-header\"}, \n        brand, \n        (this.props.toggleButton || this.props.toggleNavKey != null) ? this.renderToggleButton() : null\n      )\n    );\n  },\n\n  renderToggleButton: function () {\n    var children;\n\n    if (React.isValidElement(this.props.toggleButton)) {\n      return cloneWithProps(this.props.toggleButton, {\n        className: 'navbar-toggle',\n        onClick: createChainedFunction(this.handleToggle, this.props.toggleButton.props.onClick)\n      });\n    }\n\n    children = (this.props.toggleButton != null) ?\n      this.props.toggleButton : [\n        React.createElement(\"span\", {className: \"sr-only\", key: 0}, \"Toggle navigation\"),\n        React.createElement(\"span\", {className: \"icon-bar\", key: 1}),\n        React.createElement(\"span\", {className: \"icon-bar\", key: 2}),\n        React.createElement(\"span\", {className: \"icon-bar\", key: 3})\n    ];\n\n    return (\n      React.createElement(\"button\", {className: \"navbar-toggle\", type: \"button\", onClick: this.handleToggle}, \n        children\n      )\n    );\n  }\n});\n\nmodule.exports = Navbar;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Navbar.js\n ** module id = 105\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Navbar.js?");

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\nvar NavItem = React.createClass({displayName: \"NavItem\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    onSelect: React.PropTypes.func,\n    active: React.PropTypes.bool,\n    disabled: React.PropTypes.bool,\n    href: React.PropTypes.string,\n    title: React.PropTypes.string,\n    eventKey: React.PropTypes.any,\n    target: React.PropTypes.string\n  },\n\n  getDefaultProps: function () {\n    return {\n      href: '#'\n    };\n  },\n\n  render: function () {\n    var $__0= \n        \n        \n        \n        \n        \n        \n           this.props,disabled=$__0.disabled,active=$__0.active,href=$__0.href,title=$__0.title,target=$__0.target,children=$__0.children,props=(function(source, exclusion) {var rest = {};var hasOwn = Object.prototype.hasOwnProperty;if (source == null) {throw new TypeError();}for (var key in source) {if (hasOwn.call(source, key) && !hasOwn.call(exclusion, key)) {rest[key] = source[key];}}return rest;})($__0,{disabled:1,active:1,href:1,title:1,target:1,children:1}),\n        classes = {\n          'active': active,\n          'disabled': disabled\n        };\n\n    return (\n      React.createElement(\"li\", React.__spread({},  props, {className: joinClasses(props.className, classSet(classes))}), \n        React.createElement(\"a\", {\n          href: href, \n          title: title, \n          target: target, \n          onClick: this.handleClick, \n          ref: \"anchor\"}, \n          children \n        )\n      )\n    );\n  },\n\n  handleClick: function (e) {\n    if (this.props.onSelect) {\n      e.preventDefault();\n\n      if (!this.props.disabled) {\n        this.props.onSelect(this.props.eventKey, this.props.href, this.props.target);\n      }\n    }\n  }\n});\n\nmodule.exports = NavItem;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/NavItem.js\n ** module id = 106\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/NavItem.js?");

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar OverlayMixin = __webpack_require__(109);\nvar cloneWithProps = __webpack_require__(197);\n\nvar createChainedFunction = __webpack_require__(199);\n\nvar ModalTrigger = React.createClass({displayName: \"ModalTrigger\",\n  mixins: [OverlayMixin],\n\n  propTypes: {\n    modal: React.PropTypes.node.isRequired\n  },\n\n  getInitialState: function () {\n    return {\n      isOverlayShown: false\n    };\n  },\n\n  show: function () {\n    this.setState({\n      isOverlayShown: true\n    });\n  },\n\n  hide: function () {\n    this.setState({\n      isOverlayShown: false\n    });\n  },\n\n  toggle: function () {\n    this.setState({\n      isOverlayShown: !this.state.isOverlayShown\n    });\n  },\n\n  renderOverlay: function () {\n    if (!this.state.isOverlayShown) {\n      return React.createElement(\"span\", null);\n    }\n\n    return cloneWithProps(\n      this.props.modal,\n      {\n        onRequestHide: this.hide\n      }\n    );\n  },\n\n  render: function () {\n    var child = React.Children.only(this.props.children);\n    return cloneWithProps(\n      child,\n      {\n        onClick: createChainedFunction(child.props.onClick, this.toggle)\n      }\n    );\n  }\n});\n\nmodule.exports = ModalTrigger;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/ModalTrigger.js\n ** module id = 107\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/ModalTrigger.js?");

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar OverlayMixin = __webpack_require__(109);\nvar domUtils = __webpack_require__(192);\nvar cloneWithProps = __webpack_require__(197);\n\nvar createChainedFunction = __webpack_require__(199);\nvar assign = __webpack_require__(201);\n\n/**\n * Check if value one is inside or equal to the of value\n *\n * @param {string} one\n * @param {string|array} of\n * @returns {boolean}\n */\nfunction isOneOf(one, of) {\n  if (Array.isArray(of)) {\n    return of.indexOf(one) >= 0;\n  }\n  return one === of;\n}\n\nvar OverlayTrigger = React.createClass({displayName: \"OverlayTrigger\",\n  mixins: [OverlayMixin],\n\n  propTypes: {\n    trigger: React.PropTypes.oneOfType([\n      React.PropTypes.oneOf(['manual', 'click', 'hover', 'focus']),\n      React.PropTypes.arrayOf(React.PropTypes.oneOf(['click', 'hover', 'focus']))\n    ]),\n    placement: React.PropTypes.oneOf(['top','right', 'bottom', 'left']),\n    delay: React.PropTypes.number,\n    delayShow: React.PropTypes.number,\n    delayHide: React.PropTypes.number,\n    defaultOverlayShown: React.PropTypes.bool,\n    overlay: React.PropTypes.node.isRequired\n  },\n\n  getDefaultProps: function () {\n    return {\n      placement: 'right',\n      trigger: ['hover', 'focus']\n    };\n  },\n\n  getInitialState: function () {\n    return {\n      isOverlayShown: this.props.defaultOverlayShown == null ?\n        false : this.props.defaultOverlayShown,\n      overlayLeft: null,\n      overlayTop: null\n    };\n  },\n\n  show: function () {\n    this.setState({\n      isOverlayShown: true\n    }, function() {\n      this.updateOverlayPosition();\n    });\n  },\n\n  hide: function () {\n    this.setState({\n      isOverlayShown: false\n    });\n  },\n\n  toggle: function () {\n    this.state.isOverlayShown ?\n      this.hide() : this.show();\n  },\n\n  renderOverlay: function () {\n    if (!this.state.isOverlayShown) {\n      return React.createElement(\"span\", null);\n    }\n\n    return cloneWithProps(\n      this.props.overlay,\n      {\n        onRequestHide: this.hide,\n        placement: this.props.placement,\n        positionLeft: this.state.overlayLeft,\n        positionTop: this.state.overlayTop\n      }\n    );\n  },\n\n  render: function () {\n    if (this.props.trigger === 'manual') {\n      return React.Children.only(this.props.children);\n    }\n\n    var props = {};\n\n    if (isOneOf('click', this.props.trigger)) {\n      props.onClick = createChainedFunction(this.toggle, this.props.onClick);\n    }\n\n    if (isOneOf('hover', this.props.trigger)) {\n      props.onMouseOver = createChainedFunction(this.handleDelayedShow, this.props.onMouseOver);\n      props.onMouseOut = createChainedFunction(this.handleDelayedHide, this.props.onMouseOut);\n    }\n\n    if (isOneOf('focus', this.props.trigger)) {\n      props.onFocus = createChainedFunction(this.handleDelayedShow, this.props.onFocus);\n      props.onBlur = createChainedFunction(this.handleDelayedHide, this.props.onBlur);\n    }\n\n    return cloneWithProps(\n      React.Children.only(this.props.children),\n      props\n    );\n  },\n\n  componentWillUnmount: function() {\n    clearTimeout(this._hoverDelay);\n  },\n\n  componentDidMount: function() {\n    this.updateOverlayPosition();\n  },\n\n  handleDelayedShow: function () {\n    if (this._hoverDelay != null) {\n      clearTimeout(this._hoverDelay);\n      this._hoverDelay = null;\n      return;\n    }\n\n    var delay = this.props.delayShow != null ?\n      this.props.delayShow : this.props.delay;\n\n    if (!delay) {\n      this.show();\n      return;\n    }\n\n    this._hoverDelay = setTimeout(function() {\n      this._hoverDelay = null;\n      this.show();\n    }.bind(this), delay);\n  },\n\n  handleDelayedHide: function () {\n    if (this._hoverDelay != null) {\n      clearTimeout(this._hoverDelay);\n      this._hoverDelay = null;\n      return;\n    }\n\n    var delay = this.props.delayHide != null ?\n      this.props.delayHide : this.props.delay;\n\n    if (!delay) {\n      this.hide();\n      return;\n    }\n\n    this._hoverDelay = setTimeout(function() {\n      this._hoverDelay = null;\n      this.hide();\n    }.bind(this), delay);\n  },\n\n  updateOverlayPosition: function () {\n    if (!this.isMounted()) {\n      return;\n    }\n\n    var pos = this.calcOverlayPosition();\n\n    this.setState({\n      overlayLeft: pos.left,\n      overlayTop: pos.top\n    });\n  },\n\n  calcOverlayPosition: function () {\n    var childOffset = this.getPosition();\n\n    var overlayNode = this.getOverlayDOMNode();\n    var overlayHeight = overlayNode.offsetHeight;\n    var overlayWidth = overlayNode.offsetWidth;\n\n    switch (this.props.placement) {\n      case 'right':\n        return {\n          top: childOffset.top + childOffset.height / 2 - overlayHeight / 2,\n          left: childOffset.left + childOffset.width\n        };\n      case 'left':\n        return {\n          top: childOffset.top + childOffset.height / 2 - overlayHeight / 2,\n          left: childOffset.left - overlayWidth\n        };\n      case 'top':\n        return {\n          top: childOffset.top - overlayHeight,\n          left: childOffset.left + childOffset.width / 2 - overlayWidth / 2\n        };\n      case 'bottom':\n        return {\n          top: childOffset.top + childOffset.height,\n          left: childOffset.left + childOffset.width / 2 - overlayWidth / 2\n        };\n      default:\n        throw new Error('calcOverlayPosition(): No such placement of \"' + this.props.placement + '\" found.');\n    }\n  },\n\n  getPosition: function () {\n    var node = this.getDOMNode();\n    var container = this.getContainerDOMNode();\n\n    var offset = container.tagName == 'BODY' ?\n      domUtils.getOffset(node) : domUtils.getPosition(node, container);\n\n    return assign({}, offset, {\n      height: node.offsetHeight,\n      width: node.offsetWidth\n    });\n  }\n});\n\nmodule.exports = OverlayTrigger;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/OverlayTrigger.js\n ** module id = 108\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/OverlayTrigger.js?");

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar CustomPropTypes = __webpack_require__(202);\n\nmodule.exports = {\n  propTypes: {\n    container: CustomPropTypes.mountable\n  },\n\n  getDefaultProps: function () {\n    return {\n      container: {\n        // Provide `getDOMNode` fn mocking a React component API. The `document.body`\n        // reference needs to be contained within this function so that it is not accessed\n        // in environments where it would not be defined, e.g. nodejs. Equally this is needed\n        // before the body is defined where `document.body === null`, this ensures\n        // `document.body` is only accessed after componentDidMount.\n        getDOMNode: function getDOMNode() {\n          return document.body;\n        }\n      }\n    };\n  },\n\n  componentWillUnmount: function () {\n    this._unrenderOverlay();\n    if (this._overlayTarget) {\n      this.getContainerDOMNode()\n        .removeChild(this._overlayTarget);\n      this._overlayTarget = null;\n    }\n  },\n\n  componentDidUpdate: function () {\n    this._renderOverlay();\n  },\n\n  componentDidMount: function () {\n    this._renderOverlay();\n  },\n\n  _mountOverlayTarget: function () {\n    this._overlayTarget = document.createElement('div');\n    this.getContainerDOMNode()\n      .appendChild(this._overlayTarget);\n  },\n\n  _renderOverlay: function () {\n    if (!this._overlayTarget) {\n      this._mountOverlayTarget();\n    }\n\n    var overlay = this.renderOverlay();\n\n    // Save reference to help testing\n    if (overlay !== null) {\n      this._overlayInstance = React.render(overlay, this._overlayTarget);\n    } else {\n      // Unrender if the component is null for transitions to null\n      this._unrenderOverlay();\n    }\n  },\n\n  _unrenderOverlay: function () {\n    React.unmountComponentAtNode(this._overlayTarget);\n    this._overlayInstance = null;\n  },\n\n  getOverlayDOMNode: function () {\n    if (!this.isMounted()) {\n      throw new Error('getOverlayDOMNode(): A component must be mounted to have a DOM node.');\n    }\n\n    if (this._overlayInstance) {\n      return this._overlayInstance.getDOMNode();\n    }\n\n    return null;\n  },\n\n  getContainerDOMNode: function () {\n    return this.props.container.getDOMNode ?\n      this.props.container.getDOMNode() : this.props.container;\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/OverlayMixin.js\n ** module id = 109\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/OverlayMixin.js?");

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\n\nvar PageHeader = React.createClass({displayName: \"PageHeader\",\n\n  render: function () {\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, 'page-header')}), \n        React.createElement(\"h1\", null, this.props.children)\n      )\n    );\n  }\n});\n\nmodule.exports = PageHeader;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/PageHeader.js\n ** module id = 110\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/PageHeader.js?");

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar BootstrapMixin = __webpack_require__(81);\nvar CollapsableMixin = __webpack_require__(89);\n\nvar Panel = React.createClass({displayName: \"Panel\",\n  mixins: [BootstrapMixin, CollapsableMixin],\n\n  propTypes: {\n    onSelect: React.PropTypes.func,\n    header: React.PropTypes.node,\n    footer: React.PropTypes.node,\n    eventKey: React.PropTypes.any\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'panel',\n      bsStyle: 'default'\n    };\n  },\n\n  handleSelect: function (e) {\n    if (this.props.onSelect) {\n      this._isChanging = true;\n      this.props.onSelect(this.props.eventKey);\n      this._isChanging = false;\n    }\n\n    e.preventDefault();\n\n    this.setState({\n      expanded: !this.state.expanded\n    });\n  },\n\n  shouldComponentUpdate: function () {\n    return !this._isChanging;\n  },\n\n  getCollapsableDimensionValue: function () {\n    return this.refs.body.getDOMNode().offsetHeight;\n  },\n\n  getCollapsableDOMNode: function () {\n    if (!this.isMounted() || !this.refs || !this.refs.panel) {\n      return null;\n    }\n\n    return this.refs.panel.getDOMNode();\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n    classes['panel'] = true;\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes)), \n        id: this.props.collapsable ? null : this.props.id, onSelect: null}), \n        this.renderHeading(), \n        this.props.collapsable ? this.renderCollapsableBody() : this.renderBody(), \n        this.renderFooter()\n      )\n    );\n  },\n\n  renderCollapsableBody: function () {\n    return (\n      React.createElement(\"div\", {className: classSet(this.getCollapsableClassSet('panel-collapse')), id: this.props.id, ref: \"panel\"}, \n        this.renderBody()\n      )\n    );\n  },\n\n  renderBody: function () {\n    return (\n      React.createElement(\"div\", {className: \"panel-body\", ref: \"body\"}, \n        this.props.children\n      )\n    );\n  },\n\n  renderHeading: function () {\n    var header = this.props.header;\n\n    if (!header) {\n      return null;\n    }\n\n    if (!React.isValidElement(header) || Array.isArray(header)) {\n      header = this.props.collapsable ?\n        this.renderCollapsableTitle(header) : header;\n    } else if (this.props.collapsable) {\n      header = cloneWithProps(header, {\n        className: 'panel-title',\n        children: this.renderAnchor(header.props.children)\n      });\n    } else {\n      header = cloneWithProps(header, {\n        className: 'panel-title'\n      });\n    }\n\n    return (\n      React.createElement(\"div\", {className: \"panel-heading\"}, \n        header\n      )\n    );\n  },\n\n  renderAnchor: function (header) {\n    return (\n      React.createElement(\"a\", {\n        href: '#' + (this.props.id || ''), \n        className: this.isExpanded() ? null : 'collapsed', \n        onClick: this.handleSelect}, \n        header\n      )\n    );\n  },\n\n  renderCollapsableTitle: function (header) {\n    return (\n      React.createElement(\"h4\", {className: \"panel-title\"}, \n        this.renderAnchor(header)\n      )\n    );\n  },\n\n  renderFooter: function () {\n    if (!this.props.footer) {\n      return null;\n    }\n\n    return (\n      React.createElement(\"div\", {className: \"panel-footer\"}, \n        this.props.footer\n      )\n    );\n  }\n});\n\nmodule.exports = Panel;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Panel.js\n ** module id = 111\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Panel.js?");

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar BootstrapMixin = __webpack_require__(81);\nvar ValidComponentChildren = __webpack_require__(196);\n\nvar PanelGroup = React.createClass({displayName: \"PanelGroup\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    collapsable: React.PropTypes.bool,\n    activeKey: React.PropTypes.any,\n    defaultActiveKey: React.PropTypes.any,\n    onSelect: React.PropTypes.func\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'panel-group'\n    };\n  },\n\n  getInitialState: function () {\n    var defaultActiveKey = this.props.defaultActiveKey;\n\n    return {\n      activeKey: defaultActiveKey\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes)), onSelect: null}), \n        ValidComponentChildren.map(this.props.children, this.renderPanel)\n      )\n    );\n  },\n\n  renderPanel: function (child, index) {\n    var activeKey =\n      this.props.activeKey != null ? this.props.activeKey : this.state.activeKey;\n\n    var props = {\n      bsStyle: child.props.bsStyle || this.props.bsStyle,\n      key: child.key ? child.key : index,\n      ref: child.ref\n    };\n\n    if (this.props.accordion) {\n      props.collapsable = true;\n      props.expanded = (child.props.eventKey === activeKey);\n      props.onSelect = this.handleSelect;\n    }\n\n    return cloneWithProps(\n      child,\n      props\n    );\n  },\n\n  shouldComponentUpdate: function() {\n    // Defer any updates to this component during the `onSelect` handler.\n    return !this._isChanging;\n  },\n\n  handleSelect: function (key) {\n    if (this.props.onSelect) {\n      this._isChanging = true;\n      this.props.onSelect(key);\n      this._isChanging = false;\n    }\n\n    if (this.state.activeKey === key) {\n      key = null;\n    }\n\n    this.setState({\n      activeKey: key\n    });\n  }\n});\n\nmodule.exports = PanelGroup;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/PanelGroup.js\n ** module id = 112\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/PanelGroup.js?");

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\n\nvar PageItem = React.createClass({displayName: \"PageItem\",\n\n  propTypes: {\n    href: React.PropTypes.string,\n    target: React.PropTypes.string,\n    disabled: React.PropTypes.bool,\n    previous: React.PropTypes.bool,\n    next: React.PropTypes.bool,\n    onSelect: React.PropTypes.func,\n    eventKey: React.PropTypes.any\n  },\n\n  getDefaultProps: function () {\n    return {\n      href: '#'\n    };\n  },\n\n  render: function () {\n    var classes = {\n      'disabled': this.props.disabled,\n      'previous': this.props.previous,\n      'next': this.props.next\n    };\n\n    return (\n      React.createElement(\"li\", React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, classSet(classes))}), \n        React.createElement(\"a\", {\n          href: this.props.href, \n          title: this.props.title, \n          target: this.props.target, \n          onClick: this.handleSelect, \n          ref: \"anchor\"}, \n          this.props.children\n        )\n      )\n    );\n  },\n\n  handleSelect: function (e) {\n    if (this.props.onSelect) {\n      e.preventDefault();\n\n      if (!this.props.disabled) {\n        this.props.onSelect(this.props.eventKey, this.props.href, this.props.target);\n      }\n    }\n  }\n});\n\nmodule.exports = PageItem;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/PageItem.js\n ** module id = 113\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/PageItem.js?");

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\nvar createChainedFunction = __webpack_require__(199);\n\nvar Pager = React.createClass({displayName: \"Pager\",\n\n  propTypes: {\n    onSelect: React.PropTypes.func\n  },\n\n  render: function () {\n    return (\n      React.createElement(\"ul\", React.__spread({}, \n        this.props, \n        {className: joinClasses(this.props.className, 'pager')}), \n        ValidComponentChildren.map(this.props.children, this.renderPageItem)\n      )\n    );\n  },\n\n  renderPageItem: function (child, index) {\n    return cloneWithProps(\n      child,\n      {\n        onSelect: createChainedFunction(child.props.onSelect, this.props.onSelect),\n        ref: child.ref,\n        key: child.key ? child.key : index\n      }\n    );\n  }\n});\n\nmodule.exports = Pager;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Pager.js\n ** module id = 114\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Pager.js?");

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\n\nvar Popover = React.createClass({displayName: \"Popover\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    placement: React.PropTypes.oneOf(['top','right', 'bottom', 'left']),\n    positionLeft: React.PropTypes.number,\n    positionTop: React.PropTypes.number,\n    arrowOffsetLeft: React.PropTypes.number,\n    arrowOffsetTop: React.PropTypes.number,\n    title: React.PropTypes.node\n  },\n\n  getDefaultProps: function () {\n    return {\n      placement: 'right'\n    };\n  },\n\n  render: function () {\n    var classes = {};\n    classes['popover'] = true;\n    classes[this.props.placement] = true;\n    classes['in'] = this.props.positionLeft != null || this.props.positionTop != null;\n\n    var style = {};\n    style['left'] = this.props.positionLeft;\n    style['top'] = this.props.positionTop;\n    style['display'] = 'block';\n\n    var arrowStyle = {};\n    arrowStyle['left'] = this.props.arrowOffsetLeft;\n    arrowStyle['top'] = this.props.arrowOffsetTop;\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes)), style: style, title: null}), \n        React.createElement(\"div\", {className: \"arrow\", style: arrowStyle}), \n        this.props.title ? this.renderTitle() : null, \n        React.createElement(\"div\", {className: \"popover-content\"}, \n          this.props.children\n        )\n      )\n    );\n  },\n\n  renderTitle: function() {\n    return (\n      React.createElement(\"h3\", {className: \"popover-title\"}, this.props.title)\n    );\n  }\n});\n\nmodule.exports = Popover;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Popover.js\n ** module id = 115\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Popover.js?");

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar Interpolate = __webpack_require__(97);\nvar BootstrapMixin = __webpack_require__(81);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\n\n\nvar ProgressBar = React.createClass({displayName: \"ProgressBar\",\n  propTypes: {\n    min: React.PropTypes.number,\n    now: React.PropTypes.number,\n    max: React.PropTypes.number,\n    label: React.PropTypes.node,\n    srOnly: React.PropTypes.bool,\n    striped: React.PropTypes.bool,\n    active: React.PropTypes.bool\n  },\n\n  mixins: [BootstrapMixin],\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'progress-bar',\n      min: 0,\n      max: 100\n    };\n  },\n\n  getPercentage: function (now, min, max) {\n    return Math.ceil((now - min) / (max - min) * 100);\n  },\n\n  render: function () {\n    var classes = {\n        progress: true\n      };\n\n    if (this.props.active) {\n      classes['progress-striped'] = true;\n      classes['active'] = true;\n    } else if (this.props.striped) {\n      classes['progress-striped'] = true;\n    }\n\n    if (!ValidComponentChildren.hasValidComponent(this.props.children)) {\n      if (!this.props.isChild) {\n        return (\n          React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n            this.renderProgressBar()\n          )\n        );\n      } else {\n        return (\n          this.renderProgressBar()\n        );\n      }\n    } else {\n      return (\n        React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n          ValidComponentChildren.map(this.props.children, this.renderChildBar)\n        )\n      );\n    }\n  },\n\n  renderChildBar: function (child, index) {\n    return cloneWithProps(child, {\n      isChild: true,\n      key: child.key ? child.key : index,\n      ref: child.ref\n    });\n  },\n\n  renderProgressBar: function () {\n    var percentage = this.getPercentage(\n        this.props.now,\n        this.props.min,\n        this.props.max\n      );\n\n    var label;\n\n    if (typeof this.props.label === \"string\") {\n      label = this.renderLabel(percentage);\n    } else if (this.props.label) {\n      label = this.props.label;\n    }\n\n    if (this.props.srOnly) {\n      label = this.renderScreenReaderOnlyLabel(label);\n    }\n\n    var classes = this.getBsClassSet();\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes)), role: \"progressbar\", \n        style: {width: percentage + '%'}, \n        \"aria-valuenow\": this.props.now, \n        \"aria-valuemin\": this.props.min, \n        \"aria-valuemax\": this.props.max}), \n        label\n      )\n    );\n  },\n\n  renderLabel: function (percentage) {\n    var InterpolateClass = this.props.interpolateClass || Interpolate;\n\n    return (\n      React.createElement(InterpolateClass, {\n        now: this.props.now, \n        min: this.props.min, \n        max: this.props.max, \n        percent: percentage, \n        bsStyle: this.props.bsStyle}, \n        this.props.label\n      )\n    );\n  },\n\n  renderScreenReaderOnlyLabel: function (label) {\n    return (\n      React.createElement(\"span\", {className: \"sr-only\"}, \n        label\n      )\n    );\n  }\n});\n\nmodule.exports = ProgressBar;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/ProgressBar.js\n ** module id = 116\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/ProgressBar.js?");

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\n\nvar Row = React.createClass({displayName: \"Row\",\n  propTypes: {\n    componentClass: React.PropTypes.node.isRequired\n  },\n\n  getDefaultProps: function () {\n    return {\n      componentClass: 'div'\n    };\n  },\n\n  render: function () {\n    var ComponentClass = this.props.componentClass;\n\n    return (\n      React.createElement(ComponentClass, React.__spread({},  this.props, {className: joinClasses(this.props.className, 'row')}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Row;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Row.js\n ** module id = 117\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Row.js?");

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\nvar DropdownStateMixin = __webpack_require__(92);\nvar Button = __webpack_require__(83);\nvar ButtonGroup = __webpack_require__(84);\nvar DropdownMenu = __webpack_require__(91);\n\nvar SplitButton = React.createClass({displayName: \"SplitButton\",\n  mixins: [BootstrapMixin, DropdownStateMixin],\n\n  propTypes: {\n    pullRight:     React.PropTypes.bool,\n    title:         React.PropTypes.node,\n    href:          React.PropTypes.string,\n    target:        React.PropTypes.string,\n    dropdownTitle: React.PropTypes.node,\n    onClick:       React.PropTypes.func,\n    onSelect:      React.PropTypes.func,\n    disabled:      React.PropTypes.bool\n  },\n\n  getDefaultProps: function () {\n    return {\n      dropdownTitle: 'Toggle dropdown'\n    };\n  },\n\n  render: function () {\n    var groupClasses = {\n        'open': this.state.open,\n        'dropup': this.props.dropup\n      };\n\n    var button = (\n      React.createElement(Button, React.__spread({}, \n        this.props, \n        {ref: \"button\", \n        onClick: this.handleButtonClick, \n        title: null, \n        id: null}), \n        this.props.title\n      )\n    );\n\n    var dropdownButton = (\n      React.createElement(Button, React.__spread({}, \n        this.props, \n        {ref: \"dropdownButton\", \n        className: joinClasses(this.props.className, 'dropdown-toggle'), \n        onClick: this.handleDropdownClick, \n        title: null, \n        href: null, \n        target: null, \n        id: null}), \n        React.createElement(\"span\", {className: \"sr-only\"}, this.props.dropdownTitle), \n        React.createElement(\"span\", {className: \"caret\"})\n      )\n    );\n\n    return (\n      React.createElement(ButtonGroup, {\n        bsSize: this.props.bsSize, \n        className: classSet(groupClasses), \n        id: this.props.id}, \n        button, \n        dropdownButton, \n        React.createElement(DropdownMenu, {\n          ref: \"menu\", \n          onSelect: this.handleOptionSelect, \n          \"aria-labelledby\": this.props.id, \n          pullRight: this.props.pullRight}, \n          this.props.children\n        )\n      )\n    );\n  },\n\n  handleButtonClick: function (e) {\n    if (this.state.open) {\n      this.setDropdownState(false);\n    }\n\n    if (this.props.onClick) {\n      this.props.onClick(e, this.props.href, this.props.target);\n    }\n  },\n\n  handleDropdownClick: function (e) {\n    e.preventDefault();\n\n    this.setDropdownState(!this.state.open);\n  },\n\n  handleOptionSelect: function (key) {\n    if (this.props.onSelect) {\n      this.props.onSelect(key);\n    }\n\n    this.setDropdownState(false);\n  }\n});\n\nmodule.exports = SplitButton;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/SplitButton.js\n ** module id = 118\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/SplitButton.js?");

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\nvar createChainedFunction = __webpack_require__(199);\nvar BootstrapMixin = __webpack_require__(81);\n\n\nvar SubNav = React.createClass({displayName: \"SubNav\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    onSelect: React.PropTypes.func,\n    active: React.PropTypes.bool,\n    disabled: React.PropTypes.bool,\n    href: React.PropTypes.string,\n    title: React.PropTypes.string,\n    text: React.PropTypes.node,\n    target: React.PropTypes.string\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'nav'\n    };\n  },\n\n  handleClick: function (e) {\n    if (this.props.onSelect) {\n      e.preventDefault();\n\n      if (!this.props.disabled) {\n        this.props.onSelect(this.props.eventKey, this.props.href, this.props.target);\n      }\n    }\n  },\n\n  isActive: function () {\n    return this.isChildActive(this);\n  },\n\n  isChildActive: function (child) {\n    if (child.props.active) {\n      return true;\n    }\n\n    if (this.props.activeKey != null && this.props.activeKey === child.props.eventKey) {\n      return true;\n    }\n\n    if (this.props.activeHref != null && this.props.activeHref === child.props.href) {\n      return true;\n    }\n\n    if (child.props.children) {\n      var isActive = false;\n\n      ValidComponentChildren.forEach(\n        child.props.children,\n        function (child) {\n          if (this.isChildActive(child)) {\n            isActive = true;\n          }\n        },\n        this\n      );\n\n      return isActive;\n    }\n\n    return false;\n  },\n\n  getChildActiveProp: function (child) {\n    if (child.props.active) {\n      return true;\n    }\n    if (this.props.activeKey != null) {\n      if (child.props.eventKey == this.props.activeKey) {\n        return true;\n      }\n    }\n    if (this.props.activeHref != null) {\n      if (child.props.href === this.props.activeHref) {\n        return true;\n      }\n    }\n\n    return child.props.active;\n  },\n\n  render: function () {\n    var classes = {\n      'active': this.isActive(),\n      'disabled': this.props.disabled\n    };\n\n    return (\n      React.createElement(\"li\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        React.createElement(\"a\", {\n          href: this.props.href, \n          title: this.props.title, \n          target: this.props.target, \n          onClick: this.handleClick, \n          ref: \"anchor\"}, \n          this.props.text\n        ), \n        React.createElement(\"ul\", {className: \"nav\"}, \n          ValidComponentChildren.map(this.props.children, this.renderNavItem)\n        )\n      )\n    );\n  },\n\n  renderNavItem: function (child, index) {\n    return cloneWithProps(\n      child,\n      {\n        active: this.getChildActiveProp(child),\n        onSelect: createChainedFunction(child.props.onSelect, this.props.onSelect),\n        ref: child.ref,\n        key: child.key ? child.key : index\n      }\n    );\n  }\n});\n\nmodule.exports = SubNav;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/SubNav.js\n ** module id = 119\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/SubNav.js?");

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar BootstrapMixin = __webpack_require__(81);\nvar cloneWithProps = __webpack_require__(197);\n\nvar ValidComponentChildren = __webpack_require__(196);\nvar Nav = __webpack_require__(104);\nvar NavItem = __webpack_require__(106);\n\nfunction getDefaultActiveKeyFromChildren(children) {\n  var defaultActiveKey;\n\n  ValidComponentChildren.forEach(children, function(child) {\n    if (defaultActiveKey == null) {\n      defaultActiveKey = child.props.eventKey;\n    }\n  });\n\n  return defaultActiveKey;\n}\n\nvar TabbedArea = React.createClass({displayName: \"TabbedArea\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    bsStyle: React.PropTypes.oneOf(['tabs','pills']),\n    animation: React.PropTypes.bool,\n    onSelect: React.PropTypes.func\n  },\n\n  getDefaultProps: function () {\n    return {\n      bsStyle: \"tabs\",\n      animation: true\n    };\n  },\n\n  getInitialState: function () {\n    var defaultActiveKey = this.props.defaultActiveKey != null ?\n      this.props.defaultActiveKey : getDefaultActiveKeyFromChildren(this.props.children);\n\n    // TODO: In __DEV__ mode warn via `console.warn` if no `defaultActiveKey` has\n    // been set by this point, invalid children or missing key properties are likely the cause.\n\n    return {\n      activeKey: defaultActiveKey,\n      previousActiveKey: null\n    };\n  },\n\n  componentWillReceiveProps: function (nextProps) {\n    if (nextProps.activeKey != null && nextProps.activeKey !== this.props.activeKey) {\n      this.setState({\n        previousActiveKey: this.props.activeKey\n      });\n    }\n  },\n\n  handlePaneAnimateOutEnd: function () {\n    this.setState({\n      previousActiveKey: null\n    });\n  },\n\n  render: function () {\n    var activeKey =\n      this.props.activeKey != null ? this.props.activeKey : this.state.activeKey;\n\n    function renderTabIfSet(child) {\n      return child.props.tab != null ? this.renderTab(child) : null;\n    }\n\n    var nav = (\n      React.createElement(Nav, React.__spread({},  this.props, {activeKey: activeKey, onSelect: this.handleSelect, ref: \"tabs\"}), \n        ValidComponentChildren.map(this.props.children, renderTabIfSet, this)\n      )\n    );\n\n    return (\n      React.createElement(\"div\", null, \n        nav, \n        React.createElement(\"div\", {id: this.props.id, className: \"tab-content\", ref: \"panes\"}, \n          ValidComponentChildren.map(this.props.children, this.renderPane)\n        )\n      )\n    );\n  },\n\n  getActiveKey: function () {\n    return this.props.activeKey != null ? this.props.activeKey : this.state.activeKey;\n  },\n\n  renderPane: function (child, index) {\n    var activeKey = this.getActiveKey();\n\n    return cloneWithProps(\n        child,\n        {\n          active: (child.props.eventKey === activeKey &&\n            (this.state.previousActiveKey == null || !this.props.animation)),\n          ref: child.ref,\n          key: child.key ? child.key : index,\n          animation: this.props.animation,\n          onAnimateOutEnd: (this.state.previousActiveKey != null &&\n            child.props.eventKey === this.state.previousActiveKey) ? this.handlePaneAnimateOutEnd: null\n        }\n      );\n  },\n\n  renderTab: function (child) {\n    var key = child.props.eventKey;\n    return (\n      React.createElement(NavItem, {\n        ref: 'tab' + key, \n        eventKey: key}, \n        child.props.tab\n      )\n    );\n  },\n\n  shouldComponentUpdate: function() {\n    // Defer any updates to this component during the `onSelect` handler.\n    return !this._isChanging;\n  },\n\n  handleSelect: function (key) {\n    if (this.props.onSelect) {\n      this._isChanging = true;\n      this.props.onSelect(key);\n      this._isChanging = false;\n    } else if (key !== this.getActiveKey()) {\n      this.setState({\n        activeKey: key,\n        previousActiveKey: this.getActiveKey()\n      });\n    }\n  }\n});\n\nmodule.exports = TabbedArea;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/TabbedArea.js\n ** module id = 120\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/TabbedArea.js?");

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\n\nvar Table = React.createClass({displayName: \"Table\",\n  propTypes: {\n    striped: React.PropTypes.bool,\n    bordered: React.PropTypes.bool,\n    condensed: React.PropTypes.bool,\n    hover: React.PropTypes.bool,\n    responsive: React.PropTypes.bool\n  },\n\n  render: function () {\n    var classes = {\n      'table': true,\n      'table-striped': this.props.striped,\n      'table-bordered': this.props.bordered,\n      'table-condensed': this.props.condensed,\n      'table-hover': this.props.hover\n    };\n    var table = (\n      React.createElement(\"table\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n\n    return this.props.responsive ? (\n      React.createElement(\"div\", {className: \"table-responsive\"}, \n        table\n      )\n    ) : table;\n  }\n});\n\nmodule.exports = Table;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Table.js\n ** module id = 121\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Table.js?");

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar TransitionEvents = __webpack_require__(198);\n\nvar TabPane = React.createClass({displayName: \"TabPane\",\n  getDefaultProps: function () {\n    return {\n      animation: true\n    };\n  },\n\n  getInitialState: function () {\n    return {\n      animateIn: false,\n      animateOut: false\n    };\n  },\n\n  componentWillReceiveProps: function (nextProps) {\n    if (this.props.animation) {\n      if (!this.state.animateIn && nextProps.active && !this.props.active) {\n        this.setState({\n          animateIn: true\n        });\n      } else if (!this.state.animateOut && !nextProps.active && this.props.active) {\n        this.setState({\n          animateOut: true\n        });\n      }\n    }\n  },\n\n  componentDidUpdate: function () {\n    if (this.state.animateIn) {\n      setTimeout(this.startAnimateIn, 0);\n    }\n    if (this.state.animateOut) {\n      TransitionEvents.addEndEventListener(\n        this.getDOMNode(),\n        this.stopAnimateOut\n      );\n    }\n  },\n\n  startAnimateIn: function () {\n    if (this.isMounted()) {\n      this.setState({\n        animateIn: false\n      });\n    }\n  },\n\n  stopAnimateOut: function () {\n    if (this.isMounted()) {\n      this.setState({\n        animateOut: false\n      });\n\n      if (typeof this.props.onAnimateOutEnd === 'function') {\n        this.props.onAnimateOutEnd();\n      }\n    }\n  },\n\n  render: function () {\n    var classes = {\n      'tab-pane': true,\n      'fade': true,\n      'active': this.props.active || this.state.animateOut,\n      'in': this.props.active && !this.state.animateIn\n    };\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = TabPane;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/TabPane.js\n ** module id = 122\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/TabPane.js?");

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\n\nvar Tooltip = React.createClass({displayName: \"Tooltip\",\n  mixins: [BootstrapMixin],\n\n  propTypes: {\n    placement: React.PropTypes.oneOf(['top','right', 'bottom', 'left']),\n    positionLeft: React.PropTypes.number,\n    positionTop: React.PropTypes.number,\n    arrowOffsetLeft: React.PropTypes.number,\n    arrowOffsetTop: React.PropTypes.number\n  },\n\n  getDefaultProps: function () {\n    return {\n      placement: 'right'\n    };\n  },\n\n  render: function () {\n    var classes = {};\n    classes['tooltip'] = true;\n    classes[this.props.placement] = true;\n    classes['in'] = this.props.positionLeft != null || this.props.positionTop != null;\n\n    var style = {};\n    style['left'] = this.props.positionLeft;\n    style['top'] = this.props.positionTop;\n\n    var arrowStyle = {};\n    arrowStyle['left'] = this.props.arrowOffsetLeft;\n    arrowStyle['top'] = this.props.arrowOffsetTop;\n\n    return (\n        React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes)), style: style}), \n          React.createElement(\"div\", {className: \"tooltip-arrow\", style: arrowStyle}), \n          React.createElement(\"div\", {className: \"tooltip-inner\"}, \n            this.props.children\n          )\n        )\n      );\n  }\n});\n\nmodule.exports = Tooltip;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Tooltip.js\n ** module id = 123\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Tooltip.js?");

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar classSet = __webpack_require__(195);\nvar BootstrapMixin = __webpack_require__(81);\n\nvar Well = React.createClass({displayName: \"Well\",\n  mixins: [BootstrapMixin],\n\n  getDefaultProps: function () {\n    return {\n      bsClass: 'well'\n    };\n  },\n\n  render: function () {\n    var classes = this.getBsClassSet();\n\n    return (\n      React.createElement(\"div\", React.__spread({},  this.props, {className: joinClasses(this.props.className, classSet(classes))}), \n        this.props.children\n      )\n    );\n  }\n});\n\nmodule.exports = Well;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/Well.js\n ** module id = 124\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/Well.js?");

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * This file is part of Cytoscape.js 2.3.8.\n * \n * Cytoscape.js is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n * \n * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n * \n * You should have received a copy of the GNU Lesser General Public License along with\n * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.\n */\n \n\n// this is put as a global var in the browser\n// or it's just a global to this module if commonjs\n\nvar cytoscape;\n\n(function(window){ 'use strict';\n\n  // the object iteself is a function that init's an instance of cytoscape\n\n  var $$ = cytoscape = function(){ // jshint ignore:line\n    return cytoscape.init.apply(cytoscape, arguments);\n  };\n\n  $$.version = '2.3.8';\n  \n  // allow functional access to cytoscape.js\n  // e.g. var cyto = $.cytoscape({ selector: \"#foo\", ... });\n  //      var nodes = cyto.nodes();\n  $$.init = function( options ){\n    \n    // if no options specified, use default\n    if( options === undefined ){\n      options = {};\n    }\n\n    // create instance\n    if( $$.is.plainObject( options ) ){\n      return new $$.Core( options );\n    } \n    \n    // allow for registration of extensions\n    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);\n    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);\n    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });\n    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });\n    else if( $$.is.string( options ) ) {\n      return $$.extension.apply($$.extension, arguments);\n    }\n  };\n\n  // define the function namespace here, since it has members in many places\n  $$.fn = {};\n\n  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module\n    module.exports = cytoscape;\n  }\n\n  if( true ){ // expose as an amd/requirejs module\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){\n      return cytoscape;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n\n  // make sure we always register in the window just in case (e.g. w/ derbyjs)\n  if( window ){\n    window.cytoscape = cytoscape;\n  }\n  \n})( typeof window === 'undefined' ? null : window );\n\n// type testing utility functions\n\n;(function($$, window){ 'use strict';\n\n  $$.is = {\n    defined: function(obj){\n      return obj != null; // not undefined or null\n    },\n\n    string: function(obj){\n      return obj != null && typeof obj == typeof '';\n    },\n    \n    fn: function(obj){\n      return obj != null && typeof obj === typeof function(){};\n    },\n    \n    array: function(obj){\n      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;\n    },\n    \n    plainObject: function(obj){\n      return obj != null && typeof obj === typeof {} && !$$.is.array(obj) && obj.constructor === Object;\n    },\n    \n    number: function(obj){\n      return obj != null && typeof obj === typeof 1 && !isNaN(obj);\n    },\n\n    integer: function( obj ){\n      return $$.is.number(obj) && Math.floor(obj) === obj;\n    },\n    \n    color: function(obj){\n      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';\n    },\n    \n    bool: function(obj){\n      return obj != null && typeof obj === typeof true;\n    },\n    \n    elementOrCollection: function(obj){\n      return $$.is.element(obj) || $$.is.collection(obj);\n    },\n    \n    element: function(obj){\n      return obj instanceof $$.Element && obj._private.single;\n    },\n    \n    collection: function(obj){\n      return obj instanceof $$.Collection && !obj._private.single;\n    },\n    \n    core: function(obj){\n      return obj instanceof $$.Core;\n    },\n\n    style: function(obj){\n      return obj instanceof $$.Style;\n    },\n\n    stylesheet: function(obj){\n      return obj instanceof $$.Stylesheet;\n    },\n\n    event: function(obj){\n      return obj instanceof $$.Event;\n    },\n\n    emptyString: function(obj){\n      if( !obj ){ // null is empty\n        return true; \n      } else if( $$.is.string(obj) ){\n        if( obj === '' || obj.match(/^\\s+$/) ){\n          return true; // empty string is empty\n        }\n      }\n      \n      return false; // otherwise, we don't know what we've got\n    },\n    \n    nonemptyString: function(obj){\n      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\\s+$/) ){\n        return true;\n      }\n\n      return false;\n    },\n\n    domElement: function(obj){\n      if( typeof HTMLElement === 'undefined' ){\n        return false; // we're not in a browser so it doesn't matter\n      } else {\n        return obj instanceof HTMLElement;\n      }\n    },\n\n    boundingBox: function(obj){\n      return $$.is.plainObject(obj) && \n        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&\n        $$.is.number(obj.y1) && $$.is.number(obj.y2)\n      ;\n    },\n\n    touch: function(){\n      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );\n    },\n\n    gecko: function(){\n      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);\n    },\n\n    webkit: function(){\n      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);\n    },\n\n    chromium: function(){\n      return typeof chrome !== 'undefined';\n    },\n\n    khtml: function(){\n      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...\n    },\n\n    khtmlEtc: function(){\n      return $$.is.khtml() || $$.is.webkit() || $$.is.blink();\n    },\n\n    trident: function(){\n       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;\n    },\n\n    windows: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);\n    },\n\n    mac: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);\n    },\n\n    linux: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);\n    },\n\n    unix: function(){\n      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);\n    }\n  };  \n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n;(function($$, window){ 'use strict';\n  \n  // utility functions only for internal use\n\n  $$.util = {\n\n    // the jquery extend() function\n    // NB: modified to use $$.is etc since we can't use jquery functions\n    extend: function() {\n      var options, name, src, copy, copyIsArray, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n      // Handle a deep copy situation\n      if ( typeof target === 'boolean' ) {\n        deep = target;\n        target = arguments[1] || {};\n        // skip the boolean and the target\n        i = 2;\n      }\n\n      // Handle case when target is a string or something (possible in deep copy)\n      if ( typeof target !== 'object' && !$$.is.fn(target) ) {\n        target = {};\n      }\n\n      // extend jQuery itself if only one argument is passed\n      if ( length === i ) {\n        target = this;\n        --i;\n      }\n\n      for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) {\n          // Extend the base object\n          for ( name in options ) {\n            src = target[ name ];\n            copy = options[ name ];\n\n            // Prevent never-ending loop\n            if ( target === copy ) {\n              continue;\n            }\n\n            // Recurse if we're merging plain objects or arrays\n            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {\n              if ( copyIsArray ) {\n                copyIsArray = false;\n                clone = src && $$.is.array(src) ? src : [];\n\n              } else {\n                clone = src && $$.is.plainObject(src) ? src : {};\n              }\n\n              // Never move original objects, clone them\n              target[ name ] = $$.util.extend( deep, clone, copy );\n\n            // Don't bring in undefined values\n            } else if ( copy !== undefined ) {\n              target[ name ] = copy;\n            }\n          }\n        }\n      }\n\n      // Return the modified object\n      return target;\n    },\n\n    // require that pulls in module from commonjs, amd, or window (falling back until found)\n    require: function( name, callback, options ){\n      var ret;\n      options = $$.util.extend({\n        msgIfNotFound: true\n      }, options);\n\n      var done = false;\n      var fulfil = function( ret ){\n        done = true;\n        callback( ret );\n      };\n\n      var checkWindow = function( next ){\n        if( window ){ // detected browser/window env\n          ret = window[ name ];\n        }\n\n        if( ret !== undefined ){ fulfil(ret); }\n        if( next ){ next(); }\n      };\n      var onCheckWindowDone = function(){\n        if( !done ){\n          checkCommonJs( onCheckCommonJsDone );\n        }\n      };\n\n      var checkCommonJs = function( next ){\n        if( typeof module !== 'undefined' && module.exports && __webpack_require__(200) ){ // detected commonjs env\n          ret = __webpack_require__(200)(name); // regular require\n        }\n\n        if( ret !== undefined ){ fulfil(ret); }\n        if( next ){ next(); }\n      };\n      var onCheckCommonJsDone = function(){\n        if( !done ){\n          checkAmd( onCheckAmdDone );\n        }\n      };\n\n      var checkAmd = function( next ){\n        if( \"function\" !== 'undefined' && __webpack_require__(203) && __webpack_require__(200) ){ // detected amd env w/ defined module\n          !/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [ __webpack_require__(200)(name) ]; (function( nameImpl ){\n            ret = nameImpl;\n            \n            if( ret !== undefined ){ fulfil(ret); }\n            if( next ){ next(); }\n          }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());\n        }\n      };\n      var onCheckAmdDone = function(){\n        if( !done && options.msgIfNotFound ){\n          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');\n        }\n      };\n\n      // kick off 1st check: window\n      checkWindow( onCheckWindowDone );\n\n    },\n\n    // multiple requires in one callback\n    requires: function( names, callback ){\n      var impls = [];\n      var gotImpl = [];\n\n      var checkDone = function(){\n        for( var i = 0; i < names.length; i++ ){ // check have all impls\n          if( !gotImpl[i] ){ return; }\n        }\n\n        // otherwise, all got all impls => done\n        callback.apply( callback, impls ); \n      };\n\n      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope\n        var name = names[i];\n        var index = i;\n\n        $$.util.require(name, function(impl){\n          impls[index] = impl;\n          gotImpl[index] = true;\n\n          checkDone();\n        });\n      })(); }\n    },\n\n    // ported lodash throttle function\n    throttle: function(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (options === false) {\n        leading = false;\n      } else if ($$.is.plainObject(options)) {\n        leading = 'leading' in options ? options.leading : leading;\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      options = options || {};\n      options.leading = leading;\n      options.maxWait = wait;\n      options.trailing = trailing;\n\n      return $$.util.debounce(func, wait, options);\n    },\n\n    now: function(){\n      return +new Date();\n    },\n\n    // ported lodash debounce function\n    debounce: function(func, wait, options) {\n      var args,\n          maxTimeoutId,\n          result,\n          stamp,\n          thisArg,\n          timeoutId,\n          trailingCall,\n          lastCalled = 0,\n          maxWait = false,\n          trailing = true;\n\n      if (!$$.is.fn(func)) {\n        return;\n      }\n      wait = Math.max(0, wait) || 0;\n      if (options === true) {\n        var leading = true;\n        trailing = false;\n      } else if ($$.is.plainObject(options)) {\n        leading = options.leading;\n        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);\n        trailing = 'trailing' in options ? options.trailing : trailing;\n      }\n      var delayed = function() {\n        var remaining = wait - ($$.util.now() - stamp);\n        if (remaining <= 0) {\n          if (maxTimeoutId) {\n            clearTimeout(maxTimeoutId);\n          }\n          var isCalled = trailingCall;\n          maxTimeoutId = timeoutId = trailingCall = undefined;\n          if (isCalled) {\n            lastCalled = $$.util.now();\n            result = func.apply(thisArg, args);\n            if (!timeoutId && !maxTimeoutId) {\n              args = thisArg = null;\n            }\n          }\n        } else {\n          timeoutId = setTimeout(delayed, remaining);\n        }\n      };\n\n      var maxDelayed = function() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        maxTimeoutId = timeoutId = trailingCall = undefined;\n        if (trailing || (maxWait !== wait)) {\n          lastCalled = $$.util.now();\n          result = func.apply(thisArg, args);\n          if (!timeoutId && !maxTimeoutId) {\n            args = thisArg = null;\n          }\n        }\n      };\n\n      return function() {\n        args = arguments;\n        stamp = $$.util.now();\n        thisArg = this;\n        trailingCall = trailing && (timeoutId || !leading);\n\n        if (maxWait === false) {\n          var leadingCall = leading && !timeoutId;\n        } else {\n          if (!maxTimeoutId && !leading) {\n            lastCalled = stamp;\n          }\n          var remaining = maxWait - (stamp - lastCalled),\n              isCalled = remaining <= 0;\n\n          if (isCalled) {\n            if (maxTimeoutId) {\n              maxTimeoutId = clearTimeout(maxTimeoutId);\n            }\n            lastCalled = stamp;\n            result = func.apply(thisArg, args);\n          }\n          else if (!maxTimeoutId) {\n            maxTimeoutId = setTimeout(maxDelayed, remaining);\n          }\n        }\n        if (isCalled && timeoutId) {\n          timeoutId = clearTimeout(timeoutId);\n        }\n        else if (!timeoutId && wait !== maxWait) {\n          timeoutId = setTimeout(delayed, wait);\n        }\n        if (leadingCall) {\n          isCalled = true;\n          result = func.apply(thisArg, args);\n        }\n        if (isCalled && !timeoutId && !maxTimeoutId) {\n          args = thisArg = null;\n        }\n        return result;\n      };\n    },\n\n    error: function( msg ){\n      if( console ){\n        if( console.error ){\n          console.error.apply( console, arguments );\n        } else if( console.log ){\n          console.log.apply( console, arguments );\n        } else {\n          throw msg;\n        }\n      } else {\n        throw msg;\n      }\n    },    \n\n    clone: function( obj ){\n      var target = {};\n      for (var i in obj) {\n        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?\n          target[i] = obj[i];\n        }\n      }\n      return target;\n    },\n\n    // gets a shallow copy of the argument\n    copy: function( obj ){\n      if( obj == null ){\n        return obj;\n      } if( $$.is.array(obj) ){\n        return obj.slice();\n      } else if( $$.is.plainObject(obj) ){\n        return $$.util.clone( obj );\n      } else {\n        return obj;\n      }\n    },\n    \n    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n    makeBoundingBox: function( bb ){\n      if( bb.x1 != null && bb.y1 != null ){\n        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){\n          return {\n            x1: bb.x1,\n            y1: bb.y1,\n            x2: bb.x2,\n            y2: bb.y2,\n            w: bb.x2 - bb.x1,\n            h: bb.y2 - bb.y1\n          };\n        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){\n          return {\n            x1: bb.x1,\n            y1: bb.y1,\n            x2: bb.x1 + bb.w,\n            y2: bb.y1 + bb.h,\n            w: bb.w,\n            h: bb.h\n          };\n        }\n      } \n    },\n\n    // has anything been set in the map\n    mapEmpty: function( map ){\n      var empty = true;\n\n      if( map != null ){\n        for(var i in map){ // jshint ignore:line\n          empty = false;\n          break;\n        }\n      }\n\n      return empty;\n    },\n\n    // pushes to the array at the end of a map (map may not be built)\n    pushMap: function( options ){\n      var array = $$.util.getMap(options);\n\n      if( array == null ){ // if empty, put initial array\n        $$.util.setMap( $.extend({}, options, {\n          value: [ options.value ]\n        }) );\n      } else {\n        array.push( options.value );\n      }\n    },\n\n    // sets the value in a map (map may not be built)\n    setMap: function( options ){\n      var obj = options.map;\n      var key;\n      var keys = options.keys;\n      var l = keys.length;\n\n      for(var i = 0; i < l; i++){\n        var key = keys[i];\n\n        if( $$.is.plainObject( key ) ){\n          $$.util.error('Tried to set map with object key');\n        }\n\n        if( i < keys.length - 1 ){\n          \n          // extend the map if necessary\n          if( obj[key] == null ){\n            obj[key] = {};\n          }\n          \n          obj = obj[key];\n        } else {\n          // set the value\n          obj[key] = options.value;\n        }\n      }\n    },\n    \n    // gets the value in a map even if it's not built in places\n    getMap: function( options ){\n      var obj = options.map;\n      var keys = options.keys;\n      var l = keys.length;\n      \n      for(var i = 0; i < l; i++){\n        var key = keys[i];\n\n        if( $$.is.plainObject( key ) ){\n          $$.util.error('Tried to get map with object key');\n        }\n\n        obj = obj[key];\n        \n        if( obj == null ){\n          return obj;\n        }\n      }\n      \n      return obj;\n    },\n\n    // deletes the entry in the map\n    deleteMap: function( options ){\n      var obj = options.map;\n      var keys = options.keys;\n      var l = keys.length;\n      var keepChildren = options.keepChildren;\n      \n      for(var i = 0; i < l; i++){\n        var key = keys[i];\n\n        if( $$.is.plainObject( key ) ){\n          $$.util.error('Tried to delete map with object key');\n        }\n\n        var lastKey = i === options.keys.length - 1;\n        if( lastKey ){\n          \n          if( keepChildren ){ // then only delete child fields not in keepChildren\n            for( var child in obj ){\n              if( !keepChildren[child] ){\n                obj[child] = undefined;\n              }\n            }\n          } else {\n            obj[key] = undefined;\n          }\n\n        } else {\n          obj = obj[key];\n        }\n      }\n    },\n    \n    capitalize: function(str){\n      if( $$.is.emptyString(str) ){\n        return str;\n      }\n      \n      return str.charAt(0).toUpperCase() + str.substring(1);\n    },\n\n    camel2dash: function( str ){\n      var ret = [];\n\n      for( var i = 0; i < str.length; i++ ){\n        var ch = str[i];\n        var chLowerCase = ch.toLowerCase();\n        var isUpperCase = ch !== chLowerCase;\n\n        if( isUpperCase ){\n          ret.push( '-' );\n          ret.push( chLowerCase );\n        } else {\n          ret.push( ch );\n        }\n      }\n\n      var noUpperCases = ret.length === str.length;\n      if( noUpperCases ){ return str; } // cheaper than .join()\n\n      return ret.join('');\n    },\n\n    dash2camel: function( str ){\n      var ret = [];\n      var nextIsUpper = false;\n\n      for( var i = 0; i < str.length; i++ ){\n        var ch = str[i];\n        var isDash = ch === '-';\n\n        if( isDash ){\n          nextIsUpper = true;\n        } else {\n          if( nextIsUpper ){\n            ret.push( ch.toUpperCase() );\n          } else {\n            ret.push( ch );\n          }\n\n          nextIsUpper = false;\n        }\n      }\n\n      return ret.join('');\n    },\n\n    // strip spaces from beginning of string and end of string\n    trim: function( str ){\n      var first, last;\n\n      // find first non-space char\n      for( first = 0; first < str.length && str[first] === ' '; first++ ){}\n\n      // find last non-space char\n      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}\n\n      return str.substring(first, last + 1);\n    },\n\n    // get [r, g, b] from #abc or #aabbcc\n    hex2tuple: function( hex ){\n      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== \"#\" ){ return; }\n\n      var shortHex = hex.length === 4;\n      var r, g, b;\n      var base = 16;\n\n      if( shortHex ){\n        r = parseInt( hex[1] + hex[1], base );\n        g = parseInt( hex[2] + hex[2], base );\n        b = parseInt( hex[3] + hex[3], base );\n      } else {\n        r = parseInt( hex[1] + hex[2], base );\n        g = parseInt( hex[3] + hex[4], base );\n        b = parseInt( hex[5] + hex[6], base );\n      }\n\n      return [r, g, b];\n    },\n\n    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n    hsl2tuple: function( hsl ){\n      var ret;\n      var h, s, l, a, r, g, b;\n      function hue2rgb(p, q, t){\n        if(t < 0) t += 1;\n        if(t > 1) t -= 1;\n        if(t < 1/6) return p + (q - p) * 6 * t;\n        if(t < 1/2) return q;\n        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n        return p;\n      }\n\n      var m = new RegExp(\"^\" + $$.util.regex.hsla + \"$\").exec(hsl);\n      if( m ){\n\n        // get hue\n        h = parseInt( m[1] ); \n        if( h < 0 ){\n          h = ( 360 - (-1*h % 360) ) % 360;\n        } else if( h > 360 ){\n          h = h % 360;\n        }\n        h /= 360; // normalise on [0, 1]\n\n        s = parseFloat( m[2] );\n        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]\n        s = s/100; // normalise on [0, 1]\n\n        l = parseFloat( m[3] );\n        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]\n        l = l/100; // normalise on [0, 1]\n\n        a = m[4];\n        if( a !== undefined ){\n          a = parseFloat( a );\n\n          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]\n        }\n\n        // now, convert to rgb\n        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n        if( s === 0 ){\n          r = g = b = Math.round(l * 255); // achromatic\n        } else {\n          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n          var p = 2 * l - q;\n          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );\n          g = Math.round( 255 * hue2rgb(p, q, h) );\n          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );\n        }\n\n        ret = [r, g, b, a];\n      }\n\n      return ret;\n    },\n\n    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n    rgb2tuple: function( rgb ){\n      var ret;\n\n      var m = new RegExp(\"^\" + $$.util.regex.rgba + \"$\").exec(rgb);\n      if( m ){\n        ret = [];\n\n        var isPct = [];\n        for( var i = 1; i <= 3; i++ ){\n          var channel = m[i];\n\n          if( channel[ channel.length - 1 ] === \"%\" ){\n            isPct[i] = true;\n          }\n          channel = parseFloat( channel );\n\n          if( isPct[i] ){\n            channel = channel/100 * 255; // normalise to [0, 255]\n          }\n\n          if( channel < 0 || channel > 255 ){ return; } // invalid channel value\n\n          ret.push( Math.floor(channel) );\n        }\n\n        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n        var allArePct = isPct[1] && isPct[2] && isPct[3];\n        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is\n\n        var alpha = m[4];\n        if( alpha !== undefined ){\n          alpha = parseFloat( alpha );\n\n          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value\n\n          ret.push( alpha );\n        }\n      }\n\n      return ret;\n    },\n\n    colorname2tuple: function( color ){\n      return $$.util.colors[ color.toLowerCase() ];\n    },\n\n    color2tuple: function( color ){\n      return ( $$.is.array(color) ? color : null ) \n        || $$.util.colorname2tuple(color)\n        || $$.util.hex2tuple(color)\n        || $$.util.rgb2tuple(color)\n        || $$.util.hsl2tuple(color);\n    },\n\n    tuple2hex: function( tuple ){\n      var r = tuple[0];\n      var g = tuple[1];\n      var b = tuple[2];\n\n      function ch2hex( ch ){\n        var hex = ch.toString(16);\n\n        if( hex.length === 1 ){\n          hex = '0' + hex;\n        }\n\n        return hex;\n      }\n\n      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);\n    },\n\n    colors: {\n      // special colour names\n      transparent:      [0,0,0,0], // NB alpha === 0\n\n      // regular colours\n      aliceblue:        [240,248,255],\n      antiquewhite:      [250,235,215],\n      aqua:          [0,255,255],\n      aquamarine:        [127,255,212],\n      azure:          [240,255,255],\n      beige:          [245,245,220],\n      bisque:          [255,228,196],\n      black:          [0,0,0],\n      blanchedalmond:      [255,235,205],\n      blue:          [0,0,255],\n      blueviolet:        [138,43,226],\n      brown:          [165,42,42],\n      burlywood:        [222,184,135],\n      cadetblue:        [95,158,160],\n      chartreuse:        [127,255,0],\n      chocolate:        [210,105,30],\n      coral:          [255,127,80],\n      cornflowerblue:      [100,149,237],\n      cornsilk:        [255,248,220],\n      crimson:        [220,20,60],\n      cyan:          [0,255,255],\n      darkblue:        [0,0,139],\n      darkcyan:        [0,139,139],\n      darkgoldenrod:      [184,134,11],\n      darkgray:        [169,169,169],\n      darkgreen:        [0,100,0],\n      darkgrey:        [169,169,169],\n      darkkhaki:        [189,183,107],\n      darkmagenta:      [139,0,139],\n      darkolivegreen:      [85,107,47],\n      darkorange:        [255,140,0],\n      darkorchid:        [153,50,204],\n      darkred:        [139,0,0],\n      darksalmon:        [233,150,122],\n      darkseagreen:      [143,188,143],\n      darkslateblue:      [72,61,139],\n      darkslategray:      [47,79,79],\n      darkslategrey:      [47,79,79],\n      darkturquoise:      [0,206,209],\n      darkviolet:        [148,0,211],\n      deeppink:        [255,20,147],\n      deepskyblue:      [0,191,255],\n      dimgray:        [105,105,105],\n      dimgrey:        [105,105,105],\n      dodgerblue:        [30,144,255],\n      firebrick:        [178,34,34],\n      floralwhite:      [255,250,240],\n      forestgreen:      [34,139,34],\n      fuchsia:        [255,0,255],\n      gainsboro:        [220,220,220],\n      ghostwhite:        [248,248,255],\n      gold:          [255,215,0],\n      goldenrod:        [218,165,32],\n      gray:          [128,128,128],\n      grey:          [128,128,128],\n      green:          [0,128,0],\n      greenyellow:      [173,255,47],\n      honeydew:        [240,255,240],\n      hotpink:        [255,105,180],\n      indianred:        [205,92,92],\n      indigo:          [75,0,130],\n      ivory:          [255,255,240],\n      khaki:          [240,230,140],\n      lavender:        [230,230,250],\n      lavenderblush:      [255,240,245],\n      lawngreen:        [124,252,0],\n      lemonchiffon:      [255,250,205],\n      lightblue:        [173,216,230],\n      lightcoral:        [240,128,128],\n      lightcyan:        [224,255,255],\n      lightgoldenrodyellow:  [250,250,210],\n      lightgray:        [211,211,211],\n      lightgreen:        [144,238,144],\n      lightgrey:        [211,211,211],\n      lightpink:        [255,182,193],\n      lightsalmon:      [255,160,122],\n      lightseagreen:      [32,178,170],\n      lightskyblue:      [135,206,250],\n      lightslategray:      [119,136,153],\n      lightslategrey:      [119,136,153],\n      lightsteelblue:      [176,196,222],\n      lightyellow:      [255,255,224],\n      lime:          [0,255,0],\n      limegreen:        [50,205,50],\n      linen:          [250,240,230],\n      magenta:        [255,0,255],\n      maroon:          [128,0,0],\n      mediumaquamarine:    [102,205,170],\n      mediumblue:        [0,0,205],\n      mediumorchid:      [186,85,211],\n      mediumpurple:      [147,112,219],\n      mediumseagreen:      [60,179,113],\n      mediumslateblue:    [123,104,238],\n      mediumspringgreen:    [0,250,154],\n      mediumturquoise:    [72,209,204],\n      mediumvioletred:    [199,21,133],\n      midnightblue:      [25,25,112],\n      mintcream:        [245,255,250],\n      mistyrose:        [255,228,225],\n      moccasin:        [255,228,181],\n      navajowhite:      [255,222,173],\n      navy:          [0,0,128],\n      oldlace:        [253,245,230],\n      olive:          [128,128,0],\n      olivedrab:        [107,142,35],\n      orange:          [255,165,0],\n      orangered:        [255,69,0],\n      orchid:          [218,112,214],\n      palegoldenrod:      [238,232,170],\n      palegreen:        [152,251,152],\n      paleturquoise:      [175,238,238],\n      palevioletred:      [219,112,147],\n      papayawhip:        [255,239,213],\n      peachpuff:        [255,218,185],\n      peru:          [205,133,63],\n      pink:          [255,192,203],\n      plum:          [221,160,221],\n      powderblue:        [176,224,230],\n      purple:          [128,0,128],\n      red:          [255,0,0],\n      rosybrown:        [188,143,143],\n      royalblue:        [65,105,225],\n      saddlebrown:      [139,69,19],\n      salmon:          [250,128,114],\n      sandybrown:        [244,164,96],\n      seagreen:        [46,139,87],\n      seashell:        [255,245,238],\n      sienna:          [160,82,45],\n      silver:          [192,192,192],\n      skyblue:        [135,206,235],\n      slateblue:        [106,90,205],\n      slategray:        [112,128,144],\n      slategrey:        [112,128,144],\n      snow:          [255,250,250],\n      springgreen:      [0,255,127],\n      steelblue:        [70,130,180],\n      tan:          [210,180,140],\n      teal:          [0,128,128],\n      thistle:        [216,191,216],\n      tomato:          [255,99,71],\n      turquoise:        [64,224,208],\n      violet:          [238,130,238],\n      wheat:          [245,222,179],\n      white:          [255,255,255],\n      whitesmoke:        [245,245,245],\n      yellow:          [255,255,0],\n      yellowgreen:      [154,205,50]\n    }\n      \n  };\n\n  $$.util.regex = {};\n  \n  $$.util.regex.number = \"(?:[-]?\\\\d*\\\\.\\\\d+|[-]?\\\\d+|[-]?\\\\d*\\\\.\\\\d+[eE]\\\\d+)\";\n  \n  $$.util.regex.rgba = \"rgb[a]?\\\\((\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%]?)(?:\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"))?\\\\)\";\n  $$.util.regex.rgbaNoBackRefs = \"rgb[a]?\\\\((?:\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%]?)\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%]?)(?:\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"))?\\\\)\";\n  \n  $$.util.regex.hsla = \"hsl[a]?\\\\((\"+ $$.util.regex.number +\")\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%])\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"[%])(?:\\\\s*,\\\\s*(\"+ $$.util.regex.number +\"))?\\\\)\";\n  $$.util.regex.hslaNoBackRefs = \"hsl[a]?\\\\((?:\"+ $$.util.regex.number +\")\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%])\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"[%])(?:\\\\s*,\\\\s*(?:\"+ $$.util.regex.number +\"))?\\\\)\";\n  \n  $$.util.regex.hex3 = \"\\\\#[0-9a-fA-F]{3}\";\n  $$.util.regex.hex6 = \"\\\\#[0-9a-fA-F]{6}\";\n\n  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  \n        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );\n\n  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };\n\n  $$.util.requestAnimationFrame = function(fn){\n    raf( fn );\n  };\n\n})( cytoscape, typeof window === 'undefined' ? null : window  );\n\n;(function($$){ 'use strict';\n  \n  $$.math = {};\n  \n  $$.math.signum = function(x){\n    if( x > 0 ){\n      return 1;\n    } else if( x < 0 ){\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n\n  $$.math.distance = function( p1, p2 ){\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n\n    return Math.sqrt( dx*dx + dy*dy );\n  };\n\n  // from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\n  $$.math.qbezierAt = function(p0, p1, p2, t){\n    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;\n  };\n\n  $$.math.qbezierPtAt = function(p0, p1, p2, t){\n    return {\n      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),\n      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )\n    };\n  };\n\n  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){\n    // case: one bb to right of other\n    if( bb1.x1 > bb2.x2 ){ return false; }\n    if( bb2.x1 > bb1.x2 ){ return false; }\n\n    // case: one bb to left of other\n    if( bb1.x2 < bb2.x1 ){ return false; }\n    if( bb2.x2 < bb1.x1 ){ return false; }\n\n    // case: one bb above other\n    if( bb1.y2 < bb2.y1 ){ return false; }\n    if( bb2.y2 < bb1.y1 ){ return false; }\n\n    // case: one bb below other\n    if( bb1.y1 > bb2.y2 ){ return false; }\n    if( bb2.y1 > bb1.y2 ){ return false; }\n\n    // otherwise, must have some overlap\n    return true;\n  };\n\n  $$.math.inBoundingBox = function( bb, x, y ){\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n  };\n\n  $$.math.pointInBoundingBox = function( bb, pt ){\n    return this.inBoundingBox( bb, pt.x, pt.y );\n  };\n\n  $$.math.roundRectangleIntersectLine = function(\n    x, y, nodeX, nodeY, width, height, padding) {\n    \n    var cornerRadius = this.getRoundRectangleRadius(width, height);\n    \n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    \n    // Check intersections with straight line segments\n    var straightLineIntersections;\n    \n    // Top segment, left to right\n    {\n      var topStartX = nodeX - halfWidth + cornerRadius - padding;\n      var topStartY = nodeY - halfHeight - padding;\n      var topEndX = nodeX + halfWidth - cornerRadius + padding;\n      var topEndY = topStartY;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Right segment, top to bottom\n    {\n      var rightStartX = nodeX + halfWidth + padding;\n      var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n      var rightEndX = rightStartX;\n      var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Bottom segment, left to right\n    {\n      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n      var bottomStartY = nodeY + halfHeight + padding;\n      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n      var bottomEndY = bottomStartY;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Left segment, top to bottom\n    {\n      var leftStartX = nodeX - halfWidth - padding;\n      var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n      var leftEndX = leftStartX;\n      var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n      \n      straightLineIntersections = this.finiteLinesIntersect(\n        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n      \n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    }\n    \n    // Check intersections with arc segments\n    var arcIntersections;\n    \n    // Top Left\n    {\n      var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] <= topLeftCenterX\n        && arcIntersections[1] <= topLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    \n    // Top Right\n    {\n      var topRightCenterX = nodeX + halfWidth - cornerRadius;\n      var topRightCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        topRightCenterX, topRightCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] >= topRightCenterX\n        && arcIntersections[1] <= topRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    \n    // Bottom Right\n    {\n      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] >= bottomRightCenterX\n        && arcIntersections[1] >= bottomRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    \n    // Bottom Left\n    {\n      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = this.intersectLineCircle(\n        x, y, nodeX, nodeY, \n        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n      \n      // Ensure the intersection is on the desired quarter of the circle\n      if (arcIntersections.length > 0\n        && arcIntersections[0] <= bottomLeftCenterX\n        && arcIntersections[1] >= bottomLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n\n    return []; // if nothing\n  };\n  \n  $$.math.roundRectangleIntersectBox = function(\n    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {\n    \n    // We have the following shpae\n    \n    //    _____\n    //  _|     |_\n    // |         |\n    // |_       _|\n    //   |_____|\n    //\n    // With a quarter circle at each corner.\n    \n    var cornerRadius = this.getRoundRectangleRadius(width, height);\n    \n    var hBoxTopLeftX = centerX - width / 2 - padding;\n    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;\n    var hBoxBottomRightX = centerX + width / 2 + padding;\n    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;\n    \n    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;\n    var vBoxTopLeftY = centerY - height / 2 - padding;\n    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;\n    var vBoxBottomRightY = centerY + height / 2 + padding;\n    \n    // Check if the box is out of bounds\n    var boxMinX = Math.min(boxX1, boxX2);\n    var boxMaxX = Math.max(boxX1, boxX2);\n    var boxMinY = Math.min(boxY1, boxY2);\n    var boxMaxY = Math.max(boxY1, boxY2);\n    \n    if (boxMaxX < hBoxTopLeftX) {\n      return false;\n    } else if (boxMinX > hBoxBottomRightX) {\n      return false;\n    }\n    \n    if (boxMaxY < vBoxTopLeftY) {\n      return false;\n    } else if (boxMinY > vBoxBottomRightY) {\n      return false;\n    }\n    \n    // Check if an hBox point is in given box\n    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX\n        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX\n        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX\n        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX\n        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    // Check if a given point box is in the hBox\n    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX\n      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX\n      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX\n      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX\n      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {\n      return true;\n    }\n    \n    // Check if an vBox point is in given box\n    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX\n        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX\n        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {\n      return true;\n    }\n    \n    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX\n        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX\n        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {\n      return true;\n    }\n    \n    // Check if a given point box is in the vBox\n    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX\n      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX\n      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX\n      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX\n      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {\n      return true;\n    }\n    \n    // Lastly, check if one of the ellipses coincide with the box\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {\n      return true;\n    }\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {\n      return true;\n    }\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {\n      return true;\n    }\n    \n    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {\n      return true;\n    }\n    \n    return false;\n  };\n  \n  // @O Approximate collision functions\n  $$.math.checkInBoundingCircle = function(\n    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {\n    \n    x = (x - centerX) / (width + padding);\n    y = (y - centerY) / (height + padding);\n    \n    return (x * x + y * y) <= farthestPointSqDistance;\n  };\n  \n  $$.math.boxInBezierVicinity = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {\n    \n    // Return values:\n    // 0 - curve is not in box\n    // 1 - curve may be in box; needs precise check\n    // 2 - curve is in box\n    \n    // midpoint\n    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;\n    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;\n\n    var boxMinX = Math.min(x1box, x2box) - tolerance;\n    var boxMinY = Math.min(y1box, y2box) - tolerance;\n    var boxMaxX = Math.max(x1box, x2box) + tolerance;\n    var boxMaxY = Math.max(y1box, y2box) + tolerance;\n    \n    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box\n      return 1;\n    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box\n      return 1;\n    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box\n      return 1;\n    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box\n      return 1;\n    }\n    \n    var curveMinX = Math.min(x1, midX, x3);\n    var curveMinY = Math.min(y1, midY, y3);\n    var curveMaxX = Math.max(x1, midX, x3);\n    var curveMaxY = Math.max(y1, midY, y3);\n    \n    /*\n    console.log(curveMinX + \", \" + curveMinY + \", \" + curveMaxX \n      + \", \" + curveMaxY);\n    if (curveMinX == undefined) {\n      console.log(\"undefined curveMinX: \" + x1 + \", \" + x2 + \", \" + x3);\n    }\n    */\n    \n    if (curveMinX > boxMaxX\n      || curveMaxX < boxMinX\n      || curveMinY > boxMaxY\n      || curveMaxY < boxMinY) {\n      \n      return 0;  \n    }\n    \n    return 1;\n  };\n\n  $$.math.checkBezierInBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {\n\n    function sampleInBox(t){\n      var x = $$.math.qbezierAt(x1, x2, x3, t);\n      var y = $$.math.qbezierAt(y1, y2, y3, t);\n\n      return x1box <= x && x <= x2box\n        && y1box <= y && y <= y2box\n      ;\n    }\n\n    for( var t = 0; t <= 1; t += 0.25 ){\n      if( !sampleInBox(t) ){\n        return false;\n      }\n    }\n\n    return true;\n  };\n  \n  $$.math.checkStraightEdgeInBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {\n\n    return x1box <= x1 && x1 <= x2box\n      && x1box <= x2 && x2 <= x2box\n      && y1box <= y1 && y1 <= y2box\n      && y1box <= y2 && y2 <= y2box\n    ;\n  };\n\n  $$.math.checkStraightEdgeCrossesBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {\n    \n   //console.log(arguments);\n    \n    var boxMinX = Math.min(x1box, x2box) - tolerance;\n    var boxMinY = Math.min(y1box, y2box) - tolerance;\n    var boxMaxX = Math.max(x1box, x2box) + tolerance;\n    var boxMaxY = Math.max(y1box, y2box) + tolerance;\n    \n    // Check left + right bounds\n    var aX = x2 - x1;\n    var bX = x1;\n    var yValue;\n    \n    // Top and bottom\n    var aY = y2 - y1;\n    var bY = y1;\n    var xValue;\n    \n    if (Math.abs(aX) < 0.0001) {\n      return (x1 >= boxMinX && x1 <= boxMaxX\n        && Math.min(y1, y2) <= boxMinY\n        && Math.max(y1, y2) >= boxMaxY);  \n    }\n    \n    var tLeft = (boxMinX - bX) / aX;\n    if (tLeft > 0 && tLeft <= 1) {\n      yValue = aY * tLeft + bY;\n      if (yValue >= boxMinY && yValue <= boxMaxY) {\n        return true;\n      } \n    }\n    \n    var tRight = (boxMaxX - bX) / aX;\n    if (tRight > 0 && tRight <= 1) {\n      yValue = aY * tRight + bY;\n      if (yValue >= boxMinY && yValue <= boxMaxY) {\n        return true;\n      } \n    }\n    \n    var tTop = (boxMinY - bY) / aY;\n    if (tTop > 0 && tTop <= 1) {\n      xValue = aX * tTop + bX;\n      if (xValue >= boxMinX && xValue <= boxMaxX) {\n        return true;\n      } \n    }\n    \n    var tBottom = (boxMaxY - bY) / aY;\n    if (tBottom > 0 && tBottom <= 1) {\n      xValue = aX * tBottom + bX;\n      if (xValue >= boxMinX && xValue <= boxMaxX) {\n        return true;\n      } \n    }\n    \n    return false;\n  };\n  \n  $$.math.checkBezierCrossesBox = function(\n    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {\n    \n    var boxMinX = Math.min(x1box, x2box) - tolerance;\n    var boxMinY = Math.min(y1box, y2box) - tolerance;\n    var boxMaxX = Math.max(x1box, x2box) + tolerance;\n    var boxMaxY = Math.max(y1box, y2box) + tolerance;\n    \n    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {\n      return true;\n    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {\n      return true;\n    }\n    \n    var aX = x1 - 2 * x2 + x3;\n    var bX = -2 * x1 + 2 * x2;\n    var cX = x1;\n\n    var xIntervals = [];\n    \n    if (Math.abs(aX) < 0.0001) {\n      var leftParam = (boxMinX - x1) / bX;\n      var rightParam = (boxMaxX - x1) / bX;\n      \n      xIntervals.push(leftParam, rightParam);\n    } else {\n      // Find when x coordinate of the curve crosses the left side of the box\n      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);\n      var tX1, tX2;\n      if (discriminantX1 > 0) {\n        var sqrt = Math.sqrt(discriminantX1);\n        tX1 = (-bX + sqrt) / (2 * aX);\n        tX2 = (-bX - sqrt) / (2 * aX);\n        \n        xIntervals.push(tX1, tX2);\n      }\n      \n      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);\n      var tX3, tX4;\n      if (discriminantX2 > 0) {\n        var sqrt = Math.sqrt(discriminantX2);\n        tX3 = (-bX + sqrt) / (2 * aX);\n        tX4 = (-bX - sqrt) / (2 * aX);\n        \n        xIntervals.push(tX3, tX4);\n      }\n    }\n    \n    xIntervals.sort(function(a, b) { return a - b; });\n    \n    var aY = y1 - 2 * y2 + y3;\n    var bY = -2 * y1 + 2 * y2;\n    var cY = y1;\n    \n    var yIntervals = [];\n    \n    if (Math.abs(aY) < 0.0001) {\n      var topParam = (boxMinY - y1) / bY;\n      var bottomParam = (boxMaxY - y1) / bY;\n      \n      yIntervals.push(topParam, bottomParam);\n    } else {\n      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);\n      \n      var tY1, tY2;\n      if (discriminantY1 > 0) {\n        var sqrt = Math.sqrt(discriminantY1);\n        tY1 = (-bY + sqrt) / (2 * aY);\n        tY2 = (-bY - sqrt) / (2 * aY);\n        \n        yIntervals.push(tY1, tY2);\n      }\n  \n      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);\n      \n      var tY3, tY4;\n      if (discriminantY2 > 0) {\n        var sqrt = Math.sqrt(discriminantY2);\n        tY3 = (-bY + sqrt) / (2 * aY);\n        tY4 = (-bY - sqrt) / (2 * aY);\n        \n        yIntervals.push(tY3, tY4);\n      }\n    }\n        \n    yIntervals.sort(function(a, b) { return a - b; });\n\n    for (var index = 0; index < xIntervals.length; index += 2) {\n      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {\n        \n        // Check if there exists values for the Bezier curve\n        // parameter between 0 and 1 where both the curve's\n        // x and y coordinates are within the bounds specified by the box\n        if (xIntervals[index] < yIntervals[yIndex]\n          && yIntervals[yIndex] >= 0.0\n          && xIntervals[index] <= 1.0\n          && xIntervals[index + 1] > yIntervals[yIndex - 1]\n          && yIntervals[yIndex - 1] <= 1.0\n          && xIntervals[index + 1] >= 0.0) {\n          \n          return true;\n        }\n      }\n    }\n    \n    return false;\n  };\n  \n  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){\n    var t = tolerance;\n\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n\n    return x1 - t <= x && x <= x2 + t\n      && y1 - t <= y && y <= y2 + t;\n  };\n\n  $$.math.inBezierVicinity = function(\n    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {\n\n    var bb = {\n      x1: Math.min( x1, x3, x2 ),\n      x2: Math.max( x1, x3, x2 ),\n      y1: Math.min( y1, y3, y2 ),\n      y2: Math.max( y1, y3, y2 )\n    };\n\n    // if outside the rough bounding box for the bezier, then it can't be a hit\n    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){\n      // console.log('bezier out of rough bb')\n      return false;\n    } else {\n      // console.log('do more expensive check');\n      return true;\n    }\n\n  };\n  \n  $$.math.solveCubic = function(a, b, c, d, result) {\n    \n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n\n    b /= a;\n    c /= a;\n    d /= a;\n    \n    var discriminant, q, r, dum1, s, t, term1, r13;\n\n    q = (3.0 * c - (b * b)) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    \n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = (b / 3.0);\n    \n    if (discriminant > 0) {\n      s = r + Math.sqrt(discriminant);\n      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));\n      t = r - Math.sqrt(discriminant);\n      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));\n      result[0] = -term1 + s + t;\n      term1 += (s + t) / 2.0;\n      result[4] = result[2] = -term1;\n      term1 = Math.sqrt(3.0) * (-t + s) / 2;\n      result[3] = term1;\n      result[5] = -term1;\n      return;\n    }\n    \n    result[5] = result[3] = 0;\n    \n    if (discriminant === 0) {\n      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));\n      result[0] = -term1 + 2.0 * r13;\n      result[4] = result[2] = -(r13 + term1);\n      return;\n    }\n    \n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    \n    return;\n  };\n\n  $$.math.sqDistanceToQuadraticBezier = function(\n    x, y, x1, y1, x2, y2, x3, y3) {\n    \n    // Find minimum distance by using the minimum of the distance \n    // function between the given point and the curve\n    \n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    \n    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3\n      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;\n    \n    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3\n      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;\n    \n    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x\n      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;\n      \n    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x\n      + y1*y2 - y1*y1 + y1*y - y2*y;\n    \n    // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n    \n    var roots = [];\n    \n    // Use the cubic solving algorithm\n    this.solveCubic(a, b, c, d, roots);\n    \n    var zeroThreshold = 0.0000001;\n    \n    var params = [];\n    \n    for (var index = 0; index < 6; index += 2) {\n      if (Math.abs(roots[index + 1]) < zeroThreshold\n          && roots[index] >= 0\n          && roots[index] <= 1.0) {\n        params.push(roots[index]);\n      }\n    }\n    \n    params.push(1.0);\n    params.push(0.0);\n    \n    var minDistanceSquared = -1;\n    var closestParam;\n    \n    var curX, curY, distSquared;\n    for (var i = 0; i < params.length; i++) {\n      curX = Math.pow(1.0 - params[i], 2.0) * x1\n        + 2.0 * (1 - params[i]) * params[i] * x2\n        + params[i] * params[i] * x3;\n        \n      curY = Math.pow(1 - params[i], 2.0) * y1\n        + 2 * (1.0 - params[i]) * params[i] * y2\n        + params[i] * params[i] * y3;\n        \n      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n      // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n      if (minDistanceSquared >= 0) {\n        if (distSquared < minDistanceSquared) {\n          minDistanceSquared = distSquared;\n          closestParam = params[i];\n        }\n      } else {\n        minDistanceSquared = distSquared;\n        closestParam = params[i];\n      }\n    }\n    \n    /*\n    debugStats.clickX = x;\n    debugStats.clickY = y;\n    \n    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1\n        + 2.0 * (1.0 - closestParam) * closestParam * x2\n        + closestParam * closestParam * x3;\n        \n    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1\n        + 2.0 * (1.0 - closestParam) * closestParam * y2\n        + closestParam * closestParam * y3;\n    */\n    \n    // debug(\"given: \" \n    //   + \"( \" + x + \", \" + y + \"), \" \n    //   + \"( \" + x1 + \", \" + y1 + \"), \" \n    //   + \"( \" + x2 + \", \" + y2 + \"), \"\n    //   + \"( \" + x3 + \", \" + y3 + \")\");\n    \n    \n    // debug(\"roots: \" + roots);\n    // debug(\"params: \" + params);\n    // debug(\"closest param: \" + closestParam);\n    return minDistanceSquared;\n  };\n  \n  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {\n    var offset = [x - x1, y - y1];\n    var line = [x2 - x1, y2 - y1];\n    \n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    \n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n    \n    if (dotProduct < 0) {\n      return hypSq;\n    }\n    \n    if (adjSq > lineSq) {\n      return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n    \n    return hypSq - adjSq;\n  };\n\n  $$.math.pointInsidePolygon = function(\n    x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n\n    //var direction = arguments[6];\n    var transformedPoints = new Array(basePoints.length);\n\n    // Gives negative angle\n    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] \n      + direction[1] * direction[1])));\n    \n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n        \n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    \n//    console.log(\"base: \" + basePoints);\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = \n        width / 2 * (basePoints[i * 2] * cos\n          - basePoints[i * 2 + 1] * sin);\n      \n      transformedPoints[i * 2 + 1] = \n        height / 2 * (basePoints[i * 2 + 1] * cos \n          + basePoints[i * 2] * sin);\n\n      transformedPoints[i * 2] += centerX;\n      transformedPoints[i * 2 + 1] += centerY;\n    }\n    \n    var points;\n    \n    if (padding > 0) {\n      var expandedLineSet = this.expandPolygon(\n        transformedPoints,\n        -padding);\n      \n      points = this.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n    \n    var x1, y1, x2, y2;\n    var y3;\n    \n    // Intersect with vertical line through (x, y)\n    var up = 0;\n    var down = 0;\n    for (var i = 0; i < points.length / 2; i++) {\n      \n      x1 = points[i * 2];\n      y1 = points[i * 2 + 1];\n      \n      if (i + 1 < points.length / 2) {\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n      } else {\n        x2 = points[(i + 1 - points.length / 2) * 2];\n        y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n      }\n      \n//*      console.log(\"line from (\" + x1 + \", \" + y1 + \") to (\" + x2 + \", \" + y2 + \")\");\n\n//&      console.log(x1, x, x2);\n\n      if (x1 == x && x2 == x) {\n        \n      } else if ((x1 >= x && x >= x2)\n        || (x1 <= x && x <= x2)) {\n        \n        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n        \n        if (y3 > y) {\n          up++;\n        }\n        \n        if (y3 < y) {\n          down++;\n        }\n        \n//*        console.log(y3, y);\n        \n      } else {\n//*        console.log('22');\n        continue;\n      }\n      \n    }\n    \n//*    console.log(\"up: \" + up + \", down: \" + down);\n    \n    if (up % 2 === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n\n  $$.math.joinLines = function(lineSet) {\n    \n    var vertices = new Array(lineSet.length / 2);\n    \n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n    \n    for (var i = 0; i < lineSet.length / 4; i++) {\n      currentLineStartX = lineSet[i * 4];\n      currentLineStartY = lineSet[i * 4 + 1];\n      currentLineEndX = lineSet[i * 4 + 2];\n      currentLineEndY = lineSet[i * 4 + 3];\n      \n      if (i < lineSet.length / 4 - 1) {\n        nextLineStartX = lineSet[(i + 1) * 4];\n        nextLineStartY = lineSet[(i + 1) * 4 + 1];\n        nextLineEndX = lineSet[(i + 1) * 4 + 2];\n        nextLineEndY = lineSet[(i + 1) * 4 + 3];\n      } else {\n        nextLineStartX = lineSet[0];\n        nextLineStartY = lineSet[1];\n        nextLineEndX = lineSet[2];\n        nextLineEndY = lineSet[3];\n      }\n      \n      var intersection = this.finiteLinesIntersect(\n        currentLineStartX, currentLineStartY,\n        currentLineEndX, currentLineEndY,\n        nextLineStartX, nextLineStartY,\n        nextLineEndX, nextLineEndY,\n        true);\n      \n      vertices[i * 2] = intersection[0];\n      vertices[i * 2 + 1] = intersection[1];\n    }\n    \n    return vertices;\n  };\n\n  $$.math.expandPolygon = function(points, pad) {\n    \n    var expandedLineSet = new Array(points.length * 2);\n    \n    var currentPointX, currentPointY, nextPointX, nextPointY;\n    \n    for (var i = 0; i < points.length / 2; i++) {\n      currentPointX = points[i * 2];\n      currentPointY = points[i * 2 + 1];\n      \n      if (i < points.length / 2 - 1) {\n        nextPointX = points[(i + 1) * 2];\n        nextPointY = points[(i + 1) * 2 + 1];\n      } else {\n        nextPointX = points[0];\n        nextPointY = points[1];\n      }\n      \n      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n      \n      // Assume CCW polygon winding\n      \n      var offsetX = (nextPointY - currentPointY);\n      var offsetY = -(nextPointX - currentPointX);\n      \n      // Normalize\n      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n      var normalizedOffsetX = offsetX / offsetLength;\n      var normalizedOffsetY = offsetY / offsetLength;\n      \n      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n    \n    return expandedLineSet;\n  };\n\n  $$.math.intersectLineEllipse = function(\n    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    \n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    \n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    \n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    \n    var newLength = len - 1;\n    \n    if (newLength < 0) {\n      return [];\n    }\n    \n    var lenProportion = newLength / len;\n    \n    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n  };\n  \n  $$.math.dotProduct = function(\n    vec1, vec2) {\n    \n    if (vec1.length != 2 || vec2.length != 2) {\n      throw 'dot product: arguments are not vectors';\n    }\n    \n    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);\n  };\n  \n  // Returns intersections of increasing distance from line's start point\n  $$.math.intersectLineCircle = function(\n    x1, y1, x2, y2, centerX, centerY, radius) {\n    \n    // Calculate d, direction vector of line\n    var d = [x2 - x1, y2 - y1]; // Direction vector of line\n    var c = [centerX, centerY]; // Center of circle\n    var f = [x1 - centerX, y1 - centerY];\n    \n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;\n    \n    var discriminant = b*b-4*a*c;\n    \n    if (discriminant < 0) {\n      return [];\n    }\n    \n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    \n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n    \n    if (tMin >= 0 && tMin <= 1) {\n      inRangeParams.push(tMin);\n    }\n    \n    if (tMax >= 0 && tMax <= 1) {\n      inRangeParams.push(tMax);\n    }\n    \n    if (inRangeParams.length === 0) {\n      return [];\n    }\n    \n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n    \n    if (inRangeParams.length > 1) {\n    \n      if (inRangeParams[0] == inRangeParams[1]) {\n        return [nearIntersectionX, nearIntersectionY];\n      } else {\n        \n        var farIntersectionX = inRangeParams[1] * d[0] + x1;\n        var farIntersectionY = inRangeParams[1] * d[1] + y1;\n      \n        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n      }\n      \n    } else {\n      return [nearIntersectionX, nearIntersectionY];\n    }\n    \n  };\n  \n  $$.math.findCircleNearPoint = function(centerX, centerY, \n    radius, farX, farY) {\n    \n    var displacementX = farX - centerX;\n    var displacementY = farY - centerY;\n    var distance = Math.sqrt(displacementX * displacementX \n      + displacementY * displacementY);\n    \n    var unitDisplacementX = displacementX / distance;\n    var unitDisplacementY = displacementY / distance;\n    \n    return [centerX + unitDisplacementX * radius, \n      centerY + unitDisplacementY * radius];\n  };\n  \n  $$.math.findMaxSqDistanceToOrigin = function(points) {\n    var maxSqDistance = 0.000001;\n    var sqDistance;\n    \n    for (var i = 0; i < points.length / 2; i++) {\n      \n      sqDistance = points[i * 2] * points[i * 2] \n        + points[i * 2 + 1] * points[i * 2 + 1];\n      \n      if (sqDistance > maxSqDistance) {\n        maxSqDistance = sqDistance;\n      }\n    }\n    \n    return maxSqDistance;\n  };\n  \n  $$.math.finiteLinesIntersect = function(\n    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    \n    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n      \n      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  \n        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];\n        \n      } else {\n        if (!infiniteLines) {\n          return [];\n        } else {\n          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];\n        }\n      }\n    } else {\n      if (ua_t === 0 || ub_t === 0) {\n\n        // Parallel, coincident lines. Check if overlap\n\n        // Check endpoint of second line\n        if ([x1, x2, x4].sort()[1] === x4) {\n          return [x4, y4];\n        }\n        \n        // Check start point of second line\n        if ([x1, x2, x3].sort()[1] === x3) {\n          return [x3, y3];\n        }\n        \n        // Endpoint of first line\n        if ([x3, x4, x2].sort()[1] === x2) {\n          return [x2, y2];\n        }\n        \n        return [];\n      } else {\n      \n        // Parallel, non-coincident\n        return [];\n      }\n    }\n  };\n  \n  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,\n  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {\n  \n  $$.math.boxIntersectEllipse = function(\n    x1, y1, x2, y2, padding, width, height, centerX, centerY) {\n    \n    if (x2 < x1) {\n      var oldX1 = x1;\n      x1 = x2;\n      x2 = oldX1;\n    }\n    \n    if (y2 < y1) {\n      var oldY1 = y1;\n      y1 = y2;\n      y2 = oldY1;\n    }\n    \n    // 4 ortho extreme points\n    var west = [centerX - width / 2 - padding, centerY];\n    var east = [centerX + width / 2 + padding, centerY];\n    var north = [centerX, centerY - height / 2 - padding];\n    var south = [centerX, centerY + height / 2 + padding];\n    \n    // out of bounds: return false\n    if (x2 < west[0]) {\n      return false;\n    }\n    \n    if (x1 > east[0]) {\n      return false;\n    }\n    \n    if (y1 > south[1]) {\n      return false;\n    }\n    \n    if (y2 < north[1]) {\n      return false;\n    }\n    \n    // 1 of 4 ortho extreme points in box: return true\n    if (x1 <= east[0] && east[0] <= x2\n        && y1 <= east[1] && east[1] <= y2) {\n      return true;\n    }\n    \n    if (x1 <= west[0] && west[0] <= x2\n        && y1 <= west[1] && west[1] <= y2) {\n      return true;\n    }\n    \n    if (x1 <= north[0] && north[0] <= x2\n        && y1 <= north[1] && north[1] <= y2) {\n      return true;\n    }\n    \n    if (x1 <= south[0] && south[0] <= x2\n        && y1 <= south[1] && south[1] <= y2) {\n      return true;\n    }\n    \n    // box corner in ellipse: return true    \n    x1 = (x1 - centerX) / (width / 2 + padding);\n    x2 = (x2 - centerX) / (width / 2 + padding);\n    \n    y1 = (y1 - centerY) / (height / 2 + padding);\n    y2 = (y2 - centerY) / (height / 2 + padding);\n    \n    if (x1 * x1 + y1 * y1 <= 1) {\n      return true;\n    }\n    \n    if (x2 * x2 + y1 * y1 <= 1) {\n      return true;\n    }\n    \n    if (x2 * x2 + y2 * y2 <= 1) {\n      return true;\n    }\n    \n    if (x1 * x1 + y2 * y2 <= 1) {\n      return true;\n    }\n    \n    return false;\n  };\n  \n  $$.math.boxIntersectPolygon = function(\n    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {\n    \n//    console.log(arguments);\n    \n    if (x2 < x1) {\n      var oldX1 = x1;\n      x1 = x2;\n      x2 = oldX1;\n    }\n    \n    if (y2 < y1) {\n      var oldY1 = y1;\n      y1 = y2;\n      y2 = oldY1;\n    }\n    \n    var transformedPoints = new Array(basePoints.length);\n    \n    // Gives negative of angle\n    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] \n      + direction[1] * direction[1])));\n    \n    if (direction[0] < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = -angle - Math.PI / 2;\n    }\n    \n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    \n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = \n        width / 2 * (basePoints[i * 2] * cos\n          - basePoints[i * 2 + 1] * sin);\n      \n      transformedPoints[i * 2 + 1] = \n        height / 2 * (basePoints[i * 2 + 1] * cos \n          + basePoints[i * 2] * sin);\n      \n      transformedPoints[i * 2] += centerX;\n      transformedPoints[i * 2 + 1] += centerY;\n    }\n    \n    // Assume transformedPoints.length > 0, and check if intersection is possible\n    var minTransformedX = transformedPoints[0];\n    var maxTransformedX = transformedPoints[0];\n    var minTransformedY = transformedPoints[1];\n    var maxTransformedY = transformedPoints[1];\n    \n    for (var i = 1; i < transformedPoints.length / 2; i++) {\n      if (transformedPoints[i * 2] > maxTransformedX) {\n        maxTransformedX = transformedPoints[i * 2];\n      }\n      \n      if (transformedPoints[i * 2] < minTransformedX) {\n        minTransformedX = transformedPoints[i * 2];\n      }\n      \n      if (transformedPoints[i * 2 + 1] > maxTransformedY) {\n        maxTransformedY = transformedPoints[i * 2 + 1];\n      }\n      \n      if (transformedPoints[i * 2 + 1] < minTransformedY) {\n        minTransformedY = transformedPoints[i * 2 + 1];\n      }\n    }\n    \n    if (x2 < minTransformedX - padding) {\n      return false;\n    }\n    \n    if (x1 > maxTransformedX + padding) {\n      return false;\n    }\n    \n    if (y2 < minTransformedY - padding) {\n      return false;\n    }\n    \n    if (y1 > maxTransformedY + padding) {\n      return false;\n    }\n    \n    // Continue checking with padding-corrected points\n    var points;\n    \n    if (padding > 0) {\n      var expandedLineSet = $$.math.expandPolygon(\n        transformedPoints,\n        -padding);\n      \n      points = $$.math.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n    \n    // Check if a point is in box\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      if (x1 <= transformedPoints[i * 2]\n          && transformedPoints[i * 2] <= x2) {\n        \n        if (y1 <= transformedPoints[i * 2 + 1]\n            && transformedPoints[i * 2 + 1] <= y2) {\n          \n          return true;\n        }\n      }\n    }\n    \n    \n    // Check for intersections with the selection box\n    for (var i = 0; i < points.length / 2; i++) {\n      \n      var currentX = points[i * 2];\n      var currentY = points[i * 2 + 1];\n      var nextX;\n      var nextY;\n      \n      if (i < points.length / 2 - 1) {\n        nextX = points[(i + 1) * 2];\n        nextY = points[(i + 1) * 2 + 1];\n      } else {\n        nextX = points[0];\n        nextY = points[1];\n      }\n      \n      // Intersection with top of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {\n        return true;\n      }\n      \n      // Intersection with bottom of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {\n        return true;\n      }\n      \n      // Intersection with left side of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {\n        return true;\n      }\n      \n      // Intersection with right side of selection box\n      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {\n        return true;\n      }\n    }\n\n    /*\n    // Check if box corner in the polygon\n    if ($$.math.pointInsidePolygon(\n      x1, y1, points, 0, 0, 1, 1, 0, direction)) {\n      \n      return true;\n    } else if ($$.math.pointInsidePolygon(\n      x1, y2, points, 0, 0, 1, 1, 0, direction)) {\n      \n      return true;\n    } else if ($$.math.pointInsidePolygon(\n      x2, y2, points, 0, 0, 1, 1, 0, direction)) {\n       \n      return true; \n    } else if ($$.math.pointInsidePolygon(\n      x2, y1, points, 0, 0, 1, 1, 0, direction)) {\n      \n      return true;\n    }\n    */\n    return false;\n  };\n  \n  $$.math.polygonIntersectLine = function(\n    x, y, basePoints, centerX, centerY, width, height, padding) {\n    \n    var intersections = [];\n    var intersection;\n    \n    var transformedPoints = new Array(basePoints.length);\n    \n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n    }\n    \n    var points;\n    \n    if (padding > 0) {\n      var expandedLineSet = $$.math.expandPolygon(\n        transformedPoints,\n        -padding);\n      \n      points = $$.math.joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n    // var points = transformedPoints;\n    \n    var currentX, currentY, nextX, nextY;\n    \n    for (var i = 0; i < points.length / 2; i++) {\n    \n      currentX = points[i * 2];\n      currentY = points[i * 2 + 1];\n\n      if (i < points.length / 2 - 1) {\n        nextX = points[(i + 1) * 2]; \n        nextY = points[(i + 1) * 2 + 1];\n      } else {\n        nextX = points[0]; \n        nextY = points[1];\n      }\n      \n      intersection = this.finiteLinesIntersect(\n        x, y, centerX, centerY,\n        currentX, currentY,\n        nextX, nextY);\n      \n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n    \n    return intersections;\n  };\n  \n  $$.math.shortenIntersection = function(\n    intersection, offset, amount) {\n    \n    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n    \n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    \n    var lenRatio = (length - amount) / length;\n    \n    if (lenRatio < 0) {\n      lenRatio = 0.00001;\n    }\n\n    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n  };\n\n  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {\n    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);\n    points = $$.math.fitPolygonToSquare(points);\n\n    return points;\n  };\n\n  $$.math.fitPolygonToSquare = function(points){\n    var x, y;\n    var sides = points.length/2;\n    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n\n    for (var i = 0; i < sides; i++) {\n      x = points[2 * i];\n      y = points[2 * i + 1];\n\n      minX = Math.min( minX, x );\n      maxX = Math.max( maxX, x );\n      minY = Math.min( minY, y );\n      maxY = Math.max( maxY, y );\n    }\n    \n    // stretch factors\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n\n    for (var i = 0; i < sides; i++){\n      x = points[2 * i] = points[2 * i] * sx;\n      y = points[2 * i + 1] = points[2 * i + 1] * sy;\n\n      minX = Math.min( minX, x );\n      maxX = Math.max( maxX, x );\n      minY = Math.min( minY, y );\n      maxY = Math.max( maxY, y );\n    }\n\n    if( minY < -1 ){\n      for (var i = 0; i < sides; i++){\n        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);\n      }\n    }\n    \n    return points;\n  };\n\n  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {\n    \n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? \n      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n//    console.log(nodeShapes['square']);\n    startAngle += rotationRadians;\n    \n    var points = new Array(sides * 2);\n\n    var currentAngle, x, y;\n    for (var i = 0; i < sides; i++) {\n      currentAngle = i * increment + startAngle;\n      \n      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);\n      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);\n    }\n    \n    return points;\n  };\n\n  $$.math.getRoundRectangleRadius = function(width, height) {\n    \n    // Set the default radius, unless half of width or height is smaller than default\n    return Math.min(width / 4, height / 4, 8);\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // registered extensions to cytoscape, indexed by name\n  var extensions = {};\n  $$.extensions = extensions;\n  \n  // registered modules for extensions, indexed by name\n  var modules = {};\n  $$.modules = modules;\n  \n  function setExtension(type, name, registrant){\n    var impl = {};\n    impl[name] = registrant;\n    \n    switch( type ){\n    case 'core':\n    case 'collection':\n      $$.fn[type]( impl );\n    }\n    \n    // fill in missing layout functions in the prototype\n    if( type === 'layout' ){\n      var layoutProto = registrant.prototype;\n      var optLayoutFns = ['stop'];\n\n      for( var i = 0; i < optLayoutFns.length; i++ ){\n        var fnName = optLayoutFns[i];\n\n        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };\n      }\n\n      // either .start() or .run() is defined, so autogen the other\n      if( layoutProto.start && !layoutProto.run ){\n        layoutProto.run = function(){ this.start(); return this; };\n      } else if( !layoutProto.start && layoutProto.run ){\n        layoutProto.start = function(){ this.run(); return this; };\n      }\n\n      layoutProto.on = $$.define.on({ layout: true });\n      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });\n      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });\n      layoutProto.off = $$.define.off({ layout: true });\n      layoutProto.trigger = $$.define.trigger({ layout: true });\n\n      // aliases for those folks who like old stuff:\n      layoutProto.bind = layoutProto.on;\n      layoutProto.unbind = layoutProto.off;\n    }\n\n    return $$.util.setMap({\n      map: extensions,\n      keys: [ type, name ],\n      value: registrant\n    });\n  }\n  \n  function getExtension(type, name){\n    return $$.util.getMap({\n      map: extensions,\n      keys: [ type, name ]\n    });\n  }\n  \n  function setModule(type, name, moduleType, moduleName, registrant){\n    return $$.util.setMap({\n      map: modules,\n      keys: [ type, name, moduleType, moduleName ],\n      value: registrant\n    });\n  }\n  \n  function getModule(type, name, moduleType, moduleName){\n    return $$.util.getMap({\n      map: modules,\n      keys: [ type, name, moduleType, moduleName ]\n    });\n  }\n  \n  $$.extension = function(){\n    // e.g. $$.extension('renderer', 'svg')\n    if( arguments.length == 2 ){\n      return getExtension.apply(this, arguments);\n    }\n    \n    // e.g. $$.extension('renderer', 'svg', { ... })\n    else if( arguments.length == 3 ){\n      return setExtension.apply(this, arguments);\n    }\n    \n    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')\n    else if( arguments.length == 4 ){\n      return getModule.apply(this, arguments);\n    }\n    \n    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n    else if( arguments.length == 5 ){\n      return setModule.apply(this, arguments);\n    }\n    \n    else {\n      $$.util.error('Invalid extension access syntax');\n    }\n  \n  };\n  \n})( cytoscape );\n\n;(function($, $$){ 'use strict';\n  \n  if( !$ ){ return; } // no jquery => don't need this\n\n  var cyReg = function( $ele ){\n    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};\n\n    return d;\n  };\n\n  // allow calls on a jQuery selector by proxying calls to $.cytoscape\n  // e.g. $(\"#foo\").cytoscape(options) => $.cytoscape(options) on #foo\n  $.fn.cytoscape = function(opts){\n    var $this = $(this);\n\n    // get object\n    if( opts === 'get' ){\n      return cyReg( $this ).cy;\n    }\n    \n    // bind to ready\n    else if( $$.is.fn(opts) ){\n\n      var ready = opts;\n      var cy = cyReg( $this ).cy;\n      \n      if( cy && cy.isReady() ){ // already ready so just trigger now\n        cy.trigger('ready', [], ready);\n\n      } else { // not yet ready, so add to readies list\n        var data = cyReg( $this );\n        var readies = data.readies = data.readies || [];\n\n        readies.push( ready );\n      } \n      \n    }\n    \n    // proxy to create instance\n    else if( $$.is.plainObject(opts) ){\n      return $this.each(function(){\n        var options = $.extend({}, opts, {\n          container: $(this)[0]\n        });\n      \n        cytoscape(options);\n      });\n    }\n  };\n  \n  // allow access to the global cytoscape object under jquery for legacy reasons\n  $.cytoscape = cytoscape;\n  \n  // use short alias (cy) if not already defined\n  if( $.fn.cy == null && $.cy == null ){\n    $.fn.cy = $.fn.cytoscape;\n    $.cy = $.cytoscape;\n  }\n  \n})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);\n\n;(function($$){ 'use strict';\n  \n  // shamelessly taken from jQuery\n  // https://github.com/jquery/jquery/blob/master/src/event.js\n\n  $$.Event = function( src, props ) {\n    // Allow instantiation without the 'new' keyword\n    if ( !(this instanceof $$.Event) ) {\n      return new $$.Event( src, props );\n    }\n\n    // Event object\n    if ( src && src.type ) {\n      this.originalEvent = src;\n      this.type = src.type;\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;\n\n    // Event type\n    } else {\n      this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if ( props ) {\n      // $$.util.extend( this, props );\n\n      // more efficient to manually copy fields we use\n      this.type = props.type !== undefined ? props.type : this.type;\n      this.cy = props.cy;\n      this.cyTarget = props.cyTarget;\n      this.cyPosition = props.cyPosition;\n      this.cyRenderedPosition = props.cyRenderedPosition;\n      this.namespace = props.namespace;\n      this.layout = props.layout;\n      this.data = props.data;\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || +new Date();\n  };\n\n  function returnFalse() {\n    return false;\n  }\n  function returnTrue() {\n    return true;\n  }\n\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n  $$.Event.prototype = {\n    preventDefault: function() {\n      this.isDefaultPrevented = returnTrue;\n\n      var e = this.originalEvent;\n      if ( !e ) {\n        return;\n      }\n\n      // if preventDefault exists run it on the original event\n      if ( e.preventDefault ) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function() {\n      this.isPropagationStopped = returnTrue;\n\n      var e = this.originalEvent;\n      if ( !e ) {\n        return;\n      }\n      // if stopPropagation exists run it on the original event\n      if ( e.stopPropagation ) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function() {\n      this.isImmediatePropagationStopped = returnTrue;\n      this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n  };\n  \n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // use this module to cherry pick functions into your prototype\n  // (useful for functions shared between the core and collections, for example)\n\n  // e.g.\n  // $$.fn.collection({\n  //   foo: $$.define.foo({ /* params... */ })\n  // });\n\n  $$.define = {\n\n    // access data field\n    data: function( params ){\n      var defaults = { \n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: false,\n        allowSetting: false,\n        allowGetting: false,\n        settingEvent: 'data',\n        settingTriggersEvent: false,\n        triggerFnName: 'trigger',\n        immutableKeys: {}, // key => true if immutable\n        updateStyle: false,\n        onSet: function( self ){},\n        canSet: function( self ){ return true; }\n      };\n      params = $$.util.extend({}, defaults, params);\n\n      return function dataImpl( name, value ){\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var single = selfIsArrayLike ? self[0] : self;\n\n        // .data('foo', ...)\n        if( $$.is.string(name) ){ // set or get property\n\n          // .data('foo')\n          if( p.allowGetting && value === undefined ){ // get\n\n            var ret;\n            if( single ){\n              ret = single._private[ p.field ][ name ];\n            }\n            return ret;\n          \n          // .data('foo', 'bar')\n          } else if( p.allowSetting && value !== undefined ) { // set\n            var valid = !p.immutableKeys[name];\n            if( valid ){\n              for( var i = 0, l = all.length; i < l; i++ ){\n                if( p.canSet( all[i] ) ){\n                  all[i]._private[ p.field ][ name ] = value;\n                }\n              }\n\n              // update mappers if asked\n              if( p.updateStyle ){ self.updateStyle(); }\n\n              // call onSet callback\n              p.onSet( self );\n\n              if( p.settingTriggersEvent ){\n                self[ p.triggerFnName ]( p.settingEvent );\n              }\n            }\n          }\n\n        // .data({ 'foo': 'bar' })\n        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend\n          var obj = name;\n          var k, v;\n\n          for( k in obj ){\n            v = obj[ k ];\n\n            var valid = !p.immutableKeys[k];\n            if( valid ){\n              for( var i = 0, l = all.length; i < l; i++ ){\n                if( p.canSet( all[i] ) ){\n                  all[i]._private[ p.field ][ k ] = v;\n                }\n              }\n            }\n          }\n          \n          // update mappers if asked\n          if( p.updateStyle ){ self.updateStyle(); }\n\n          // call onSet callback\n          p.onSet( self );\n\n          if( p.settingTriggersEvent ){\n            self[ p.triggerFnName ]( p.settingEvent );\n          }\n        \n        // .data(function(){ ... })\n        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event\n          var fn = name;\n          self.bind( p.bindingEvent, fn );\n        \n        // .data()\n        } else if( p.allowGetting && name === undefined ){ // get whole object\n          var ret;\n          if( single ){\n            ret = single._private[ p.field ];\n          }\n          return ret;\n        }\n\n        return self; // maintain chainability\n      }; // function\n    }, // data\n\n    // remove data field\n    removeData: function( params ){\n      var defaults = { \n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: false,\n        immutableKeys: {} // key => true if immutable\n      };\n      params = $$.util.extend({}, defaults, params);\n\n      return function removeDataImpl( names ){\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        \n        // .removeData('foo bar')\n        if( $$.is.string(names) ){ // then get the list of keys, and delete them\n          var keys = names.split(/\\s+/);\n          var l = keys.length;\n\n          for( var i = 0; i < l; i++ ){ // delete each non-empty key\n            var key = keys[i];\n            if( $$.is.emptyString(key) ){ continue; }\n\n            var valid = !p.immutableKeys[ key ]; // not valid if immutable\n            if( valid ){\n              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n                all[ i_a ]._private[ p.field ][ key ] = undefined;\n              }\n            }\n          }\n\n          if( p.triggerEvent ){\n            self[ p.triggerFnName ]( p.event );\n          }\n\n        // .removeData()\n        } else if( names === undefined ){ // then delete all keys\n\n          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){\n            var _privateFields = all[ i_a ]._private[ p.field ];\n            \n            for( var key in _privateFields ){\n              var validKeyToDelete = !p.immutableKeys[ key ];\n\n              if( validKeyToDelete ){\n                _privateFields[ key ] = undefined;\n              }\n            }\n          }\n\n          if( p.triggerEvent ){\n            self[ p.triggerFnName ]( p.event );\n          }\n        }\n\n        return self; // maintain chaining\n      }; // function\n    }, // removeData\n\n    // event function reusable stuff\n    event: {\n      regex: /(\\w+)(\\.\\w+)?/, // regex for matching event strings (e.g. \"click.namespace\")\n      optionalTypeRegex: /(\\w+)?(\\.\\w+)?/,\n      falseCallback: function(){ return false; }\n    },\n\n    // event binding\n    on: function( params ){\n      var defaults = {\n        unbindSelfOnTrigger: false,\n        unbindAllBindersOnTrigger: false\n      };\n      params = $$.util.extend({}, defaults, params);\n      \n      return function onImpl(events, selector, data, callback){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var eventsIsString = $$.is.string(events);\n        var p = params;\n\n        if( $$.is.plainObject(selector) ){ // selector is actually data\n          callback = data;\n          data = selector;\n          selector = undefined;\n        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback\n          callback = selector;\n          data = undefined;\n          selector = undefined;\n        }\n\n        if( $$.is.fn(data) || data === false ){ // data is actually callback\n          callback = data;\n          data = undefined;\n        }\n\n        // if there isn't a callback, we can't really do anything\n        // (can't speak for mapped events arg version)\n        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){\n          return self; // maintain chaining\n        }\n\n        if( eventsIsString ){ // then convert to map\n          var map = {};\n          map[ events ] = callback;\n          events = map;\n        }\n\n        for( var evts in events ){\n          callback = events[evts];\n          if( callback === false ){\n            callback = $$.define.event.falseCallback;\n          }\n\n          if( !$$.is.fn(callback) ){ continue; }\n\n          evts = evts.split(/\\s+/);\n          for( var i = 0; i < evts.length; i++ ){\n            var evt = evts[i];\n            if( $$.is.emptyString(evt) ){ continue; }\n\n            var match = evt.match( $$.define.event.regex ); // type[.namespace]\n\n            if( match ){\n              var type = match[1];\n              var namespace = match[2] ? match[2] : undefined;\n\n              var listener = {\n                callback: callback, // callback to run\n                data: data, // extra data in eventObj.data\n                delegated: selector ? true : false, // whether the evt is delegated\n                selector: selector, // the selector to match for delegated events\n                selObj: new $$.Selector(selector), // cached selector object to save rebuilding\n                type: type, // the event type (e.g. 'click')\n                namespace: namespace, // the event namespace (e.g. \".foo\")\n                unbindSelfOnTrigger: p.unbindSelfOnTrigger,\n                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,\n                binders: all // who bound together\n              };\n\n              for( var j = 0; j < all.length; j++ ){\n                all[j]._private.listeners.push( listener );\n              }\n            }\n          } // for events array\n        } // for events map\n        \n        return self; // maintain chaining\n      }; // function\n    }, // on\n\n    off: function offImpl( params ){\n      var defaults = {\n      };\n      params = $$.util.extend({}, defaults, params);\n      \n      return function(events, selector, callback){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var eventsIsString = $$.is.string(events);\n\n        if( arguments.length === 0 ){ // then unbind all\n\n          for( var i = 0; i < all.length; i++ ){\n            all[i]._private.listeners = [];\n          }\n\n          return self; // maintain chaining\n        }\n\n        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback\n          callback = selector;\n          selector = undefined;\n        }\n\n        if( eventsIsString ){ // then convert to map\n          var map = {};\n          map[ events ] = callback;\n          events = map;\n        }\n\n        for( var evts in events ){\n          callback = events[evts];\n\n          if( callback === false ){\n            callback = $$.define.event.falseCallback;\n          }\n\n          evts = evts.split(/\\s+/);\n          for( var h = 0; h < evts.length; h++ ){\n            var evt = evts[h];\n            if( $$.is.emptyString(evt) ){ continue; }\n\n            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]\n            if( match ){\n              var type = match[1] ? match[1] : undefined;\n              var namespace = match[2] ? match[2] : undefined;\n\n              for( var i = 0; i < all.length; i++ ){ //\n                var listeners = all[i]._private.listeners;\n\n                for( var j = 0; j < listeners.length; j++ ){\n                  var listener = listeners[j];\n                  var nsMatches = !namespace || namespace === listener.namespace;\n                  var typeMatches = !type || listener.type === type;\n                  var cbMatches = !callback || callback === listener.callback;\n                  var listenerMatches = nsMatches && typeMatches && cbMatches;\n\n                  // delete listener if it matches\n                  if( listenerMatches ){\n                    listeners.splice(j, 1);\n                    j--;\n                  }\n                } // for listeners\n              } // for all\n            } // if match\n          } // for events array\n\n        } // for events map\n        \n        return self; // maintain chaining\n      }; // function\n    }, // off\n\n    trigger: function( params ){\n      var defaults = {};\n      params = $$.util.extend({}, defaults, params);\n      \n      return function triggerImpl(events, extraParams, fnToTrigger){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var eventsIsString = $$.is.string(events);\n        var eventsIsObject = $$.is.plainObject(events);\n        var eventsIsEvent = $$.is.event(events);\n        var cy = this._private.cy || this;\n        var hasCompounds = cy.hasCompoundNodes();\n\n        if( eventsIsString ){ // then make a plain event object for each event name\n          var evts = events.split(/\\s+/);\n          events = [];\n\n          for( var i = 0; i < evts.length; i++ ){\n            var evt = evts[i];\n            if( $$.is.emptyString(evt) ){ continue; }\n\n            var match = evt.match( $$.define.event.regex ); // type[.namespace]\n            var type = match[1];\n            var namespace = match[2] ? match[2] : undefined;\n\n            events.push( {\n              type: type,\n              namespace: namespace\n            } );\n          }\n        } else if( eventsIsObject ){ // put in length 1 array\n          var eventArgObj = events;\n\n          events = [ eventArgObj ];\n        }\n\n        if( extraParams ){\n          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified\n            extraParams = [ extraParams ];\n          }\n        } else { // otherwise, we've got nothing\n          extraParams = [];\n        }\n\n        for( var i = 0; i < events.length; i++ ){ // trigger each event in order\n          var evtObj = events[i];\n          \n          for( var j = 0; j < all.length; j++ ){ // for each\n            var triggerer = all[j];\n            var listeners = triggerer._private.listeners;\n            var triggererIsElement = $$.is.element(triggerer);\n            var bubbleUp = triggererIsElement || params.layout;\n\n            // create the event for this element from the event object\n            var evt;\n\n            if( eventsIsEvent ){ // then just get the object\n              evt = evtObj;\n              \n              evt.cyTarget = evt.cyTarget || triggerer;\n              evt.cy = evt.cy || cy;\n\n            } else { // then we have to make one\n              evt = new $$.Event( evtObj, {\n                cyTarget: triggerer,\n                cy: cy,\n                namespace: evtObj.namespace\n              } );\n            }\n\n            // if a layout was specified, then put it in the typed event\n            if( evtObj.layout ){\n              evt.layout = evtObj.layout;\n            }\n\n            // if triggered by layout, put in event\n            if( params.layout ){\n              evt.layout = triggerer;\n            }\n\n            // create a rendered position based on the passed position\n            if( evt.cyPosition ){\n              var pos = evt.cyPosition;\n              var zoom = cy.zoom();\n              var pan = cy.pan();\n\n              evt.cyRenderedPosition = {\n                x: pos.x * zoom + pan.x,\n                y: pos.y * zoom + pan.y\n              };\n            }\n\n            if( fnToTrigger ){ // then override the listeners list with just the one we specified\n              listeners = [{\n                namespace: evt.namespace,\n                type: evt.type,\n                callback: fnToTrigger\n              }];\n            }\n\n            for( var k = 0; k < listeners.length; k++ ){ // check each listener\n              var lis = listeners[k];\n              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;\n              var typeMatches = lis.type === evt.type;\n              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive\n              var listenerMatches = nsMatches && typeMatches && targetMatches;\n\n              if( listenerMatches ){ // then trigger it\n                var args = [ evt ];\n                args = args.concat( extraParams ); // add extra params to args list\n\n                if( lis.data ){ // add on data plugged into binding\n                  evt.data = lis.data;\n                } else { // or clear it in case the event obj is reused\n                  evt.data = undefined;\n                }\n\n                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener\n                  listeners.splice(k, 1);\n                  k--;\n                }\n\n                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders\n                  var binders = lis.binders;\n                  for( var l = 0; l < binders.length; l++ ){\n                    var binder = binders[l];\n                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it\n\n                    var binderListeners = binder._private.listeners;\n                    for( var m = 0; m < binderListeners.length; m++ ){\n                      var binderListener = binderListeners[m];\n\n                      if( binderListener === lis ){ // delete listener from list\n                        binderListeners.splice(m, 1);\n                        m--;\n                      }\n                    }\n                  }\n                }\n\n                // run the callback\n                var context = lis.delegated ? evt.cyTarget : triggerer;\n                var ret = lis.callback.apply( context, args );\n\n                if( ret === false || evt.isPropagationStopped() ){\n                  // then don't bubble\n                  bubbleUp = false;\n\n                  if( ret === false ){\n                    // returning false is a shorthand for stopping propagation and preventing the def. action\n                    evt.stopPropagation();\n                    evt.preventDefault();\n                  }\n                }\n              } // if listener matches\n            } // for each listener\n\n            // bubble up event for elements\n            if( bubbleUp ){\n              var parent = hasCompounds ? triggerer._private.parent : null;\n              var hasParent = parent != null && parent.length !== 0;\n\n              if( hasParent ){ // then bubble up to parent\n                parent = parent[0];\n                parent.trigger(evt);\n              } else { // otherwise, bubble up to the core\n                cy.trigger(evt);\n              }\n            }\n\n          } // for each of all\n        } // for each event\n        \n        return self; // maintain chaining\n      }; // function\n    }, // trigger\n\n\n    animated: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function animatedImpl(){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return false; }\n\n        var ele = all[0];\n\n        if( ele ){\n          return ele._private.animation.current.length > 0;\n        }\n      };\n    }, // animated\n\n    clearQueue: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function clearQueueImpl(){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        for( var i = 0; i < all.length; i++ ){\n          var ele = all[i];\n          ele._private.animation.queue = [];\n        }\n\n        return this;\n      };\n    }, // clearQueue\n\n    delay: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function delayImpl( time, complete ){\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        this.animate({\n          delay: time\n        }, {\n          duration: time,\n          complete: complete\n        });\n\n        return this;\n      };\n    }, // delay\n\n    animate: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function animateImpl( properties, params ){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n        var isCore = !selfIsArrayLike;\n        var isEles = !isCore;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        var callTime = +new Date();\n        var style = cy.style();\n        var q;\n        \n        if( params === undefined ){\n          params = {};\n        }\n\n        if( params.duration === undefined ){\n          params.duration = 400;\n        }\n        \n        switch( params.duration ){\n        case 'slow':\n          params.duration = 600;\n          break;\n        case 'fast':\n          params.duration = 200;\n          break;\n        }\n        \n        var propertiesEmpty = true;\n        if( properties ){ for( var i in properties ){\n          propertiesEmpty = false;\n          break;\n        } }\n\n        if( propertiesEmpty ){\n          return this; // nothing to animate\n        }\n\n        if( properties.css && isEles ){\n          properties.css = style.getValueStyle( properties.css, { array: true } );\n        }\n\n        if( properties.renderedPosition && isEles ){\n          var rpos = properties.renderedPosition;\n          var pan = cy.pan();\n          var zoom = cy.zoom();\n\n          properties.position = {\n            x: ( rpos.x - pan.x ) /zoom,\n            y: ( rpos.y - pan.y ) /zoom\n          };\n        }\n\n        // override pan w/ panBy if set\n        if( properties.panBy && isCore ){\n          var panBy = properties.panBy;\n          var cyPan = cy.pan();\n\n          properties.pan = {\n            x: cyPan.x + panBy.x,\n            y: cyPan.y + panBy.y\n          };\n        }\n\n        // override pan w/ center if set\n        var center = properties.center || properties.centre;\n        if( center && isCore ){\n          var centerPan = cy.getCenterPan( center.eles, properties.zoom );\n\n          if( centerPan ){\n            properties.pan = centerPan;\n          }\n        }\n\n        // override pan & zoom w/ fit if set\n        if( properties.fit && isCore ){\n          var fit = properties.fit;\n          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );\n\n          if( fitVp ){\n            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };\n            properties.zoom = fitVp.zoom;\n          }\n        }\n\n        for( var i = 0; i < all.length; i++ ){\n          var ele = all[i];\n         \n          if( ele.animated() && (params.queue === undefined || params.queue) ){\n            q = ele._private.animation.queue;\n          } else {\n            q = ele._private.animation.current;\n          }\n\n          q.push({\n            properties: properties,\n            duration: params.duration,\n            params: params,\n            callTime: callTime\n          });\n        }\n\n        if( isEles ){\n          cy.addToAnimationPool( this );\n        }\n\n        return this; // chaining\n      };\n    }, // animate\n\n    stop: function( fnParams ){\n      var defaults = {};\n      fnParams = $$.util.extend({}, defaults, fnParams);\n\n      return function stopImpl( clearQueue, jumpToEnd ){\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        var cy = this._private.cy || this;\n\n        if( !cy.styleEnabled() ){ return this; }\n\n        for( var i = 0; i < all.length; i++ ){\n          var ele = all[i];\n          var anis = ele._private.animation.current;\n\n          for( var j = 0; j < anis.length; j++ ){\n            var animation = anis[j];    \n            if( jumpToEnd ){\n              // next iteration of the animation loop, the animation\n              // will go straight to the end and be removed\n              animation.duration = 0; \n            }\n          }\n          \n          // clear the queue of future animations\n          if( clearQueue ){\n            ele._private.animation.queue = [];\n          }\n\n          if( !jumpToEnd ){\n            ele._private.animation.current = [];\n          }\n        }\n        \n        // we have to notify (the animation loop doesn't do it for us on `stop`)\n        cy.notify({\n          collection: this,\n          type: 'draw'\n        });\n        \n        return this;\n      };\n    } // stop\n\n  }; // define\n\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.selector = function(map, options){\n    for( var name in map ){\n      var fn = map[name];\n      $$.Selector.prototype[ name ] = fn;\n    }\n  };\n\n  $$.Selector = function(onlyThisGroup, selector){\n    \n    if( !(this instanceof $$.Selector) ){\n      return new $$.Selector(onlyThisGroup, selector);\n    }\n  \n    if( selector === undefined && onlyThisGroup !== undefined ){\n      selector = onlyThisGroup;\n      onlyThisGroup = undefined;\n    }\n    \n    var self = this;\n    \n    self._private = {\n      selectorText: null,\n      invalid: true\n    };\n    \n    if( !selector || ( $$.is.string(selector) && selector.match(/^\\s*$/) ) ){\n      \n      if( onlyThisGroup == null ){\n        // ignore\n        self.length = 0;\n      } else {\n        self[0] = newQuery();\n        self[0].group = onlyThisGroup;\n        self.length = 1;\n      }\n              \n    } else if( $$.is.element( selector ) ){\n      var collection = new $$.Collection(self.cy(), [ selector ]);\n      \n      self[0] = newQuery();\n      self[0].collection = collection;\n      self.length = 1;\n      \n    } else if( $$.is.collection( selector ) ){\n      self[0] = newQuery();\n      self[0].collection = selector;\n      self.length = 1;\n      \n    } else if( $$.is.fn( selector ) ) {\n      self[0] = newQuery();\n      self[0].filter = selector;\n      self.length = 1;\n      \n    } else if( $$.is.string( selector ) ){\n\n      // the current subject in the query\n      var currentSubject = null;\n      \n      // storage for parsed queries\n      var newQuery = function(){\n        return {\n          classes: [], \n          colonSelectors: [],\n          data: [],\n          group: null,\n          ids: [],\n          meta: [],\n\n          // fake selectors\n          collection: null, // a collection to match against\n          filter: null, // filter function\n\n          // these are defined in the upward direction rather than down (e.g. child)\n          // because we need to go up in Selector.filter()\n          parent: null, // parent query obj\n          ancestor: null, // ancestor query obj\n          subject: null, // defines subject in compound query (subject query obj; points to self if subject)\n\n          // use these only when subject has been defined\n          child: null,\n          descendant: null\n        };\n      };\n\n      // tokens in the query language\n      var tokens = {\n        metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]', // chars we need to escape in var names, etc\n        comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=', // binary comparison op (used in data selectors)\n        boolOp: '\\\\?|\\\\!|\\\\^', // boolean (unary) operators (used in data selectors)\n        string: '\"(?:\\\\\\\\\"|[^\"])+\"' + '|' + \"'(?:\\\\\\\\'|[^'])+'\", // string literals (used in data selectors) -- doublequotes | singlequotes\n        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)\n        separator: '\\\\s*,\\\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n        descendant: '\\\\s+',\n        child: '\\\\s+>\\\\s+',\n        subject: '\\\\$'\n      };\n      tokens.variable = '(?:[\\\\w-]|(?:\\\\\\\\'+ tokens.metaChar +'))+'; // a variable name\n      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n      tokens.className = tokens.variable; // a class name (follows variable conventions)\n      tokens.id = tokens.variable; // an element id (follows variable conventions)\n\n      // when a token like a variable has escaped meta characters, we need to clean the backslashes out\n      // so that values get compared properly in Selector.filter()\n      var cleanMetaChars = function(str){\n        return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){\n          return $1;\n        });\n      };\n      \n      // add @ variants to comparatorOp\n      var ops = tokens.comparatorOp.split('|');\n      for( var i = 0; i < ops.length; i++ ){\n        var op = ops[i];\n        tokens.comparatorOp += '|@' + op;\n      }\n\n      // add ! variants to comparatorOp\n      var ops = tokens.comparatorOp.split('|');\n      for( var i = 0; i < ops.length; i++ ){\n        var op = ops[i];\n\n        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !\n        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined\n\n        tokens.comparatorOp += '|\\\\!' + op;\n      }\n\n      // NOTE: add new expression syntax here to have it recognised by the parser;\n      // - a query contains all adjacent (i.e. no separator in between) expressions;\n      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;\n      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward\n      // - when you add something here, also add to Selector.toString()\n      var exprs = {\n        group: {\n          query: true,\n          regex: '(node|edge|\\\\*)',\n          populate: function( group ){\n            this.group = group == \"*\" ? group : group + 's';\n          }\n        },\n        \n        state: {\n          query: true,\n          // NB: if one colon selector is a substring of another from its start, place the longer one first\n          // e.g. :foobar|:foo\n          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch)',\n          populate: function( state ){\n            this.colonSelectors.push( state );\n          }\n        },\n        \n        id: {\n          query: true,\n          regex: '\\\\#('+ tokens.id +')',\n          populate: function( id ){\n            this.ids.push( cleanMetaChars(id) );\n          }\n        },\n        \n        className: {\n          query: true,\n          regex: '\\\\.('+ tokens.className +')',\n          populate: function( className ){\n            this.classes.push( cleanMetaChars(className) );\n          }\n        },\n        \n        dataExists: {\n          query: true,\n          regex: '\\\\[\\\\s*('+ tokens.variable +')\\\\s*\\\\]',\n          populate: function( variable ){\n            this.data.push({\n              field: cleanMetaChars(variable)\n            });\n          }\n        },\n        \n        dataCompare: {\n          query: true,\n          regex: '\\\\[\\\\s*('+ tokens.variable +')\\\\s*('+ tokens.comparatorOp +')\\\\s*('+ tokens.value +')\\\\s*\\\\]',\n          populate: function( variable, comparatorOp, value ){ \n            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\n            if( valueIsString ){\n              value = value.substring(1, value.length - 1);\n            } else {\n              value = parseFloat(value);\n            }\n\n            this.data.push({\n              field: cleanMetaChars(variable),\n              operator: comparatorOp,\n              value: value\n            });\n          }\n        },\n        \n        dataBool: {\n          query: true,\n          regex: '\\\\[\\\\s*('+ tokens.boolOp +')\\\\s*('+ tokens.variable +')\\\\s*\\\\]',\n          populate: function( boolOp, variable ){\n            this.data.push({\n              field: cleanMetaChars(variable),\n              operator: boolOp\n            });\n          }\n        },\n        \n        metaCompare: {\n          query: true,\n          regex: '\\\\[\\\\[\\\\s*('+ tokens.meta +')\\\\s*('+ tokens.comparatorOp +')\\\\s*('+ tokens.number +')\\\\s*\\\\]\\\\]',\n          populate: function( meta, comparatorOp, number ){\n            this.meta.push({\n              field: cleanMetaChars(meta),\n              operator: comparatorOp,\n              value: parseFloat(number)\n            });\n          }\n        },\n\n        nextQuery: {\n          separator: true,\n          regex: tokens.separator,\n          populate: function(){\n            // go on to next query\n            self[++i] = newQuery();\n            currentSubject = null;\n          }\n        },\n\n        child: {\n          separator: true,\n          regex: tokens.child,\n          populate: function(){\n            // this query is the parent of the following query\n            var childQuery = newQuery();\n            childQuery.parent = this;\n            childQuery.subject = currentSubject;\n\n            // we're now populating the child query with expressions that follow\n            self[i] = childQuery;\n          }\n        },\n\n        descendant: {\n          separator: true,\n          regex: tokens.descendant,\n          populate: function(){\n            // this query is the ancestor of the following query\n            var descendantQuery = newQuery();\n            descendantQuery.ancestor = this;\n            descendantQuery.subject = currentSubject;\n\n            // we're now populating the descendant query with expressions that follow\n            self[i] = descendantQuery;\n          }\n        },\n\n        subject: {\n          modifier: true,\n          regex: tokens.subject,\n          populate: function(){\n            if( currentSubject != null && this.subject != this ){\n              $$.util.error('Redefinition of subject in selector `' + selector + '`');\n              return false;\n            }\n\n            currentSubject = this;\n            this.subject = this;\n          }\n\n        }\n      };\n\n      var j = 0;\n      for( var name in exprs ){\n        exprs[j] = exprs[name];\n        exprs[j].name = name;\n\n        j++;\n      }\n      exprs.length = j;\n\n      self._private.selectorText = selector;\n      var remaining = selector;\n      var i = 0;\n      \n      // of all the expressions, find the first match in the remaining text\n      var consumeExpr = function( expectation ){\n        var expr;\n        var match;\n        var name;\n        \n        for( var j = 0; j < exprs.length; j++ ){\n          var e = exprs[j];\n          var n = e.name;\n\n          // ignore this expression if it doesn't meet the expectation function\n          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }\n\n          var m = remaining.match(new RegExp( '^' + e.regex ));\n          \n          if( m != null ){\n            match = m;\n            expr = e;\n            name = n;\n            \n            var consumed = m[0];\n            remaining = remaining.substring( consumed.length );                \n            \n            break; // we've consumed one expr, so we can return now\n          }\n        }\n        \n        return {\n          expr: expr,\n          match: match,\n          name: name\n        };\n      };\n      \n      // consume all leading whitespace\n      var consumeWhitespace = function(){\n        var match = remaining.match(/^\\s+/);\n        \n        if( match ){\n          var consumed = match[0];\n          remaining = remaining.substring( consumed.length );\n        }\n      };\n      \n      self[0] = newQuery(); // get started\n\n      consumeWhitespace(); // get rid of leading whitespace\n      for(;;){        \n        var check = consumeExpr();\n        \n        if( check.expr == null ){\n          $$.util.error('The selector `'+ selector +'`is invalid');\n          return;\n        } else {\n          var args = [];\n          for(var j = 1; j < check.match.length; j++){\n            args.push( check.match[j] );\n          }\n          \n          // let the token populate the selector object (i.e. in self[i])\n          var ret = check.expr.populate.apply( self[i], args );\n\n          if( ret === false ){ return; } // exit if population failed\n        }\n        \n        // we're done when there's nothing left to parse\n        if( remaining.match(/^\\s*$/) ){\n          break;\n        }\n      }\n      \n      self.length = i + 1;\n\n      // adjust references for subject\n      for(j = 0; j < self.length; j++){\n        var query = self[j];\n\n        if( query.subject != null ){\n          // go up the tree until we reach the subject\n          for(;;){\n            if( query.subject == query ){ break; } // done if subject is self\n\n            if( query.parent != null ){ // swap parent/child reference\n              var parent = query.parent;\n              var child = query;\n\n              child.parent = null;\n              parent.child = child;\n\n              query = parent; // go up the tree\n            } else if( query.ancestor != null ){ // swap ancestor/descendant\n              var ancestor = query.ancestor;\n              var descendant = query;\n\n              descendant.ancestor = null;\n              ancestor.descendant = descendant;\n\n              query = ancestor; // go up the tree\n            } else {\n              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');\n              break;\n            }\n          } // for\n\n          self[j] = query.subject; // subject should be the root query\n        } // if\n      } // for\n\n      // make sure for each query that the subject group matches the implicit group if any\n      if( onlyThisGroup != null ){\n        for(var j = 0; j < self.length; j++){\n          if( self[j].group != null && self[j].group != onlyThisGroup ){\n            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');\n            return;\n          }\n\n          self[j].group = onlyThisGroup; // set to implicit group\n        }\n      }\n      \n    } else {\n      $$.util.error('A selector must be created from a string; found ' + selector);\n      return;\n    }\n\n    self._private.invalid = false;\n    \n  };\n\n  $$.selfn = $$.Selector.prototype;\n  \n  $$.selfn.size = function(){\n    return this.length;\n  };\n  \n  $$.selfn.eq = function(i){\n    return this[i];\n  };\n  \n  // get elements from the core and then filter them\n  $$.selfn.find = function(){\n    // TODO impl if we decide to use a DB for storing elements\n  };\n  \n  var queryMatches = function(query, element){\n    // check group\n    if( query.group != null && query.group != '*' && query.group != element._private.group ){\n      return false;\n    }\n\n    var cy = element.cy();\n    \n    // check colon selectors\n    var allColonSelectorsMatch = true;\n    for(var k = 0; k < query.colonSelectors.length; k++){\n      var sel = query.colonSelectors[k];\n      \n      switch(sel){\n      case ':selected':\n        allColonSelectorsMatch = element.selected();\n        break;\n      case ':unselected':\n        allColonSelectorsMatch = !element.selected();\n        break;\n      case ':selectable':\n        allColonSelectorsMatch = element.selectable();\n        break;\n      case ':unselectable':\n        allColonSelectorsMatch = !element.selectable();\n        break;\n      case ':locked':\n        allColonSelectorsMatch = element.locked();\n        break;\n      case ':unlocked':\n        allColonSelectorsMatch = !element.locked();\n        break;\n      case ':visible':\n        allColonSelectorsMatch = element.visible();\n        break;\n      case ':hidden':\n        allColonSelectorsMatch = !element.visible();\n        break;\n      case ':transparent':\n        allColonSelectorsMatch = element.transparent();\n        break;\n      case ':grabbed':\n        allColonSelectorsMatch = element.grabbed();\n        break;\n      case ':free':\n        allColonSelectorsMatch = !element.grabbed();\n        break;\n      case ':removed':\n        allColonSelectorsMatch = element.removed();\n        break;\n      case ':inside':\n        allColonSelectorsMatch = !element.removed();\n        break;\n      case ':grabbable':\n        allColonSelectorsMatch = element.grabbable();\n        break;\n      case ':ungrabbable':\n        allColonSelectorsMatch = !element.grabbable();\n        break;\n      case ':animated':\n        allColonSelectorsMatch = element.animated();\n        break;\n      case ':unanimated':\n        allColonSelectorsMatch = !element.animated();\n        break;\n      case ':parent':\n        allColonSelectorsMatch = element.isNode() && element.children().nonempty();\n        break;\n      case ':child':\n      case ':nonorphan':\n        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();\n        break;\n      case ':orphan':\n        allColonSelectorsMatch = element.isNode() && element.parent().empty();\n        break;\n      case ':loop':\n        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');\n        break;\n      case ':simple':\n        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');\n        break;\n      case ':active':\n        allColonSelectorsMatch = element.active();\n        break;\n      case ':inactive':\n        allColonSelectorsMatch = !element.active();\n        break;\n      case ':touch':\n        allColonSelectorsMatch = $$.is.touch();\n        break;\n      }\n      \n      if( !allColonSelectorsMatch ) break;\n    }\n    if( !allColonSelectorsMatch ) return false;\n    \n    // check id\n    var allIdsMatch = true;\n    for(var k = 0; k < query.ids.length; k++){\n      var id = query.ids[k];\n      var actualId = element._private.data.id;\n      \n      allIdsMatch = allIdsMatch && (id == actualId);\n      \n      if( !allIdsMatch ) break;\n    }\n    if( !allIdsMatch ) return false;\n    \n    // check classes\n    var allClassesMatch = true;\n    for(var k = 0; k < query.classes.length; k++){\n      var cls = query.classes[k];\n      \n      allClassesMatch = allClassesMatch && element.hasClass(cls);\n      \n      if( !allClassesMatch ) break;\n    }\n    if( !allClassesMatch ) return false;\n    \n    // generic checking for data/metadata\n    var operandsMatch = function(params){\n      var allDataMatches = true;\n      for(var k = 0; k < query[params.name].length; k++){\n        var data = query[params.name][k];\n        var operator = data.operator;\n        var value = data.value;\n        var field = data.field;\n        var matches;\n        \n        if( operator != null && value != null ){\n          \n          var fieldVal = params.fieldValue(field);\n          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;\n          var valStr = '' + value;\n          \n          var caseInsensitive = false;\n          if( operator.indexOf('@') >= 0 ){\n            fieldStr = fieldStr.toLowerCase();\n            valStr = valStr.toLowerCase();\n            \n            operator = operator.replace('@', '');\n            caseInsensitive = true;\n          }\n\n          var notExpr = false;\n          var handledNotExpr = false;\n          if( operator.indexOf('!') >= 0 ){\n            operator = operator.replace('!', '');\n            notExpr = true;\n          }\n          \n          // if we're doing a case insensitive comparison, then we're using a STRING comparison\n          // even if we're comparing numbers\n          if( caseInsensitive ){\n            value = valStr.toLowerCase();\n            fieldVal = fieldStr.toLowerCase();\n          }\n\n          switch(operator){\n          case '*=':\n            matches = fieldStr.search(valStr) >= 0;\n            break;\n          case '$=':\n            matches = new RegExp(valStr + '$').exec(fieldStr) != null;\n            break;\n          case '^=':\n            matches = new RegExp('^' + valStr).exec(fieldStr) != null;\n            break;\n          case '=':\n            matches = fieldVal === value;\n            break;\n          case '!=':\n            matches = fieldVal !== value;\n            break;\n          case '>':\n            matches = !notExpr ? fieldVal > value : fieldVal <= value;\n            handledNotExpr = true;\n            break;\n          case '>=':\n            matches = !notExpr ? fieldVal >= value : fieldVal < value;\n            handledNotExpr = true;\n            break;\n          case '<':\n            matches = !notExpr ? fieldVal < value : fieldVal >= value;\n            handledNotExpr = true;\n            break;\n          case '<=':\n            matches = !notExpr ? fieldVal <= value : fieldVal > value;\n            handledNotExpr = true;\n            break;\n          default:\n            matches = false;\n            break;\n            \n          }\n        } else if( operator != null ){\n          switch(operator){\n          case '?':\n            matches = params.fieldTruthy(field);\n            break;\n          case '!':\n            matches = !params.fieldTruthy(field);\n            break;\n          case '^':\n            matches = params.fieldUndefined(field);\n            break;\n          }\n        } else {   \n          matches = !params.fieldUndefined(field);\n        }\n\n        if( notExpr && !handledNotExpr ){\n          matches = !matches;\n          handledNotExpr = true;\n        }\n        \n        if( !matches ){\n          allDataMatches = false;\n          break;\n        }\n      } // for\n      \n      return allDataMatches;\n    }; // operandsMatch\n    \n    // check data matches\n    var allDataMatches = operandsMatch({\n      name: 'data',\n      fieldValue: function(field){\n        return element._private.data[field];\n      },\n      fieldRef: function(field){\n        return 'element._private.data.' + field;\n      },\n      fieldUndefined: function(field){\n        return element._private.data[field] === undefined;\n      },\n      fieldTruthy: function(field){\n        if( element._private.data[field] ){\n          return true;\n        }\n        return false;\n      }\n    });\n    \n    if( !allDataMatches ){\n      return false;\n    }\n    \n    // check metadata matches\n    var allMetaMatches = operandsMatch({\n      name: 'meta',\n      fieldValue: function(field){\n        return element[field]();\n      },\n      fieldRef: function(field){\n        return 'element.' + field + '()';\n      },\n      fieldUndefined: function(field){\n        return element[field]() == null;\n      },\n      fieldTruthy: function(field){\n        if( element[field]() ){\n          return true;\n        }\n        return false;\n      }\n    });\n    \n    if( !allMetaMatches ){\n      return false;\n    }\n    \n    // check collection\n    if( query.collection != null ){\n      var matchesAny = query.collection._private.ids[ element.id() ] != null;\n      \n      if( !matchesAny ){\n        return false;\n      }\n    }\n    \n    // check filter function\n    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){\n      return false;\n    }\n    \n\n    // check parent/child relations\n    var confirmRelations = function( query, elements ){\n      if( query != null ){\n        var matches = false;\n\n        if( !cy.hasCompoundNodes() ){\n          return false;\n        }\n\n        elements = elements(); // make elements functional so we save cycles if query == null\n\n        // query must match for at least one element (may be recursive)\n        for(var i = 0; i < elements.length; i++){\n          if( queryMatches( query, elements[i] ) ){\n            matches = true;\n            break;\n          }\n        }\n\n        return matches;\n      } else {\n        return true;\n      }\n    };\n\n    if (! confirmRelations(query.parent, function(){\n      return element.parent();\n    }) ){ return false; }\n\n    if (! confirmRelations(query.ancestor, function(){\n      return element.parents();\n    }) ){ return false; }\n\n    if (! confirmRelations(query.child, function(){\n      return element.children();\n    }) ){ return false; }\n\n    if (! confirmRelations(query.descendant, function(){\n      return element.descendants();\n    }) ){ return false; }\n\n    // we've reached the end, so we've matched everything for this query\n    return true;\n  }; // queryMatches\n\n  // filter an existing collection\n  $$.selfn.filter = function(collection){\n    var self = this;\n    var cy = collection.cy();\n    \n    // don't bother trying if it's invalid\n    if( self._private.invalid ){\n      return new $$.Collection( cy );\n    }\n  \n    var selectorFunction = function(i, element){\n      for(var j = 0; j < self.length; j++){\n        var query = self[j];\n        \n        if( queryMatches(query, element) ){\n          return true;\n        }\n      }\n      \n      return false;\n    };\n    \n    if( self._private.selectorText == null ){\n      selectorFunction = function(){ return true; };\n    }\n    \n    var filteredCollection = collection.filter( selectorFunction );\n    \n    return filteredCollection;\n  }; // filter\n\n  // does selector match a single element?\n  $$.selfn.matches = function(ele){\n    var self = this;\n    \n    // don't bother trying if it's invalid\n    if( self._private.invalid ){\n      return false;\n    }\n  \n    for(var j = 0; j < self.length; j++){\n      var query = self[j];\n      \n      if( queryMatches(query, ele) ){\n        return true;\n      }\n    }\n    \n    return false;\n  }; // filter\n  \n  // ith query to string\n  $$.selfn.toString = $$.selfn.selector = function(){\n    \n    var str = '';\n    \n    var clean = function(obj){\n      if( $$.is.string(obj) ){\n        return obj;\n      } \n      return '';\n    };\n    \n    var queryToString = function(query){\n      var str = '';\n\n      var group = clean(query.group);\n      str += group.substring(0, group.length - 1);\n      \n      for(var j = 0; j < query.data.length; j++){\n        var data = query.data[j];\n        \n        if( data.value ){\n          str += '[' + data.field + clean(data.operator) + clean(data.value) + ']';\n        } else {\n          str += '[' + clean(data.operator) + data.field + ']';\n        }\n      }\n\n      for(var j = 0; j < query.meta.length; j++){\n        var meta = query.meta[j];\n        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value) + ']]';\n      }\n      \n      for(var j = 0; j < query.colonSelectors.length; j++){\n        var sel = query.colonSelectors[i];\n        str += sel;\n      }\n      \n      for(var j = 0; j < query.ids.length; j++){\n        var sel = '#' + query.ids[i];\n        str += sel;\n      }\n      \n      for(var j = 0; j < query.classes.length; j++){\n        var sel = '.' + query.classes[i];\n        str += sel;\n      }\n\n      if( query.parent != null ){\n        str = queryToString( query.parent ) + ' > ' + str; \n      }\n\n      if( query.ancestor != null ){\n        str = queryToString( query.ancestor ) + ' ' + str; \n      }\n\n      if( query.child != null ){\n        str += ' > ' + queryToString( query.child ); \n      }\n\n      if( query.descendant != null ){\n        str += ' ' + queryToString( query.descendant ); \n      }\n\n      return str;\n    };\n\n    for(var i = 0; i < this.length; i++){\n      var query = this[i];\n      \n      str += queryToString( query );\n      \n      if( this.length > 1 && i < this.length - 1 ){\n        str += ', ';\n      }\n    }\n    \n    return str;\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.Style = function( cy ){\n\n    if( !(this instanceof $$.Style) ){\n      return new $$.Style(cy);\n    }\n\n    if( !$$.is.core(cy) ){\n      $$.util.error('A style must have a core reference');\n      return;\n    }\n\n    this._private = {\n      cy: cy,\n      coreStyle: {},\n      newStyle: true\n    };\n    \n    this.length = 0;\n\n    this.addDefaultStylesheet();\n  };\n\n  // nice-to-have aliases\n  $$.style = $$.Style;\n  $$.styfn = $$.Style.prototype;\n\n  // define functions in the Style prototype\n  $$.fn.style = function( fnMap, options ){\n    for( var fnName in fnMap ){\n      var fn = fnMap[ fnName ];\n      $$.Style.prototype = fn;\n    }\n  };\n\n  (function(){\n    var number = $$.util.regex.number;\n    var rgba = $$.util.regex.rgbaNoBackRefs;\n    var hsla = $$.util.regex.hslaNoBackRefs;\n    var hex3 = $$.util.regex.hex3;\n    var hex6 = $$.util.regex.hex6;\n    var data = function( prefix ){ return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$'; };\n    var mapData = function( prefix ){ return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*\\\\,\\\\s*(' + number + ')\\\\s*,\\\\s*(' + number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\\\s*\\\\,\\\\s*(' + number + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\\\)$'; };\n\n    // each visual style property has a type and needs to be validated according to it\n    $$.style.types = {\n      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },\n      percent: { number: true, min: 0, max: 100, units: '%' },\n      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },\n      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },\n      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },\n      position: { enums: ['parent', 'origin'] },\n      autoSize: { number: true, min: 0, enums: ['auto'] },\n      number: { number: true },\n      size: { number: true, min: 0 },\n      bgSize: { number: true, min: 0, allowPercent: true },\n      bgPos: { number: true, allowPercent: true },\n      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },\n      bgFit: { enums: ['none', 'contain', 'cover'] },\n      bgClip: { enums: ['none', 'node'] },\n      color: { color: true },\n      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },\n      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },\n      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },\n      fontFamily: { regex: '^([\\\\w- ]+(?:\\\\s*,\\\\s*[\\\\w- ]+)*)$' },\n      fontVariant: { enums: ['small-caps', 'normal'] },\n      fontStyle: { enums: ['italic', 'normal', 'oblique'] },\n      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },\n      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },\n      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },\n      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star'] },\n      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },\n      arrowFill: { enums: ['filled', 'hollow'] },\n      display: { enums: ['element', 'none'] },\n      visibility: { enums: ['hidden', 'visible'] },\n      valign: { enums: ['top', 'center', 'bottom'] },\n      halign: { enums: ['left', 'center', 'right'] },\n      text: { string: true },\n      data: { mapping: true, regex: data('data') },\n      layoutData: { mapping: true, regex: data('layoutData') },\n      mapData: { mapping: true, regex: mapData('mapData') },\n      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },\n      url: { regex: '^url\\\\s*\\\\(\\\\s*([^\\\\s]+)\\\\s*\\\\s*\\\\)|none|(.+)$' },\n      propList: { propList: true },\n      angle: { number: true, units: 'deg|rad' }\n    };\n\n    // define visual style properties\n    var t = $$.style.types;\n    var props = $$.style.properties = [\n      // labels\n      { name: 'text-valign', type: t.valign },\n      { name: 'text-halign', type: t.halign },\n      { name: 'color', type: t.color },\n      { name: 'content', type: t.text },\n      { name: 'text-outline-color', type: t.color },\n      { name: 'text-outline-width', type: t.size },\n      { name: 'text-outline-opacity', type: t.zeroOneNumber },\n      { name: 'text-opacity', type: t.zeroOneNumber },\n      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas\n      { name: 'text-transform', type: t.textTransform },\n      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes\n      { name: 'font-family', type: t.fontFamily },\n      { name: 'font-style', type: t.fontStyle },\n      // { name: 'font-variant', type: t.fontVariant }, // not useful\n      { name: 'font-weight', type: t.fontWeight },\n      { name: 'font-size', type: t.size },\n      { name: 'min-zoomed-font-size', type: t.size },\n\n      // visibility\n      { name: 'display', type: t.display },\n      { name: 'visibility', type: t.visibility },\n      { name: 'opacity', type: t.zeroOneNumber },\n      { name: 'z-index', type: t.nonNegativeInt },\n\n      // overlays\n      { name: 'overlay-padding', type: t.size },\n      { name: 'overlay-color', type: t.color },\n      { name: 'overlay-opacity', type: t.zeroOneNumber },\n\n      // transition anis\n      { name: 'transition-property', type: t.propList },\n      { name: 'transition-duration', type: t.time },\n      { name: 'transition-delay', type: t.time },\n\n      // node body\n      { name: 'height', type: t.autoSize },\n      { name: 'width', type: t.autoSize },\n      { name: 'shape', type: t.nodeShape },\n      { name: 'background-color', type: t.color },\n      { name: 'background-opacity', type: t.zeroOneNumber },\n      { name: 'background-blacken', type: t.nOneOneNumber },\n\n      // node border\n      { name: 'border-color', type: t.color },\n      { name: 'border-opacity', type: t.zeroOneNumber },\n      { name: 'border-width', type: t.size },\n      { name: 'border-style', type: t.borderStyle },\n      \n      // node background images\n      { name: 'background-image', type: t.url },\n      { name: 'background-image-opacity', type: t.zeroOneNumber },\n      { name: 'background-position-x', type: t.bgPos },\n      { name: 'background-position-y', type: t.bgPos },\n      { name: 'background-repeat', type: t.bgRepeat },\n      { name: 'background-fit', type: t.bgFit },\n      { name: 'background-clip', type: t.bgClip },\n\n      // compound props\n      { name: 'padding-left', type: t.size },\n      { name: 'padding-right', type: t.size },\n      { name: 'padding-top', type: t.size },\n      { name: 'padding-bottom', type: t.size },\n      { name: 'position', type: t.position },\n\n      // edge line\n      { name: 'line-style', type: t.lineStyle },\n      { name: 'line-color', type: t.color },\n      { name: 'control-point-step-size', type: t.size },\n      { name: 'control-point-distance', type: t.number },\n      { name: 'control-point-weight', type: t.zeroOneNumber },\n      { name: 'curve-style', type: t.curveStyle },\n      { name: 'haystack-radius', type: t.zeroOneNumber },\n\n      // edge arrows\n      { name: 'source-arrow-shape', type: t.arrowShape },\n      { name: 'target-arrow-shape', type: t.arrowShape },\n      { name: 'mid-source-arrow-shape', type: t.arrowShape },\n      { name: 'mid-target-arrow-shape', type: t.arrowShape },\n      { name: 'source-arrow-color', type: t.color },\n      { name: 'target-arrow-color', type: t.color },\n      { name: 'mid-source-arrow-color', type: t.color },\n      { name: 'mid-target-arrow-color', type: t.color },\n      { name: 'source-arrow-fill', type: t.arrowFill },\n      { name: 'target-arrow-fill', type: t.arrowFill },\n      { name: 'mid-source-arrow-fill', type: t.arrowFill },\n      { name: 'mid-target-arrow-fill', type: t.arrowFill },\n\n      // these are just for the core\n      { name: 'selection-box-color', type: t.color },\n      { name: 'selection-box-opacity', type: t.zeroOneNumber },\n      { name: 'selection-box-border-color', type: t.color },\n      { name: 'selection-box-border-width', type: t.size },\n      { name: 'active-bg-color', type: t.color },\n      { name: 'active-bg-opacity', type: t.zeroOneNumber },\n      { name: 'active-bg-size', type: t.size },\n      { name: 'outside-texture-bg-color', type: t.color },\n      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }\n    ];\n\n    // pie backgrounds for nodes\n    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n    props.push({ name: 'pie-size', type: t.bgSize });\n    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){\n      props.push({ name: 'pie-'+i+'-background-color', type: t.color });\n      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });\n      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });\n    }\n\n    // allow access of properties by name ( e.g. $$.style.properties.height )\n    for( var i = 0; i < props.length; i++ ){\n      var prop = props[i];\n      \n      props[ prop.name ] = prop; // allow lookup by name\n    }\n  })();\n\n  // adds the default stylesheet to the current style\n  $$.styfn.addDefaultStylesheet = function(){\n    // to be nice, we build font related style properties from the core container\n    // so that cytoscape matches the style of its container by default\n    // \n    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values\n    // instead of the developer's values so let's just make it explicit for the dev for now\n    //\n    // delaying the read of these val's is not an opt'n: that would delay init'l load time\n    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';\n    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';\n    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';\n    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';\n    var color = '#000' || this.containerPropertyAsString('color') || '#000';\n    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';\n    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;\n\n    // fill the style with the default stylesheet\n    this\n      .selector('node, edge') // common properties\n        .css({\n          'text-valign': 'top',\n          'text-halign': 'center',\n          'color': color,\n          'text-outline-color': '#000',\n          'text-outline-width': 0,\n          'text-outline-opacity': 1,\n          'text-opacity': 1,\n          'text-decoration': 'none',\n          'text-transform': textTransform,\n          'font-family': fontFamily,\n          'font-style': fontStyle,\n          // 'font-variant': fontVariant,\n          'font-weight': fontWeight,\n          'font-size': fontSize,\n          'min-zoomed-font-size': 0,\n          'visibility': 'visible',\n          'display': 'element',\n          'opacity': 1,\n          'z-index': 0,\n          'content': '',\n          'overlay-opacity': 0,\n          'overlay-color': '#000',\n          'overlay-padding': 10,\n          'transition-property': 'none',\n          'transition-duration': 0,\n          'transition-delay': 0,\n\n          // node props\n          'background-blacken': 0,\n          'background-color': '#888',\n          'background-opacity': 1,\n          'background-image': 'none',\n          'background-image-opacity': 1,\n          'background-position-x': '50%',\n          'background-position-y': '50%',\n          'background-repeat': 'no-repeat',\n          'background-fit': 'none',\n          'background-clip': 'node',\n          'border-color': '#000',\n          'border-opacity': 1,\n          'border-width': 0,\n          'border-style': 'solid',\n          'height': 30,\n          'width': 30,\n          'shape': 'ellipse',\n\n          // compound props\n          'padding-top': 0,\n          'padding-bottom': 0,\n          'padding-left': 0,\n          'padding-right': 0,\n          'position': 'origin',\n          \n\n          // node pie bg\n          'pie-size': '100%',\n          'pie-1-background-color': 'black',\n          'pie-2-background-color': 'black',\n          'pie-3-background-color': 'black',\n          'pie-4-background-color': 'black',\n          'pie-5-background-color': 'black',\n          'pie-6-background-color': 'black',\n          'pie-7-background-color': 'black',\n          'pie-8-background-color': 'black',\n          'pie-9-background-color': 'black',\n          'pie-10-background-color': 'black',\n          'pie-11-background-color': 'black',\n          'pie-12-background-color': 'black',\n          'pie-13-background-color': 'black',\n          'pie-14-background-color': 'black',\n          'pie-15-background-color': 'black',\n          'pie-16-background-color': 'black',\n          'pie-1-background-size': '0%',\n          'pie-2-background-size': '0%',\n          'pie-3-background-size': '0%',\n          'pie-4-background-size': '0%',\n          'pie-5-background-size': '0%',\n          'pie-6-background-size': '0%',\n          'pie-7-background-size': '0%',\n          'pie-8-background-size': '0%',\n          'pie-9-background-size': '0%',\n          'pie-10-background-size': '0%',\n          'pie-11-background-size': '0%',\n          'pie-12-background-size': '0%',\n          'pie-13-background-size': '0%',\n          'pie-14-background-size': '0%',\n          'pie-15-background-size': '0%',\n          'pie-16-background-size': '0%',\n          'pie-1-background-opacity': 1,\n          'pie-2-background-opacity': 1,\n          'pie-3-background-opacity': 1,\n          'pie-4-background-opacity': 1,\n          'pie-5-background-opacity': 1,\n          'pie-6-background-opacity': 1,\n          'pie-7-background-opacity': 1,\n          'pie-8-background-opacity': 1,\n          'pie-9-background-opacity': 1,\n          'pie-10-background-opacity': 1,\n          'pie-11-background-opacity': 1,\n          'pie-12-background-opacity': 1,\n          'pie-13-background-opacity': 1,\n          'pie-14-background-opacity': 1,\n          'pie-15-background-opacity': 1,\n          'pie-16-background-opacity': 1,\n\n          // edge props\n          'source-arrow-shape': 'none',\n          'mid-source-arrow-shape': 'none',\n          'target-arrow-shape': 'none',\n          'mid-target-arrow-shape': 'none',\n          'source-arrow-color': '#ddd',\n          'mid-source-arrow-color': '#ddd',\n          'target-arrow-color': '#ddd',\n          'mid-target-arrow-color': '#ddd',\n          'source-arrow-fill': 'filled',\n          'mid-source-arrow-fill': 'filled',\n          'target-arrow-fill': 'filled',\n          'mid-target-arrow-fill': 'filled',\n          'line-style': 'solid',\n          'line-color': '#ddd',\n          'control-point-step-size': 40,\n          'control-point-weight': 0.5,\n          'curve-style': 'bezier',\n          'haystack-radius': 0.8\n        })\n      .selector('$node > node') // compound (parent) node properties\n        .css({\n          'width': 'auto',\n          'height': 'auto',\n          'shape': 'rectangle',\n          'background-opacity': 0.5,\n          'padding-top': 10,\n          'padding-right': 10,\n          'padding-left': 10,\n          'padding-bottom': 10\n        })\n      .selector('edge') // just edge properties\n        .css({\n          'width': 1\n        })\n      .selector(':active')\n        .css({\n          'overlay-color': 'black',\n          'overlay-padding': 10,\n          'overlay-opacity': 0.25\n        })\n      .selector('core') // just core properties\n        .css({\n          'selection-box-color': '#ddd',\n          'selection-box-opacity': 0.65,\n          'selection-box-border-color': '#aaa',\n          'selection-box-border-width': 1,\n          'active-bg-color': 'black',\n          'active-bg-opacity': 0.15,\n          'active-bg-size': $$.is.touch() ? 40 : 15,\n          'outside-texture-bg-color': '#000',\n          'outside-texture-bg-opacity': 0.125\n        })\n    ;\n  };\n\n  // remove all contexts\n  $$.styfn.clear = function(){\n    for( var i = 0; i < this.length; i++ ){\n      this[i] = undefined;\n    }\n    this.length = 0;\n    this._private.newStyle = true;\n\n    return this; // chaining\n  };\n\n  $$.styfn.resetToDefault = function(){\n    this.clear();\n    this.addDefaultStylesheet();\n\n    return this;\n  };\n\n  // builds a style object for the 'core' selector\n  $$.styfn.core = function(){\n    return this._private.coreStyle;\n  };\n\n  // parse a property; return null on invalid; return parsed property otherwise\n  // fields :\n  // - name : the name of the property\n  // - value : the parsed, native-typed value of the property\n  // - strValue : a string value that represents the property value in valid css\n  // - bypass : true iff the property is a bypass property\n  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){\n    \n    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n    var property = $$.style.properties[ name ];\n    var passedValue = value;\n    \n    if( !property ){ return null; } // return null on property of unknown name\n    if( value === undefined || value === null ){ return null; } // can't assign null\n\n    var valueIsString = $$.is.string(value);\n    if( valueIsString ){ // trim the value to make parsing easier\n      value = $$.util.trim( value );\n    }\n\n    var type = property.type;\n    if( !type ){ return null; } // no type, no luck\n\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n    if( propIsBypass && (value === '' || value === null) ){\n      return {\n        name: name,\n        value: value,\n        bypass: true,\n        deleteBypass: true\n      };\n    }\n\n    // check if value is mapped\n    var data, mapData, layoutData, mapLayoutData;\n    if( !valueIsString || propIsFlat ){\n      // then don't bother to do the expensive regex checks\n\n    } else if(\n      ( data = new RegExp( $$.style.types.data.regex ).exec( value ) ) ||\n      ( layoutData = new RegExp( $$.style.types.layoutData.regex ).exec( value ) )\n    ){\n      if( propIsBypass ){ return false; } // mappers not allowed in bypass\n      \n      var isLayout = layoutData !== undefined;\n      data = data || layoutData;\n\n      return {\n        name: name,\n        value: data,\n        strValue: '' + value,\n        mapped: isLayout ? $$.style.types.layoutData : $$.style.types.data,\n        field: data[1],\n        bypass: propIsBypass,\n        hasPie: name.match(/pie-(\\d+)-background-size/)\n      };\n\n    } else if(\n      ( mapData = new RegExp( $$.style.types.mapData.regex ).exec( value ) ) ||\n      ( mapLayoutData = new RegExp( $$.style.types.mapLayoutData.regex ).exec( value ) )\n    ){\n      if( propIsBypass ){ return false; } // mappers not allowed in bypass\n\n      var isLayout = mapLayoutData !== undefined;\n      mapData = mapData || mapLayoutData;\n\n      // we can map only if the type is a colour or a number\n      if( !(type.color || type.number) ){ return false; }\n\n      var valueMin = this.parse( name, mapData[4]); // parse to validate\n      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped\n\n      var valueMax = this.parse( name, mapData[5]); // parse to validate\n      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped\n\n      // check if valueMin and valueMax are the same\n      if( valueMin.value === valueMax.value ){\n        return false; // can't make much of a mapper without a range\n      \n      } else if( type.color ){\n        var c1 = valueMin.value;\n        var c2 = valueMax.value;\n        \n        var same = c1[0] === c2[0] // red\n          && c1[1] === c2[1] // green\n          && c1[2] === c2[2] // blue\n          && ( // optional alpha\n            c1[3] === c2[3] // same alpha outright\n            || (\n              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?\n              &&\n              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n            )\n          )\n        ;\n\n        if( same ){ return false; } // can't make a mapper without a range\n      }\n\n      return {\n        name: name,\n        value: mapData,\n        strValue: '' + value,\n        mapped: isLayout ? $$.style.types.mapLayoutData : $$.style.types.mapData,\n        field: mapData[1],\n        fieldMin: parseFloat( mapData[2] ), // min & max are numeric\n        fieldMax: parseFloat( mapData[3] ),\n        valueMin: valueMin.value,\n        valueMax: valueMax.value,\n        bypass: propIsBypass,\n        hasPie: name.match(/pie-(\\d+)-background-size/)\n      };\n    }\n\n    // check the type and return the appropriate object\n    if( type.number ){ \n      var units;\n      var implicitUnits = 'px'; // not set => px\n\n      if( type.units ){ // use specified units if set\n        units = type.units;\n      }\n\n      if( type.implicitUnits ){\n        implicitUnits = type.implicitUnits;\n      }\n\n      if( !type.unitless ){\n        if( valueIsString ){\n          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n          if( units ){ unitsRegex = units; } // only allow explicit units if so set \n          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );\n          \n          if( match ){\n            value = match[1];\n            units = match[2] || implicitUnits;\n          }\n          \n        } else if( !units || type.implicitUnits ) {\n          units = implicitUnits; // implicitly px if unspecified\n        }\n      }\n\n      value = parseFloat( value );\n\n      // if not a number and enums not allowed, then the value is invalid\n      if( isNaN(value) && type.enums === undefined ){\n        return null;\n      }\n\n      // check if this number type also accepts special keywords in place of numbers\n      // (i.e. `left`, `auto`, etc)\n      if( isNaN(value) && type.enums !== undefined ){\n        value = passedValue;\n\n        for( var i = 0; i < type.enums.length; i++ ){\n          var en = type.enums[i];\n\n          if( en === value ){\n            return {\n              name: name,\n              value: value,\n              strValue: '' + value,\n              bypass: propIsBypass\n            };\n          }\n        }\n\n        return null; // failed on enum after failing on number\n      }\n\n      // check if value must be an integer\n      if( type.integer && !$$.is.integer(value) ){\n        return null;\n      }\n\n      // check value is within range\n      if( (type.min !== undefined && value < type.min) \n      || (type.max !== undefined && value > type.max)\n      ){\n        return null;\n      }\n\n      var ret = {\n        name: name,\n        value: value,\n        strValue: '' + value + (units ? units : ''),\n        units: units,\n        bypass: propIsBypass,\n        hasPie: name.match(/pie-(\\d+)-background-size/) && value != null && value !== 0 && value !== ''\n      };\n\n      // normalise value in pixels\n      if( type.unitless || (units !== 'px' && units !== 'em') ){\n        // then pxValue does not apply\n      } else {\n        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );\n      }\n\n      // normalise value in ms\n      if( units === 'ms' || units === 's' ){\n        ret.msValue = units === 'ms' ? value : 1000 * value;\n      }\n\n      return ret;\n\n    } else if( type.propList ) {\n\n      var props = [];\n      var propsStr = '' + value;      \n \n      if( propsStr === 'none' ){\n        // leave empty\n\n      } else { // go over each prop\n\n        var propsSplit = propsStr.split(',');\n        for( var i = 0; i < propsSplit.length; i++ ){\n          var propName = $$.util.trim( propsSplit[i] );\n\n          if( $$.style.properties[propName] ){\n            props.push( propName );\n          }\n        }\n\n        if( props.length === 0 ){ return null; }\n\n      }\n\n      return {\n        name: name,\n        value: props,\n        strValue: props.length === 0 ? 'none' : props.join(', '),\n        bypass: propIsBypass\n      };\n\n    } else if( type.color ){\n      var tuple = $$.util.color2tuple( value );\n\n      if( !tuple ){ return null; }\n\n      return {\n        name: name,\n        value: tuple,\n        strValue: '' + value,\n        bypass: propIsBypass\n      };\n\n    } else if( type.enums ){\n      for( var i = 0; i < type.enums.length; i++ ){\n        var en = type.enums[i];\n\n        if( en === value ){\n          return {\n            name: name,\n            value: value,\n            strValue: '' + value,\n            bypass: propIsBypass\n          };\n        }\n      }\n\n      return null;\n\n    } else if( type.regex ){\n      var regex = new RegExp( type.regex ); // make a regex from the type\n      var m = regex.exec( value );\n\n      if( m ){ // regex matches\n        return {\n          name: name,\n          value: m,\n          strValue: '' + value,\n          bypass: propIsBypass\n        };\n      } else { // regex doesn't match\n        return null; // didn't match the regex so the value is bogus\n      }\n\n    } else if( type.string ){\n      // just return\n      return {\n        name: name,\n        value: value,\n        strValue: '' + value,\n        bypass: propIsBypass\n      };\n\n    } else {\n      return null; // not a type we can handle\n    }\n\n  };\n\n  // create a new context from the specified selector string and switch to that context\n  $$.styfn.selector = function( selectorStr ){\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );\n\n    var i = this.length++; // new context means new index\n    this[i] = {\n      selector: selector,\n      properties: [],\n      mappedProperties: [],\n      index: i\n    };\n\n    return this; // chaining\n  };\n\n  // add one or many css rules to the current context\n  $$.styfn.css = function(){\n    var args = arguments;\n\n    switch( args.length ){\n    case 1:\n      var map = args[0];\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var mapVal = map[ prop.name ];\n\n        if( mapVal === undefined ){\n          mapVal = map[ $$.util.dash2camel(prop.name) ];\n        }\n\n        if( mapVal !== undefined ){\n          this.cssRule( prop.name, mapVal );\n        }\n      }\n\n      break;\n\n    case 2:\n      this.cssRule( args[0], args[1] );\n      break;\n\n    default:\n      break; // do nothing if args are invalid\n    }\n\n    return this; // chaining\n  };\n\n  // add a single css rule to the current context\n  $$.styfn.cssRule = function( name, value ){ \n    // name-value pair\n    var property = this.parse( name, value );\n\n    // add property to current context if valid\n    if( property ){\n      var i = this.length - 1;\n      this[i].properties.push( property );\n      this[i].properties[ property.name ] = property; // allow access by name as well\n\n      if( property.hasPie ){\n        this._private.hasPie = true;\n      }\n\n      if( property.mapped ){\n        this[i].mappedProperties.push( property );\n      }\n\n      // add to core style if necessary\n      var currentSelectorIsCore = !this[i].selector;\n      if( currentSelectorIsCore ){\n        this._private.coreStyle[ property.name ] = property;\n      }\n    }\n\n    return this; // chaining\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  // (potentially expensive calculation)\n  // apply the style to the element based on\n  // - its bypass\n  // - what selectors match it\n  $$.styfn.apply = function( eles ){\n    var self = this;\n\n    if( self._private.newStyle ){ // clear style caches\n      this._private.contextStyles = {};\n      this._private.propDiffs = {};\n    }\n\n    for( var ie = 0; ie < eles.length; ie++ ){\n      var ele = eles[ie];\n      var cxtMeta = self.getContextMeta( ele );\n      var cxtStyle = self.getContextStyle( cxtMeta );\n      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );\n\n      self.updateTransitions( ele, app.diffProps );\n      self.updateStyleHints( ele );\n\n    } // for elements\n\n    self._private.newStyle = false;\n  };\n\n  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){\n    var self = this;\n    var cache = self._private.propDiffs = self._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n\n    if( cachedVal ){\n      return cachedVal;\n    }\n\n    var diffProps = [];\n    var addedProp = {};\n\n    for( var i = 0; i < self.length; i++ ){\n      var cxt = self[i];\n      var oldHasCxt = oldCxtKey[i] === 't';\n      var newHasCxt = newCxtKey[i] === 't';\n      var cxtHasDiffed = oldHasCxt !== newHasCxt;\n      var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n      if( cxtHasDiffed || cxtHasMappedProps ){\n        var props;\n\n        if( cxtHasDiffed && cxtHasMappedProps ){\n          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n        } else if( cxtHasDiffed ){\n          props = cxt.properties; // need to check them all\n        } else if( cxtHasMappedProps ){\n          props = cxt.mappedProperties; // only need to check mapped\n        }\n\n        for( var j = 0; j < props.length; j++ ){\n          var prop = props[j];\n          var name = prop.name;\n\n          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n          // is cached)\n          var laterCxtOverrides = false; \n          for( var k = i + 1; k < self.length; k++ ){\n            var laterCxt = self[k];\n            var hasLaterCxt = newCxtKey[k] === 't';\n\n            if( !hasLaterCxt ){ continue; } // can't override unless the context is active\n\n            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;\n\n            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides\n          }\n\n          if( !addedProp[name] && !laterCxtOverrides ){\n            addedProp[name] = true;\n            diffProps.push( name );\n          }\n        } // for props\n      } // if\n\n    } // for contexts\n\n    cache[ dualCxtKey ] = diffProps;\n    return diffProps;\n  };\n\n  $$.styfn.getContextMeta = function( ele ){\n    var self = this;\n    var cxtKey = '';\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || '';\n\n    if( self._private.newStyle ){\n      prevKey = ''; // since we need to apply all style if a fresh stylesheet\n    }\n\n    // get the cxt key\n    for( var i = 0; i < self.length; i++ ){\n      var context = self[i];\n      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'\n\n      if( contextSelectorMatches ){\n        cxtKey += 't';\n      } else {\n        cxtKey += 'f';\n      }\n    } // for context\n\n    diffProps = self.getPropertiesDiff( prevKey, cxtKey );\n\n    ele._private.styleCxtKey = cxtKey;\n\n    return {\n      key: cxtKey,\n      diffPropNames: diffProps\n    };\n  };\n\n  // gets a computed ele style object based on matched contexts\n  $$.styfn.getContextStyle = function( cxtMeta ){\n    var cxtKey = cxtMeta.key;\n    var self = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n\n    // if already computed style, returned cached copy\n    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }\n\n    var style = {\n      _private: {\n        key: cxtKey\n      }\n    };\n\n    for( var i = 0; i < self.length; i++ ){\n      var cxt = self[i];\n      var hasCxt = cxtKey[i] === 't';\n\n      if( !hasCxt ){ continue; }\n\n      for( var j = 0; j < cxt.properties.length; j++ ){\n        var prop = cxt.properties[j];\n        var styProp = style[ prop.name ] = prop;\n\n        styProp.context = cxt;\n      }\n    }\n\n    cxtStyles[cxtKey] = style;\n    return style;\n  };\n\n  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){\n    var self = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n\n    for( var i = 0; i < diffProps.length; i++ ){\n      var diffPropName = diffProps[i];\n      var cxtProp = cxtStyle[ diffPropName ];\n      var eleProp = ele._private.style[ diffPropName ];\n\n      // save cycles when the context prop doesn't need to be applied\n      if( !cxtProp || eleProp === cxtProp ){ continue; }\n\n      var retDiffProp = retDiffProps[ diffPropName ] = {\n        prev: eleProp\n      };\n\n      self.applyParsedProperty( ele, cxtProp );\n\n      retDiffProp.next = ele._private.style[ diffPropName ];\n\n      if( retDiffProp.next.bypass ){\n        retDiffProp.next = retDiffProp.next.bypassed;\n      }\n    }\n\n    return {\n      diffProps: retDiffProps\n    };\n  };\n\n  $$.styfn.updateStyleHints = function(ele){\n    var _p = ele._private;\n    var self = this;\n    var style = _p.style;\n\n    // set whether has pie or not; for greater efficiency\n    var hasPie = false;\n    if( _p.group === 'nodes' && self._private.hasPie ){\n      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N\n        var size = _p.style['pie-' + i + '-background-size'].value;\n\n        if( size > 0 ){\n          hasPie = true;\n          break;\n        }\n      }\n    }\n\n    _p.hasPie = hasPie;\n\n    var transform = style['text-transform'].strValue;\n    var content = style['content'].strValue;\n    var fStyle = style['font-style'].strValue;\n    var size = style['font-size'].pxValue + 'px';\n    var family = style['font-family'].strValue;\n    // var variant = style['font-variant'].strValue;\n    var weight = style['font-weight'].strValue;\n    var valign = style['text-valign'].strValue;\n    var halign = style['text-valign'].strValue;\n    var oWidth = style['text-outline-width'].pxValue;\n    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth;\n    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;\n\n    var width = style['width'].pxValue;\n    var height = style['height'].pxValue;\n    var borderW = style['border-width'].pxValue;\n    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;\n\n    if( ele._private.group === 'edges' ){\n      var cpss = style['control-point-step-size'].pxValue;\n      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;\n      var cpw = style['control-point-weight'].value;\n      var curve = style['curve-style'].strValue;\n      \n      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;\n    }\n\n    _p.styleKey = Date.now(); // probably safe to use applied time and much faster\n    // for( var i = 0; i < $$.style.properties.length; i++ ){\n    //   var prop = $$.style.properties[i];\n    //   var eleProp = _p.style[ prop.name ];\n    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';\n\n    //   _p.styleKey += '$' + val;\n    // }\n  };\n\n  // apply a property to the style (for internal use)\n  // returns whether application was successful\n  //\n  // now, this function flattens the property, and here's how:\n  //\n  // for parsedProp:{ bypass: true, deleteBypass: true }\n  // no property is generated, instead the bypass property in the\n  // element's style is replaced by what's pointed to by the `bypassed`\n  // field in the bypass property (i.e. restoring the property the\n  // bypass was overriding)\n  //\n  // for parsedProp:{ mapped: truthy }\n  // the generated flattenedProp:{ mapping: prop }\n  // \n  // for parsedProp:{ bypass: true }\n  // the generated flattenedProp:{ bypassed: parsedProp } \n  $$.styfn.applyParsedProperty = function( ele, parsedProp ){\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var fieldVal, flatProp;\n    var type = $$.style.properties[ prop.name ].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[ prop.name ];\n    var origPropIsBypass = origProp && origProp.bypass;\n\n    // can't apply auto to width or height unless it's a parent node\n    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && parsedProp.value === 'auto' && ele.isNode() && !ele.isParent() ){\n      return false;\n    }\n\n    // check if we need to delete the current bypass\n    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete\n      var currentProp = style[ prop.name ];\n\n      // can only delete if the current prop is a bypass and it points to the property it was overriding\n      if( !currentProp ){\n        return true; // property is already not defined\n      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original\n        \n        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n        style[ prop.name ] = currentProp.bypassed;\n        return true;\n      \n      } else {\n        return false; // we're unsuccessful deleting the bypass\n      }\n    }\n\n    var printMappingErr = function(){\n      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');\n    };\n\n    // put the property in the style objects\n    switch( prop.mapped ){ // flatten the property if mapped\n    case $$.style.types.mapData:\n    case $$.style.types.mapLayoutData:\n      \n      var isLayout = prop.mapped === $$.style.types.mapLayoutData;\n\n      // flatten the field (e.g. data.foo.bar)\n      var fields = prop.field.split(\".\");\n      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;\n      for( var i = 0; i < fields.length && fieldVal; i++ ){\n        var field = fields[i];\n        fieldVal = fieldVal[ field ];\n      }\n\n      var percent;\n      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now\n        percent = 0;\n      } else {\n        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);\n      }\n\n      // make sure to bound percent value\n      if( percent < 0 ){\n        percent = 0;\n      } else if( percent > 1 ){\n        percent = 1;\n      }\n\n      if( type.color ){\n        var r1 = prop.valueMin[0];\n        var r2 = prop.valueMax[0];\n        var g1 = prop.valueMin[1];\n        var g2 = prop.valueMax[1];\n        var b1 = prop.valueMin[2];\n        var b2 = prop.valueMax[2];\n        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n\n        var clr = [\n          Math.round( r1 + (r2 - r1)*percent ),\n          Math.round( g1 + (g2 - g1)*percent ),\n          Math.round( b1 + (b2 - b1)*percent ),\n          Math.round( a1 + (a2 - a1)*percent )\n        ];\n\n        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing\n          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass\n          name: prop.name,\n          value: clr,\n          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n        };\n      \n      } else if( type.number ){\n        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );\n      \n      } else {\n        return false; // can only map to colours and numbers\n      }\n\n      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );\n      } \n\n      if( !flatProp ){ printMappingErr(); }\n      flatProp.mapping = prop; // keep a reference to the mapping\n      prop = flatProp; // the flattened (mapped) property is the one we want\n\n      break;\n\n    // direct mapping  \n    case $$.style.types.data: \n    case $$.style.types.layoutData: \n\n      var isLayout = prop.mapped === $$.style.types.layoutData;\n\n      // flatten the field (e.g. data.foo.bar)\n      var fields = prop.field.split(\".\");\n      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;\n      for( var i = 0; i < fields.length && fieldVal; i++ ){\n        var field = fields[i];\n        fieldVal = fieldVal[ field ];\n      }\n\n      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );\n\n      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself\n        var flatPropVal = origProp ? origProp.strValue : '';\n\n        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );\n      }\n\n      if( !flatProp ){ printMappingErr(); }\n      flatProp.mapping = prop; // keep a reference to the mapping\n      prop = flatProp; // the flattened (mapped) property is the one we want\n      break;\n\n    case undefined:\n      break; // just set the property\n\n    default: \n      return false; // not a valid mapping\n    }\n\n    // if the property is a bypass property, then link the resultant property to the original one\n    if( propIsBypass ){\n      if( origPropIsBypass ){ // then this bypass overrides the existing one\n        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n      } else { // then link the orig prop to the new bypass\n        prop.bypassed = origProp;\n      }\n\n      style[ prop.name ] = prop; // and set\n    \n    } else { // prop is not bypass\n      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop\n        origProp.bypassed = prop;\n      } else { // then just replace the old prop with the new one\n        style[ prop.name ] = prop; \n      }\n    }\n\n    return true;\n  };\n\n  // updates the visual style for all elements (useful for manual style modification after init)\n  $$.styfn.update = function(){\n    var cy = this._private.cy;\n    var eles = cy.elements();\n\n    eles.updateStyle();\n  };\n\n  // just update the functional properties (i.e. mappings) in the elements'\n  // styles (less expensive than recalculation)\n  $$.styfn.updateMappers = function( eles ){\n    for( var i = 0; i < eles.length; i++ ){ // for each ele\n      var ele = eles[i];\n      var style = ele._private.style;\n\n      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop\n        var prop = $$.style.properties[j];\n        var propInStyle = style[ prop.name ];\n\n        if( propInStyle && propInStyle.mapping ){\n          var mapping = propInStyle.mapping;\n          this.applyParsedProperty( ele, mapping ); // reapply the mapping property\n        }\n      }\n\n      this.updateStyleHints( ele );\n    }\n  };\n\n  // diffProps : { name => { prev, next } }\n  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){\n    var self = this;\n    var style = ele._private.style;\n\n    var props = style['transition-property'].value;\n    var duration = style['transition-duration'].msValue;\n    var delay = style['transition-delay'].msValue;\n    var css = {};\n\n    if( props.length > 0 && duration > 0 ){\n\n      // build up the style to animate towards\n      var anyPrev = false;\n      for( var i = 0; i < props.length; i++ ){\n        var prop = props[i];\n        var styProp = style[ prop ];\n        var diffProp = diffProps[ prop ];\n\n        if( !diffProp ){ continue; }\n\n        var prevProp = diffProp.prev;\n        var fromProp = prevProp;\n        var toProp = diffProp.next != null ? diffProp.next : styProp;\n        var diff = false;\n\n        if( !fromProp ){ continue; } \n\n        // consider px values\n        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){\n          diff = fromProp.pxValue !== toProp.pxValue;\n\n        // consider numerical values\n        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){\n          diff = fromProp.value !== toProp.value;\n\n        // consider colour values\n        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){\n          diff = fromProp.value[0] !== toProp.value[0]\n            || fromProp.value[1] !== toProp.value[1]\n            || fromProp.value[2] !== toProp.value[2]\n          ;\n        }\n\n        // the previous value is good for an animation only if it's different\n        if( diff ){\n          css[ prop ] = toProp.strValue; // to val\n          this.applyBypass(ele, prop, fromProp.strValue); // from val\n          anyPrev = true;\n        }\n        \n      } // end if props allow ani\n\n      // can't transition if there's nothing previous to transition from\n      if( !anyPrev ){ return; }\n      \n      ele._private.transitioning = true;\n\n      ele.stop();\n\n      if( delay > 0 ){\n        ele.delay( delay );\n      }\n\n      ele.animate({\n        css: css\n      }, {\n        duration: duration,\n        queue: false,\n        complete: function(){ \n          if( !isBypass ){\n            self.removeBypasses( ele, props );\n          }\n\n          ele._private.transitioning = false;\n        }\n      });\n\n    } else if( ele._private.transitioning ){\n      ele.stop();\n\n      this.removeBypasses( ele, props );\n\n      ele._private.transitioning = false;\n    }\n  }; \n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  // bypasses are applied to an existing style on an element, and just tacked on temporarily\n  // returns true iff application was successful for at least 1 specified property\n  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){\n    var props = [];\n    var isBypass = true;\n    \n    // put all the properties (can specify one or many) in an array after parsing them\n    if( name === \"*\" || name === \"**\" ){ // apply to all property names\n\n      if( value !== undefined ){\n        for( var i = 0; i < $$.style.properties.length; i++ ){\n          var prop = $$.style.properties[i];\n          var name = prop.name;\n\n          var parsedProp = this.parse(name, value, true);\n          \n          if( parsedProp ){\n            props.push( parsedProp );\n          }\n        }\n      }\n\n    } else if( $$.is.string(name) ){ // then parse the single property\n      var parsedProp = this.parse(name, value, true);\n\n      if( parsedProp ){\n        props.push( parsedProp );\n      }\n    } else if( $$.is.plainObject(name) ){ // then parse each property\n      var specifiedProps = name;\n      updateTransitions = value;\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var name = prop.name;\n        var value = specifiedProps[ name ];\n\n        if( value === undefined ){ // try camel case name too\n          value = specifiedProps[ $$.util.dash2camel(name) ];\n        }\n\n        if( value !== undefined ){\n          var parsedProp = this.parse(name, value, true);\n          \n          if( parsedProp ){\n            props.push( parsedProp );\n          }\n        }\n      }\n    } else { // can't do anything without well defined properties\n      return false;\n    }\n\n    // we've failed if there are no valid properties\n    if( props.length === 0 ){ return false; }\n\n    // now, apply the bypass properties on the elements\n    var ret = false; // return true if at least one succesful bypass applied\n    for( var i = 0; i < eles.length; i++ ){ // for each ele\n      var ele = eles[i];\n      var style = ele._private.style;\n      var diffProps = {};\n      var diffProp;\n\n      for( var j = 0; j < props.length; j++ ){ // for each prop\n        var prop = props[j];\n\n        if( updateTransitions ){\n          var prevProp = style[ prop.name ];\n          diffProp = diffProps[ prop.name ] = { prev: prevProp };\n        }\n\n        ret = this.applyParsedProperty( ele, prop ) || ret;\n\n        if( updateTransitions ){\n          diffProp.next = style[ prop.name ];\n        }\n\n      } // for props\n\n      if( updateTransitions ){\n        this.updateTransitions( ele, diffProps, isBypass );\n      }\n    } // for eles\n\n    return ret;\n  };\n\n  // only useful in specific cases like animation\n  $$.styfn.overrideBypass = function( eles, name, value ){\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[i];\n      var prop = ele._private.style[ $$.util.camel2dash(name) ];\n\n      if( !prop.bypass ){ // need a bypass if one doesn't exist\n        this.applyBypass( ele, name, value );\n        continue;\n      }\n\n      prop.value = value;\n      prop.pxValue = value;\n    }\n  };\n\n  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){\n    var isBypass = true;\n\n    for( var j = 0; j < eles.length; j++ ){\n      var ele = eles[j];\n      var diffProps = {};\n      var style = ele._private.style;\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var name = prop.name;\n        var value = ''; // empty => remove bypass\n        var parsedProp = this.parse(name, value, true);\n        var prevProp = style[ prop.name ];\n        var diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\n        this.applyParsedProperty(ele, parsedProp);\n\n        diffProp.next = style[ prop.name ];\n      } // for props\n\n      if( updateTransitions ){\n        this.updateTransitions( ele, diffProps, isBypass );\n      }\n    } // for eles\n  };\n\n  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){\n    var isBypass = true;\n\n    for( var j = 0; j < eles.length; j++ ){\n      var ele = eles[j];\n      var diffProps = {};\n      var style = ele._private.style;\n\n      for( var i = 0; i < props.length; i++ ){\n        var name = props[i];\n        var prop = $$.style.properties[ name ];\n        var value = ''; // empty => remove bypass\n        var parsedProp = this.parse(name, value, true);\n        var prevProp = style[ prop.name ];\n        var diffProp = diffProps[ prop.name ] = { prev: prevProp };\n\n        this.applyParsedProperty(ele, parsedProp);\n\n        diffProp.next = style[ prop.name ];\n      } // for props\n\n      if( updateTransitions ){\n        this.updateTransitions( ele, diffProps, isBypass );\n      }\n    } // for eles\n  };\n\n})( cytoscape );\n;(function($$, window){ 'use strict';\n\n  // gets what an em size corresponds to in pixels relative to a dom element\n  $$.styfn.getEmSizeInPixels = function(){\n    var cy = this._private.cy;\n    var domElement = cy.container();\n\n    if( window && domElement && window.getComputedStyle ){\n      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');\n      var px = parseFloat( pxAsStr );\n      return px;\n    } else {\n      return 1; // in case we're running outside of the browser\n    }\n  };\n\n  // gets css property from the core container\n  $$.styfn.containerCss = function( propName ){\n    var cy = this._private.cy;\n    var domElement = cy.container();\n\n    if( window && domElement && window.getComputedStyle ){\n      return window.getComputedStyle(domElement).getPropertyValue( propName );\n    }\n  };\n\n  $$.styfn.containerProperty = function( propName ){\n    var propStr = this.containerCss( propName );\n    var prop = this.parse( propName, propStr );\n    return prop;\n  };\n\n  $$.styfn.containerPropertyAsString = function( propName ){\n    var prop = this.containerProperty( propName );\n\n    if( prop ){\n      return prop.strValue;\n    }\n  };\n\n})( cytoscape, typeof window === 'undefined' ? null : window );\n;(function($$){ 'use strict';\n\n  // gets the rendered style for an element\n  $$.styfn.getRenderedStyle = function( ele ){\n    var ele = ele[0]; // insure it's an element\n\n    if( ele ){\n      var rstyle = {};\n      var style = ele._private.style;\n      var cy = this._private.cy;\n      var zoom = cy.zoom();\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var styleProp = style[ prop.name ];\n\n        if( styleProp ){\n          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';\n          rstyle[ prop.name ] = val;\n          rstyle[ $$.util.dash2camel(prop.name) ] = val;\n        }\n      }\n\n      return rstyle;\n    }\n  };\n\n  // gets the raw style for an element\n  $$.styfn.getRawStyle = function( ele ){\n    var ele = ele[0]; // insure it's an element\n\n    if( ele ){\n      var rstyle = {};\n      var style = ele._private.style;\n\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var styleProp = style[ prop.name ];\n\n        if( styleProp ){\n          rstyle[ prop.name ] = styleProp.strValue;\n          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;\n        }\n      }\n\n      return rstyle;\n    }\n  };\n\n  // gets the value style for an element (useful for things like animations)\n  $$.styfn.getValueStyle = function( ele, opts ){\n    opts = opts || {};\n\n    var rstyle = opts.array ? [] : {}; \n    var style;\n\n    if( $$.is.element(ele) ){\n      style = ele._private.style;    \n    } else {\n      style = ele; // just passed the style itself\n    }\n\n    if( style ){\n      for( var i = 0; i < $$.style.properties.length; i++ ){\n        var prop = $$.style.properties[i];\n        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];\n\n        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it\n          styleProp = this.parse(prop.name, styleProp);\n        }\n\n        if( styleProp ){\n          if( opts.array ){\n            rstyle.push( styleProp );\n          } else {\n            rstyle[ prop.name ] = styleProp;\n            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;\n          }\n        }\n      }\n    }\n\n    return rstyle;\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  $$.style.applyFromJson = function( style, json ){\n    for( var i = 0; i < json.length; i++ ){\n      var context = json[i];\n      var selector = context.selector;\n      var props = context.css;\n\n      style.selector(selector); // apply selector\n\n      for( var name in props ){\n        var value = props[name];\n\n        style.css( name, value ); // apply property\n      }\n    }\n\n    return style;\n  };\n\n  // static function\n  $$.style.fromJson = function( cy, json ){\n    var style = new $$.Style(cy);\n\n    $$.style.applyFromJson( style, json );\n\n    return style;\n  };\n\n  // accessible cy.style() function\n  $$.styfn.fromJson = function( json ){\n    var style = this;\n\n    style.resetToDefault();\n\n    $$.style.applyFromJson( style, json );\n\n    return style;\n  };\n\n  // get json from cy.style() api\n  $$.styfn.json = function(){\n    var json = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var cxt = this[i];\n      var selector = cxt.selector;\n      var props = cxt.properties;\n      var css = {};\n\n      for( var j = 0; j < props.length; j++ ){\n        var prop = props[j];\n        css[ prop.name ] = prop.strValue;\n      }\n\n      json.push({\n        selector: !selector ? 'core' : selector.toString(),\n        css: css\n      });\n    }\n\n    return json;\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  $$.style.applyFromString = function( style, string ){\n    var remaining = '' + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr;\n\n    // remove comments from the style string\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n    function removeSelAndBlockFromRemaining(){\n      // remove the parsed selector and block from the remaining text to parse\n      if( remaining.length > selAndBlockStr.length ){\n        remaining = remaining.substr( selAndBlockStr.length );\n      } else {\n        remaining = '';\n      }\n    }\n\n    function removePropAndValFromRem(){\n      // remove the parsed property and value from the remaining block text to parse\n      if( blockRem.length > propAndValStr.length ){\n        blockRem = blockRem.substr( propAndValStr.length );\n      } else {\n        blockRem = '';\n      }\n    }\n\n    while(true){\n      var nothingLeftToParse = remaining.match(/^\\s*$/);\n      if( nothingLeftToParse ){ break; }\n\n      var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n      if( !selAndBlock ){\n        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n        break;\n      }\n\n      selAndBlockStr = selAndBlock[0];\n\n      // parse the selector\n      var selectorStr = selAndBlock[1];\n      var selector = new $$.Selector( selectorStr );\n      if( selector._private.invalid && selectorStr !== 'core' ){\n        $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n\n        // skip this selector and block\n        removeSelAndBlockFromRemaining();\n        continue; \n      }\n\n      // parse the block of properties and values\n      var blockStr = selAndBlock[2];\n      var invalidBlock = false;\n      blockRem = blockStr;\n      var props = [];\n\n      while(true){\n        var nothingLeftToParse = blockRem.match(/^\\s*$/);\n        if( nothingLeftToParse ){ break; }\n\n        var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);\n\n        if( !propAndVal ){\n          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n          invalidBlock = true;\n          break;\n        }\n\n        propAndValStr = propAndVal[0];\n        var propStr = propAndVal[1];\n        var valStr = propAndVal[2];\n\n        var prop = $$.style.properties[ propStr ];\n        if( !prop ){\n          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);\n\n          // skip this property in the block\n          removePropAndValFromRem();\n          continue;\n        }\n\n        var parsedProp = style.parse( propStr, valStr );\n\n        if( !parsedProp ){\n          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);\n\n          // skip this property in the block\n          removePropAndValFromRem();\n          continue;\n        }\n\n        props.push({\n          name: propStr,\n          val: valStr\n        });\n        removePropAndValFromRem();\n      }\n\n      if( invalidBlock ){\n        removeSelAndBlockFromRemaining();\n        break;\n      }\n\n      // put the parsed block in the style\n      style.selector( selectorStr );\n      for( var i = 0; i < props.length; i++ ){\n        var prop = props[i];\n        style.css( prop.name, prop.val );\n      }\n\n      removeSelAndBlockFromRemaining();\n    }\n\n    return style;\n  };\n\n  $$.style.fromString = function( cy, string ){\n    var style = new $$.Style(cy);\n    \n    $$.style.applyFromString( style, string );\n\n    return style;\n  };\n\n  $$.styfn.fromString = function( string ){\n    var style = this;\n\n    style.resetToDefault();\n\n    $$.style.applyFromString( style, string );\n\n    return style;\n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // a dummy stylesheet object that doesn't need a reference to the core\n  // (useful for init)\n  $$.stylesheet = $$.Stylesheet = function(){\n    if( !(this instanceof $$.Stylesheet) ){\n      return new $$.Stylesheet();\n    }\n\n    this.length = 0;\n  };\n\n  // just store the selector to be parsed later\n  $$.Stylesheet.prototype.selector = function( selector ){\n    var i = this.length++;\n\n    this[i] = {\n      selector: selector,\n      properties: []\n    };\n\n    return this; // chaining\n  };\n\n  // just store the property to be parsed later\n  $$.Stylesheet.prototype.css = function( name, value ){\n    var i = this.length - 1;\n\n    if( $$.is.string(name) ){\n      this[i].properties.push({\n        name: name,\n        value: value\n      });\n    } else if( $$.is.plainObject(name) ){\n      var map = name;\n\n      for( var j = 0; j < $$.style.properties.length; j++ ){\n        var prop = $$.style.properties[j];\n        var mapVal = map[ prop.name ];\n\n        if( mapVal === undefined ){ // also try camel case name\n          mapVal = map[ $$.util.dash2camel(prop.name) ];\n        }\n\n        if( mapVal !== undefined ){\n          var name = prop.name;\n          var value = mapVal;\n\n          this[i].properties.push({\n            name: name,\n            value: value\n          });\n        }\n      }\n    }\n\n    return this; // chaining\n  };\n\n  // generate a real style object from the dummy stylesheet\n  $$.Stylesheet.prototype.generateStyle = function( cy ){\n    var style = new $$.Style(cy);\n\n    for( var i = 0; i < this.length; i++ ){\n      var context = this[i];\n      var selector = context.selector;\n      var props = context.properties;\n\n      style.selector(selector); // apply selector\n\n      for( var j = 0; j < props.length; j++ ){\n        var prop = props[j];\n\n        style.css( prop.name, prop.value ); // apply property\n      }\n    }\n\n    return style;\n  };\n\n})( cytoscape );\n;(function($$, window){ 'use strict';\n\n  var isTouch = $$.is.touch();\n\n  var defaults = {\n  };\n  \n  var origDefaults = $$.util.copy( defaults );\n\n  $$.defaults = function( opts ){\n    defaults = $$.util.extend({}, origDefaults, opts);\n  };\n\n  $$.fn.core = function( fnMap, options ){\n    for( var name in fnMap ){\n      var fn = fnMap[name];\n      $$.Core.prototype[ name ] = fn;\n    }\n  };\n  \n  $$.Core = function( opts ){\n    if( !(this instanceof $$.Core) ){\n      return new $$.Core(opts);\n    }\n    var cy = this;\n\n    opts = $$.util.extend({}, defaults, opts);\n\n    var container = opts.container;\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n    reg = reg || {};\n\n    if( reg && reg.cy ){ \n      if( container ){\n        while( container.firstChild ){ // clean the container\n          container.removeChild( container.firstChild );\n        }\n      }\n      \n      reg.cy.notify({ type: 'destroy' }); // destroy the renderer\n\n      reg = {}; // old instance => replace reg completely\n    }\n\n    var readies = reg.readies = reg.readies || [];\n    \n    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy\n    reg.cy = cy;\n\n    var head = window !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );\n    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );\n    \n    var defVal = function( def, val, altVal ){\n      if( val !== undefined ){\n        return val;\n      } else if( altVal !== undefined ){\n        return altVal;\n      } else {\n        return def;\n      }\n    };\n\n    var _p = this._private = {\n      container: options.container, // html dom ele container\n      ready: false, // whether ready has been triggered\n      initrender: false, // has initrender has been triggered\n      options: options, // cached options\n      elements: [], // array of elements\n      id2index: {}, // element id => index in elements array\n      listeners: [], // list of listeners\n      aniEles: $$.Collection(this), // elements being animated\n      scratch: {}, // scratch object for core\n      layout: null,\n      renderer: null,\n      notificationsEnabled: true, // whether notifications are sent to the renderer\n      minZoom: 1e-50,\n      maxZoom: 1e50,\n      zoomingEnabled: defVal(true, options.zoomingEnabled),\n      userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n      panningEnabled: defVal(true, options.panningEnabled),\n      userPanningEnabled: defVal(true, options.userPanningEnabled),\n      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),\n      autolock: defVal(false, options.autolock, options.autolockNodes),\n      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n      autounselectify: defVal(false, options.autounselectify),\n      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n      zoom: $$.is.number(options.zoom) ? options.zoom : 1,\n      pan: {\n        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,\n        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0\n      },\n      animation: { // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      hasCompoundNodes: false,\n      deferredExecQueue: []\n    };\n\n    // set selection type\n    var selType = options.selectionType;\n    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){\n      // then set default\n\n      if( isTouch ){\n        _p.selectionType = 'additive';\n      } else {\n        _p.selectionType = 'single';\n      }\n    } else {\n      _p.selectionType = selType;\n    }\n\n    // init zoom bounds\n    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){\n      _p.minZoom = options.minZoom;\n      _p.maxZoom = options.maxZoom;\n    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){\n      _p.minZoom = options.minZoom;\n    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){\n      _p.maxZoom = options.maxZoom;\n    }\n\n    // init style\n    if( _p.styleEnabled ){\n      this.setStyle( options.style );\n    }\n\n    // create the renderer\n    cy.initRenderer( $$.util.extend({\n      hideEdgesOnViewport: options.hideEdgesOnViewport,\n      hideLabelsOnViewport: options.hideLabelsOnViewport,\n      textureOnViewport: options.textureOnViewport,\n      wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,\n      motionBlur: options.motionBlur,\n      pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),\n      tapThreshold: defVal( $$.is.touch() ? 8 : 4, $$.is.touch() ? options.touchTapThreshold : options.desktopTapThreshold )\n    }, options.renderer) );\n\n    // trigger the passed function for the `initrender` event\n    if( options.initrender ){\n      cy.on('initrender', options.initrender);\n      cy.on('initrender', function(){\n        cy._private.initrender = true;\n      });\n    }\n\n    // initial load\n    cy.load(options.elements, function(){ // onready\n      cy.startAnimationLoop();\n      cy._private.ready = true;\n\n      // if a ready callback is specified as an option, the bind it\n      if( $$.is.fn( options.ready ) ){\n        cy.on('ready', options.ready);\n      }\n\n      // bind all the ready handlers registered before creating this instance\n      for( var i = 0; i < readies.length; i++ ){\n        var fn = readies[i];\n        cy.on('ready', fn);\n      }\n      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n      \n      cy.trigger('ready');\n    }, options.done);\n  };\n\n  $$.corefn = $$.Core.prototype; // short alias\n  \n\n  $$.fn.core({\n    isReady: function(){\n      return this._private.ready;\n    },\n\n    ready: function( fn ){\n      if( this.isReady() ){\n        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event\n      } else {\n        this.on('ready', fn);\n      }\n    },\n\n    initrender: function(){\n      return this._private.initrender;\n    },\n\n    destroy: function(){\n      this.notify({ type: 'destroy' }); // destroy the renderer\n\n      var domEle = this.container();\n      var parEle = domEle.parentNode;\n      if( parEle ){\n        parEle.removeChild( domEle );\n      }\n\n      return this;\n    },\n\n    getElementById: function( id ){\n      var index = this._private.id2index[ id ];\n      if( index !== undefined ){\n        return this._private.elements[ index ];\n      }\n\n      // worst case, return an empty collection\n      return new $$.Collection( this );\n    },\n\n    selectionType: function(){\n      return this._private.selectionType;\n    },\n\n    hasCompoundNodes: function(){\n      return this._private.hasCompoundNodes;\n    },\n\n    styleEnabled: function(){\n      return this._private.styleEnabled;\n    },\n\n    addToPool: function( eles ){\n      var elements = this._private.elements;\n      var id2index = this._private.id2index;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n\n        var id = ele._private.data.id;\n        var index = id2index[ id ];\n        var alreadyInPool = index !== undefined;\n\n        if( !alreadyInPool ){\n          index = elements.length;\n          elements.push( ele );\n          id2index[ id ] = index;\n          ele._private.index = index;\n        }\n      }\n\n      return this; // chaining\n    },\n\n    removeFromPool: function( eles ){\n      var elements = this._private.elements;\n      var id2index = this._private.id2index;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n\n        var id = ele._private.data.id;\n        var index = id2index[ id ];\n        var inPool = index !== undefined;\n\n        if( inPool ){\n          this._private.id2index[ id ] = undefined;\n          elements.splice(index, 1);\n\n          // adjust the index of all elements past this index\n          for( var j = index; j < elements.length; j++ ){\n            var jid = elements[j]._private.data.id;\n            id2index[ jid ]--;\n          }\n        }\n      }\n    },\n\n    container: function(){\n      return this._private.container;\n    },\n\n    options: function(){\n      return $$.util.copy( this._private.options );\n    },\n    \n    json: function(params){\n      var json = {};\n      var cy = this;\n      \n      json.elements = {};\n      cy.elements().each(function(i, ele){\n        var group = ele.group();\n        \n        if( !json.elements[group] ){\n          json.elements[group] = [];\n        }\n        \n        json.elements[group].push( ele.json() );\n      });\n\n      if( this._private.styleEnabled ){\n        json.style = cy.style().json();\n      }\n\n      json.zoomingEnabled = cy._private.zoomingEnabled;\n      json.userZoomingEnabled = cy._private.userZoomingEnabled;\n      json.zoom = cy._private.zoom;\n      json.minZoom = cy._private.minZoom;\n      json.maxZoom = cy._private.maxZoom;\n      json.panningEnabled = cy._private.panningEnabled;\n      json.userPanningEnabled = cy._private.userPanningEnabled;\n      json.pan = cy._private.pan;\n      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;\n      json.layout = cy._private.options.layout;\n      json.renderer = cy._private.options.renderer;\n      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;\n      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;\n      json.textureOnViewport = cy._private.options.textureOnViewport;\n      json.wheelSensitivity = cy._private.options.wheelSensitivity;\n      json.motionBlur = cy._private.options.motionBlur;\n      \n      return json;\n    },\n\n    // defer execution until not busy and guarantee relative execution order of deferred functions\n    defer: function( fn ){\n      var cy = this;\n      var _p = cy._private;\n      var q = _p.deferredExecQueue;\n\n      q.push( fn );\n\n      if( !_p.deferredTimeout ){\n        _p.deferredTimeout = setTimeout(function(){\n          while( q.length > 0 ){\n            ( q.shift() )();\n          }\n\n          _p.deferredTimeout = null;\n        }, 0);\n      }\n    }\n    \n  });  \n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n(function($$, window){ 'use strict';\n\n  function ready(f) {\n    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;\n\n    setTimeout(fn, 9, f);\n  }\n\n  $$.fn.core({\n    add: function(opts){\n      \n      var elements;\n      var cy = this;\n      \n      // add the elements\n      if( $$.is.elementOrCollection(opts) ){\n        var eles = opts;\n\n        if( eles._private.cy === cy ){ // same instance => just restore\n          elements = eles.restore();\n\n        } else { // otherwise, copy from json\n          var jsons = [];\n\n          for( var i = 0; i < eles.length; i++ ){\n            var ele = eles[i];\n            jsons.push( ele.json() );\n          }\n\n          elements = new $$.Collection( cy, jsons );\n        }\n      }\n      \n      // specify an array of options\n      else if( $$.is.array(opts) ){\n        var jsons = opts;\n\n        elements = new $$.Collection(cy, jsons);\n      }\n      \n      // specify via opts.nodes and opts.edges\n      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){\n        var elesByGroup = opts;\n        var jsons = [];\n\n        var grs = ['nodes', 'edges'];\n        for( var i = 0, il = grs.length; i < il; i++ ){\n          var group = grs[i];\n          var elesArray = elesByGroup[group];\n\n          if( $$.is.array(elesArray) ){\n\n            for( var j = 0, jl = elesArray.length; j < jl; j++ ){\n              var json = elesArray[j];\n              json.group = group;\n\n              jsons.push( json );\n            }\n          } \n        }\n\n        elements = new $$.Collection(cy, jsons);\n      }\n      \n      // specify options for one element\n      else {\n        var json = opts;\n        elements = (new $$.Element( cy, json )).collection();\n      }\n      \n      return elements;\n    },\n    \n    remove: function(collection){\n      if( $$.is.elementOrCollection(collection) ){\n        collection = collection;\n      } else if( $$.is.string(collection) ){\n        var selector = collection;\n        collection = this.$( selector );\n      }\n      \n      return collection.remove();\n    },\n    \n    load: function(elements, onload, ondone){\n      var cy = this;\n      \n      // remove old elements\n      var oldEles = cy.elements();\n      if( oldEles.length > 0 ){\n        oldEles.remove();\n      }\n\n      cy.notifications(false);\n      \n      if( elements != null ){\n        if( $$.is.plainObject(elements) || $$.is.array(elements) ){\n          cy.add( elements );\n        } \n      }\n      \n      function callback(){        \n        cy.one('layoutready', function(e){\n          cy.notifications(true);\n          cy.trigger(e); // we missed this event by turning notifications off, so pass it on\n\n          cy.notify({\n            type: 'load',\n            collection: cy.elements()\n          });\n\n          cy.one('load', onload);\n          cy.trigger('load');\n        }).one('layoutstop', function(){\n          cy.one('done', ondone);\n          cy.trigger('done');\n        });\n        \n        var layoutOpts = $$.util.extend({}, cy._private.options.layout);\n        layoutOpts.eles = cy.$();\n\n        cy.layout( layoutOpts );\n\n      }\n\n      if( window ){\n        ready( callback );\n      } else {\n        callback();\n      }\n\n      return this;\n    }\n  });\n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n;(function($$, window){ 'use strict';\n  \n  $$.fn.core({\n    \n    // pull in animation functions\n    animated: $$.define.animated(),\n    clearQueue: $$.define.clearQueue(),\n    delay: $$.define.delay(),\n    animate: $$.define.animate(),\n    stop: $$.define.stop(),\n\n    addToAnimationPool: function( eles ){\n      var cy = this;\n\n      if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n      \n      cy._private.aniEles.merge( eles );\n    },\n\n    startAnimationLoop: function(){\n      var cy = this;\n\n      if( !cy.styleEnabled() ){ return; } // save cycles when no style used\n\n      // don't execute the animation loop in headless environments\n      if( !window ){\n        return;\n      }\n      \n      function globalAnimationStep(){\n        $$.util.requestAnimationFrame(function(now){\n          handleElements(now);\n          globalAnimationStep();\n        });\n      }\n      \n      globalAnimationStep(); // first call\n      \n      function handleElements(now){\n        now = +new Date();\n\n        var eles = cy._private.aniEles;\n        var doneEles = [];\n\n        function handleElement( ele, isCore ){\n          var current = ele._private.animation.current;\n          var queue = ele._private.animation.queue;\n          var ranAnis = false;\n          \n          // if nothing currently animating, get something from the queue\n          if( current.length === 0 ){\n            var next = queue.length > 0 ? queue.shift() : null;\n            \n            if( next ){\n              next.callTime = now; // was queued, so update call time\n              current.push( next );\n            }\n          }\n          \n          // step and remove if done\n          var completes = [];\n          for(var i = current.length - 1; i >= 0; i--){\n            var ani = current[i];\n\n            // start if need be\n            if( !ani.started ){ startAnimation( ele, ani ); }\n            \n            step( ele, ani, now, isCore );\n\n            if( ani.done ){\n              completes.push( ani );\n              \n              // remove current[i]\n              current.splice(i, 1);\n            }\n\n            ranAnis = true;\n          }\n          \n          // call complete callbacks\n          for( var i = 0; i < completes.length; i++ ){\n            var ani = completes[i];\n            var complete = ani.params.complete;\n\n            if( $$.is.fn(complete) ){\n              complete.apply( ele, [ now ] );\n            }\n          }\n\n          if( !isCore && current.length === 0 && queue.length === 0 ){\n            doneEles.push( ele );\n          }\n\n          return ranAnis;\n        } // handleElements\n\n        // handle all eles\n        for( var e = 0; e < eles.length; e++ ){\n          var ele = eles[e];\n          \n          handleElement( ele );\n        } // each element\n\n        var ranCoreAni = handleElement( cy, true );\n        \n        // notify renderer\n        if( eles.length > 0 || ranCoreAni ){\n          var toNotify;\n\n          if( eles.length > 0 ){\n            var updatedEles = eles.updateCompoundBounds();\n            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;\n          }\n\n          cy.notify({\n            type: 'draw',\n            collection: toNotify\n          });\n        }\n\n        // remove elements from list of currently animating if its queues are empty\n        eles.unmerge( doneEles );\n\n      } // handleElements\n      \n      function startAnimation( self, ani ){\n        var isCore = $$.is.core( self );\n        var isEles = !isCore;\n        var ele = self;\n        var style = cy._private.style;\n\n        if( isEles ){\n          var pos = ele._private.position;\n          var startPosition = {\n            x: pos.x,\n            y: pos.y\n          };\n          var startStyle = style.getValueStyle( ele );\n        }\n\n        if( isCore ){\n          var pan = cy._private.pan;\n          var startPan = {\n            x: pan.x,\n            y: pan.y\n          };\n\n          var startZoom = cy._private.zoom;\n        }\n\n        ani.started = true;\n        ani.startTime = Date.now();\n        ani.startPosition = startPosition;\n        ani.startStyle = startStyle;\n        ani.startPan = startPan;\n        ani.startZoom = startZoom;\n      }\n\n      function step( self, animation, now, isCore ){\n        var style = cy._private.style;\n        var properties = animation.properties;\n        var params = animation.params;\n        var startTime = animation.startTime;\n        var percent;\n        var isEles = !isCore;\n        \n        if( animation.duration === 0 ){\n          percent = 1;\n        } else {\n          percent = Math.min(1, (now - startTime)/animation.duration);\n        }\n\n        if( percent < 0 ){\n          percent = 0;\n        } else if( percent > 1 ){\n          percent = 1;\n        }\n        \n        if( properties.delay == null ){ // then update\n\n          var startPos = animation.startPosition;\n          var endPos = properties.position;\n          var pos = self._private.position;\n          if( endPos && isEles ){\n            if( valid( startPos.x, endPos.x ) ){\n              pos.x = ease( startPos.x, endPos.x, percent );\n            }\n\n            if( valid( startPos.y, endPos.y ) ){\n              pos.y = ease( startPos.y, endPos.y, percent );\n            }\n          }\n\n          var startPan = animation.startPan;\n          var endPan = properties.pan;\n          var pan = self._private.pan;\n          var animatingPan = endPan != null && isCore;\n          if( animatingPan ){\n            if( valid( startPan.x, endPan.x ) ){\n              pan.x = ease( startPan.x, endPan.x, percent );\n            }\n\n            if( valid( startPan.y, endPan.y ) ){\n              pan.y = ease( startPan.y, endPan.y, percent );\n            }\n\n            self.trigger('pan');\n          }\n\n          var startZoom = animation.startZoom;\n          var endZoom = properties.zoom;\n          var animatingZoom = endZoom != null && isCore;\n          if( animatingZoom ){\n            if( valid( startZoom, endZoom ) ){\n              self._private.zoom = ease( startZoom, endZoom, percent );\n            }\n\n            self.trigger('zoom');\n          }\n\n          if( animatingPan || animatingZoom ){\n            self.trigger('viewport');\n          }\n\n          if( properties.css && isEles ){\n            var props = properties.css;\n\n            for( var i = 0; i < props.length; i++ ){\n              var name = props[i].name;\n              var prop = props[i];\n              var end = prop;\n\n              var start = animation.startStyle[ name ];\n              var easedVal = ease( start, end, percent );\n              \n              style.overrideBypass( self, name, easedVal );\n            } // for props\n          } // if \n\n        }\n        \n        if( $$.is.fn(params.step) ){\n          params.step.apply( self, [ now ] );\n        }\n        \n        if( percent >= 1 ){\n          animation.done = true;\n        }\n        \n        return percent;\n      }\n      \n      function valid(start, end){\n        if( start == null || end == null ){\n          return false;\n        }\n        \n        if( $$.is.number(start) && $$.is.number(end) ){\n          return true;\n        } else if( (start) && (end) ){\n          return true;\n        }\n        \n        return false;\n      }\n      \n      function ease(startProp, endProp, percent){\n        if( percent < 0 ){\n          percent = 0;\n        } else if( percent > 1 ){\n          percent = 1;\n        }\n\n        var start, end;\n\n        if( startProp.pxValue != null || startProp.value != null ){\n          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;\n        } else {\n          start = startProp;\n        }\n\n        if( endProp.pxValue != null || endProp.value != null ){\n          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;\n        } else {\n          end = endProp;\n        }\n\n        if( $$.is.number(start) && $$.is.number(end) ){\n          return start + (end - start) * percent;\n\n        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour\n          var c1 = start;\n          var c2 = end;\n\n          var ch = function(ch1, ch2){\n            var diff = ch2 - ch1;\n            var min = ch1;\n            return Math.round( percent * diff + min );\n          };\n          \n          var r = ch( c1[0], c2[0] );\n          var g = ch( c1[1], c2[1] );\n          var b = ch( c1[2], c2[2] );\n          \n          return [r, g, b];\n        }\n        \n        return undefined;\n      }\n      \n    }\n    \n  });\n  \n})( cytoscape, typeof window === 'undefined' ? null : window );\n\n\n  \n    \n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    data: $$.define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true\n    }),\n\n    removeData: $$.define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true\n    }),\n\n    scratch: $$.define.data({\n      field: 'scratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n\n    removeScratch: $$.define.removeData({\n      field: 'scratch',\n      triggerEvent: false\n    })\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.core({\n    on: $$.define.on(), // .on( events [, selector] [, data], handler)\n    one: $$.define.on({ unbindSelfOnTrigger: true }),\n    once: $$.define.on({ unbindAllBindersOnTrigger: true }),\n    off: $$.define.off(), // .off( events [, selector] [, handler] )\n    trigger: $$.define.trigger() // .trigger( events [, extraParams] )\n  });\n\n  // aliases for those folks who like old stuff:\n  $$.corefn.bind = $$.corefn.on;\n  $$.corefn.unbind = $$.corefn.off;\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    png: function( options ){\n      var renderer = this._private.renderer;\n      options = options || {};\n\n      return renderer.png( options );      \n    }\n    \n  });\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    layout: function( params ){\n      var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.initLayout( params ) );\n\n      layout.run();\n\n      return this; // chaining\n    },\n\n    makeLayout: function( params ){\n      return this.initLayout( params );\n    },\n    \n    initLayout: function( options ){\n      if( options == null ){\n        $$.util.error('Layout options must be specified to make a layout');\n        return;\n      }\n      \n      if( options.name == null ){\n        $$.util.error('A `name` must be specified to make a layout');\n        return;\n      }\n      \n      var name = options.name;\n      var LayoutProto = $$.extension('layout', name);\n      \n      if( LayoutProto == null ){\n        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');\n        return;\n      }\n\n      options.eles = options.eles != null ? options.eles : this.$();\n\n      if( $$.is.string( options.eles ) ){\n        options.eles = this.$( options.eles );\n      }\n      \n      var layout = new LayoutProto( $$.util.extend({}, options, {\n        cy: this\n      }) );\n\n      // make sure layout has _private for use w/ std apis like .on()\n      if( !$$.is.plainObject(layout._private) ){\n        layout._private = {};\n      }\n\n      layout._private.cy = this;\n      layout._private.listeners = [];\n      \n      return layout;\n    }\n    \n  });\n  \n})( cytoscape );\n(function($$){ 'use strict';\n  \n  $$.fn.core({\n    notify: function( params ){\n      if( this._private.batchingNotify ){\n        var bEles = this._private.batchNotifyEles;\n        var bTypes = this._private.batchNotifyTypes;\n\n        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){\n          var ele = params.collection[i];\n\n          if( !bEles.ids[ ele._private.id ] ){\n            bEles.push( ele );\n          }\n        } }\n\n        if( !bTypes.ids[ params.type ] ){\n          bTypes.push( params.type );\n        }\n\n        return; // notifications are disabled during batching\n      }\n\n      if( !this._private.notificationsEnabled ){ return; } // exit on disabled\n\n      var renderer = this.renderer();\n      \n      renderer.notify(params);\n    },\n    \n    notifications: function( bool ){\n      var p = this._private;\n      \n      if( bool === undefined ){\n        return p.notificationsEnabled;\n      } else {\n        p.notificationsEnabled = bool ? true : false;\n      }\n    },\n    \n    noNotifications: function( callback ){\n      this.notifications(false);\n      callback();\n      this.notifications(true);\n    },\n\n    startBatch: function(){\n      var _p = this._private;\n\n      _p.batchingStyle = _p.batchingNotify = true;\n      _p.batchStyleEles = [];\n      _p.batchNotifyEles = [];\n      _p.batchNotifyTypes = [];\n\n      _p.batchStyleEles.ids = {};\n      _p.batchNotifyEles.ids = {};\n      _p.batchNotifyTypes.ids = {};\n\n      return this;\n    },\n\n    endBatch: function(){\n      var _p = this._private;\n\n      // update style for dirty eles\n      _p.batchingStyle = false;\n      new $$.Collection(this, _p.batchStyleEles).updateStyle();\n\n      // notify the renderer of queued eles and event types\n      _p.batchingNotify = false;\n      this.notify({\n        type: _p.batchNotifyTypes,\n        collection: _p.batchNotifyEles\n      });\n\n      return this;\n    },\n\n    batch: function( callback ){\n      this.startBatch();\n      callback();\n      this.endBatch();\n\n      return this;\n    },\n\n    // for backwards compatibility\n    batchData: function( map ){\n      var cy = this;\n\n      return this.batch(function(){\n        for( var id in map ){\n          var data = map[id];\n          var ele = cy.getElementById( id );\n          \n          ele.data( data );\n        }\n      });\n    }\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    renderTo: function( context, zoom, pan, pxRatio ){\n      var r = this._private.renderer;\n\n      r.renderTo( context, zoom, pan, pxRatio );\n      return this;\n    },\n\n    renderer: function(){\n      return this._private.renderer;\n    },\n\n    forceRender: function(){\n      this.notify({\n        type: 'draw'\n      });\n\n      return this;\n    },\n\n    resize: function(){\n      this.notify({\n        type: 'resize'\n      });\n\n      this.trigger('resize');\n\n      return this;\n    },\n    \n    initRenderer: function( options ){\n      var cy = this;\n\n      var RendererProto = $$.extension('renderer', options.name);\n      if( RendererProto == null ){\n        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);\n        return;\n      }\n      \n      this._private.renderer = new RendererProto(\n        $$.util.extend({}, options, {\n          cy: cy,\n          style: cy._private.style\n        })\n      );\n       \n    }\n    \n  });  \n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function( eles ){\n\n      if( $$.is.string( eles ) ){\n        return this.$( eles );\n\n      } else if( $$.is.elementOrCollection( eles ) ){\n        return eles.collection();\n\n      } else if( $$.is.array( eles ) ){\n        return new $$.Collection( this, eles );\n      }\n\n      return new $$.Collection( this );\n    },\n    \n    nodes: function( selector ){\n      var nodes = this.$(function(){\n        return this.isNode();\n      });\n\n      if( selector ){\n        return nodes.filter( selector );\n      } \n\n      return nodes;\n    },\n    \n    edges: function( selector ){\n      var edges = this.$(function(){\n        return this.isEdge();\n      });\n\n      if( selector ){\n        return edges.filter( selector );\n      }\n\n      return edges;\n    },\n      \n    // search the graph like jQuery\n    $: function( selector ){\n      var eles = new $$.Collection( this, this._private.elements );\n\n      if( selector ){\n        return eles.filter( selector );\n      }\n\n      return eles;\n    }\n    \n  });  \n\n  // aliases\n  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  \n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n    \n    style: function( newStyle ){\n      if( newStyle ){\n        var s = this.setStyle( newStyle );\n\n        s.update();\n      }\n\n      return this._private.style;\n    },\n\n    setStyle: function( style ){\n      var _p = this._private;\n\n      if( $$.is.stylesheet(style) ){\n        _p.style = style.generateStyle(this);\n      \n      } else if( $$.is.array(style) ) {\n        _p.style = $$.style.fromJson(this, style);\n      \n      } else if( $$.is.string(style) ){\n        _p.style = $$.style.fromString(this, style);\n      \n      } else {\n        _p.style = new $$.Style( this );\n      }\n\n      return _p.style;\n    }\n  });\n  \n})( cytoscape );\n\n\n;(function($$){ 'use strict';\n  \n  $$.fn.core({\n\n    autolock: function(bool){\n      if( bool !== undefined ){\n        this._private.autolock = bool ? true : false;\n      } else {\n        return this._private.autolock;\n      }\n      \n      return this; // chaining\n    },\n\n    autoungrabify: function(bool){\n      if( bool !== undefined ){\n        this._private.autoungrabify = bool ? true : false;\n      } else {\n        return this._private.autoungrabify;\n      }\n      \n      return this; // chaining\n    },\n\n    autounselectify: function(bool){\n      if( bool !== undefined ){\n        this._private.autounselectify = bool ? true : false;\n      } else {\n        return this._private.autounselectify;\n      }\n      \n      return this; // chaining\n    },\n\n    panningEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.panningEnabled = bool ? true : false;\n      } else {\n        return this._private.panningEnabled;\n      }\n      \n      return this; // chaining\n    },\n\n    userPanningEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.userPanningEnabled = bool ? true : false;\n      } else {\n        return this._private.userPanningEnabled;\n      }\n      \n      return this; // chaining\n    },\n    \n    zoomingEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.zoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.zoomingEnabled;\n      }\n      \n      return this; // chaining\n    },\n\n    userZoomingEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.userZoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.userZoomingEnabled;\n      }\n      \n      return this; // chaining\n    },\n\n    boxSelectionEnabled: function( bool ){\n      if( bool !== undefined ){\n        this._private.boxSelectionEnabled = bool ? true : false;\n      } else {\n        return this._private.boxSelectionEnabled;\n      }\n      \n      return this; // chaining\n    },\n    \n    pan: function(){\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      switch( args.length ){\n      case 0: // .pan()\n        return pan;\n\n      case 1: \n\n        if( $$.is.string( args[0] ) ){ // .pan('x')\n          dim = args[0];\n          return pan[ dim ];\n\n        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })\n          if( !this._private.panningEnabled ){\n            return this;\n          }\n\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if( $$.is.number(x) ){\n            pan.x = x;\n          }\n\n          if( $$.is.number(y) ){\n            pan.y = y;\n          }\n\n          this.trigger('pan viewport');\n        }\n        break;\n\n      case 2: // .pan('x', 100)\n        if( !this._private.panningEnabled ){\n          return this;\n        }\n\n        dim = args[0];\n        val = args[1];\n\n        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){\n          pan[dim] = val;\n        }\n\n        this.trigger('pan viewport');\n        break;\n\n      default:\n        break; // invalid\n      }\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    },\n    \n    panBy: function(params){\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      if( !this._private.panningEnabled ){\n        return this;\n      }\n\n      switch( args.length ){\n      case 1: \n\n        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })\n          dims = args[0];\n          x = dims.x;\n          y = dims.y;\n\n          if( $$.is.number(x) ){\n            pan.x += x;\n          }\n\n          if( $$.is.number(y) ){\n            pan.y += y;\n          }\n\n          this.trigger('pan viewport');\n        }\n        break;\n\n      case 2: // .panBy('x', 100)\n        dim = args[0];\n        val = args[1];\n\n        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){\n          pan[dim] += val;\n        }\n\n        this.trigger('pan viewport');\n        break;\n\n      default:\n        break; // invalid\n      }\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    },\n    \n    fit: function( elements, padding ){\n      var viewportState = this.getFitViewport( elements, padding );\n\n      if( viewportState ){\n        var _p = this._private;\n        _p.zoom = viewportState.zoom;\n        _p.pan = viewportState.pan;\n\n        this.trigger('pan zoom viewport');\n\n        this.notify({ // notify the renderer that the viewport changed\n          type: 'viewport'\n        });\n      }\n\n      return this; // chaining\n    },\n\n    getFitViewport: function( elements, padding ){\n      if( $$.is.number(elements) && padding === undefined ){ // elements is optional\n        padding = elements;\n        elements = undefined;\n      }\n\n      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n        return;\n      }\n\n      var bb;\n\n      if( $$.is.string(elements) ){\n        var sel = elements;\n        elements = this.$( sel );\n\n      } else if( $$.is.boundingBox(elements) ){ // assume bb\n        var bbe = elements;\n        bb = {\n          x1: bbe.x1,\n          y1: bbe.y1,\n          x2: bbe.x2,\n          y2: bbe.y2\n        };\n\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n\n      } else if( !$$.is.elementOrCollection(elements) ){\n        elements = this.elements();\n      }\n\n      bb = bb || elements.boundingBox();\n\n      var w = this.width();\n      var h = this.height();\n      var zoom;\n      padding = $$.is.number(padding) ? padding : 0;\n\n      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){\n        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );\n\n        // crop zoom\n        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n        var pan = { // now pan to middle\n          x: (w - zoom*( bb.x1 + bb.x2 ))/2,\n          y: (h - zoom*( bb.y1 + bb.y2 ))/2\n        };\n\n        return {\n          zoom: zoom, \n          pan: pan\n        };\n      }\n\n      return;\n    },\n    \n    minZoom: function( zoom ){\n      if( zoom === undefined ){\n        return this._private.minZoom;\n      } else if( $$.is.number(zoom) ){\n        this._private.minZoom = zoom;\n      }\n\n      return this;\n    },\n\n    maxZoom: function( zoom ){\n      if( zoom === undefined ){\n        return this._private.maxZoom;\n      } else if( $$.is.number(zoom) ){\n        this._private.maxZoom = zoom;\n      }\n\n      return this;\n    },\n\n    zoom: function( params ){\n      var pos; // in rendered px\n      var zoom;\n\n      if( params === undefined ){ // then get the zoom\n        return this._private.zoom;\n\n      } else if( $$.is.number(params) ){ // then set the zoom\n        zoom = params;\n\n      } else if( $$.is.plainObject(params) ){ // then zoom about a point\n        zoom = params.level;\n\n        if( params.position ){\n          var p = params.position;\n          var pan = this._private.pan;\n          var z = this._private.zoom;\n\n          pos = { // convert to rendered px\n            x: p.x * z + pan.x,\n            y: p.y * z + pan.y\n          };\n        } else if( params.renderedPosition ){\n          pos = params.renderedPosition;\n        }\n\n        if( pos && !this._private.panningEnabled ){\n          return this; // panning disabled\n        }\n      }\n\n      if( !this._private.zoomingEnabled ){\n        return this; // zooming disabled\n      }\n\n      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){\n        return this; // can't zoom with invalid params\n      }\n\n      // crop zoom\n      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n\n      if( pos ){ // set zoom about position\n        var pan1 = this._private.pan;\n        var zoom1 = this._private.zoom;\n        var zoom2 = zoom;\n        \n        var pan2 = {\n          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,\n          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y\n        };\n\n        this._private.zoom = zoom;\n        this._private.pan = pan2;\n\n        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;\n        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );\n      \n      } else { // just set the zoom\n        this._private.zoom = zoom;\n        this.trigger('zoom viewport');\n      }\n\n      this.notify({ // notify the renderer that the viewport changed\n        type: 'viewport'\n      });\n\n      return this; // chaining\n    },\n\n    viewport: function( opts ){ \n      var _p = this._private;\n      var zoomDefd = true;\n      var panDefd = true;\n      var events = []; // to trigger\n      var zoomFailed = false;\n      var panFailed = false;\n\n      if( !opts ){ return this; }\n      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }\n      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }\n      if( !zoomDefd && !panDefd ){ return this; }\n\n      if( zoomDefd ){\n        var z = opts.zoom;\n\n        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){\n          zoomFailed = true;\n\n        } else {\n          _p.zoom = z;\n\n          events.push('zoom');\n        }\n      }\n\n      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){\n        var p = opts.pan;\n\n        if( $$.is.number(p.x) ){\n          _p.pan.x = p.x;\n          panFailed = false;\n        }\n\n        if( $$.is.number(p.y) ){\n          _p.pan.y = p.y;\n          panFailed = false;\n        }\n\n        if( !panFailed ){\n          events.push('pan');\n        }\n      }\n\n      if( events.length > 0 ){\n        events.push('viewport');\n        this.trigger( events.join(' ') );\n\n        this.notify({\n          type: 'viewport'\n        });\n      }\n\n      return this; // chaining\n    },\n    \n    center: function( elements ){\n      var pan = this.getCenterPan( elements );\n\n      if( pan ){\n        this._private.pan = pan;\n\n        this.trigger('pan viewport');\n\n        this.notify({ // notify the renderer that the viewport changed\n          type: 'viewport'\n        });\n      }\n\n      return this; // chaining\n    },\n\n    getCenterPan: function( elements, zoom ){\n      if( !this._private.panningEnabled ){\n        return;\n      }\n\n      if( $$.is.string(elements) ){\n        var selector = elements;\n        elements = this.elements( selector );\n      } else if( !$$.is.elementOrCollection(elements) ){\n        elements = this.elements();\n      }\n\n      var bb = elements.boundingBox();\n      var w = this.width();\n      var h = this.height();\n      zoom = zoom === undefined ? this._private.zoom : zoom;\n\n      var pan = { // middle\n        x: (w - zoom*( bb.x1 + bb.x2 ))/2,\n        y: (h - zoom*( bb.y1 + bb.y2 ))/2\n      };\n      \n      return pan;\n    },\n    \n    reset: function(){\n      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){\n        return this;\n      }\n\n      this.viewport({\n        pan: { x: 0, y: 0 },\n        zoom: 1\n      });\n      \n      return this; // chaining\n    },\n\n    width: function(){\n      var container = this._private.container;\n\n      if( container ){\n        return container.clientWidth;\n      }\n\n      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)\n    },\n\n    height: function(){\n      var container = this._private.container;\n\n      if( container ){\n        return container.clientHeight;\n      }\n\n      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)\n    },\n\n    extent: function(){\n      var pan = this._private.pan;\n      var zoom = this._private.zoom;\n      var rb = this.renderedExtent();\n\n      var b = {\n        x1: ( rb.x1 - pan.x )/zoom,\n        x2: ( rb.x2 - pan.x )/zoom,\n        y1: ( rb.y1 - pan.y )/zoom,\n        y2: ( rb.y2 - pan.y )/zoom,\n      };\n\n      b.w = b.x2 - b.x1;\n      b.h = b.y2 - b.y1;\n\n      return b;\n    },\n\n    renderedExtent: function(){\n      var width = this.width();\n      var height = this.height();\n\n      return {\n        x1: 0,\n        y1: 0,\n        x2: width,\n        y2: height,\n        w: width,\n        h: height\n      };\n    }\n  });\n\n  // aliases\n  $$.corefn.centre = $$.corefn.center;\n\n  // backwards compatibility\n  $$.corefn.autolockNodes = $$.corefn.autolock;\n  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // Use this interface to define functions for collections/elements.\n  // This interface is good, because it forces you to think in terms\n  // of the collections case (more than 1 element), so we don't need\n  // notification blocking nonsense everywhere.\n  //\n  // Other collection-*.js files depend on this being defined first.\n  // It's a trade off: It simplifies the code for Collection and \n  // Element integration so much that it's worth it to create the\n  // JS dependency.\n  //\n  // Having this integration guarantees that we can call any\n  // collection function on an element and vice versa.\n\n  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })\n  $$.fn.collection = $$.fn.eles = function( fnMap, options ){\n    for( var name in fnMap ){\n      var fn = fnMap[name];\n\n      $$.Collection.prototype[ name ] = fn;\n    }\n  };\n  \n  // factory for generating edge ids when no id is specified for a new element\n  var idFactory = {\n    prefix: {\n      nodes: 'n',\n      edges: 'e'\n    },\n    id: {\n      nodes: 0,\n      edges: 0\n    },\n    generate: function(cy, element, tryThisId){\n      var json = $$.is.element( element ) ? element._private : element;\n      var group = json.group;\n      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];\n      \n      if( cy.getElementById(id).empty() ){\n        this.id[group]++; // we've used the current id, so move it up\n      } else { // otherwise keep trying successive unused ids\n        while( !cy.getElementById(id).empty() ){\n          id = this.prefix[group] + ( ++this.id[group] );\n        }\n      }\n      \n      return id;\n    }\n  };\n  \n  // Element\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  // represents a node or an edge\n  $$.Element = function(cy, params, restore){\n    if( !(this instanceof $$.Element) ){\n      return new $$.Element(cy, params, restore);\n    }\n\n    var self = this;\n    restore = (restore === undefined || restore ? true : false);\n    \n    if( cy === undefined || params === undefined || !$$.is.core(cy) ){\n      $$.util.error('An element must have a core reference and parameters set');\n      return;\n    }\n    \n    // validate group\n    if( params.group !== 'nodes' && params.group !== 'edges' ){\n      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');\n      return;\n    }\n    \n    // make the element array-like, just like a collection\n    this.length = 1;\n    this[0] = this;\n    \n    // NOTE: when something is added here, add also to ele.json()\n    this._private = {\n      cy: cy,\n      single: true, // indicates this is an element\n      data: params.data || {}, // data object\n      layoutData: {}, // place for layouts to put calculated stats etc for mappers\n      position: params.position || {}, // (x, y) position pair\n      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value\n      autoHeight: undefined, \n      listeners: [], // array of bound listeners\n      group: params.group, // string; 'nodes' or 'edges'\n      style: {}, // properties as set by the style\n      rstyle: {}, // properties for style sent from the renderer to the core\n      styleCxts: [], // applied style contexts from the styler\n      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)\n      selected: params.selected ? true : false, // whether it's selected\n      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable\n      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)\n      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately\n      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed\n      active: false, // whether the element is active from user interaction\n      classes: {}, // map ( className => true )\n      animation: { // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      rscratch: {}, // object in which the renderer can store information\n      scratch: {}, // scratch objects\n      edges: [], // array of connected edges\n      children: [] // array of children\n    };\n    \n    // renderedPosition overrides if specified\n    if( params.renderedPosition ){\n      var rpos = params.renderedPosition;\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n\n      this._private.position = {\n        x: (rpos.x - pan.x)/zoom,\n        y: (rpos.y - pan.y)/zoom\n      };\n    }\n    \n    if( $$.is.string(params.classes) ){\n      var classes = params.classes.split(/\\s+/);\n      for( var i = 0, l = classes.length; i < l; i++ ){\n        var cls = classes[i];\n        if( !cls || cls === '' ){ continue; }\n\n        self._private.classes[cls] = true;\n      }\n    }\n\n    if( params.css ){\n      cy.style().applyBypass( this, params.css );\n    }\n    \n    if( restore === undefined || restore ){\n      this.restore();\n    }\n    \n  };\n\n  \n  // Collection\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  // represents a set of nodes, edges, or both together\n  $$.Collection = function(cy, elements, options){\n    if( !(this instanceof $$.Collection) ){\n      return new $$.Collection(cy, elements);\n    }\n\n    if( cy === undefined || !$$.is.core(cy) ){\n      $$.util.error('A collection must have a reference to the core');\n      return;\n    }\n    \n    var ids = {};\n    var indexes = {};\n    var createdElements = false;\n    \n    if( !elements ){\n      elements = [];\n    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){\n      createdElements = true;\n\n      // make elements from json and restore all at once later\n      var eles = [];\n      var elesIds = {};\n\n      for( var i = 0, l = elements.length; i < l; i++ ){\n        var json = elements[i];\n\n        if( json.data == null ){\n          json.data = {};\n        }\n        \n        var data = json.data;\n\n        // make sure newly created elements have valid ids\n        if( data.id == null ){\n          data.id = idFactory.generate( cy, json );\n        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){\n          continue; // can't create element if prior id already exists\n        }\n\n        var ele = new $$.Element( cy, json, false );\n        eles.push( ele );\n        elesIds[ data.id ] = true;\n      }\n\n      elements = eles;\n    }\n    \n    this.length = 0;\n\n    for( var i = 0, l = elements.length; i < l; i++ ){\n      var element = elements[i];\n      if( !element ){  continue; }\n      \n      var id = element._private.data.id;\n      \n      if( !options || (options.unique && !ids[ id ] ) ){\n        ids[ id ] = element;\n        indexes[ id ] = this.length;\n\n        this[ this.length ] = element;\n        this.length++;\n      }\n    }\n    \n    this._private = {\n      cy: cy,\n      ids: ids,\n      indexes: indexes\n    };\n\n    // restore the elements if we created them from json\n    if( createdElements ){\n      this.restore();\n    }\n  };\n  \n  \n  // Functions\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  // keep the prototypes in sync (an element has the same functions as a collection)\n  // and use $$.elefn and $$.elesfn as shorthands to the prototypes\n  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;\n\n  $$.elesfn.cy = function(){\n    return this._private.cy;\n  };\n  \n  $$.elesfn.element = function(){\n    return this[0];\n  };\n  \n  $$.elesfn.collection = function(){\n    if( $$.is.collection(this) ){\n      return this;\n    } else { // an element\n      return new $$.Collection( this._private.cy, [this] );\n    }\n  };\n\n  $$.elesfn.unique = function(){\n    return new $$.Collection( this._private.cy, this, { unique: true } );\n  };\n\n  $$.elesfn.getElementById = function( id ){\n    var cy = this._private.cy;\n    var ele = this._private.ids[ id ];\n\n    return ele ? ele : $$.Collection(cy); // get ele or empty collection\n  };\n\n  $$.elesfn.json = function(){\n    var ele = this.element();\n    if( ele == null ){ return undefined; }\n\n    var p = ele._private;\n    \n    var json = $$.util.copy({\n      data: p.data,\n      position: p.position,\n      group: p.group,\n      bypass: p.bypass,\n      removed: p.removed,\n      selected: p.selected,\n      selectable: p.selectable,\n      locked: p.locked,\n      grabbed: p.grabbed,\n      grabbable: p.grabbable,\n      classes: ''\n    });\n    \n    var classes = [];\n    for( var cls in p.classes ){\n      if( p.classes[cls] ){\n        classes.push(cls);\n      }\n    }\n    \n    for( var i = 0; i < classes.length; i++ ){\n      var cls = classes[i];\n      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );\n    }\n    \n    return json;\n  };\n\n  $$.elesfn.jsons = function(){\n    var jsons = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[i];\n      var json = ele.json();\n\n      jsons.push( json );\n    }\n\n    return jsons;\n  };\n\n  $$.elesfn.clone = function(){\n    var cy = this.cy();\n    var elesArr = [];\n\n    for( var i = 0; i < this.length; i++ ){\n      var ele = this[i];\n      var json = ele.json();\n      var clone = new $$.Element(cy, json, false); // NB no restore\n\n      elesArr.push( clone );\n    }\n\n    return new $$.Collection( cy, elesArr );\n  };\n\n  $$.elesfn.restore = function( notifyRenderer ){\n    var self = this;\n    var restored = [];\n    var cy = self.cy();\n    \n    if( notifyRenderer === undefined ){\n      notifyRenderer = true;\n    }\n\n    // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n    var elements = [];\n    var nodes = [], edges = [];\n    var numNodes = 0;\n    var numEdges = 0;\n    for( var i = 0, l = self.length; i < l; i++ ){\n      var ele = self[i];\n      \n      // keep nodes first in the array and edges after\n      if( ele.isNode() ){ // put to front of array if node\n        nodes.push( ele );\n        numNodes++;\n      } else { // put to end of array if edge\n        edges.push( ele );\n        numEdges++;\n      }\n    }\n\n    elements = nodes.concat( edges );\n\n    // now, restore each element\n    for( var i = 0, l = elements.length; i < l; i++ ){\n      var ele = elements[i];\n\n      if( !ele.removed() ){\n        // don't need to do anything\n        continue;\n      }\n      \n      var _private = ele._private;\n      var data = _private.data;\n      \n      // set id and validate\n      if( data.id === undefined ){\n        data.id = idFactory.generate( cy, ele );\n      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){\n        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');\n        \n        // can't create element if it has empty string as id or non-string id\n        continue;\n      } else if( cy.getElementById( data.id ).length !== 0 ){\n        $$.util.error('Can not create second element with ID `' + data.id + '`');\n        \n        // can't create element if one already has that id\n        continue;\n      }\n\n      var id = data.id; // id is finalised, now let's keep a ref\n      \n      if( ele.isEdge() ){ // extra checks for edges\n        \n        var edge = ele;\n        var fields = ['source', 'target'];\n        var fieldsLength = fields.length;\n        var badSourceOrTarget = false;\n        for(var j = 0; j < fieldsLength; j++){\n          \n          var field = fields[j];\n          var val = data[field];\n          \n          if( val == null || val === '' ){\n            // can't create if source or target is not defined properly\n            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);\n            badSourceOrTarget = true;\n          } else if( cy.getElementById(val).empty() ){ \n            // can't create edge if one of its nodes doesn't exist\n            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n            badSourceOrTarget = true;\n          }\n        }\n\n        if( badSourceOrTarget ){ continue; } // can't create this\n        \n        var src = cy.getElementById( data.source );\n        var tgt = cy.getElementById( data.target );\n\n        src._private.edges.push( edge );\n        tgt._private.edges.push( edge );\n\n        edge._private.source = src;\n        edge._private.target = tgt;\n\n      } // if is edge\n       \n      // create mock ids map for element so it can be used like collections\n      _private.ids = {};\n      _private.ids[ id ] = ele;\n\n      _private.removed = false;\n      cy.addToPool( ele );\n      \n      restored.push( ele );\n    } // for each element\n\n    // do compound node sanity checks\n    for( var i = 0; i < numNodes; i++ ){ // each node \n      var node = elements[i];\n      var data = node._private.data;\n\n      var parentId = node._private.data.parent;\n      var specifiedParent = parentId != null;\n\n      if( specifiedParent ){\n        var parent = cy.getElementById( parentId );\n\n        if( parent.empty() ){\n          // non-existant parent; just remove it\n          data.parent = undefined;\n        } else {\n          var selfAsParent = false;\n          var ancestor = parent;\n          while( !ancestor.empty() ){\n            if( node.same(ancestor) ){\n              // mark self as parent and remove from data\n              selfAsParent = true;\n              data.parent = undefined; // remove parent reference\n\n              // exit or we loop forever\n              break;\n            }\n\n            ancestor = ancestor.parent();\n          }\n\n          if( !selfAsParent ){\n            // connect with children\n            parent[0]._private.children.push( node );\n            node._private.parent = parent[0];\n\n            // let the core know we have a compound graph\n            cy._private.hasCompoundNodes = true;\n          }\n        } // else\n      } // if specified parent\n    } // for each node\n    \n    restored = new $$.Collection( cy, restored );\n    if( restored.length > 0 ){\n\n      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );\n      toUpdateStyle.updateStyle( notifyRenderer );\n\n      if( notifyRenderer ){\n        restored.rtrigger('add');\n      } else {\n        restored.trigger('add');\n      }\n    }\n    \n    return self; // chainability\n  };\n  \n  $$.elesfn.removed = function(){\n    var ele = this[0];\n    return ele && ele._private.removed;\n  };\n\n  $$.elesfn.inside = function(){\n    var ele = this[0];\n    return ele && !ele._private.removed;\n  };\n\n  $$.elesfn.remove = function( notifyRenderer ){\n    var self = this;\n    var removed = [];\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self._private.cy;\n    \n    if( notifyRenderer === undefined ){\n      notifyRenderer = true;\n    }\n    \n    // add connected edges\n    function addConnectedEdges(node){\n      var edges = node._private.edges; \n      for( var i = 0; i < edges.length; i++ ){\n        add( edges[i] );\n      }\n    }\n    \n\n    // add descendant nodes\n    function addChildren(node){\n      var children = node._private.children;\n      \n      for( var i = 0; i < children.length; i++ ){\n        add( children[i] );\n      }\n    }\n\n    function add( ele ){\n      var alreadyAdded =  elesToRemoveIds[ ele.id() ];\n      if( alreadyAdded ){\n        return;\n      } else {\n        elesToRemoveIds[ ele.id() ] = true;\n      }\n\n      if( ele.isNode() ){\n        elesToRemove.push( ele ); // nodes are removed last\n\n        addConnectedEdges( ele );\n        addChildren( ele );\n      } else {\n        elesToRemove.unshift( ele ); // edges are removed first\n      }\n    }\n\n    // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n\n    for( var i = 0, l = self.length; i < l; i++ ){\n      var ele = self[i];\n\n      add( ele );\n    }\n    \n    function removeEdgeRef(node, edge){\n      var connectedEdges = node._private.edges;\n      for( var j = 0; j < connectedEdges.length; j++ ){\n        var connectedEdge = connectedEdges[j];\n        \n        if( edge === connectedEdge ){\n          connectedEdges.splice( j, 1 );\n          break;\n        }\n      }\n    }\n\n    function removeChildRef(parent, ele){\n      ele = ele[0];\n      parent = parent[0];\n      var children = parent._private.children;\n\n      for( var j = 0; j < children.length; j++ ){\n        if( children[j][0] === ele[0] ){\n          children.splice(j, 1);\n          break;\n        }\n      }\n    }\n\n    for( var i = 0; i < elesToRemove.length; i++ ){\n      var ele = elesToRemove[i];\n\n      // mark as removed\n      ele._private.removed = true;\n\n      // remove from core pool\n      cy.removeFromPool( ele );\n\n      // add to list of removed elements\n      removed.push( ele );\n\n      if( ele.isEdge() ){ // remove references to this edge in its connected nodes\n        var src = ele.source()[0];\n        var tgt = ele.target()[0];\n\n        removeEdgeRef( src, ele );\n        removeEdgeRef( tgt, ele );\n\n      } else { // remove reference to parent \n        var parent = ele.parent();\n\n        if( parent.length !== 0 ){\n          removeChildRef(parent, ele);\n        }\n      }\n    }\n\n    // check to see if we have a compound graph or not\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n    for( var i = 0; i < elesStillInside.length; i++ ){\n      var ele = elesStillInside[i];\n\n      if( ele.isParent() ){\n        cy._private.hasCompoundNodes = true;\n        break;\n      }\n    }\n\n    var removedElements = new $$.Collection( this.cy(), removed );\n    if( removedElements.size() > 0 ){\n      // must manually notify since trigger won't do this automatically once removed\n      \n      if( notifyRenderer ){\n        this.cy().notify({\n          type: 'remove',\n          collection: removedElements\n        });\n      }\n      \n      removedElements.trigger('remove');\n    }\n\n    // check for empty remaining parent nodes\n    var checkedParentId = {};\n    for( var i = 0; i < elesToRemove.length; i++ ){\n      var ele = elesToRemove[i];\n      var isNode = ele._private.group === 'nodes';\n      var parentId = ele._private.data.parent;\n\n      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){\n        checkedParentId[ parentId ] = true;\n        var parent = cy.getElementById( parentId );\n\n        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){\n          parent.updateStyle();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  $$.elesfn.move = function( struct ){\n    var cy = this._private.cy;\n\n    if( struct.source !== undefined || struct.target !== undefined ){\n      var srcId = struct.source;\n      var tgtId = struct.target;\n      var srcExists = cy.getElementById( srcId ).length > 0;\n      var tgtExists = cy.getElementById( tgtId ).length > 0;\n\n      if( srcExists || tgtExists ){\n        var jsons = this.jsons();\n\n        this.remove();\n\n        for( var i = 0; i < jsons.length; i++ ){\n          var json = jsons[i];\n\n          if( json.group === 'edges' ){\n            if( srcExists ){ json.data.source = srcId; }\n            if( tgtExists ){ json.data.target = tgtId; }\n          }\n        }\n\n        return cy.add( jsons );\n      }\n \n    } else if( struct.parent !== undefined ){ // move node to new parent\n      var parentId = struct.parent;\n      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;\n    \n      if( parentExists ){\n        var jsons = this.jsons();\n        var descs = this.descendants();\n        var descsEtc = descs.merge( descs.add(this).connectedEdges() );\n\n        this.remove(); // NB: also removes descendants and their connected edges\n\n        for( var i = 0; i < this.length; i++ ){\n          var json = jsons[i];\n\n          if( json.group === 'nodes' ){\n            json.data.parent = parentId === null ? undefined : parentId;\n          }\n        }\n      }\n\n      return cy.add( jsons ).merge( descsEtc.restore() );\n    }\n\n    return this; // if nothing done\n  };\n  \n})( cytoscape );\n\n\n;(function($$){ 'use strict';\n\n  // search, spanning trees, etc\n  $$.fn.eles({\n\n    // std functional ele first callback style\n    stdBreadthFirstSearch: function( options ){\n      options = $$.util.extend( {}, options, {\n        std: true\n      } );\n\n      return this.breadthFirstSearch( options );\n    },\n\n    // do a breadth first search from the nodes in the collection\n    // from pseudocode on wikipedia\n    breadthFirstSearch: function( roots, fn, directed ){\n      var options;\n      var std;\n      var thisArg;\n      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){\n        options = roots;\n        roots = options.roots;\n        fn = options.visit;\n        directed = options.directed;\n        std = options.std;\n        thisArg = options.thisArg;\n      }\n\n      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;\n      fn = $$.is.fn(fn) ? fn : function(){};\n      \n      var cy = this._private.cy;\n      var v = $$.is.string(roots) ? this.filter(roots) : roots;\n      var Q = [];\n      var connectedNodes = [];\n      var connectedBy = {};\n      var id2depth = {};\n      var V = {};\n      var j = 0;\n      var found;\n      var nodes = this.nodes();\n      var edges = this.edges();\n\n      // enqueue v\n      for( var i = 0; i < v.length; i++ ){\n        if( v[i].isNode() ){\n          Q.unshift( v[i] );\n          V[ v[i].id() ] = true; \n\n          connectedNodes.push( v[i] );\n          id2depth[ v[i].id() ] = 0;\n        }\n      }\n\n      while( Q.length !== 0 ){\n        var v = Q.shift();\n        var depth = id2depth[ v.id() ];\n        var prevEdge = connectedBy[ v.id() ];\n        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];\n        var ret;\n\n        if( std ){\n          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);\n        } else {\n          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);\n        }\n\n        if( ret === true ){\n          found = v;\n          break;\n        }\n\n        if( ret === false ){\n          break;\n        }\n\n        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );\n        for( var i = 0; i < vwEdges.length; i++ ){\n          var e = vwEdges[i];\n          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );\n\n          if( w.length !== 0 && !V[ w.id() ] ){\n            w = w[0];\n\n            Q.push( w );\n            V[ w.id() ] = true;\n\n            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;\n\n            connectedNodes.push( w );\n            connectedBy[ w.id() ] = e;\n          }\n        }\n        \n      }\n\n      var connectedEles = [];\n\n      for( var i = 0; i < connectedNodes.length; i++ ){\n        var node = connectedNodes[i];\n        var edge = connectedBy[ node.id() ];\n\n        if( edge ){\n          connectedEles.push( edge );\n        }\n\n        connectedEles.push( node );\n      }\n\n      return {\n        path: new $$.Collection( cy, connectedEles, { unique: true } ),\n        found: new $$.Collection( cy, found, { unique: true } )\n      };\n    },\n\n    // std functional ele first callback style\n    stdDepthFirstSearch: function( options ){\n      options = $$.util.extend( {}, options, {\n        std: true\n      } );\n\n      return this.depthFirstSearch( options );\n    },\n\n    // do a depth first search on the nodes in the collection\n    // from pseudocode on wikipedia (iterative impl)\n    depthFirstSearch: function( roots, fn, directed ){\n      var options;\n      var std;\n      var thisArg;\n      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){\n        options = roots;\n        roots = options.roots;\n        fn = options.visit;\n        directed = options.directed;\n        std = options.std;\n        thisArg = options.thisArg;\n      }\n      \n      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;\n      fn = $$.is.fn(fn) ? fn : function(){};\n      var cy = this._private.cy;\n      var v = $$.is.string(roots) ? this.filter(roots) : roots;\n      var S = [];\n      var connectedNodes = [];\n      var connectedBy = {};\n      var id2depth = {};\n      var discovered = {};\n      var j = 0;\n      var found;\n      var edges = this.edges();\n      var nodes = this.nodes();\n\n      // push v\n      for( var i = 0; i < v.length; i++ ){\n        if( v[i].isNode() ){\n          S.push( v[i] );\n\n          connectedNodes.push( v[i] );\n          id2depth[ v[i].id() ] = 0;\n        }\n      }\n\n      while( S.length !== 0 ){\n        var v = S.pop();\n\n        if( !discovered[ v.id() ] ){\n          discovered[ v.id() ] = true;\n\n          var depth = id2depth[ v.id() ];\n          var prevEdge = connectedBy[ v.id() ];\n          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];\n          var ret;\n\n          if( std ){\n            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);\n          } else {\n            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);\n          }\n\n          if( ret === true ){\n            found = v;\n            break;\n          }\n\n          if( ret === false ){\n            break;\n          }\n\n          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );\n          \n          for( var i = 0; i < vwEdges.length; i++ ){\n            var e = vwEdges[i];\n            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );\n\n            if( w.length !== 0 && !discovered[ w.id() ] ){\n              w = w[0];\n\n              S.push( w );\n\n              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;\n\n              connectedNodes.push( w );\n              connectedBy[ w.id() ] = e;\n            }\n          }\n        }\n      }\n\n      var connectedEles = [];\n\n      for( var i = 0; i < connectedNodes.length; i++ ){\n        var node = connectedNodes[i];\n        var edge = connectedBy[ node.id() ];\n\n        if( edge ){\n          connectedEles.push( edge );\n        }\n\n        connectedEles.push( node );\n      }\n\n      return {\n        path: new $$.Collection( cy, connectedEles, { unique: true } ),\n        found: new $$.Collection( cy, found, { unique: true } )\n      };\n    },\n\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function( weightFn ){\n      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\n      function findSet(ele){\n        for( var i = 0; i < forest.length; i++ ){\n          var eles = forest[i];\n\n          if( eles.anySame(ele) ){\n            return {\n              eles: eles,\n              index: i\n            };\n          }\n        }\n      }\n\n      var A = new $$.Collection(this._private.cy, []);\n      var forest = [];\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){\n        forest.push( nodes[i].collection() );\n      }\n\n      var edges = this.edges();\n      var S = edges.toArray().sort(function(a, b){\n        var weightA = weightFn.call(a, a);\n        var weightB = weightFn.call(b, b);\n\n        return weightA - weightB;\n      });\n\n      for(var i = 0; i < S.length; i++){\n        var edge = S[i];\n        var u = edge.source()[0];\n        var v = edge.target()[0];\n        var setU = findSet(u);\n        var setV = findSet(v);\n\n        if( setU.index !== setV.index ){\n          A = A.add( edge );\n\n          // combine forests for u and v\n          forest[ setU.index ] = setU.eles.add( setV.eles );\n          forest.splice( setV.index, 1 );\n        }\n      }\n\n      return nodes.add( A );\n\n    },\n\n    dijkstra: function( root, weightFn, directed ){\n      var options;\n      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){\n        options = root;\n        root = options.root;\n        weightFn = options.weight;\n        directed = options.directed;\n      }\n\n      var cy = this._private.cy;\n      directed = !$$.is.fn(weightFn) ? weightFn : directed;\n      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)\n\n      var source = $$.is.string(root) ? this.filter(root).eq(0) : root.eq(0);\n      var dist = {};\n      var prev = {};\n      var knownDist = {};\n\n      var edges = this.edges().filter(function(){ return !this.isLoop(); });\n      var nodes = this.nodes();\n      var Q = [];\n\n      for( var i = 0; i < nodes.length; i++ ){\n        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;\n        Q.push( nodes[i] );\n      }\n\n      var valueFn = function(node) {\n        return dist[ node.id() ];\n      };\n      \n      Q = new $$.Collection(cy, Q);\n    \n      var heap = $$.Minheap(cy, Q, valueFn);\n    \n      var distBetween = function(u, v){\n        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);\n        var smallestDistance = Infinity;\n        var smallestEdge;\n\n        for( var i = 0; i < uvs.length; i++ ){\n          var edge = uvs[i];\n          var weight = weightFn.apply( edge, [edge] );\n\n          if( weight < smallestDistance || !smallestEdge ){\n            smallestDistance = weight;\n            smallestEdge = edge;\n          }\n        }\n\n        return {\n          edge: smallestEdge,\n          dist: smallestDistance\n        };\n      };\n\n      while(heap.size() > 0){\n        var smallestEl = heap.pop(),\n        smalletsDist = smallestEl.value,\n        uid = smallestEl.id,\n        u = cy.getElementById(uid);\n    \n        knownDist[uid] = smalletsDist;\n      \n        if( smalletsDist === Math.Infinite ){\n          break;\n        }\n\n        var neighbors = u.neighborhood().intersect(nodes);\n        for( var i = 0; i < neighbors.length; i++ ){\n          var v = neighbors[i];\n          var vid = v.id();\n          var vDist = distBetween(u, v);\n\n          var alt = smalletsDist + vDist.dist;\n\n          if( alt < heap.getValueById(vid) ){\n            heap.edit(vid, alt);\n            prev[ vid ] = {\n              node: u,\n              edge: vDist.edge\n            };\n          }\n        } // for \n      } // while\n\n      return {\n        distanceTo: function(node){\n          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);\n\n          return knownDist[ target.id() ];\n        },\n\n        pathTo: function(node){\n          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);\n          var S = [];\n          var u = target;\n\n          if( target.length > 0 ){\n            S.unshift( target );\n\n            while( prev[ u.id() ] ){\n              var p = prev[ u.id() ];\n\n              S.unshift( p.edge );\n              S.unshift( p.node );\n\n              u = p.node;\n            }\n          }\n\n          return new $$.Collection( cy, S );\n        }\n      };\n    }  \n  });\n\n  // nice, short mathemathical alias\n  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;\n  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;\n  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;\n  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;\n  \n})( cytoscape );\n;(function($$) { \n  'use strict';\n\n  // Additional graph analysis algorithms\n  $$.fn.eles({\n\n    // Implemented from pseudocode from wikipedia\n\n    // options => options object\n    //   root // starting node (either element or selector string)\n    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges\n    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`\n    //   directed // default false\n    //   goal // target node (either element or selector string). Mandatory.\n\n    // retObj => returned object by function\n    //   found : true/false // whether a path from root to goal has been found\n    //   distance // Distance for the shortest path from root to goal\n    //   path // Array of ids of nodes in shortest path\n    aStar: function(options) {\n      options = options || {};\n\n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Reconstructs the path from Start to End, acumulating the result in pathAcum\n      var reconstructPath = function(start, end, cameFromMap, pathAcum) {\n        // Base case\n        if (start == end) {\n          pathAcum.push( cy.getElementById(end) );\n          return pathAcum;\n        }\n        \n        if (end in cameFromMap) {\n          // We know which node is before the last one\n          var previous = cameFromMap[end];\n          var previousEdge = cameFromEdge[end];\n\n          pathAcum.push( cy.getElementById(end) );\n          pathAcum.push( cy.getElementById(previousEdge) );\n\n\n          return reconstructPath(start, \n                       previous, \n                       cameFromMap, \n                       pathAcum);\n        }\n\n        // We should not reach here!\n        return undefined;       \n      };\n\n      // Returns the index of the element in openSet which has minimum fScore\n      var findMin = function(openSet, fScore) {\n        if (openSet.length === 0) {\n          // Should never be the case\n          return undefined;\n        }\n        var minPos = 0;\n        var tempScore = fScore[openSet[0]];\n        for (var i = 1; i < openSet.length; i++) {\n          var s = fScore[openSet[i]];\n          if (s < tempScore) {\n            tempScore = s;\n            minPos = i;\n          }\n        }\n        return minPos;\n      };\n\n      // Parse options\n      // debug - optional\n      if (options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n\n      logDebug(\"Starting aStar...\"); \n      var cy = this._private.cy;\n\n      // root - mandatory!\n      if (options != null && options.root != null) {        \n        var source = $$.is.string(options.root) ? \n          // use it as a selector, e.g. \"#rootID\n          this.filter(options.root)[0] : \n          options.root[0];\n        logDebug(\"Source node: %s\", source.id()); \n      } else {\n        return undefined;\n      }\n      \n      // goal - mandatory!\n      if (options.goal != null) {       \n        var target = $$.is.string(options.goal) ? \n          // use it as a selector, e.g. \"#goalID\n          this.filter(options.goal)[0] : \n          options.goal[0];\n        logDebug(\"Target node: %s\", target.id()); \n      } else {\n        return undefined;\n      }\n\n      // Heuristic function - optional\n      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       \n        var heuristic = options.heuristic;\n      } else {\n        var heuristic = function(){ return 0; }; // use constant if unspecified\n        // $$.util.error(\"Missing required parameter (heuristic)! Aborting.\");\n        // return;\n      }\n\n      // Weight function - optional\n      if (options.weight != null && $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;};\n      }\n\n      // directed - optional\n      if (options.directed != null) {       \n        var directed = options.directed;\n      } else {\n        var directed = false;\n      }\n\n      var closedSet = [];\n      var openSet = [source.id()];\n      var cameFrom = {};\n      var cameFromEdge = {};\n      var gScore = {};\n      var fScore = {};\n\n      gScore[source.id()] = 0;\n      fScore[source.id()] = heuristic(source);\n      \n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n\n      // Counter\n      var steps = 0;\n\n      // Main loop \n      while (openSet.length > 0) {\n        var minPos = findMin(openSet, fScore);\n        var cMin = this.filter(\"#\" + openSet[minPos])[0];\n        steps++;\n\n        logDebug(\"\\nStep: %s\", steps);\n        logDebug(\"Processing node: %s, fScore = %s\", cMin.id(), fScore[cMin.id()]);\n        \n        // If we've found our goal, then we are done\n        if (cMin.id() == target.id()) {\n          logDebug(\"Found goal node!\");\n          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);\n          rPath.reverse();\n          logDebug(\"Path: %s\", rPath);\n          return {\n            found : true,\n            distance : gScore[cMin.id()],\n            path : new $$.Collection(cy, rPath),\n            steps : steps\n          };          \n        }\n        \n        // Add cMin to processed nodes\n        closedSet.push(cMin.id());\n        // Remove cMin from boundary nodes\n        openSet.splice(minPos, 1);\n        logDebug(\"Added node to closedSet, removed from openSet.\");\n        logDebug(\"Processing neighbors...\");\n\n        // Update scores for neighbors of cMin\n        // Take into account if graph is directed or not\n        var vwEdges = cMin.connectedEdges(directed ? '[source = \"' + cMin.id() + '\"]' \n                         : undefined).intersect(edges);         \n        for (var i = 0; i < vwEdges.length; i++) {\n          var e = vwEdges[i];\n          var w = e.connectedNodes('[id != \"' + cMin.id() + '\"]').intersect(nodes);\n\n          logDebug(\"   processing neighbor: %s\", w.id());\n          // if node is in closedSet, ignore it\n          if (closedSet.indexOf(w.id()) != -1) {\n            logDebug(\"   already in closedSet, ignoring it.\");\n            continue;\n          }\n          \n          // New tentative score for node w\n          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);\n          logDebug(\"   tentative gScore: %d\", tempScore);\n\n          // Update gScore for node w if:\n          //   w not present in openSet\n          // OR\n          //   tentative gScore is less than previous value\n\n          // w not in openSet\n          if (openSet.indexOf(w.id()) == -1) {\n            gScore[w.id()] = tempScore;\n            fScore[w.id()] = tempScore + heuristic(w);\n            openSet.push(w.id()); // Add node to openSet\n            cameFrom[w.id()] = cMin.id();\n            cameFromEdge[w.id()] = e.id();\n            logDebug(\"   not in openSet, adding it. \");\n            logDebug(\"   fScore(%s) = %s\", w.id(), tempScore);\n            continue;\n          }\n          // w already in openSet, but with greater gScore\n          if (tempScore < gScore[w.id()]) {\n            gScore[w.id()] = tempScore;\n            fScore[w.id()] = tempScore + heuristic(w);\n            cameFrom[w.id()] = cMin.id();\n            logDebug(\"   better score, replacing gScore. \");\n            logDebug(\"   fScore(%s) = %s\", w.id(), tempScore);\n          }\n\n        } // End of neighbors update\n\n      } // End of main loop\n\n      // If we've reached here, then we've not reached our goal\n      logDebug(\"Reached end of computation without finding our goal\");\n      return {\n        found : false,\n        distance : undefined,\n        path : undefined,\n        steps : steps\n      };\n    }, // aStar()\n\n\n    // Implemented from pseudocode from wikipedia\n    // options => options object\n    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges\n    //   directed // default false\n    // retObj => returned object by function\n    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID \"fromID\" to node with ID \"toId\", as an array of node IDs\n    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID \"fromID\" to node with ID \"toId\"\n    floydWarshall: function(options) {\n      options = options || {};\n\n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Parse options\n      // debug - optional\n      if (options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting floydWarshall...\"); \n\n      var cy = this._private.cy;\n\n      // Weight function - optional\n      if (options.weight != null && $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;};\n      }\n\n      // directed - optional\n      if (options.directed != null) {       \n        var directed = options.directed;\n      } else {\n        var directed = false;\n      }\n\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n\n      // mapping: node id -> position in nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }     \n\n      // Initialize distance matrix\n      var dist = [];\n      for (var i = 0; i < numNodes; i++) {\n        var newRow = new Array(numNodes);\n        for (var j = 0; j < numNodes; j++) {\n          if (i == j) {\n            newRow[j] = 0;\n          } else {\n            newRow[j] = Infinity;\n          }\n        }\n        dist.push(newRow);\n      }           \n\n      // Initialize matrix used for path reconstruction\n      // Initialize distance matrix\n      var next = [];\n      var edgeNext = [];\n\n      var initMatrix = function(next){\n        for (var i = 0; i < numNodes; i++) {\n          var newRow = new Array(numNodes);\n          for (var j = 0; j < numNodes; j++) {\n            newRow[j] = undefined;\n          }\n          next.push(newRow);\n        }\n      };\n\n      initMatrix(next);\n      initMatrix(edgeNext);\n      \n      // Process edges\n      for (var i = 0; i < edges.length ; i++) {     \n        var sourceIndex = id2position[edges[i].source().id()];\n        var targetIndex = id2position[edges[i].target().id()];    \n        var weight = weightFn.apply(edges[i], [edges[i]]);\n        \n        // Check if already process another edge between same 2 nodes\n        if (dist[sourceIndex][targetIndex] > weight) {\n          dist[sourceIndex][targetIndex] = weight;\n          next[sourceIndex][targetIndex] = targetIndex;\n          edgeNext[sourceIndex][targetIndex] = edges[i];\n        }\n      }\n\n      // If undirected graph, process 'reversed' edges\n      if (!directed) {\n        for (var i = 0; i < edges.length ; i++) {     \n          var sourceIndex = id2position[edges[i].target().id()];    \n          var targetIndex = id2position[edges[i].source().id()];\n          var weight = weightFn.apply(edges[i], [edges[i]]);\n          \n          // Check if already process another edge between same 2 nodes\n          if (dist[sourceIndex][targetIndex] > weight) {\n            dist[sourceIndex][targetIndex] = weight;\n            next[sourceIndex][targetIndex] = targetIndex;\n            edgeNext[sourceIndex][targetIndex] = edges[i];\n          }\n        }\n      }\n\n      // Main loop\n      for (var k = 0; k < numNodes; k++) {\n        for (var i = 0; i < numNodes; i++) {\n          for (var j = 0; j < numNodes; j++) {            \n            if (dist[i][k] + dist[k][j] < dist[i][j]) {\n              dist[i][j] = dist[i][k] + dist[k][j];\n              next[i][j] = next[i][k];\n            }\n          }\n        }\n      }\n\n      // Build result object       \n      var position2id = [];\n      for (var i = 0; i < numNodes; i++) {\n        position2id.push(nodes[i].id());\n      }\n\n      var res = {\n        distance: function(from, to) {\n          if ($$.is.string(from)) {\n            // from is a selector string\n            var fromId = (cy.filter(from)[0]).id();\n          } else {\n            // from is a node\n            var fromId = from.id();\n          }\n\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n\n          return dist[id2position[fromId]][id2position[toId]];\n        },\n\n        path: function(from, to) {\n          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {\n            if (from === to) {\n              return cy.getElementById( position2id[from] );\n            }\n            if (next[from][to] === undefined) {\n              return undefined;\n            }\n\n            var path = [ cy.getElementById(position2id[from]) ];\n            var prev = from;\n            while (from !== to) {\n              prev = from;\n              from = next[from][to];\n\n              var edge = edgeNext[prev][from];\n              path.push( edge );\n\n              path.push( cy.getElementById(position2id[from]) );\n            }\n            return path;\n          };\n\n          if ($$.is.string(from)) {\n            // from is a selector string\n            var fromId = (cy.filter(from)[0]).id();\n          } else {\n            // from is a node\n            var fromId = from.id();\n          }\n\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n          \n          var pathArr = reconstructPathAux(id2position[fromId], \n                        id2position[toId], \n                        next,\n                        position2id,\n                        edgeNext);\n\n          return new $$.Collection( cy, pathArr );\n        },\n      };\n\n      return res;\n\n    }, // floydWarshall\n\n\n    // Implemented from pseudocode from wikipedia\n    // options => options object\n    //   root: starting node (either element or selector string)\n    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges\n    //   directed // default false\n    // retObj => returned object by function\n    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID \"toId\", as an array of node IDs\n    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID \"toId\"\n    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)\n    bellmanFord: function(options) {\n      options = options || {};\n\n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Parse options\n      // debug - optional\n      if (options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting bellmanFord...\"); \n\n      // Weight function - optional\n      if (options.weight != null && $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;};\n      }\n\n      // directed - optional\n      if (options.directed != null) {       \n        var directed = options.directed;\n      } else {\n        var directed = false;\n      }\n\n      // root - mandatory!\n      if (options.root != null) {       \n        if ($$.is.string(options.root)) {\n          // use it as a selector, e.g. \"#rootID\n          var source = this.filter(options.root)[0];\n        } else {\n          var source = options.root[0];\n        }\n        logDebug(\"Source node: %s\", source.id()); \n      } else {\n        $$.util.error(\"options.root required\");\n        return undefined;\n      }\n\n      var cy = this._private.cy;\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n\n      // mapping: node id -> position in nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }     \n\n      // Initializations\n      var cost = [];\n      var predecessor = [];\n      var predEdge = [];\n      \n      for (var i = 0; i < numNodes; i++) {\n        if (nodes[i].id() === source.id()) {\n          cost[i] = 0;\n        } else {\n          cost[i] = Infinity;\n        } \n        predecessor[i] = undefined;\n      }\n      \n      // Edges relaxation      \n      var flag = false;\n      for (var i = 1; i < numNodes; i++) {\n        flag = false;\n        for (var e = 0; e < edges.length; e++) {\n          var sourceIndex = id2position[edges[e].source().id()];\n          var targetIndex = id2position[edges[e].target().id()];    \n          var weight = weightFn.apply(edges[e], [edges[e]]);\n          \n          var temp = cost[sourceIndex] + weight;\n          if (temp < cost[targetIndex]) {\n            cost[targetIndex] = temp;\n            predecessor[targetIndex] = sourceIndex;\n            predEdge[targetIndex] = edges[e];\n            flag = true;\n          }\n\n          // If undirected graph, we need to take into account the 'reverse' edge\n          if (!directed) {\n            var temp = cost[targetIndex] + weight;\n            if (temp < cost[sourceIndex]) {\n              cost[sourceIndex] = temp;\n              predecessor[sourceIndex] = targetIndex;\n              predEdge[sourceIndex] = edges[e];\n              flag = true;\n            }\n          }\n        }\n\n        if (!flag) {\n          break;\n        }\n      }      \n            \n      if (flag) {\n        // Check for negative weight cycles\n        for (var e = 0; e < edges.length; e++) {\n          var sourceIndex = id2position[edges[e].source().id()];\n          var targetIndex = id2position[edges[e].target().id()];    \n          var weight = weightFn.apply(edges[e], [edges[e]]);\n          \n          if (cost[sourceIndex] + weight < cost[targetIndex]) {\n            $$.util.error(\"Error: graph contains a negative weigth cycle!\"); \n            return { pathTo: undefined,\n                 distanceTo: undefined,\n                 hasNegativeWeightCycle: true};\n          }\n        }     \n      }\n\n      // Build result object       \n      var position2id = [];\n      for (var i = 0; i < numNodes; i++) {\n        position2id.push(nodes[i].id());\n      }\n      \n      \n      var res = {       \n        distanceTo : function(to) {\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n\n          return cost[id2position[toId]];\n        }, \n\n        pathTo : function(to) {\n\n          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {\n            for(;;){\n              // Add toId to path\n              acumPath.push( cy.getElementById(position2id[toPos]) );\n              acumPath.push( predEdge[toPos] );\n\n              if (fromPos === toPos) {\n                // reached starting node\n                return acumPath;\n              }\n\n              // If no path exists, discart acumulated path and return undefined\n              var predPos = predecessor[toPos];\n              if (typeof predPos === \"undefined\") {\n                return undefined;\n              }\n\n              toPos = predPos;\n            }\n\n          };\n\n          if ($$.is.string(to)) {\n            // to is a selector string\n            var toId = (cy.filter(to)[0]).id();\n          } else {\n            // to is a node\n            var toId = to.id();\n          }\n          var path = [];\n\n          // This returns a reversed path \n          var res =  reconstructPathAux(predecessor, \n                        id2position[source.id()],\n                        id2position[toId], \n                        position2id, \n                        path,\n                        predEdge);\n\n          // Get it in the correct order and return it\n          if (res != null) {\n            res.reverse();\n          }\n\n          return new $$.Collection(cy, res);                       \n        }, \n\n        hasNegativeWeightCycle: false\n      };\n\n      return res;\n\n    }, // bellmanFord\n\n\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    // options => options object\n    // \n    // retObj => returned object by function\n    //   cut : list of IDs of edges in the cut,\n    //   partition1: list of IDs of nodes in one partition\n    //   partition2: list of IDs of nodes in the other partition\n    kargerStein: function(options) {\n      options = options || {};\n      \n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n\n      // Function which colapses 2 (meta) nodes into one\n      // Updates the remaining edge lists\n      // Receives as a paramater the edge which causes the collapse\n      var colapse = function(edgeIndex, nodeMap, remainingEdges) {\n        var edgeInfo = remainingEdges[edgeIndex];\n        var sourceIn = edgeInfo[1];\n        var targetIn = edgeInfo[2];\n        var partition1 = nodeMap[sourceIn];\n        var partition2 = nodeMap[targetIn];\n\n        // Delete all edges between partition1 and partition2\n        var newEdges = remainingEdges.filter(function(edge) {\n          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {\n            return false;\n          }\n          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {\n            return false;\n          }\n          return true;\n        });\n        \n        // All edges pointing to partition2 should now point to partition1\n        for (var i = 0; i < newEdges.length; i++) {\n          var edge = newEdges[i];\n          if (edge[1] === partition2) { // Check source\n            newEdges[i] = edge.slice(0);\n            newEdges[i][1] = partition1;\n          } else if (edge[2] === partition2) { // Check target\n            newEdges[i] = edge.slice(0);\n            newEdges[i][2] = partition1;\n          }\n        } \n        \n        // Move all nodes from partition2 to partition1\n        for (var i = 0; i < nodeMap.length; i++) {\n          if (nodeMap[i] === partition2) {\n            nodeMap[i] = partition1;\n          }\n        }\n        \n        return newEdges;\n      };\n\n\n      // Contracts a graph until we reach a certain number of meta nodes\n      var contractUntil = function(metaNodeMap, \n                     remainingEdges,\n                     size, \n                     sizeLimit) {\n        // Stop condition\n        if (size <= sizeLimit) {\n          return remainingEdges;\n        }\n        \n        // Choose an edge randomly\n        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));\n\n        // Colapse graph based on edge\n        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);\n        \n        return contractUntil(metaNodeMap, \n                   newEdges, \n                   size - 1, \n                   sizeLimit);        \n      };\n\n\n      // Parse options\n      // debug - optional\n      if (options != null && options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting kargerStein...\"); \n\n      var cy = this._private.cy;\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n      var numEdges = edges.length;\n      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n      var stopSize = Math.floor(numNodes / Math.sqrt(2));\n\n      if (numNodes < 2) {\n        $$.util.error(\"At least 2 nodes are required for KargerSteing algorithm!\"); \n        return undefined;\n      }\n\n      // Create numerical identifiers for each node\n      // mapping: node id -> position in nodes array\n      // for reverse mapping, simply use nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }\n\n      // Now store edge destination as indexes\n      // Format for each edge (edge index, source node index, target node index)\n      var edgeIndexes = [];\n      for (var i = 0; i < numEdges; i++) {\n        var e = edges[i];\n        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);\n      }\n\n      // We will store the best cut found here\n      var minCutSize = Infinity;\n      var minCut;     \n\n      // Initial meta node partition\n      var originalMetaNode = [];\n      for (var i = 0; i < numNodes; i++) {\n        originalMetaNode.push(i);\n      }\n\n      // Main loop\n      for (var iter = 0; iter <= numIter; iter++) {\n        // Create new meta node partition\n        var metaNodeMap = originalMetaNode.slice(0);\n\n        // Contract until stop point (stopSize nodes)\n        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);\n        \n        // Create a copy of the colapsed nodes state\n        var metaNodeMap2 = metaNodeMap.slice(0);\n\n        // Run 2 iterations starting in the stop state\n        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);\n\n        // Is any of the 2 results the best cut so far?\n        if (res1.length <= res2.length && res1.length < minCutSize) {\n          minCutSize = res1.length;\n          minCut = [res1, metaNodeMap];\n        } else if (res2.length <= res1.length && res2.length < minCutSize) {\n          minCutSize = res2.length;\n          minCut = [res2, metaNodeMap2];\n        }\n      } // end of main loop\n\n      \n      // Construct result\n      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });\n      var partition1 = [];\n      var partition2 = [];\n\n      // traverse metaNodeMap for best cut\n      var witnessNodePartition = minCut[1][0];\n      for (var i = 0; i < minCut[1].length; i++) { \n        var partitionId = minCut[1][i]; \n        if (partitionId === witnessNodePartition) {\n          partition1.push(nodes[i]);\n        } else {\n          partition2.push(nodes[i]);\n        }       \n      }\n      \n      var ret = {\n        cut: new $$.Collection(cy, resEdges),\n        partition1: new $$.Collection(cy, partition1),\n        partition2: new $$.Collection(cy, partition2)\n      };\n      \n      return ret;\n    },\n\n\n    // \n    // options => options object\n    //   dampingFactor: optional\n    //   precision: optional\n    //   iterations : optional\n    // retObj => returned object by function\n    //  rank : function that returns the pageRank of a given node (object or selector string)\n    pageRank: function(options) {\n      options = options || {};\n      \n      var normalizeVector = function(vector) {\n        var length = vector.length;\n\n        // First, get sum of all elements\n        var total = 0; \n        for (var i = 0; i < length; i++) {\n          total += vector[i];\n        }\n\n        // Now, divide each by the sum of all elements\n        for (var i = 0; i < length; i++) {\n          vector[i] = vector[i] / total;\n        }\n      };\n      \n      var logDebug = function() {\n        if (debug) {\n          console.log.apply(console, arguments);\n        }\n      };\n      \n      // Parse options\n      // debug - optional\n      if (options != null && \n        options.debug != null) {\n        var debug = options.debug;\n      } else {\n        var debug = false;\n      }\n      logDebug(\"Starting pageRank...\"); \n\n      // dampingFactor - optional\n      if (options != null && \n        options.dampingfactor != null) {\n        var dampingFactor = options.dampingFactor;\n      } else {\n        var dampingFactor = 0.8; // Default damping factor\n      }\n\n      // desired precision - optional\n      if (options != null && \n        options.precision != null) {\n        var epsilon = options.precision;\n      } else {\n        var epsilon = 0.000001; // Default precision\n      }\n\n      // Max number of iterations - optional\n      if (options != null && \n        options.iterations != null) {\n        var numIter = options.iterations;\n      } else {\n        var numIter = 200; // Default number of iterations\n      }\n\n      // Weight function - optional\n      if (options != null && \n        options.weight != null && \n        $$.is.fn(options.weight)) {       \n        var weightFn = options.weight;\n      } else {\n        // If not specified, assume each edge has equal weight (1)\n        var weightFn = function(e) {return 1;}; \n      }\n\n      var cy = this._private.cy;\n      var edges = this.edges().not(':loop');\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n      var numEdges = edges.length;\n\n      // Create numerical identifiers for each node\n      // mapping: node id -> position in nodes array\n      // for reverse mapping, simply use nodes array\n      var id2position = {};\n      for (var i = 0; i < numNodes; i++) {\n        id2position[nodes[i].id()] = i;\n      }\n\n      // Construct transposed adjacency matrix\n      // First lets have a zeroed matrix of the right size\n      // We'll also keep track of the sum of each column\n      var matrix = [];\n      var columnSum = [];\n      var additionalProb = (1 - dampingFactor) / numNodes;\n\n      // Create null matric\n      for (var i = 0; i < numNodes; i++) { \n        var newRow = [];\n        for (var j = 0; j < numNodes; j++) {\n          newRow.push(0.0);\n        }\n        matrix.push(newRow);\n        columnSum.push(0.0);\n      }\n\n      // Now, process edges\n      for (var i = 0; i < numEdges; i++) {\n        var edge = edges[i];\n        var s = id2position[edge.source().id()];\n        var t = id2position[edge.target().id()];\n        var w = weightFn.apply(edge, [edge]);\n        \n        // Update matrix\n        matrix[t][s] += w;\n\n        // Update column sum\n        columnSum[s] += w; \n      }\n\n      // Add additional probability based on damping factor\n      // Also, take into account columns that have sum = 0\n      var p = 1.0 / numNodes + additionalProb; // Shorthand\n      // Traverse matrix, column by column\n      for (var j = 0; j < numNodes; j++) { \n        if (columnSum[j] === 0) {\n          // No 'links' out from node jth, assume equal probability for each possible node\n          for (var i = 0; i < numNodes; i++) {\n            matrix[i][j] = p;\n          }\n        } else {\n          // Node jth has outgoing link, compute normalized probabilities\n          for (var i = 0; i < numNodes; i++) {\n            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;\n          }         \n        }\n      }\n\n      // Compute dominant eigenvector using power method\n      var eigenvector = [];\n      var nullVector = [];\n      var previous;\n\n      // Start with a vector of all 1's\n      // Also, initialize a null vector which will be used as shorthand\n      for (var i = 0; i < numNodes; i++) {\n        eigenvector.push(1.0);\n        nullVector.push(0.0);\n      }\n            \n      for (var iter = 0; iter < numIter; iter++) {\n        // New array with all 0's\n        var temp = nullVector.slice(0);\n        \n        // Multiply matrix with previous result\n        for (var i = 0; i < numNodes; i++) {\n          for (var j = 0; j < numNodes; j++) {        \n            temp[i] += matrix[i][j] * eigenvector[j];\n          }\n        }\n\n        normalizeVector(temp);\n        previous = eigenvector;\n        eigenvector = temp;\n\n        var diff = 0;\n        // Compute difference (squared module) of both vectors\n        for (var i = 0; i < numNodes; i++) {\n          diff += Math.pow(previous[i] - eigenvector[i], 2);\n        }\n        \n        // If difference is less than the desired threshold, stop iterating\n        if (diff < epsilon) {\n          logDebug(\"Stoped at iteration %s\", iter);\n          break;\n        }\n      }\n            \n      logDebug(\"Result:\\n\" + eigenvector);\n\n      // Construct result\n      var res = {\n        rank : function(node) {\n          if ($$.is.string(node)) {\n            // is a selector string\n            var nodeId = (cy.filter(node)[0]).id();\n          } else {\n            // is a node object\n            var nodeId = node.id();\n          }\n          return eigenvector[id2position[nodeId]];\n        }\n      };\n\n\n      return res;\n    } // pageRank\n\n  }); // $$.fn.eles\n\n\n}) (cytoscape);\n;(function( $$ ){ 'use strict';\n\n  $$.fn.eles({\n    animated: $$.define.animated(),\n    clearQueue: $$.define.clearQueue(),\n    delay: $$.define.delay(),\n    animate: $$.define.animate(),\n    stop: $$.define.stop()\n  });\n  \n})( cytoscape );  \n\n;(function( $$ ){ 'use strict';\n  \n  $$.fn.eles({\n    classes: function(opts){\n      var eles = this;\n      var changed = [];\n      var fn;\n\n      if( $$.is.fn(opts) ){\n        fn = opts;\n\n      } else if( !$$.is.plainObject(opts) ){\n        return this; // needs opts or fn\n      } \n\n      for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var eleChanged = false;\n\n        opts = fn ? fn.apply(ele, [i, ele]) : opts;\n\n        // add classes\n        if( opts.add ){ for( var j = 0; j < opts.add.length; j++ ){\n          var cls = opts.add[j];\n          var hasClass = ele._private.classes[cls];\n\n          ele._private.classes[cls] = true;\n\n          if( !hasClass && !eleChanged ){\n            changed.push( ele );\n            eleChanged = true;\n          }\n        } }\n\n        // remove classes\n        if( opts.remove ){ for( var j = 0; j < opts.remove.length; j++ ){\n          var cls = opts.remove[j];\n          var hasClass = ele._private.classes[cls];\n\n          ele._private.classes[cls] = false;\n\n          if( hasClass && !eleChanged ){\n            changed.push( ele );\n            eleChanged = true;\n          }\n        } }\n\n        // toggle classes\n        if( opts.toggle ){ for( var j = 0; j < opts.toggle.length; j++ ){\n          var cls = opts.toggle[j];\n          var hasClass = ele._private.classes[cls];\n\n          ele._private.classes[cls] = !hasClass;\n\n          if( !eleChanged ){\n            changed.push( ele );\n            eleChanged = true;\n          }\n        } }\n      }\n\n      if( changed.length > 0 ){\n        new $$.Collection( this.cy(), changed )\n          .updateStyle()\n          .trigger('class')\n        ;\n      }\n\n      return this;\n    },\n\n    addClass: function(classes){\n      classes = classes.split(/\\s+/);\n      var self = this;\n      var changed = [];\n      \n      for( var i = 0; i < classes.length; i++ ){\n        var cls = classes[i];\n        if( $$.is.emptyString(cls) ){ continue; }\n        \n        for( var j = 0; j < self.length; j++ ){\n          var ele = self[j];\n          var hasClass = ele._private.classes[cls];\n          ele._private.classes[cls] = true;\n\n          if( !hasClass ){ // if didn't already have, add to list of changed\n            changed.push( ele );\n          }\n        }\n      }\n      \n      // trigger update style on those eles that had class changes\n      if( changed.length > 0 ){\n        new $$.Collection(this._private.cy, changed)\n          .updateStyle()\n          .trigger('class')\n        ;\n      }\n\n      return self;\n    },\n\n    hasClass: function(className){\n      var ele = this[0];\n      return ( ele != null && ele._private.classes[className] ) ? true : false;\n    },\n\n    toggleClass: function(classesStr, toggle){\n      var classes = classesStr.split(/\\s+/);\n      var self = this;\n      var changed = []; // eles who had classes changed\n      \n      for( var i = 0, il = self.length; i < il; i++ ){\n        var ele = self[i];\n\n        for( var j = 0; j < classes.length; j++ ){\n          var cls = classes[j];\n\n          if( $$.is.emptyString(cls) ){ continue; }\n          \n          var hasClass = ele._private.classes[cls];\n          var shouldAdd = toggle || (toggle === undefined && !hasClass);\n\n          if( shouldAdd ){\n            ele._private.classes[cls] = true;\n\n            if( !hasClass ){ changed.push(ele); }\n          } else { // then remove\n            ele._private.classes[cls] = false;\n\n            if( hasClass ){ changed.push(ele); }\n          }\n\n        } // for j classes\n      } // for i eles\n      \n      // trigger update style on those eles that had class changes\n      if( changed.length > 0 ){\n        new $$.Collection(this._private.cy, changed)\n          .updateStyle()\n          .trigger('class')\n        ;\n      }\n\n      return self;\n    },\n\n    removeClass: function(classes){\n      classes = classes.split(/\\s+/);\n      var self = this;\n      var changed = [];\n\n      for( var i = 0; i < self.length; i++ ){\n        var ele = self[i];\n\n        for( var j = 0; j < classes.length; j++ ){\n          var cls = classes[j];\n          if( !cls || cls === '' ){ continue; }\n\n          var hasClass = ele._private.classes[cls];\n          ele._private.classes[cls] = undefined;\n\n          if( hasClass ){ // then we changed its set of classes\n            changed.push( ele );\n          }\n        }\n      }\n      \n      // trigger update style on those eles that had class changes\n      if( changed.length > 0 ){\n        new $$.Collection(self._private.cy, changed).updateStyle();\n      }\n\n      self.trigger('class');\n      return self;\n    },\n\n    flashClass: function(classes, duration){\n      var self = this;\n\n      if( duration == null ){\n        duration = 250;\n      } else if( duration === 0 ){\n        return self; // nothing to do really\n      }\n\n      self.addClass( classes );\n      setTimeout(function(){\n        self.removeClass( classes );\n      }, duration);\n\n      return self;\n    }\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n    allAre: function( selector ){\n      return this.filter(selector).length === this.length;\n    },\n\n    is: function( selector ){\n      return this.filter(selector).length > 0;\n    },\n\n    some: function( fn, thisArg ){\n      for( var i = 0; i < this.length; i++ ){\n        var ret = fn.apply( thisArg, [ this[i], i, this ] );\n\n        if( ret ){\n          return true;\n        }\n      }\n\n      return false;\n    },\n\n    every: function( fn, thisArg ){\n      for( var i = 0; i < this.length; i++ ){\n        var ret = fn.apply( thisArg, [ this[i], i, this ] );\n\n        if( !ret ){\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    same: function( collection ){\n      collection = this.cy().collection( collection );\n\n      // cheap extra check\n      if( this.length !== collection.length ){\n        return false;\n      }\n\n      return this.intersect( collection ).length === this.length;\n    },\n\n    anySame: function( collection ){\n      collection = this.cy().collection( collection );\n\n      return this.intersect( collection ).length > 0;\n    },\n\n    allAreNeighbors: function( collection ){\n      collection = this.cy().collection( collection );\n\n      return this.neighborhood().intersect( collection ).length === collection.length;\n    }\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // Compound functions\n  /////////////////////\n\n  $$.fn.eles({\n    parent: function( selector ){\n      var parents = [];\n      var cy = this._private.cy;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        var parent = cy.getElementById( ele._private.data.parent );\n\n        if( parent.size() > 0 ){\n          parents.push( parent );\n        }\n      }\n      \n      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );\n    },\n\n    parents: function( selector ){\n      var parents = [];\n\n      var eles = this.parent();\n      while( eles.nonempty() ){\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n          parents.push( ele );\n        }\n\n        eles = eles.parent();\n      }\n\n      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );\n    },\n\n    commonAncestors: function( selector ){\n      var ancestors;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        var parents = ele.parents();\n        \n        ancestors = ancestors || parents;\n\n        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set\n      }\n\n      return ancestors.filter( selector );\n    },\n\n    orphans: function( selector ){\n      return this.stdFilter(function( ele ){\n        return ele.isNode() && ele.parent().empty();\n      }).filter( selector );\n    },\n\n    nonorphans: function( selector ){\n      return this.stdFilter(function( ele ){\n        return ele.isNode() && ele.parent().nonempty();\n      }).filter( selector );\n    },\n\n    children: function( selector ){\n      var children = [];\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        children = children.concat( ele._private.children );\n      }\n\n      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );\n    },\n\n    siblings: function( selector ){\n      return this.parent().children().not( this ).filter( selector );\n    },\n\n    isParent: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.children.length !== 0;\n      }\n    },\n\n    isChild: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.data.parent !== undefined && ele.parent().length !== 0;\n      }\n    },\n\n    descendants: function( selector ){\n      var elements = [];\n\n      function add( eles ){\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          elements.push( ele );\n\n          if( ele.children().nonempty() ){\n            add( ele.children() );\n          }\n        }\n      }\n\n      add( this.children() );\n\n      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );\n    }\n  });\n\n  // aliases\n  $$.elesfn.ancestors = $$.elesfn.parents;\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  var borderWidthMultiplier = 2 * 0.5;\n  var borderWidthAdjustment = 0;\n\n  $$.fn.eles({\n\n    data: $$.define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n\n    removeData: $$.define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n\n    scratch: $$.define.data({\n      field: 'scratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n\n    removeScratch: $$.define.removeData({\n      field: 'scratch',\n      triggerEvent: false\n    }),\n\n    rscratch: $$.define.data({\n      field: 'rscratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n\n    removeRscratch: $$.define.removeData({\n      field: 'rscratch',\n      triggerEvent: false\n    }),\n\n    id: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.data.id;\n      }\n    },\n\n    position: $$.define.data({\n      field: 'position',\n      bindingEvent: 'position',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'position',\n      settingTriggersEvent: true,\n      triggerFnName: 'rtrigger',\n      allowGetting: true,\n      validKeys: ['x', 'y'],\n      onSet: function( eles ){\n        var updatedEles = eles.updateCompoundBounds();\n        updatedEles.rtrigger('position');\n      },\n      canSet: function( ele ){\n        return !ele.locked();\n      }\n    }),\n\n    // position but no notification to renderer\n    silentPosition: $$.define.data({\n      field: 'position',\n      bindingEvent: 'position',\n      allowBinding: false,\n      allowSetting: true,\n      settingEvent: 'position',\n      settingTriggersEvent: false,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      validKeys: ['x', 'y'],\n      onSet: function( eles ){\n        eles.updateCompoundBounds();\n      },\n      canSet: function( ele ){\n        return !ele.locked();\n      }\n    }),\n\n    positions: function( pos, silent ){\n      if( $$.is.plainObject(pos) ){\n        this.position(pos);\n        \n      } else if( $$.is.fn(pos) ){\n        var fn = pos;\n        \n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n\n          var pos = fn.apply(ele, [i, ele]);\n\n          if( pos && !ele.locked() ){\n            var elePos = ele._private.position;\n            elePos.x = pos.x;\n            elePos.y = pos.y;\n          }\n        }\n\n        var updatedEles = this.updateCompoundBounds();\n        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;\n\n        if( silent ){\n          toTrigger.trigger('position');\n        } else {\n          toTrigger.rtrigger('position');\n        }\n      }\n\n      return this; // chaining\n    },\n\n    silentPositions: function( pos ){\n      return this.positions( pos, true );\n    },\n\n    updateCompoundBounds: function(){\n      var cy = this.cy();\n\n      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled\n\n      var updated = [];\n\n      function update( parent ){\n        var children = parent.children();\n        var style = parent._private.style;\n        var bb = children.boundingBox({ includeLabels: false, includeEdges: false });\n        var padding = {\n          top: style['padding-top'].pxValue,\n          bottom: style['padding-bottom'].pxValue,\n          left: style['padding-left'].pxValue,\n          right: style['padding-right'].pxValue\n        };\n        var pos = parent._private.position;\n        var didUpdate = false;\n\n        if( style['width'].value === 'auto' ){\n          parent._private.autoWidth = bb.w + padding.left + padding.right;\n          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;\n          didUpdate = true;\n        }\n\n        if( style['height'].value === 'auto' ){\n          parent._private.autoHeight = bb.h + padding.top + padding.bottom;\n          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;\n          didUpdate = true;\n        }\n\n        if( didUpdate ){\n          updated.push( parent );\n        }\n      }\n\n      // go up, level by level\n      var eles = this.parent();\n      while( eles.nonempty() ){\n\n        // update each parent node in this level\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          update( ele );\n        }\n\n        // next level\n        eles = eles.parent();\n      }\n\n      // return changed\n      return new $$.Collection( cy, updated );\n    },\n\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function( dim, val ){\n      var ele = this[0];\n      var cy = this.cy();\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var rpos = $$.is.plainObject( dim ) ? dim : undefined;\n      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );\n\n      if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n        if( setting ){\n          for( var i = 0; i < this.length; i++ ){\n            var ele = this[i];\n\n            if( val !== undefined ){ // set one dimension\n              ele._private.position[dim] = ( val - pan[dim] )/zoom;\n            } else if( rpos !== undefined ){ // set whole position\n              ele._private.position = {\n                x: ( rpos.x - pan.x ) /zoom,\n                y: ( rpos.y - pan.y ) /zoom\n              };\n            }\n          }\n\n          this.rtrigger('position');\n        } else { // getting\n          var pos = ele._private.position;\n          rpos = {\n            x: pos.x * zoom + pan.x,\n            y: pos.y * zoom + pan.y\n          };\n\n          if( dim === undefined ){ // then return the whole rendered position\n            return rpos;\n          } else { // then return the specified dimension\n            return rpos[ dim ];\n          }\n        }\n      } else if( !setting ){\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    },\n\n    // get/set the position relative to the parent\n    parentPosition: function( dim, val ){\n      var ele = this[0];\n      var cy = this.cy();\n      var ppos = $$.is.plainObject( dim ) ? dim : undefined;\n      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if( ele && ele.isNode() ){ // must have an element and must be a node to return position\n        if( setting ){\n          for( var i = 0; i < this.length; i++ ){\n            var ele = this[i];\n            var parent = hasCompoundNodes ? ele.parent() : null;\n            var hasParent = parent && parent.length > 0;\n            var relativeToParent = hasParent;\n\n            if( hasParent ){\n              parent = parent[0];\n            }\n\n            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\n            if( val !== undefined ){ // set one dimension\n              ele._private.position[dim] = val + origin[dim];\n            } else if( ppos !== undefined ){ // set whole position\n              ele._private.position = {\n                x: ppos.x + origin.x,\n                y: ppos.y + origin.y,\n              };\n            }\n          }\n\n          this.rtrigger('position');\n\n        } else { // getting\n          var pos = ele._private.position;\n          var parent = hasCompoundNodes ? ele.parent() : null;\n          var hasParent = parent && parent.length > 0;\n          var relativeToParent = hasParent;\n\n          if( hasParent ){\n            parent = parent[0];\n          }\n\n          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };\n\n          ppos = {\n            x: pos.x - origin.x,\n            y: pos.y - origin.y\n          };\n\n          if( dim === undefined ){ // then return the whole rendered position\n            return ppos;\n          } else { // then return the specified dimension\n            return ppos[ dim ];\n          }\n        }\n      } else if( !setting ){\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    },\n\n    // convenience function to get a numerical value for the width of the node/edge\n    width: function(){\n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele ){\n        if( styleEnabled ){\n          var w = ele._private.style.width;\n          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;\n        } else {\n          return 1;\n        }\n      }\n    },\n\n    outerWidth: function(){\n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele ){\n        if( styleEnabled ){\n          var style = ele._private.style;\n          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;\n          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;\n\n          return width + border;\n        } else {\n          return 1;\n        }\n      }\n    },\n\n    renderedWidth: function(){\n      var ele = this[0];\n\n      if( ele ){\n        var width = ele.width();\n        return width * this.cy().zoom();\n      }\n    },\n\n    renderedOuterWidth: function(){\n      var ele = this[0];\n\n      if( ele ){\n        var owidth = ele.outerWidth();\n        return owidth * this.cy().zoom();\n      }\n    },\n\n    // convenience function to get a numerical value for the height of the node\n    height: function(){ \n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele && ele._private.group === 'nodes' ){\n        if( styleEnabled ){\n          var h = ele._private.style.height;\n          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;\n        } else {\n          return 1;\n        }\n      }\n    },\n\n    outerHeight: function(){\n      var ele = this[0];\n      var cy = ele._private.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if( ele && ele._private.group === 'nodes' ){\n        if( styleEnabled ){\n          var style = ele._private.style;\n          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;\n          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;\n        } else {\n          return 1;\n        }\n\n        return height + border;\n      }\n    },\n\n    renderedHeight: function(){\n      var ele = this[0];\n\n      if( ele && ele._private.group === 'nodes' ){\n        var height = ele.height();\n        return height * this.cy().zoom();\n      }\n    },\n\n    renderedOuterHeight: function(){\n      var ele = this[0];\n\n      if( ele && ele._private.group === 'nodes' ){\n        var oheight = ele.outerHeight();\n        return oheight * this.cy().zoom();\n      }\n    },\n\n    renderedBoundingBox: function( options ){\n      var bb = this.boundingBox( options );\n      var cy = this.cy();\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n\n      var x1 = bb.x1 * zoom + pan.x;\n      var x2 = bb.x2 * zoom + pan.x;\n      var y1 = bb.y1 * zoom + pan.y;\n      var y2 = bb.y2 * zoom + pan.y;\n\n      return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n      };\n    },\n\n    // get the bounding box of the elements (in raw model position)\n    boundingBox: function( options ){\n      var eles = this;\n      var cy = eles._private.cy;\n      var cy_p = cy._private;\n      var styleEnabled = cy_p.styleEnabled;\n\n      options = options || {};\n\n      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;\n      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;\n      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;\n\n      // recalculate projections etc\n      if( styleEnabled ){\n        cy_p.renderer.recalculateRenderedStyle( this );\n      }\n\n      var x1 = Infinity;\n      var x2 = -Infinity;\n      var y1 = Infinity;\n      var y2 = -Infinity;\n\n      // find bounds of elements\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var _p = ele._private;\n        var display = styleEnabled ? _p.style['display'].value : 'element';\n        var isNode = _p.group === 'nodes';\n        var ex1, ex2, ey1, ey2, x, y;\n        var includedEle = false;\n\n        if( display === 'none' ){ continue; } // then ele doesn't take up space      \n\n        if( isNode && includeNodes ){\n          includedEle = true;\n\n          var pos = _p.position;\n          x = pos.x;\n          y = pos.y;\n          var w = ele.outerWidth();\n          var halfW = w/2;\n          var h = ele.outerHeight();\n          var halfH = h/2;\n\n          // handle node dimensions\n          /////////////////////////\n\n          ex1 = x - halfW;\n          ex2 = x + halfW;\n          ey1 = y - halfH;\n          ey2 = y + halfH;\n\n          x1 = ex1 < x1 ? ex1 : x1;\n          x2 = ex2 > x2 ? ex2 : x2;\n          y1 = ey1 < y1 ? ey1 : y1;\n          y2 = ey2 > y2 ? ey2 : y2;\n\n        } else if( ele.isEdge() && includeEdges ){ \n          includedEle = true;\n\n          var n1pos = ele._private.source._private.position;\n          var n2pos = ele._private.target._private.position;\n\n          // handle edge dimensions (rough box estimate)\n          //////////////////////////////////////////////\n\n          var rstyle = ele._private.rstyle || {};\n\n          ex1 = n1pos.x;\n          ex2 = n2pos.x;\n          ey1 = n1pos.y;\n          ey2 = n2pos.y;\n\n          if( ex1 > ex2 ){\n            var temp = ex1;\n            ex1 = ex2;\n            ex2 = temp;\n          }\n\n          if( ey1 > ey2 ){\n            var temp = ey1;\n            ey1 = ey2;\n            ey2 = temp;\n          }\n\n          x1 = ex1 < x1 ? ex1 : x1;\n          x2 = ex2 > x2 ? ex2 : x2;\n          y1 = ey1 < y1 ? ey1 : y1;\n          y2 = ey2 > y2 ? ey2 : y2;\n\n          // handle points along edge (sanity check)\n          //////////////////////////////////////////\n\n          if( styleEnabled ){\n            var bpts = rstyle.bezierPts || [];\n\n            var w = ele._private.style['width'].pxValue;\n            var wHalf = w/2;\n\n            for( var j = 0; j < bpts.length; j++ ){\n              var bpt = bpts[j];\n\n              ex1 = bpt.x - wHalf;\n              ex2 = bpt.x + wHalf;\n              ey1 = bpt.y - wHalf;\n              ey2 = bpt.y + wHalf;\n\n              x1 = ex1 < x1 ? ex1 : x1;\n              x2 = ex2 > x2 ? ex2 : x2;\n              y1 = ey1 < y1 ? ey1 : y1;\n              y2 = ey2 > y2 ? ey2 : y2;\n            }\n          }\n\n        } // edges\n\n        // handle label dimensions\n        //////////////////////////\n\n        if( styleEnabled ){\n\n          var style = ele._private.style;\n          var rstyle = ele._private.rstyle;\n          var label = style['content'].strValue;\n          var fontSize = style['font-size'];\n          var halign = style['text-halign'];\n          var valign = style['text-valign'];\n          var labelWidth = rstyle.labelWidth;\n          var labelHeight = rstyle.labelHeight;\n          var labelX = rstyle.labelX;\n          var labelY = rstyle.labelY;\n\n          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){\n            var lh = labelHeight;\n            var lw = labelWidth;\n            var lx1, lx2, ly1, ly2;\n\n            if( ele.isEdge() ){\n              lx1 = labelX - lw/2;\n              lx2 = labelX + lw/2;\n              ly1 = labelY - lh/2;\n              ly2 = labelY + lh/2;\n            } else {\n              switch( halign.value ){\n                case 'left':\n                  lx1 = labelX - lw;\n                  lx2 = labelX;\n                  break;\n\n                case 'center':\n                  lx1 = labelX - lw/2;\n                  lx2 = labelX + lw/2;\n                  break;\n\n                case 'right':\n                  lx1 = labelX;\n                  lx2 = labelX + lw;\n                  break;\n              }\n\n              switch( valign.value ){\n                case 'top':\n                  ly1 = labelY - lh;\n                  ly2 = labelY;\n                  break;\n\n                case 'center':\n                  ly1 = labelY - lh/2;\n                  ly2 = labelY + lh/2;\n                  break;\n\n                case 'bottom':\n                  ly1 = labelY;\n                  ly2 = labelY + lh;\n                  break;\n              }\n            }\n\n            x1 = lx1 < x1 ? lx1 : x1;\n            x2 = lx2 > x2 ? lx2 : x2;\n            y1 = ly1 < y1 ? ly1 : y1;\n            y2 = ly2 > y2 ? ly2 : y2;\n          }\n        } // style enabled\n      } // for\n\n      return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n      };\n    }\n  }); \n\n  // in case some users want to be explicit\n  $$.elesfn.modelPosition = $$.elesfn.position;\n  $$.elesfn.modelPositions = $$.elesfn.positions;\n  \n})( cytoscape );\n\n;(function( $$ ){ 'use strict';\n  \n  // Regular degree functions (works on single element)\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  function defineDegreeFunction(callback){\n    return function( includeLoops ){\n      var self = this;\n\n      if( includeLoops === undefined ){\n        includeLoops = true;\n      }\n      \n      if( self.length === 0 ){ return; }\n\n      if( self.isNode() && !self.removed() ){\n        var degree = 0;\n        var node = self[0];\n        var connectedEdges = node._private.edges;\n\n        for( var i = 0; i < connectedEdges.length; i++ ){\n          var edge = connectedEdges[i];\n\n          if( !includeLoops && edge.isLoop() ){\n            continue;\n          }\n\n          degree += callback( node, edge );\n        }\n        \n        return degree;\n      } else {\n        return;\n      }\n    };\n  }\n  \n  $$.fn.eles({\n    degree: defineDegreeFunction(function(node, edge){\n      if( edge.source().same( edge.target() ) ){\n        return 2;\n      } else {\n        return 1;\n      }\n    }),\n\n    indegree: defineDegreeFunction(function(node, edge){\n      if( edge.target().same(node) ){\n        return 1;\n      } else {\n        return 0;\n      }\n    }),\n\n    outdegree: defineDegreeFunction(function(node, edge){\n      if( edge.source().same(node) ){\n        return 1;\n      } else {\n        return 0;\n      }\n    })\n  });\n  \n  \n  // Collection degree stats\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  function defineDegreeBoundsFunction(degreeFn, callback){\n    return function( includeLoops ){\n      var ret;\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){\n        var ele = nodes[i];\n        var degree = ele[degreeFn]( includeLoops );\n        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){\n          ret = degree;\n        }\n      }\n      \n      return ret;\n    };\n  }\n  \n  $$.fn.eles({\n    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){\n      return degree < min;\n    }),\n\n    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){\n      return degree > max;\n    }),\n\n    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){\n      return degree < min;\n    }),\n\n    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){\n      return degree > max;\n    }),\n\n    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){\n      return degree < min;\n    }),\n\n    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){\n      return degree > max;\n    })\n  });\n  \n  $$.fn.eles({\n    totalDegree: function( includeLoops ){\n      var total = 0;\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){\n        total += nodes[i].degree( includeLoops );\n      }\n\n      return total;\n    }\n  });\n  \n})( cytoscape );\n\n  \n;(function($$){ 'use strict';\n  \n  // Functions for binding & triggering events\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  $$.fn.eles({\n    on: $$.define.on(), // .on( events [, selector] [, data], handler)\n    one: $$.define.on({ unbindSelfOnTrigger: true }),\n    once: $$.define.on({ unbindAllBindersOnTrigger: true }),\n    off: $$.define.off(), // .off( events [, selector] [, handler] )\n    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )\n\n    rtrigger: function(event, extraParams){ // for internal use only\n      if( this.length === 0 ){ return; } // empty collections don't need to notify anything\n\n      // notify renderer\n      this.cy().notify({\n        type: event,\n        collection: this\n      });\n      \n      this.trigger(event, extraParams);\n      return this;\n    }\n  });\n\n  // aliases for those folks who like old stuff:\n  $$.elesfn.bind = $$.elesfn.on;\n  $$.elesfn.unbind = $$.elesfn.off;\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n    nodes: function( selector ){\n      return this.filter(function(i, element){\n        return element.isNode();\n      }).filter(selector);\n    },\n\n    edges: function( selector ){\n      return this.filter(function(i, element){\n        return element.isEdge();\n      }).filter(selector);\n    },\n\n    filter: function( filter ){\n      var cy = this._private.cy;\n      \n      if( $$.is.fn(filter) ){\n        var elements = [];\n\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n\n          if( filter.apply(ele, [i, ele]) ){\n            elements.push(ele);\n          }\n        }\n        \n        return new $$.Collection(cy, elements);\n      \n      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){\n        return new $$.Selector(filter).filter(this);\n      \n      } else if( filter === undefined ){\n        return this;\n      }\n\n      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection\n    },\n\n    not: function( toRemove ){\n      var cy = this._private.cy;\n\n      if( !toRemove ){\n        return this;\n      } else {\n      \n        if( $$.is.string( toRemove ) ){\n          toRemove = this.filter( toRemove );\n        }\n        \n        var elements = [];\n        \n        for( var i = 0; i < this.length; i++ ){\n          var element = this[i];\n\n          var remove = toRemove._private.ids[ element.id() ];\n          if( !remove ){\n            elements.push( element );\n          }\n        }\n        \n        return new $$.Collection( cy, elements );\n      }\n      \n    },\n\n    intersect: function( other ){\n      var cy = this._private.cy;\n      \n      // if a selector is specified, then filter by it instead\n      if( $$.is.string(other) ){\n        var selector = other;\n        return this.filter( selector );\n      }\n      \n      var elements = [];\n      var col1 = this;\n      var col2 = other;\n      var col1Smaller = this.length < other.length;\n      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;\n      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;\n      var col = col1Smaller ? col1 : col2;\n      \n      for( var i = 0; i < col.length; i++ ){\n        var id = col[i]._private.data.id;\n        var ele = ids2[ id ];\n\n        if( ele ){\n          elements.push( ele );\n        }\n      }\n      \n      return new $$.Collection( cy, elements );\n    },\n\n    add: function( toAdd ){\n      var cy = this._private.cy;    \n      \n      if( !toAdd ){\n        return this;\n      }\n      \n      if( $$.is.string(toAdd) ){\n        var selector = toAdd;\n        toAdd = cy.elements(selector);\n      }\n      \n      var elements = [];\n\n      for( var i = 0; i < this.length; i++ ){\n        elements.push( this[i] );\n      }\n\n      for( var i = 0; i < toAdd.length; i++ ){\n\n        var add = !this._private.ids[ toAdd[i].id() ];\n        if( add ){\n          elements.push( toAdd[i] );\n        }\n      }\n      \n      return new $$.Collection(cy, elements);\n    },\n\n    // in place merge on calling collection\n    merge: function( toAdd ){\n      var _p = this._private;\n      var cy = _p.cy;    \n      \n      if( !toAdd ){\n        return this;\n      }\n      \n      if( $$.is.string(toAdd) ){\n        var selector = toAdd;\n        toAdd = cy.elements(selector);\n      }\n\n      for( var i = 0; i < toAdd.length; i++ ){\n        var toAddEle = toAdd[i];\n        var id = toAddEle.id();\n        var add = !_p.ids[ id ];\n\n        if( add ){\n          var index = this.length++;\n\n          this[ index ] = toAddEle;\n          _p.ids[ id ] = toAddEle;\n          _p.indexes[ id ] = index;\n        }\n      }\n      \n      return this; // chaining\n    },\n\n    // remove single ele in place in calling collection\n    unmergeOne: function( ele ){\n      ele = ele[0];\n\n      var _p = this._private;\n      var id = ele.id();\n      var i = _p.indexes[ id ];\n\n      if( i == null ){\n        return this; // no need to remove\n      }\n\n      // remove ele\n      this[i] = undefined;\n      _p.ids[ id ] = undefined;\n      _p.indexes[ id ] = undefined;\n\n      var unmergedLastEle = i === this.length - 1;\n\n      // replace empty spot with last ele in collection\n      if( this.length > 1 && !unmergedLastEle ){\n        var lastEleI = this.length - 1;\n        var lastEle = this[ lastEleI ];\n\n        this[ lastEleI ] = undefined;\n        this[i] = lastEle;\n        _p.indexes[ lastEle.id() ] = i;\n      }\n\n      // the collection is now 1 ele smaller\n      this.length--;\n\n      return this;\n    },\n\n    // remove eles in place on calling collection\n    unmerge: function( toRemove ){\n      var cy = this._private.cy;    \n      \n      if( !toRemove ){\n        return this;\n      }\n\n      if( $$.is.string(toRemove) ){\n        var selector = toRemove;\n        toRemove = cy.elements(selector);\n      }\n\n      for( var i = 0; i < toRemove.length; i++ ){\n        this.unmergeOne( toRemove[i] );\n      }\n      \n      return this; // chaining\n    },\n\n    map: function( mapFn, thisArg ){\n      var arr = [];\n      var eles = this;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var ret = mapFn.apply( thisArg, [ele, i, eles] );\n\n        arr.push( ret );\n      }\n\n      return arr;\n    },\n\n    stdFilter: function( fn, thisArg ){\n      var filterEles = [];\n      var eles = this;\n      var cy = this._private.cy;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var include = fn.apply( thisArg, [ele, i, eles] );\n\n        if( include ){\n          filterEles.push( ele );\n        }\n      }\n\n      return new $$.Collection( cy, filterEles );\n    },\n\n    max: function( valFn, thisArg ){\n      var max = -Infinity;\n      var maxEle;\n      var eles = this;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var val = valFn.apply( thisArg, [ ele, i, eles ] );\n\n        if( val > max ){\n          max = val;\n          maxEle = ele;\n        }\n      }\n\n      return {\n        value: max,\n        ele: maxEle\n      };\n    },\n\n    min: function( valFn, thisArg ){\n      var min = Infinity;\n      var minEle;\n      var eles = this;\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var val = valFn.apply( thisArg, [ ele, i, eles ] );\n\n        if( val < min ){\n          min = val;\n          minEle = ele;\n        }\n      }\n\n      return {\n        value: min,\n        ele: minEle\n      };\n    }\n  });\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n    isNode: function(){\n      return this.group() === 'nodes';\n    },\n\n    isEdge: function(){\n      return this.group() === 'edges';\n    },\n\n    isLoop: function(){\n      return this.isEdge() && this.source().id() === this.target().id();\n    },\n\n    isSimple: function(){\n      return this.isEdge() && this.source().id() !== this.target().id();\n    },\n\n    group: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return ele._private.group;\n      }\n    }\n  });\n\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // Functions for iterating over collections\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  $$.fn.eles({\n    each: function(fn){\n      if( $$.is.fn(fn) ){\n        for(var i = 0; i < this.length; i++){\n          var ele = this[i];\n          var ret = fn.apply( ele, [ i, ele ] );\n\n          if( ret === false ){ break; } // exit each early on return false\n        }\n      }\n      return this;\n    },\n\n    forEach: function(fn, thisArg){\n      if( $$.is.fn(fn) ){\n\n        for(var i = 0; i < this.length; i++){\n          var ele = this[i];\n          var ret = fn.apply( thisArg, [ ele, i, this ] );\n\n          if( ret === false ){ break; } // exit each early on return false\n        }\n      }\n\n      return this;\n    },\n\n    toArray: function(){\n      var array = [];\n      \n      for(var i = 0; i < this.length; i++){\n        array.push( this[i] );\n      }\n      \n      return array;\n    },\n\n    slice: function(start, end){\n      var array = [];\n      var thisSize = this.length;\n      \n      if( end == null ){\n        end = thisSize;\n      }\n\n      if( start == null ){\n        start = 0;\n      }\n      \n      if( start < 0 ){\n        start = thisSize + start;\n      }\n\n      if( end < 0 ){\n        end = thisSize + end;\n      }\n      \n      for(var i = start; i >= 0 && i < end && i < thisSize; i++){\n        array.push( this[i] );\n      }\n      \n      return new $$.Collection(this.cy(), array);\n    },\n\n    size: function(){\n      return this.length;\n    },\n\n    eq: function(i){\n      return this[i] || new $$.Collection( this.cy() );\n    },\n\n    first: function(){\n      return this[0] || new $$.Collection( this.cy() );\n    },\n\n    last: function(){\n      return this[ this.length - 1 ] || new $$.Collection( this.cy() );\n    },\n\n    empty: function(){\n      return this.length === 0;\n    },\n\n    nonempty: function(){\n      return !this.empty();\n    },\n\n    sort: function( sortFn ){\n      if( !$$.is.fn( sortFn ) ){\n        return this;\n      }\n\n      var cy = this.cy();      \n      var sorted = this.toArray().sort( sortFn );\n\n      return new $$.Collection(cy, sorted);\n    },\n\n    sortByZIndex: function(){\n      return this.sort( $$.Collection.zIndexSort );\n    },\n\n    zDepth: function(){\n      var ele = this[0];\n      if( !ele ){ return undefined; }\n\n      var _p = ele._private;\n      var group = _p.group;\n\n      if( group === 'nodes' ){\n        return _p.data.parent ? ele.parents().size() : 0;\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcDepth = src._private.data.parent ? src.parents().size() : 0;\n        var tgtDepth = tgt._private.data.parent ? tgt.parents().size() : 0;\n\n        return Math.max( srcDepth - 1, tgtDepth - 1, 0 ) + 0.5; // depth of deepest parent and just a bit above\n      }\n    }\n  });\n\n  $$.Collection.zIndexSort = function(a, b){\n    var cy = a.cy();\n    var a_p = a._private;\n    var b_p = b._private;\n    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;\n    var depthA = 0;\n    var depthB = 0;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var aIsNode = a_p.group === 'nodes';\n    var aIsEdge = a_p.group === 'edges';\n    var bIsNode = b_p.group === 'nodes';\n    var bIsEdge = b_p.group === 'edges';\n\n    // no need to calculate element depth if there is no compound node\n    if( hasCompoundNodes ){\n      depthA = a.zDepth();\n      depthB = b.zDepth();\n    }\n\n    var depthDiff = depthA - depthB;\n    var sameDepth = depthDiff === 0;\n\n    if( sameDepth ){\n      \n      if( aIsNode && bIsEdge ){\n        return 1; // 'a' is a node, it should be drawn later       \n      \n      } else if( aIsEdge && bIsNode ){\n        return -1; // 'a' is an edge, it should be drawn first\n\n      } else { // both nodes or both edges\n        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)\n          return a_p.index - b_p.index;\n        } else {\n          return zDiff;\n        }\n      }\n    \n    // elements on different level\n    } else {\n      return depthDiff; // deeper element should be drawn later\n    }\n\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  // Functions for layouts on nodes\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  $$.fn.eles({\n\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function( layout, options, fn ){\n      var nodes = this.nodes();\n      var cy = this.cy();\n\n      layout.trigger({ type: 'layoutstart', layout: layout });\n\n      if( options.animate ){\n        for( var i = 0; i < nodes.length; i++ ){\n          var node = nodes[i];\n          var lastNode = i === nodes.length - 1;\n\n          var newPos = fn.call( node, i, node );\n          var pos = node.position();\n\n          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){\n            node.silentPosition({ x: 0, y: 0 });\n          }\n\n          node.animate({\n            position: newPos\n          }, {\n            duration: options.animationDuration,\n            step: !lastNode ? undefined : function(){\n              if( options.fit ){\n                cy.fit( options.padding );\n              } \n            },\n            complete: !lastNode ? undefined : function(){\n              if( options.zoom != null ){\n                cy.zoom( options.zoom );\n              }\n\n              if( options.pan ){\n                cy.pan( options.pan );\n              } \n\n              if( options.fit ){\n                cy.fit( options.padding );\n              } \n              \n              layout.one('layoutstop', options.stop);\n              layout.trigger({ type: 'layoutstop', layout: layout });\n            }\n          });\n        }\n\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n      } else {\n        nodes.positions( fn );\n\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n\n        if( options.zoom != null ){\n          cy.zoom( options.zoom );\n        }\n\n        if( options.pan ){\n          cy.pan( options.pan );\n        } \n\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n        \n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      }\n\n      return this; // chaining\n    },\n\n    layout: function( options ){\n      var cy = this.cy();\n\n      cy.layout( $$.util.extend({}, options, {\n        eles: this\n      }) );\n\n      return this;\n    },\n\n    makeLayout: function( options ){\n      var cy = this.cy();\n\n      return cy.makeLayout( $$.util.extend({}, options, {\n        eles: this\n      }) );\n    }\n\n  });\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function( notifyRenderer ){\n      var cy = this._private.cy;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      if( cy._private.batchingStyle ){\n        var bEles = cy._private.batchStyleEles;\n\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n\n          if( !bEles.ids[ ele._private.id ] ){\n            bEles.push( ele );\n          }\n        }\n\n        return this; // chaining and exit early when batching\n      }\n\n      var style = cy.style();\n      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n      style.apply( this );\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\n      if( notifyRenderer ){\n        toNotify.rtrigger('style'); // let renderer know we changed style\n      } else {\n        toNotify.trigger('style'); // just fire the event\n      }\n      return this; // chaining\n    },\n\n    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()\n    updateMappers: function( notifyRenderer ){\n      var cy = this._private.cy;\n      var style = cy.style();\n      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n      if( !cy.styleEnabled() ){ return this; }\n\n      style.updateMappers( this );\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n\n      if( notifyRenderer ){\n        toNotify.rtrigger('style'); // let renderer know we changed style\n      } else {\n        toNotify.trigger('style'); // just fire the event\n      }\n      return this; // chaining\n    },\n\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedCss: function( property ){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return this; }\n\n      var ele = this[0];\n\n      if( ele ){\n        var renstyle = ele.cy().style().getRenderedStyle( ele );\n\n        if( property === undefined ){\n          return renstyle;\n        } else {\n          return renstyle[ property ];\n        }\n      }\n    },\n\n    // read the calculated css style of the element or override the style (via a bypass)\n    css: function( name, value ){\n      var cy = this.cy();\n      \n      if( !cy.styleEnabled() ){ return this; }\n\n      var updateTransitions = false;\n      var style = cy.style();\n\n      if( $$.is.plainObject(name) ){ // then extend the bypass\n        var props = name;\n        style.applyBypass( this, props, updateTransitions );\n\n        var updatedCompounds = this.updateCompoundBounds();\n        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n        toNotify.rtrigger('style'); // let the renderer know we've updated style\n\n      } else if( $$.is.string(name) ){\n  \n        if( value === undefined ){ // then get the property from the style\n          var ele = this[0];\n\n          if( ele ){\n            return ele._private.style[ name ].strValue;\n          } else { // empty collection => can't get any value\n            return;\n          }\n\n        } else { // then set the bypass with the property value\n          style.applyBypass( this, name, value, updateTransitions );\n\n          var updatedCompounds = this.updateCompoundBounds();\n          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n          toNotify.rtrigger('style'); // let the renderer know we've updated style\n        }\n\n      } else if( name === undefined ){\n        var ele = this[0];\n\n        if( ele ){\n          return style.getRawStyle( ele );\n        } else { // empty collection => can't get any value\n          return;\n        }\n      }\n\n      return this; // chaining\n    },\n\n    removeCss: function( names ){\n      var cy = this.cy();\n      \n      if( !cy.styleEnabled() ){ return this; }\n\n      var updateTransitions = false;\n      var style = cy.style();\n      var eles = this;\n\n      if( names === undefined ){\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          style.removeAllBypasses( ele, updateTransitions );\n        }\n      } else {\n        names = names.split(/\\s+/);\n\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          style.removeBypasses( ele, names, updateTransitions );\n        }\n      }\n\n      var updatedCompounds = this.updateCompoundBounds();\n      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;\n      toNotify.rtrigger('style'); // let the renderer know we've updated style\n\n      return this; // chaining\n    },\n\n    show: function(){\n      this.css('display', 'element');\n      return this; // chaining\n    },\n\n    hide: function(){\n      this.css('display', 'none');\n      return this; // chaining\n    },\n\n    visible: function(){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return true; }\n\n      var ele = this[0];\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if( ele ){\n        var style = ele._private.style;\n\n        if(\n          style['visibility'].value !== 'visible'\n          || style['display'].value !== 'element'\n        ){\n          return false;\n        }\n        \n        if( ele._private.group === 'nodes' ){\n          if( !hasCompoundNodes ){ return true; }\n\n          var parents = ele._private.data.parent ? ele.parents() : null;\n\n          if( parents ){\n            for( var i = 0; i < parents.length; i++ ){\n              var parent = parents[i];\n              var pStyle = parent._private.style;\n              var pVis = pStyle['visibility'].value;\n              var pDis = pStyle['display'].value;\n\n              if( pVis !== 'visible' || pDis !== 'element' ){\n                return false;\n              }\n            }\n          }\n\n          return true;\n        } else {\n          var src = ele._private.source;\n          var tgt = ele._private.target;\n\n          return src.visible() && tgt.visible();\n        }\n\n      }\n    },\n\n    hidden: function(){\n      var ele = this[0];\n\n      if( ele ){\n        return !ele.visible();\n      }\n    },\n\n    effectiveOpacity: function(){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return 1; }\n\n      var hasCompoundNodes = cy.hasCompoundNodes();\n      var ele = this[0];\n\n      if( ele ){\n        var _p = ele._private;\n        var parentOpacity = _p.style.opacity.value;\n\n        if( !hasCompoundNodes ){ return parentOpacity; }\n\n        var parents = !_p.data.parent ? null : ele.parents();\n        \n        if( parents ){\n          for( var i = 0; i < parents.length; i++ ){\n            var parent = parents[i];\n            var opacity = parent._private.style.opacity.value;\n\n            parentOpacity = opacity * parentOpacity;\n          }\n        }\n\n        return parentOpacity;\n      }\n    },\n\n    transparent: function(){\n      var ele = this[0];\n      var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n      if( ele ){\n        if( !hasCompoundNodes ){\n          return ele._private.style.opacity.value === 0;\n        } else {\n          return ele.effectiveOpacity() === 0;\n        }\n      }\n    },\n\n    isFullAutoParent: function(){\n      var cy = this.cy();\n      if( !cy.styleEnabled() ){ return false; }\n\n      var ele = this[0];\n\n      if( ele ){\n        var autoW = ele._private.style['width'].value === 'auto';\n        var autoH = ele._private.style['height'].value === 'auto';\n\n        return ele.isParent() && autoW && autoH;\n      }\n    }\n\n  });\n\n\n  $$.elesfn.style = $$.elesfn.css;\n  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;\n  $$.elesfn.removeStyle = $$.elesfn.removeCss;\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n  \n  // Collection functions that toggle a boolean value\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  \n  \n  function defineSwitchFunction(params){\n    return function(){\n      var args = arguments;\n      \n      // e.g. cy.nodes().select( data, handler )\n      if( args.length === 2 ){\n        var data = args[0];\n        var handler = args[1];\n        this.bind( params.event, data, handler );\n      } \n      \n      // e.g. cy.nodes().select( handler )\n      else if( args.length === 1 ){\n        var handler = args[0];\n        this.bind( params.event, handler );\n      }\n      \n      // e.g. cy.nodes().select()\n      else if( args.length === 0 ){\n        for( var i = 0; i < this.length; i++ ){\n          var ele = this[i];\n          var able = !params.ableField || ele._private[params.ableField];\n\n          if( params.overrideAble ){\n            var overrideAble = params.overrideAble(ele);\n\n            if( overrideAble !== undefined ){\n              able = overrideAble;\n\n              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override\n            }\n          }\n\n          if( able ){\n            ele._private[params.field] = params.value;\n          }\n        }\n        this.updateStyle(); // change of state => possible change of style\n        this.trigger( params.event );\n      }\n\n      return this;\n    };\n  }\n  \n  function defineSwitchSet( params ){\n    $$.elesfn[ params.field ] = function(){\n      var ele = this[0];\n\n      if( ele ){\n        if( params.overrideField ){\n          var val = params.overrideField(ele);\n\n          if( val !== undefined ){\n            return val;\n          }\n        }\n\n        return ele._private[ params.field ];\n      }\n    };\n    \n    $$.elesfn[ params.on ] = defineSwitchFunction({\n      event: params.on,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: true\n    });\n\n    $$.elesfn[ params.off ] = defineSwitchFunction({\n      event: params.off,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: false\n    });\n  }\n  \n  defineSwitchSet({\n    field: 'locked',\n    overrideField: function(ele){\n      return ele.cy().autolock() ? true : undefined;\n    },\n    on: 'lock',\n    off: 'unlock'\n  });\n  \n  defineSwitchSet({\n    field: 'grabbable',\n    overrideField: function(ele){\n      return ele.cy().autoungrabify() ? false : undefined;\n    },\n    on: 'grabify',\n    off: 'ungrabify'\n  });\n  \n  defineSwitchSet({\n    field: 'selected',\n    ableField: 'selectable',\n    overrideAble: function(ele){\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'select',\n    off: 'unselect'\n  });\n  \n  defineSwitchSet({\n    field: 'selectable',\n    overrideField: function(ele){\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'selectify',\n    off: 'unselectify'\n  });\n  \n  $$.elesfn.grabbed = function(){\n    var ele = this[0];\n    if( ele ){\n      return ele._private.grabbed;\n    }\n  };\n\n  defineSwitchSet({\n    field: 'active',\n    on: 'activate',\n    off: 'unactivate'\n  });\n\n  $$.elesfn.inactive = function(){\n    var ele = this[0];\n    if( ele ){\n      return !ele._private.active;\n    }\n  };\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // DAG functions\n  //////////////////////////\n\n  $$.fn.eles({\n    // get the root nodes in the DAG\n    roots: function( selector ){\n      var eles = this;\n      var roots = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        if( !ele.isNode() ){\n          continue;\n        }\n\n        var hasEdgesPointingIn = ele.connectedEdges(function(){\n          return this.data('target') === ele.id() && this.data('source') !== ele.id();\n        }).length > 0;\n\n        if( !hasEdgesPointingIn ){\n          roots.push( ele );\n        }\n      }\n\n      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );\n    },\n\n    // get the leaf nodes in the DAG\n    leaves: function( selector ){\n      var eles = this;\n      var leaves = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        if( !ele.isNode() ){\n          continue;\n        }\n\n        var hasEdgesPointingOut = ele.connectedEdges(function(){\n          return this.data('source') === ele.id() && this.data('target') !== ele.id();\n        }).length > 0;\n\n        if( !hasEdgesPointingOut ){\n          leaves.push( ele );\n        }\n      }\n\n      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );\n    },\n\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: function( selector ){\n      var eles = this;\n      var oEles = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var eleId = ele.id();\n\n        if( !ele.isNode() ){ continue; }\n\n        var edges = ele._private.edges;\n        for( var j = 0; j < edges.length; j++ ){\n          var edge = edges[j];\n          var srcId = edge._private.data.source;\n          var tgtId = edge._private.data.target;\n\n          if( srcId === eleId && tgtId !== eleId ){\n            oEles.push( edge );\n            oEles.push( edge.target()[0] );\n          }\n        }\n      }\n\n      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );\n    },\n\n    // aka DAG descendants\n    successors: function( selector ){\n      var eles = this;\n      var sEles = [];\n      var sElesIds = {};\n\n      for(;;){\n        var outgoers = eles.outgoers();\n\n        if( outgoers.length === 0 ){ break; } // done if no outgoers left\n\n        var newOutgoers = false;\n        for( var i = 0; i < outgoers.length; i++ ){\n          var outgoer = outgoers[i];\n          var outgoerId = outgoer.id();\n\n          if( !sElesIds[ outgoerId ] ){\n            sElesIds[ outgoerId ] = true;\n            sEles.push( outgoer );\n            newOutgoers = true;\n          }\n        }\n\n        if( !newOutgoers ){ break; } // done if touched all outgoers already\n\n        eles = outgoers;\n      }\n\n      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );\n    },\n\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: function( selector ){\n      var eles = this;\n      var oEles = [];\n\n      for( var i = 0; i < eles.length; i++ ){\n        var ele = eles[i];\n        var eleId = ele.id();\n\n        if( !ele.isNode() ){ continue; }\n\n        var edges = ele._private.edges;\n        for( var j = 0; j < edges.length; j++ ){\n          var edge = edges[j];\n          var srcId = edge._private.data.source;\n          var tgtId = edge._private.data.target;\n\n          if( tgtId === eleId && srcId !== eleId ){\n            oEles.push( edge );\n            oEles.push( edge.source()[0] );\n          }\n        }\n      }\n\n      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );\n    },\n\n    // aka DAG ancestors\n    predecessors: function( selector ){\n      var eles = this;\n      var pEles = [];\n      var pElesIds = {};\n\n      for(;;){\n        var incomers = eles.incomers();\n\n        if( incomers.length === 0 ){ break; } // done if no incomers left\n\n        var newIncomers = false;\n        for( var i = 0; i < incomers.length; i++ ){\n          var incomer = incomers[i];\n          var incomerId = incomer.id();\n\n          if( !pElesIds[ incomerId ] ){\n            pElesIds[ incomerId ] = true;\n            pEles.push( incomer );\n            newIncomers = true;\n          }\n        }\n\n        if( !newIncomers ){ break; } // done if touched all incomers already\n\n        eles = incomers;\n      }\n\n      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );\n    }\n  });\n\n\n  // Neighbourhood functions\n  //////////////////////////\n\n  $$.fn.eles({\n    neighborhood: function(selector){\n      var elements = [];\n      var cy = this._private.cy;\n      var nodes = this.nodes();\n\n      for( var i = 0; i < nodes.length; i++ ){ // for all nodes\n        var node = nodes[i];\n        var connectedEdges = node.connectedEdges();\n\n        // for each connected edge, add the edge and the other node\n        for( var j = 0; j < connectedEdges.length; j++ ){\n          var edge = connectedEdges[j];\n          var otherNode = edge.connectedNodes().not(node);\n\n          // need check in case of loop\n          if( otherNode.length > 0 ){\n            elements.push( otherNode[0] ); // add node 1 hop away\n          }\n          \n          // add connected edge\n          elements.push( edge[0] );\n        }\n\n      }\n      \n      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );\n    },\n\n    closedNeighborhood: function(selector){\n      return this.neighborhood().add( this ).filter( selector );\n    },\n\n    openNeighborhood: function(selector){\n      return this.neighborhood( selector );\n    }\n  });  \n\n\n  // Edge functions\n  /////////////////\n\n  $$.fn.eles({\n    source: function( selector ){\n      var ele = this[0];\n      var src;\n\n      if( ele ){\n        src = ele._private.source;\n      }\n\n      return src && selector ? src.filter( selector ) : src;\n    },\n\n    target: function( selector ){\n      var ele = this[0];\n      var tgt;\n\n      if( ele ){\n        tgt = ele._private.target;\n      }\n\n      return tgt && selector ? tgt.filter( selector ) : tgt;\n    },\n\n    sources: defineSourceFunction({\n      attr: 'source'\n    }),\n\n    targets: defineSourceFunction({\n      attr: 'target'\n    })\n  });\n  \n  function defineSourceFunction( params ){\n    return function( selector ){\n      var sources = [];\n      var cy = this._private.cy;\n\n      for( var i = 0; i < this.length; i++ ){\n        var ele = this[i];\n        var src = ele._private[ params.attr ];\n\n        if( src ){\n          sources.push( src );\n        }\n      }\n      \n      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );\n    };\n  }\n\n  $$.fn.eles({\n    edgesWith: defineEdgesWithFunction(),\n\n    edgesTo: defineEdgesWithFunction({\n      thisIs: 'source'\n    })\n  });\n  \n  function defineEdgesWithFunction( params ){\n    \n    return function(otherNodes){\n      var elements = [];\n      var cy = this._private.cy;\n      var p = params || {};\n\n      // get elements if a selector is specified\n      if( $$.is.string(otherNodes) ){\n        otherNodes = cy.$( otherNodes );\n      }\n      \n      var edges = otherNodes.connectedEdges();\n      var thisIds = this._private.ids;\n      \n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[i];\n        var foundId;\n        var edgeData = edge._private.data;\n\n        if( p.thisIs ){\n          var idToFind = edgeData[ p.thisIs ];\n          foundId = thisIds[ idToFind ];\n        } else {\n          foundId = thisIds[ edgeData.source ] || thisIds[ edgeData.target ];\n        }\n        \n        if( foundId ){\n          elements.push( edge );\n        }\n      }\n      \n      return new $$.Collection( cy, elements, { unique: true } );\n    };\n  }\n  \n  $$.fn.eles({\n    connectedEdges: function( selector ){\n      var retEles = [];\n      var cy = this._private.cy;\n      \n      var eles = this;\n      for( var i = 0; i < eles.length; i++ ){\n        var node = eles[i];\n        if( !node.isNode() ){ continue; }\n\n        var edges = node._private.edges;\n\n        for( var j = 0; j < edges.length; j++ ){\n          var edge = edges[j];          \n          retEles.push( edge );\n        }\n      }\n      \n      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );\n    },\n\n    connectedNodes: function( selector ){\n      var retEles = [];\n      var cy = this._private.cy;\n\n      var eles = this;\n      for( var i = 0; i < eles.length; i++ ){\n        var edge = eles[i];\n        if( !edge.isEdge() ){ continue; }\n\n        retEles.push( edge.source()[0] );\n        retEles.push( edge.target()[0] );\n      }\n\n      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );\n    },\n\n    parallelEdges: defineParallelEdgesFunction(),\n\n    codirectedEdges: defineParallelEdgesFunction({\n      codirected: true\n    })\n  });\n  \n  function defineParallelEdgesFunction(params){\n    var defaults = {\n      codirected: false\n    };\n    params = $$.util.extend({}, defaults, params);\n    \n    return function( selector ){\n      var cy = this._private.cy;\n      var elements = [];\n      var edges = this.edges();\n      var p = params;\n\n      // look at all the edges in the collection\n      for( var i = 0; i < edges.length; i++ ){\n        var edge1 = edges[i];\n        var src1 = edge1.source()[0];\n        var srcid1 = src1.id();\n        var tgt1 = edge1.target()[0];\n        var tgtid1 = tgt1.id();\n        var srcEdges1 = src1._private.edges;\n\n        // look at edges connected to the src node of this edge\n        for( var j = 0; j < srcEdges1.length; j++ ){\n          var edge2 = srcEdges1[j];\n          var edge2data = edge2._private.data;\n          var tgtid2 = edge2data.target;\n          var srcid2 = edge2data.source;\n\n          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n          \n          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){\n            elements.push( edge2 );\n          }\n        }\n      }\n      \n      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );\n    };\n  \n  }\n\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  $$.fn.eles({\n\n    fit: function(){},\n    center: function(){}\n\n  });\n  \n})( cytoscape );\n;(function ($$) {\n  \"use strict\";\n\n  /*  Min and Max heap predefaults */\n  \n  $$.Minheap = function (cy, eles, valueFn) {\n    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);\n  };\n\n  $$.Maxheap = function (cy, eles, valueFn) {\n    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);\n  };\n  \n  $$.Heap = function (cy, eles, comparator, valueFn) {\n    if (typeof comparator === \"undefined\" || typeof eles === \"undefined\") {\n      return;\n    }\n    \n    if (typeof valueFn === \"undefined\") {\n      valueFn = $$.Heap.idFn;\n    }\n\n    var sourceHeap = [],\n      pointers = {},\n      elements = [],\n      i = 0,\n      id,\n      heap,\n      elesLen;\n\n    eles = this.getArgumentAsCollection(eles, cy);\n    elesLen = eles.length;\n\n    for (i = 0; i < elesLen; i += 1) {\n      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));\n\n      id = eles[i].id();\n      \n      if (pointers.hasOwnProperty(id)) {\n        throw \"ERROR: Multiple items with the same id found: \" + id;\n      }\n      \n      pointers[id] = i;\n      elements.push(id);\n    }\n\n    this._private = {\n      cy: cy,\n      heap: sourceHeap,\n      pointers: pointers,\n      elements: elements,\n      comparator: comparator,\n      extractor: valueFn,\n      length: elesLen\n    };\n\n    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {\n      heap = this.heapify(i);\n    }\n\n    return heap;\n  };\n\n  /* static methods */\n  $$.Heap.idFn = function (node) {\n    return node.id();\n  };\n\n  $$.Heap.minHeapComparator = function (a, b) {\n    return a >= b;\n  };\n\n  $$.Heap.maxHeapComparator = function (a, b) {\n    return a <= b;\n  };\n\n  $$.fn.heap = function( fnMap, options ){\n    for( var name in fnMap ){\n      var fn = fnMap[name];\n      $$.Heap.prototype[ name ] = fn;\n    }\n  };\n\n  $$.heapfn = $$.Heap.prototype; // short alias\n\n  /* object methods */\n  $$.heapfn.size = function () {\n    return this._private.length;\n  };\n\n  $$.heapfn.getArgumentAsCollection = function (eles, cy) {\n    var result;\n    if(typeof cy === \"undefined\") {\n      cy = this._private.cy;\n    }\n\n    if ($$.is.elementOrCollection(eles)) {\n      result = eles;\n\n    } else {\n      var resultArray = [],\n        sourceEles = [].concat.apply([], [eles]);\n\n      for (var i = 0; i < sourceEles.length; i++) {\n        var id = sourceEles[i],\n          ele = cy.getElementById(id);\n\n        if(ele.length > 0) {\n          resultArray.push(ele);\n        }\n      }\n\n      result = new $$.Collection(cy, resultArray);\n    }\n\n    return result;\n  };\n\n  $$.heapfn.isHeap = function () {\n    var array = this._private.heap,\n      arrlen = array.length,\n      i,\n      left,\n      right,\n      lCheck,\n      rCheck,\n      comparator = this._private.comparator;\n\n    for (i = 0; i < arrlen; i += 1) {\n      left = 2 * i + 1;\n      right = left + 1;\n      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;\n      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;\n\n      if (!lCheck || !rCheck) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  $$.heapfn.heapSwap = function (i, j) {\n    var heap = this._private.heap,\n      pointers = this._private.pointers,\n      elements = this._private.elements,\n      swapValue = heap[i],\n      swapElems = elements[i],\n      idI = elements[i],\n      idJ = elements[j];\n\n    heap[i] = heap[j];\n    elements[i] = elements[j];\n\n    pointers[idI] = j;\n    pointers[idJ] = i;\n\n    heap[j] = swapValue;\n    elements[j] = swapElems;\n  };\n\n  $$.heapfn.heapify = function (i, rootToLeaf) {\n    var treeLen = 0,\n      condHeap = false,\n      array,\n      current,\n      left,\n      right,\n      best,\n      comparator,\n      parent;\n    \n    if (typeof rootToLeaf === \"undefined\") {\n      rootToLeaf = true;\n    }\n\n    array = this._private.heap;\n    treeLen = array.length;\n    comparator = this._private.comparator;\n    current = i;\n\n    while (!condHeap) {\n\n      if (rootToLeaf) {\n        left = 2 * current + 1;\n        right = left + 1;\n        best = current;\n        \n        if (left < treeLen && !comparator(array[left], array[best])) {\n          best = left;\n        }\n        \n        if (right < treeLen && !comparator(array[right], array[best])) {\n          best = right;\n        }\n        \n        condHeap = best === current;\n        \n        if (!condHeap) {\n          this.heapSwap(best, current);\n          current = best;\n        }\n\n      } else {\n        parent = Math.floor((current - 1) / 2);\n        best = current;\n        condHeap = parent < 0 || comparator(array[best], array[parent]);\n\n        if (!condHeap) {\n          this.heapSwap(best, parent);\n          current = parent;\n        }\n      }\n\n    } // while\n  };\n\n  /* collectionOrElement */\n  $$.heapfn.insert = function (eles) {\n    var elements = this.getArgumentAsCollection(eles),\n      elsize = elements.length,\n      element,\n      elindex,\n      elvalue,\n      elid,\n      i;\n\n    for (i = 0; i < elsize; i += 1) {\n      element = elements[i];\n      elindex = this._private.heap.length;\n      elvalue = this._private.extractor(element);\n      elid = element.id();\n\n      if (this._private.pointers.hasOwnProperty(elid)) {\n        throw \"ERROR: Multiple items with the same id found: \" + elid;\n      }\n\n      this._private.heap.push(elvalue);\n      this._private.elements.push(elid);\n      this._private.pointers[elid] = elindex;\n      this.heapify(elindex, false);\n    }\n\n    this._private.length = this._private.heap.length;\n  };\n\n  $$.heapfn.getValueById = function (elementId) {\n    if (this._private.pointers.hasOwnProperty(elementId)) {\n      var elementIndex = this._private.pointers[elementId];\n\n      return this._private.heap[elementIndex];\n    }\n  };\n  \n  $$.heapfn.contains = function (eles) {\n    var elements = this.getArgumentAsCollection(eles);\n\n    for (var i = 0; i < elements.length; i += 1) {\n      var elementId = elements[i].id();\n\n      if(!this._private.pointers.hasOwnProperty(elementId)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  \n  $$.heapfn.top = function () {\n    if (this._private.length > 0) {\n\n      return {\n        value: this._private.heap[0],\n        id: this._private.elements[0]\n      };\n\n    }\n  };\n\n  $$.heapfn.pop = function () {\n    if (this._private.length > 0) {\n      var top = this.top(),\n        lastIndex = this._private.length - 1,\n        removeCandidate,\n        removeValue,\n        remId;\n\n      this.heapSwap(0, lastIndex);\n\n      removeCandidate = this._private.elements[lastIndex];\n      removeValue = this._private.heap[lastIndex];\n      remId = removeCandidate;\n\n      this._private.heap.pop();\n      this._private.elements.pop();\n      this._private.length = this._private.heap.length;\n      this._private.pointers[remId] = undefined;\n\n      this.heapify(0);\n      return top;\n    }\n  };\n\n  $$.heapfn.findDirectionHeapify = function (index) {\n    var parent = Math.floor((index - 1) / 2),\n      array = this._private.heap,\n      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);\n\n    this.heapify(index, condHeap);\n  };\n\n  /* edit is a new value or function */\n  // only values in heap are updated. elements themselves are not!\n  $$.heapfn.edit = function (eles, edit) {\n    var elements = this.getArgumentAsCollection(eles);\n    \n    for (var i = 0; i < elements.length; i += 1) {\n      var elementId = elements[i].id(),\n        elementIndex = this._private.pointers[elementId],\n        elementValue = this._private.heap[elementIndex];\n      \n      if ($$.is.number(edit)) {\n        this._private.heap[elementIndex] = edit;\n        \n      } else if ($$.is.fn(edit)) {\n        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);\n      }\n\n      this.findDirectionHeapify(elementIndex);\n    }\n  };\n\n  $$.heapfn.delete = function (eles) {\n    var elements = this.getArgumentAsCollection(eles);\n    \n    for (var i = 0; i < elements.length; i += 1) {\n      var elementId = elements[i].id(),\n        elementIndex = this._private.pointers[elementId],\n        lastIndex = this._private.length - 1,\n        removeCandidate,\n        removeValue,\n        remId;\n\n      if (elementIndex !== lastIndex) {\n        this.heapSwap(elementIndex, lastIndex);\n      }\n\n      removeCandidate = this._private.elements[lastIndex];\n      removeValue = this._private.heap[lastIndex];\n      remId = removeCandidate;\n\n      this._private.heap.pop();\n      this._private.elements.pop();\n      this._private.length = this._private.heap.length;\n      this._private.pointers[remId] = undefined;\n\n      this.findDirectionHeapify(elementIndex);\n    }\n\n    return removeValue;\n  };\n\n})(cytoscape);\n/*\n  The canvas renderer was written by Yue Dong.\n\n  Modifications tracked on Github.\n*/\n\n(function($$) { 'use strict';\n\n  function CanvasRenderer(options) {\n    \n    CanvasRenderer.CANVAS_LAYERS = 5;\n    CanvasRenderer.SELECT_BOX = 0;\n    CanvasRenderer.DRAG = 2;\n    CanvasRenderer.NODE = 4;\n    CanvasRenderer.TEXTURE_BUFFER = 0;\n    CanvasRenderer.BUFFER_COUNT = 2;\n\n    this.options = options;\n\n    this.data = {\n        \n      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag \n      renderer: this, cy: options.cy, container: options.cy.container(),\n      \n      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),\n      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),\n      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),\n      \n      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),\n      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)\n\n    };\n    \n    //--Pointer-related data\n    this.hoverData = {down: null, last: null, \n        downTime: null, triggerMode: null, \n        dragging: false, \n        initialPan: [null, null], capture: false};\n    \n    this.timeoutData = {panTimeout: null};\n    \n    this.dragData = {possibleDragElements: []};\n    \n    this.touchData = {start: null, capture: false,\n        // These 3 fields related to tap, taphold events\n        startPosition: [null, null, null, null, null, null],\n        singleTouchStartTime: null,\n        singleTouchMoved: true,\n        \n        \n        now: [null, null, null, null, null, null], \n        earlier: [null, null, null, null, null, null] };\n    //--\n    \n    //--Wheel-related data \n    this.zoomData = {freeToZoom: false, lastPointerX: null};\n    //--\n    \n    this.redraws = 0;\n    this.showFps = options.showFps;\n\n    this.bindings = [];\n    \n    this.data.canvasContainer = document.createElement('div');\n    var containerStyle = this.data.canvasContainer.style;\n    containerStyle.position = 'absolute';\n    containerStyle.zIndex = '0';\n    containerStyle.overflow = 'hidden';\n\n    this.data.container.appendChild( this.data.canvasContainer );\n\n    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {\n      this.data.canvases[i] = document.createElement('canvas');\n      this.data.contexts[i] = this.data.canvases[i].getContext('2d');\n      this.data.canvases[i].style.position = 'absolute';\n      this.data.canvases[i].setAttribute('data-id', 'layer' + i);\n      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);\n      this.data.canvasContainer.appendChild(this.data.canvases[i]);\n      \n      this.data.canvasNeedsRedraw[i] = false;\n    }\n    this.data.topCanvas = this.data.canvases[0];\n\n    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');\n    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');\n    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');\n    \n    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {\n      this.data.bufferCanvases[i] = document.createElement('canvas');\n      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');\n      this.data.bufferCanvases[i].style.position = 'absolute';\n      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n      this.data.bufferCanvases[i].style.visibility = 'hidden';\n      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);\n    }\n\n    this.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    this.hideLabelsOnViewport = options.hideLabelsOnViewport;\n    this.textureOnViewport = options.textureOnViewport;\n    this.wheelSensitivity = options.wheelSensitivity;\n    this.motionBlurEnabled = options.motionBlur === undefined ? true : options.motionBlur; // on by default\n    this.forcedPixelRatio = options.pixelRatio;\n    this.motionBlur = true; // for initial kick off\n    this.tapThreshold = options.tapThreshold;\n    this.tapThreshold2 = options.tapThreshold * options.tapThreshold;\n    this.tapholdDuration = 500;\n\n    this.load();\n  }\n\n  CanvasRenderer.panOrBoxSelectDelay = 400;\n  CanvasRenderer.isTouch = $$.is.touch();\n\n  // whether to use Path2D caching for drawing\n  var pathsImpld = typeof Path2D !== 'undefined';\n  CanvasRenderer.usePaths = function(){\n    return pathsImpld;\n  };\n\n  CanvasRenderer.prototype.notify = function(params) {\n    var types;\n\n    if( $$.is.array( params.type ) ){\n      types = params.type;\n\n    } else {\n      types = [ params.type ];\n    }\n\n    for( var i = 0; i < types.length; i++ ){\n      var type = types[i];\n\n      switch( type ){\n        case 'destroy':\n          this.destroy();\n          return;\n\n        case 'add':\n        case 'remove':\n        case 'load':\n          this.updateNodesCache();\n          this.updateEdgesCache();\n          break;\n\n        case 'viewport':\n          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          break;\n\n        case 'style':\n          this.updateCachedZSortedEles();\n          break;\n      }\n\n      if( type === 'load' || type === 'resize' ){\n        this.invalidateContainerClientCoordsCache();\n        this.matchCanvasSize(this.data.container);\n      }\n    } // for\n    \n    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n    this.redraw();\n  };\n\n  CanvasRenderer.prototype.destroy = function(){\n    this.destroyed = true;\n\n    for( var i = 0; i < this.bindings.length; i++ ){\n      var binding = this.bindings[i];\n      var b = binding;\n\n      b.target.removeEventListener(b.event, b.handler, b.useCapture);\n    }\n\n    if( this.removeObserver ){\n      this.removeObserver.disconnect();\n    }\n  };\n\n  \n\n  // copy the math functions into the renderer prototype\n  // unfortunately these functions are used interspersed t/o the code\n  // and this makes sure things work just in case a ref was missed in refactoring\n  // TODO remove this eventually\n  for( var fnName in $$.math ){\n    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];\n  }\n  \n  \n  $$('renderer', 'canvas', CanvasRenderer);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n  var rendFunc = CanvasRenderer.prototype;\n  var arrowShapes = CanvasRenderer.arrowShapes = {};\n\n  CanvasRenderer.arrowShapeHeight = 0.3;\n\n  // Contract for arrow shapes:\n  // 0, 0 is arrow tip\n  // (0, 1) is direction towards node\n  // (1, 0) is right\n  //\n  // functional api:\n  // collide: check x, y in shape\n  // roughCollide: called before collide, no false negatives\n  // draw: draw\n  // spacing: dist(arrowTip, nodeBoundary)\n  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){\n    var x1 = centerX - width/2;\n    var x2 = centerX + width/2;\n    var y1 = centerY - height/2;\n    var y2 = centerY + height/2;\n\n    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);\n  };\n\n  var transform = function(x, y, size, angle, translation){\n    angle = -angle; // b/c of notation used in arrow draw fn\n\n    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n    \n    var xScaled = xRotated * size;\n    var yScaled = yRotated * size;\n\n    var xTranslated = xScaled + translation.x;\n    var yTranslated = yScaled + translation.y;\n    \n    return {\n      x: xTranslated,\n      y: yTranslated\n    };\n  };\n\n  arrowShapes['arrow'] = {\n    _points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['arrow']._points;\n      \n//      console.log(\"collide(): \" + direction);\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['arrow']._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['triangle'] = arrowShapes['arrow'];\n  \n  arrowShapes['triangle-backcurve'] = {\n    _ctrlPt: [ 0, -0.15 ],\n\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['triangle']._points;\n      \n//      console.log(\"collide(): \" + direction);\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['triangle']._points;\n      var firstPt;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        if( i === 0 ){\n          firstPt = pt;\n        }\n\n        context.lineTo(pt.x, pt.y);\n      }\n\n      var ctrlPt = this._ctrlPt;\n      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );\n\n      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n  \n\n  arrowShapes['triangle-tee'] = {\n    _points: [\n      -0.15, -0.3,\n      0, 0,\n      0.15, -0.3,\n      -0.15, -0.3\n    ],\n\n    _pointsTee: [\n      -0.15, -0.4,\n      -0.15, -0.5,\n      0.15, -0.5,\n      0.15, -0.4\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var triPts = arrowShapes['triangle-tee']._points;\n      var teePts = arrowShapes['triangle-tee']._pointsTee;\n      \n      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) \n        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);\n\n      return inside;\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var triPts = arrowShapes['triangle-tee']._points;\n      for (var i = 0; i < triPts.length / 2; i++){\n        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );\n        \n        context.lineTo( pt.x, pt.y );\n      }\n\n      var teePts = arrowShapes['triangle-tee']._pointsTee;\n      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );\n      context.moveTo( firstTeePt.x, firstTeePt.y );\n\n      for (var i = 0; i < teePts.length / 2; i++){\n        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );\n        \n        context.lineTo( pt.x, pt.y );\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['half-triangle-overshot'] = {\n    _points: [\n      0, -0.25,\n      -0.5, -0.25,\n      0.5, 0.25\n    ],\n    \n    leavePathOpen: true,\n    matchEdgeWidth: true,\n\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = this._points;\n      \n//      console.log(\"collide(): \" + direction);\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = this._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['none'] = {\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      return false;\n    },\n    \n    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      return false;\n    },\n    \n    draw: function(context) {\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return 0;\n    }\n  };\n  \n  arrowShapes['circle'] = {\n    _baseRadius: 0.15,\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      // Transform x, y to get non-rotated ellipse\n      \n      if (width != height) {                  \n        var aspectRatio = (height + padding) / (width + padding);\n        y /= aspectRatio;\n        centerY /= aspectRatio;\n        \n        return (Math.pow(centerX - x, 2) \n          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)\n            * arrowShapes['circle']._baseRadius, 2));\n      } else {\n        return (Math.pow(centerX - x, 2) \n          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)\n            * arrowShapes['circle']._baseRadius, 2));\n      }\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);\n    },\n    \n    spacing: function(edge) {\n      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)\n        * arrowShapes['circle']._baseRadius;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n  \n  arrowShapes['inhibitor'] = {\n    _points: [\n      -0.25, 0,\n      -0.25, -0.1,\n      0.25, -0.1,\n      0.25, 0\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['inhibitor']._points;\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['inhibitor']._points;\n      \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 1;\n    },\n    \n    gap: function(edge) {\n      return 1;\n    }\n  };\n\n  arrowShapes['tee'] = arrowShapes['inhibitor'];\n\n  arrowShapes['square'] = {\n    _points: [\n      -0.15, 0.00,\n      0.15, 0.00,\n      0.15, -0.3,\n      -0.15, -0.3\n    ],\n    \n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['square']._points;\n      \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n    \n    roughCollide: bbCollide,\n    \n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['square']._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n\n    gap: function(edge) {\n      return edge._private.style['width'].pxValue * 2;\n    }\n  };\n\n  arrowShapes['diamond'] = {\n    _points: [\n      -0.15, -0.15,\n      0, -0.3,\n      0.15, -0.15,\n      0, 0\n    ],\n\n    collide: function(x, y, centerX, centerY, width, height, direction, padding) {\n      var points = arrowShapes['diamond']._points;\n          \n      return $$.math.pointInsidePolygon(\n        x, y, points, centerX, centerY, width, height, direction, padding);\n    },\n\n    roughCollide: bbCollide,\n\n    draw: function(context, size, angle, translation) {\n      var points = arrowShapes['diamond']._points;\n    \n      for (var i = 0; i < points.length / 2; i++) {\n        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );\n\n        context.lineTo(pt.x, pt.y);\n      }\n    },\n    \n    spacing: function(edge) {\n      return 0;\n    },\n    \n    gap: function(edge) {\n      return edge._private.style['width'].pxValue;\n    }\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.getCachedNodes = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    if (data.cache.cachedNodes == null) {\n      data.cache.cachedNodes = cy.nodes();\n    }\n    \n    return data.cache.cachedNodes;\n  };\n  \n  CanvasRenderer.prototype.updateNodesCache = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    data.cache.cachedNodes = cy.nodes();\n  };\n  \n  CanvasRenderer.prototype.getCachedEdges = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    if (data.cache.cachedEdges == null) {\n      data.cache.cachedEdges = cy.edges();\n    }\n    \n    return data.cache.cachedEdges;\n  };\n  \n  CanvasRenderer.prototype.updateEdgesCache = function() {\n    var data = this.data; var cy = this.data.cy;\n    \n    if (data.cache == null) {\n      data.cache = {};\n    }\n    \n    data.cache.cachedEdges = cy.edges();\n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // Project mouse\n  CanvasRenderer.prototype.projectIntoViewport = function(clientX, clientY) {\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    \n    var x = clientX - offsetLeft; \n    var y = clientY - offsetTop;\n    \n    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();\n    return [x, y];\n  };\n\n  CanvasRenderer.prototype.findContainerClientCoords = function() {\n    var container = this.data.container;\n\n    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();\n\n    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];\n  };\n\n  CanvasRenderer.prototype.invalidateContainerClientCoordsCache = function(){\n    this.containerBB = null;\n  };\n\n  // Find nearest element\n  CanvasRenderer.prototype.findNearestElement = function(x, y, visibleElementsOnly){\n    var self = this;\n    var eles = this.getCachedZSortedEles();\n    var near = [];\n    var isTouch = CanvasRenderer.isTouch;\n    var zoom = this.data.cy.zoom();\n    var hasCompounds = this.data.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 256 : 32) / zoom;\n    var nodeThreshold = (isTouch ? 16 : 0) /  zoom;\n\n    function checkNode(node){\n      var width = node.outerWidth();\n      var height = node.outerHeight();\n      var hw = width/2;\n      var hh = height/2;\n      var pos = node._private.position;\n\n      if(\n        pos.x - hw <= x && x <= pos.x + hw // bb check x\n          &&\n        pos.y - hh <= y && y <= pos.y + hh // bb check y\n      ){\n        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );\n\n        // exit early if invisible edge and must be visible\n        if( visibleElementsOnly && !visible ){\n          return;\n        }\n\n        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];\n        var borderWO = node._private.style['border-width'].pxValue / 2;\n\n        if(\n          shape.checkPoint(x, y, borderWO, width + nodeThreshold, height + nodeThreshold, pos.x, pos.y)\n        ){\n            near.push( node );\n        }\n\n      }\n    }\n\n    function checkEdge(edge){\n      var rs = edge._private.rscratch;\n      var style = edge._private.style;\n      var width = style['width'].pxValue;\n      var widthSq = width * width;\n      var width2 = width * 2;\n      var src = edge._private.source;\n      var tgt = edge._private.target;\n      var inEdgeBB = false;\n\n      // exit early if invisible edge and must be visible\n      var passedVisibilityCheck;\n      var passesVisibilityCheck = function(){\n        if( passedVisibilityCheck !== undefined ){\n          return passedVisibilityCheck;\n        }\n\n        if( !visibleElementsOnly ){\n          passedVisibilityCheck = true;\n          return true;\n        }\n\n        var visible = edge.visible() && !edge.transparent();\n        if( visible ){\n          passedVisibilityCheck = true;\n          return true;\n        }\n\n        passedVisibilityCheck = false;\n        return false;\n      };\n\n      if (rs.edgeType === 'self') {\n        if(\n            (\n              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))\n                && passesVisibilityCheck() &&\n              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY) )\n            )\n              ||\n            (\n              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))\n                && passesVisibilityCheck() &&\n              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY) )\n            )\n        ){\n          near.push( edge );\n        }\n      \n      } else if (rs.edgeType === 'haystack') {\n        var radius = style['haystack-radius'].value;\n        var halfRadius = radius/2; // b/c have to half width/height\n\n        var tgtPos = tgt._private.position;\n        var tgtW = tgt.width();\n        var tgtH = tgt.height();\n        var srcPos = src._private.position;\n        var srcW = src.width();\n        var srcH = src.height();\n\n        var startX = srcPos.x + rs.source.x * srcW * halfRadius;\n        var startY = srcPos.y + rs.source.y * srcH * halfRadius;\n        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;\n        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;\n\n        if( \n          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))\n            && passesVisibilityCheck() &&\n          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY )\n        ){\n          near.push( edge );\n        }\n      \n      } else if (rs.edgeType === 'straight') {\n        if(\n          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))\n            && passesVisibilityCheck() &&\n          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY)\n        ){\n          near.push( edge );\n        }\n      \n      } else if (rs.edgeType === 'bezier') {\n        if(\n          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))\n            && passesVisibilityCheck() &&\n          (widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY))\n        ){\n          near.push( edge );\n        }\n      }\n      \n      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){\n        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];\n        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];\n\n        var src = src || edge._private.source;\n        var tgt = tgt || edge._private.target;\n\n        var tgtPos = tgt._private.position;\n        var srcPos = src._private.position;\n\n        var srcArW = self.getArrowWidth( style['width'].pxValue );\n        var srcArH = self.getArrowHeight( style['width'].pxValue );\n\n        var tgtArW = srcArW;\n        var tgtArH = srcArH;\n\n        if(\n          (\n            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)\n              && \n            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)\n          )\n            ||\n          (\n            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)\n              &&\n            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)\n          )\n        ){\n          near.push( edge );\n        }\n      }\n\n      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){\n        checkNode( src );\n        checkNode( tgt );\n      }\n    }\n\n    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence\n      var ele = eles[i];\n\n      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early\n\n      if( ele._private.group === 'nodes' ){ \n        checkNode( eles[i] );\n\n      } else  { // then edge\n        checkEdge( eles[i] );\n      }\n\n    }\n  \n    \n    if( near.length > 0 ){\n      return near[ near.length - 1 ];\n    } else {\n      return null;\n    }\n  }; \n\n  // 'Give me everything from this box'\n  CanvasRenderer.prototype.getAllInBox = function(x1, y1, x2, y2) {\n    var nodes = this.getCachedNodes();\n    var edges = this.getCachedEdges();\n    var box = [];\n    \n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2); \n\n    x1 = x1c; \n    x2 = x2c; \n    y1 = y1c; \n    y2 = y2c; \n\n    var heur;\n    \n    for ( var i = 0; i < nodes.length; i++ ){\n      var pos = nodes[i]._private.position;\n      var nShape = this.getNodeShape(nodes[i]);\n      var w = this.getNodeWidth(nodes[i]);\n      var h = this.getNodeHeight(nodes[i]);\n      var border = nodes[i]._private.style['border-width'].pxValue / 2;\n      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];\n\n      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){\n        box.push(nodes[i]);\n      }\n    }\n    \n    for ( var i = 0; i < edges.length; i++ ){\n      var rs = edges[i]._private.rscratch;\n\n      if (edges[i]._private.rscratch.edgeType == 'self') {\n        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.cp2ax, rs.cp2ay,\n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              &&\n            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.cp2ax, rs.cp2ay,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))\n                ||\n          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.cp2cx, rs.cp2cy,\n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              &&\n            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.cp2cx, rs.cp2cy,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))\n          )\n        { box.push(edges[i]); }\n      }\n      \n      if (rs.edgeType == 'bezier' &&\n        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.cp2x, rs.cp2y,\n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              &&\n            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.cp2x, rs.cp2y,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))\n        { box.push(edges[i]); }\n    \n      if (rs.edgeType == 'straight' &&\n        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,\n            rs.startX, rs.startY,\n            rs.startX * 0.5 + rs.endX * 0.5, \n            rs.startY * 0.5 + rs.endY * 0.5, \n            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))\n              && /* console.log('test', heur) == undefined && */\n            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,\n              rs.startX, rs.startY,\n              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))\n        { box.push(edges[i]); }\n\n\n      if (rs.edgeType == 'haystack'){\n        var tgt = edges[i].target()[0];\n        var tgtPos = tgt.position();\n        var src = edges[i].source()[0];\n        var srcPos = src.position();\n\n        var startX = srcPos.x + rs.source.x;\n        var startY = srcPos.y + rs.source.y;\n        var endX = tgtPos.x + rs.target.x;\n        var endY = tgtPos.y + rs.target.y;\n\n        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);\n        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);\n\n        if( startInBox && endInBox ){\n          box.push( edges[i] );\n        }\n      }\n      \n    }\n    \n    return box;\n  };\n\n\n  /**\n   * Returns the width of the given node. If the width is set to auto,\n   * returns the value of the autoWidth field.\n   *\n   * @param node          a node\n   * @return {number}     width of the node\n   */\n  CanvasRenderer.prototype.getNodeWidth = function(node)\n  {\n    return node.width();\n  };\n\n  /**\n   * Returns the height of the given node. If the height is set to auto,\n   * returns the value of the autoHeight field.\n   *\n   * @param node          a node\n   * @return {number}     width of the node\n   */\n  CanvasRenderer.prototype.getNodeHeight = function(node)\n  {\n    return node.height();\n  };\n\n  /**\n   * Returns the shape of the given node. If the height or width of the given node\n   * is set to auto, the node is considered to be a compound.\n   *\n   * @param node          a node\n   * @return {String}     shape of the node\n   */\n  CanvasRenderer.prototype.getNodeShape = function(node)\n  {\n    // TODO only allow rectangle for a compound node?\n//    if (node._private.style['width'].value == 'auto' ||\n//        node._private.style['height'].value == 'auto')\n//    {\n//      return 'rectangle';\n//    }\n\n    var shape = node._private.style['shape'].value;\n\n    if( node.isParent() ){\n      if( shape === 'rectangle' || shape === 'roundrectangle' ){\n        return shape;\n      } else {\n        return 'rectangle';\n      }\n    }\n\n    return shape;\n  };\n\n\n  CanvasRenderer.prototype.getNodePadding = function(node)\n  {\n    var left = node._private.style['padding-left'].pxValue;\n    var right = node._private.style['padding-right'].pxValue;\n    var top = node._private.style['padding-top'].pxValue;\n    var bottom = node._private.style['padding-bottom'].pxValue;\n\n    if (isNaN(left))\n    {\n      left = 0;\n    }\n\n    if (isNaN(right))\n    {\n      right = 0;\n    }\n\n    if (isNaN(top))\n    {\n      top = 0;\n    }\n\n    if (isNaN(bottom))\n    {\n      bottom = 0;\n    }\n\n    return {left : left,\n      right : right,\n      top : top,\n      bottom : bottom};\n  };\n\n  CanvasRenderer.prototype.zOrderSort = $$.Collection.zIndexSort;\n\n  CanvasRenderer.prototype.updateCachedZSortedEles = function(){\n    this.getCachedZSortedEles( true );\n  };\n\n  CanvasRenderer.prototype.getCachedZSortedEles = function( forceRecalc ){\n    var lastNodes = this.lastZOrderCachedNodes;\n    var lastEdges = this.lastZOrderCachedEdges;\n    var nodes = this.getCachedNodes();\n    var edges = this.getCachedEdges();\n    var eles = [];\n\n    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ \n      //console.time('cachezorder')\n      \n      for( var i = 0; i < nodes.length; i++ ){\n        if( nodes[i].visible() && !nodes[i].transparent() ){\n          eles.push( nodes[i] );\n        }\n      }\n\n      for( var i = 0; i < edges.length; i++ ){\n        if( edges[i].visible() && !edges[i].transparent() ){\n          eles.push( edges[i] );\n        }\n      }\n\n      eles.sort( this.zOrderSort );\n      this.cachedZSortedEles = eles;\n      //console.log('make cache')\n\n      //console.timeEnd('cachezorder')\n    } else {\n      eles = this.cachedZSortedEles;\n      //console.log('read cache')\n    }\n\n    this.lastZOrderCachedNodes = nodes;\n    this.lastZOrderCachedEdges = edges;\n\n    return eles;\n  };\n\n  CanvasRenderer.prototype.projectBezier = function(edge){\n    var qbezierAt = $$.math.qbezierAt;\n    var rs = edge._private.rscratch;\n    var bpts = edge._private.rstyle.bezierPts = [];\n\n    function pushBezierPts(pts){\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )\n      });\n\n      var mid = {\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )\n      };\n\n      bpts.push( mid );\n\n      if( rs.edgeType === 'self' ){\n        rs.midX = rs.selfEdgeMidX;\n        rs.midY = rs.selfEdgeMidY;\n      } else {\n        rs.midX = mid.x;\n        rs.midY = mid.y;\n      }\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )\n      });\n\n      bpts.push({\n        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),\n        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )\n      });\n    }\n\n    if( rs.edgeType === 'self' ){\n      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );\n      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );\n    } else if( rs.edgeType === 'bezier' ){\n      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );\n    }\n  };\n\n  CanvasRenderer.prototype.recalculateNodeLabelProjection = function( node ){\n    var content = node._private.style['content'].strValue;\n    if( !content || content.match(/^\\s+$/) ){ return; }\n\n    var textX, textY;\n    var nodeWidth = node.outerWidth();\n    var nodeHeight = node.outerHeight();\n    var nodePos = node._private.position;\n    var textHalign = node._private.style['text-halign'].strValue;\n    var textValign = node._private.style['text-valign'].strValue;\n    var rs = node._private.rscratch;\n    var rstyle = node._private.rstyle;\n\n    switch( textHalign ){\n      case 'left':\n        textX = nodePos.x - nodeWidth / 2;\n        break;\n\n      case 'right':\n        textX = nodePos.x + nodeWidth / 2;\n        break;\n\n      default: // e.g. center\n        textX = nodePos.x;\n    }\n\n    switch( textValign ){\n      case 'top':\n        textY = nodePos.y - nodeHeight / 2;\n        break;\n\n      case 'bottom':\n        textY = nodePos.y + nodeHeight / 2;\n        break;\n\n      default: // e.g. middle\n        textY = nodePos.y;\n    }\n  \n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n\n    this.applyLabelDimensions( node );\n  };\n\n  CanvasRenderer.prototype.recalculateEdgeLabelProjection = function( edge ){\n    var content = edge._private.style['content'].strValue;\n    if( !content || content.match(/^\\s+$/) ){ return; }\n\n    var textX, textY;  \n    var edgeCenterX, edgeCenterY;\n    var rs = edge._private.rscratch;\n    var rstyle = edge._private.rstyle;\n    \n    if (rs.edgeType == 'self') {\n      edgeCenterX = rs.selfEdgeMidX;\n      edgeCenterY = rs.selfEdgeMidY;\n    } else if (rs.edgeType == 'straight') {\n      edgeCenterX = (rs.startX + rs.endX) / 2;\n      edgeCenterY = (rs.startY + rs.endY) / 2;\n    } else if (rs.edgeType == 'bezier') {\n      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );\n      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );\n    } else if (rs.edgeType == 'haystack') {\n      var srcPos = edge._private.source._private.position;\n      var tgtPos = edge._private.target._private.position;\n\n      edgeCenterX = (srcPos.x + rs.source.x + tgtPos.x + rs.target.x)/2;\n      edgeCenterY = (srcPos.y + rs.source.y + tgtPos.y + rs.target.y)/2;\n    }\n    \n    textX = edgeCenterX;\n    textY = edgeCenterY;\n\n    // add center point to style so bounding box calculations can use it\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n\n    this.applyLabelDimensions( edge );\n  };\n\n  CanvasRenderer.prototype.applyLabelDimensions = function( ele ){\n    var rs = ele._private.rscratch;\n    var rstyle = ele._private.rstyle;\n\n    var text = this.getLabelText( ele );\n    var labelDims = this.calculateLabelDimensions( ele, text );\n \n    rstyle.labelWidth = labelDims.width;\n    rs.labelWidth = labelDims.width;\n \n    rstyle.labelHeight = labelDims.height;\n    rs.labelHeight = labelDims.height;\n  };\n\n  CanvasRenderer.prototype.getLabelText = function( ele ){\n    var style = ele._private.style;\n    var text = ele._private.style['content'].strValue;\n    var textTransform = style['text-transform'].value;\n    \n    if (textTransform == 'none') {\n    } else if (textTransform == 'uppercase') {\n      text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n      text = text.toLowerCase();\n    }\n\n    return text;\n  };\n\n  CanvasRenderer.prototype.calculateLabelDimensions = function( ele, text ){\n    var r = this;\n    var style = ele._private.style;\n    var fStyle = style['font-style'].strValue;\n    var size = style['font-size'].pxValue + 'px';\n    var family = style['font-family'].strValue;\n    // var variant = style['font-variant'].strValue;\n    var weight = style['font-weight'].strValue;\n\n    var cacheKey = ele._private.labelKey;\n    var cache = r.labelDimCache || (r.labelDimCache = {});\n\n    if( cache[cacheKey] ){\n      return cache[cacheKey];\n    }\n\n    var div = this.labelCalcDiv;\n\n    if( !div ){\n      div = this.labelCalcDiv = document.createElement('div');\n      document.body.appendChild( div );\n    }\n\n    var ds = div.style;\n\n    // from ele style\n    ds.fontFamily = family;\n    ds.fontStyle = fStyle;\n    ds.fontSize = size;\n    // ds.fontVariant = variant;\n    ds.fontWeight = weight;\n\n    // forced style\n    ds.position = 'absolute';\n    ds.left = '-9999px';\n    ds.top = '-9999px';\n    ds.zIndex = '-1';\n    ds.visibility = 'hidden';\n    ds.pointerEvents = 'none';\n    ds.padding = '0';\n    ds.lineHeight = '1';\n\n    // put label content in div\n    div.textContent = text;\n\n    cache[cacheKey] = {\n      width: div.clientWidth,\n      height: div.clientHeight\n    };\n\n    return cache[cacheKey];\n  };  \n\n  CanvasRenderer.prototype.recalculateRenderedStyle = function( eles ){\n    var edges = [];\n    var nodes = [];\n    var handledEdge = {};\n\n    for( var i = 0; i < eles.length; i++ ){\n      var ele = eles[i];\n      var _p = ele._private;\n      var rs = _p.rscratch;\n      var rstyle = _p.rstyle;\n      var id = _p.data.id;\n      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;\n      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;\n      var styleSame = bbStyleSame && labelStyleSame;\n\n      if( ele._private.group === 'nodes' ){\n        var pos = _p.position;\n        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;\n\n        if( !posSame || !styleSame ){\n          nodes.push( ele );\n        }\n\n        rstyle.nodeX = pos.x;\n        rstyle.nodeY = pos.y;\n      } else { // edges\n\n        var srcPos = ele._private.source._private.position;\n        var tgtPos = ele._private.target._private.position;\n        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;\n        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;\n        var positionsSame = srcSame && tgtSame;\n\n        if( !positionsSame || !styleSame ){\n          var curveType = _p.style['curve-style'].value;\n\n          if( curveType === 'bezier' ){\n            if( !handledEdge[ id ] ){\n              edges.push( ele );\n              handledEdge[ id ] = true;\n\n              var parallelEdges = ele.parallelEdges();\n              for( var i = 0; i < parallelEdges.length; i++ ){\n                var pEdge = parallelEdges[i];\n                var pId = pEdge._private.data.id;\n\n                if( !handledEdge[ pId ] ){\n                  edges.push( pEdge );\n                  handledEdge[ pId ] = true;\n                }\n                \n              }\n            }\n          } else {\n            edges.push( ele );\n          }\n        } // if positions diff\n\n        // update rstyle positions\n        rstyle.srcX = srcPos.x;\n        rstyle.srcY = srcPos.y;\n        rstyle.tgtX = tgtPos.x;\n        rstyle.tgtY = tgtPos.y;\n\n      } // if edges\n\n      rs.boundingBoxKey = _p.boundingBoxKey;\n      rs.labelKey = _p.labelKey;\n    }\n\n    this.recalculateEdgeProjections( edges );\n    this.recalculateLabelProjections( nodes, edges );\n  };\n\n  CanvasRenderer.prototype.recalculateLabelProjections = function( nodes, edges ){\n    for( var i = 0; i < nodes.length; i++ ){\n      this.recalculateNodeLabelProjection( nodes[i] );\n    }\n\n    for( var i = 0; i < edges.length; i++ ){\n      this.recalculateEdgeLabelProjection( edges[i] );\n    }\n  };\n\n  CanvasRenderer.prototype.recalculateEdgeProjections = function( edges ){\n    this.findEdgeControlPoints( edges );\n  };\n\n\n  // Find edge control points\n  CanvasRenderer.prototype.findEdgeControlPoints = function(edges) {\n    if( !edges || edges.length === 0 ){ return; }\n\n    var hashTable = {};\n    var pairIds = [];\n    var haystackEdges = [];\n\n    // create a table of edge (src, tgt) => list of edges between them\n    var pairId;\n    for (var i = 0; i < edges.length; i++){\n      var edge = edges[i];\n      var style = edge._private.style;\n      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';\n\n      // ignore edges who are not to be displayed\n      // they shouldn't take up space\n      if( style.display.value === 'none' ){\n        continue;\n      }\n\n      if( style['curve-style'].value === 'haystack' ){\n        haystackEdges.push( edge );\n        continue;\n      }\n\n      var srcId = edge._private.data.source;\n      var tgtId = edge._private.data.target;\n\n      pairId = srcId > tgtId ?\n        tgtId + '-' + srcId :\n        srcId + '-' + tgtId ;\n\n      if( edgeIsUnbundled ){\n        pairId = 'unbundled' + edge._private.data.id;\n      }\n\n      if (hashTable[pairId] == null) {\n        hashTable[pairId] = [];\n        pairIds.push( pairId );\n      }\n      \n      hashTable[pairId].push( edge );\n\n      if( edgeIsUnbundled ){\n        hashTable[pairId].hasUnbundled = true;\n      }\n    }\n\n    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;\n    var vectorNormInverse;\n    var badBezier;\n    \n    // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount  \n    for (var p = 0; p < pairIds.length; p++) {\n      pairId = pairIds[p];\n      var pairEdges = hashTable[pairId];\n    \n      // for each pair id, the edges should be sorted by index\n      pairEdges.sort(function(edge1, edge2){\n        return edge1._private.index - edge2._private.index;\n      });\n\n      src = pairEdges[0]._private.source;\n      tgt = pairEdges[0]._private.target;\n\n      // make sure src/tgt distinction is consistent\n      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)\n      if( src._private.data.id > tgt._private.data.id ){\n        var temp = src;\n        src = tgt;\n        tgt = temp;\n      }\n\n      srcPos = src._private.position;\n      tgtPos = tgt._private.position;\n\n      srcW = this.getNodeWidth(src);\n      srcH = this.getNodeHeight(src);\n\n      tgtW = this.getNodeWidth(tgt);\n      tgtH = this.getNodeHeight(tgt);\n\n      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];\n      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];\n\n      srcBorder = src._private.style['border-width'].pxValue;\n      tgtBorder = tgt._private.style['border-width'].pxValue;\n\n      badBezier = false;\n      \n\n      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){\n\n        // pt outside src shape to calc distance/displacement from src to tgt\n        var srcOutside = srcShape.intersectLine(\n          srcPos.x,\n          srcPos.y,\n          srcW,\n          srcH,\n          tgtPos.x,\n          tgtPos.y,\n          srcBorder / 2\n        );\n\n        // pt outside tgt shape to calc distance/displacement from src to tgt\n        var tgtOutside = tgtShape.intersectLine(\n          tgtPos.x,\n          tgtPos.y,\n          tgtW,\n          tgtH,\n          srcPos.x,\n          srcPos.y,\n          tgtBorder / 2\n        );\n\n        var midptSrcPts = {\n          x1: srcOutside[0],\n          x2: tgtOutside[0],\n          y1: srcOutside[1],\n          y2: tgtOutside[1]\n        };\n\n        var dy = ( tgtOutside[1] - srcOutside[1] );\n        var dx = ( tgtOutside[0] - srcOutside[0] );\n        var l = Math.sqrt( dx*dx + dy*dy );\n\n        var vector = {\n          x: dx,\n          y: dy\n        };\n        \n        var vectorNorm = {\n          x: vector.x/l,\n          y: vector.y/l\n        };\n        vectorNormInverse = {\n          x: -vectorNorm.y,\n          y: vectorNorm.x\n        };\n\n        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw\n        if( \n          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||\n          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) \n        ){\n          vectorNormInverse = {};\n          badBezier = true;\n        }\n        \n      }\n      \n      var edge;\n      var rs;\n      \n      for (var i = 0; i < pairEdges.length; i++) {\n        edge = pairEdges[i];\n        rs = edge._private.rscratch;\n        \n        var edgeIndex1 = rs.lastEdgeIndex;\n        var edgeIndex2 = i;\n\n        var numEdges1 = rs.lastNumEdges;\n        var numEdges2 = pairEdges.length;\n\n        var eStyle = edge._private.style;\n        var stepSize = eStyle['control-point-step-size'].pxValue;\n        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;\n        var stepWeight = eStyle['control-point-weight'].value;\n        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';\n\n        var srcX1 = rs.lastSrcCtlPtX;\n        var srcX2 = srcPos.x;\n        var srcY1 = rs.lastSrcCtlPtY;\n        var srcY2 = srcPos.y;\n        var srcW1 = rs.lastSrcCtlPtW;\n        var srcW2 = src.outerWidth();\n        var srcH1 = rs.lastSrcCtlPtH;\n        var srcH2 = src.outerHeight();\n\n        var tgtX1 = rs.lastTgtCtlPtX;\n        var tgtX2 = tgtPos.x;\n        var tgtY1 = rs.lastTgtCtlPtY;\n        var tgtY2 = tgtPos.y;\n        var tgtW1 = rs.lastTgtCtlPtW;\n        var tgtW2 = tgt.outerWidth();\n        var tgtH1 = rs.lastTgtCtlPtH;\n        var tgtH2 = tgt.outerHeight();\n\n        if( badBezier ){\n          rs.badBezier = true;\n        } else {\n          rs.badBezier = false;\n        }\n\n        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2\n        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2\n        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){\n          // console.log('edge ctrl pt cache HIT')\n          continue; // then the control points haven't changed and we can skip calculating them\n        } else {\n          rs.lastSrcCtlPtX = srcX2;\n          rs.lastSrcCtlPtY = srcY2;\n          rs.lastSrcCtlPtW = srcW2;\n          rs.lastSrcCtlPtH = srcH2;\n          rs.lastTgtCtlPtX = tgtX2;\n          rs.lastTgtCtlPtY = tgtY2;\n          rs.lastTgtCtlPtW = tgtW2;\n          rs.lastTgtCtlPtH = tgtH2;\n          rs.lastEdgeIndex = edgeIndex2;\n          rs.lastNumEdges = numEdges2;\n          // console.log('edge ctrl pt cache MISS')\n        }\n\n        // Self-edge\n        if ( src === tgt ) {\n            \n          rs.edgeType = 'self';\n          \n          var j = i;\n          var loopDist = stepSize;\n\n          if( edgeIsUnbundled ){\n            j = 0;\n            loopDist = stepDist;\n          }\n\n          // New -- fix for large nodes\n          rs.cp2ax = srcPos.x;\n          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);\n          \n          rs.cp2cx = src._private.position.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);\n          rs.cp2cy = srcPos.y;\n          \n          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;\n          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;\n          \n        // Straight edge\n        } else if (pairEdges.length % 2 === 1\n          && i === Math.floor(pairEdges.length / 2)\n          && !edgeIsUnbundled ) {\n          \n          rs.edgeType = 'straight';\n          \n        // Bezier edge\n        } else {\n          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;\n          var manStepDist;\n          var sign = $$.math.signum( normStepDist );\n\n          if( edgeIsUnbundled ){\n            manStepDist = stepDist;\n          } else {\n            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; \n          }\n\n          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;\n          \n          var w1 = (1 - stepWeight);\n          var w2 = stepWeight;\n\n          var swappedDirection = edge._private.source !== src;\n          if( swappedDirection ){\n            w1 = stepWeight;\n            w2 = (1 - stepWeight);\n          }\n\n          var adjustedMidpt = {\n            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,\n            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2\n          };\n\n          rs.edgeType = 'bezier';\n          \n          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;\n          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;\n          \n          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);\n        }\n\n        // find endpts for edge\n        this.findEndpoints( edge );\n\n        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );\n        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );\n        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );\n        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );\n\n        var minCpADistFactor = 3;\n        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;\n        var minCpADist = minCpADistFactor * arrowW;\n        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );\n        var closeStartACp = startACpDist < minCpADist;\n        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );\n        var closeEndACp = endACpDist < minCpADist;\n\n        if( rs.edgeType === 'bezier' ){\n          var overlapping = false;\n\n          if( badStart || badAStart || closeStartACp ){\n            overlapping = true;\n\n            // project control point along line from src centre to outside the src shape\n            // (otherwise intersection will yield nothing)\n            var cpD = { // delta\n              x: rs.cp2x - srcPos.x,\n              y: rs.cp2y - srcPos.y\n            };\n            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line\n            var cpM = { // normalised delta\n              x: cpD.x / cpL,\n              y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = { // *2 radius guarantees outside shape\n              x: rs.cp2x + cpM.x * 2 * radius,\n              y: rs.cp2y + cpM.y * 2 * radius\n            };\n\n            var srcCtrlPtIntn = srcShape.intersectLine(\n              srcPos.x,\n              srcPos.y,\n              srcW,\n              srcH,\n              cpProj.x,\n              cpProj.y,\n              srcBorder / 2\n            );\n\n            if( closeStartACp ){\n              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); \n              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);\n            } else {\n              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; \n              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n          }\n\n          if( badEnd || badAEnd || closeEndACp ){\n            overlapping = true;\n\n            // project control point along line from tgt centre to outside the tgt shape\n            // (otherwise intersection will yield nothing)\n            var cpD = { // delta\n              x: rs.cp2x - tgtPos.x,\n              y: rs.cp2y - tgtPos.y\n            };\n            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line\n            var cpM = { // normalised delta\n              x: cpD.x / cpL,\n              y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = { // *2 radius guarantees outside shape\n              x: rs.cp2x + cpM.x * 2 * radius,\n              y: rs.cp2y + cpM.y * 2 * radius\n            };\n\n            var tgtCtrlPtIntn = tgtShape.intersectLine(\n              tgtPos.x,\n              tgtPos.y,\n              tgtW,\n              tgtH,\n              cpProj.x,\n              cpProj.y,\n              tgtBorder / 2\n            );\n\n            if( closeEndACp ){\n              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); \n              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);\n            } else {\n              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; \n              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n            \n          }\n\n          if( overlapping ){\n            // recalc endpts\n            this.findEndpoints( edge );\n          }\n        } else if( rs.edgeType === 'straight' ){\n          rs.midX = ( srcX2 + tgtX2 )/2;\n          rs.midY = ( srcY2 + tgtY2 )/2;\n        }\n\n        // project the edge into rstyle\n        this.projectBezier( edge );\n\n      }\n    }\n      \n    for( var i = 0; i < haystackEdges.length; i++ ){\n      var edge = haystackEdges[i];\n      var rscratch = edge._private.rscratch;\n\n      if( !rscratch.haystack ){\n        var angle = Math.random() * 2 * Math.PI;\n\n        rscratch.source = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n\n        var angle = Math.random() * 2 * Math.PI;\n\n        rscratch.target = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n\n        rscratch.edgeType = 'haystack';\n        rscratch.haystack = true;\n      }  \n    }\n\n    return hashTable;\n  };\n\n  CanvasRenderer.prototype.findEndpoints = function(edge) {\n    var intersect;\n\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    \n    var tgtArShape = edge._private.style['target-arrow-shape'].value;\n    var srcArShape = edge._private.style['source-arrow-shape'].value;\n\n    var tgtBorderW = target._private.style['border-width'].pxValue;\n    var srcBorderW = source._private.style['border-width'].pxValue;\n\n    var rs = edge._private.rscratch;\n    \n    if (edge._private.rscratch.edgeType == 'self') {\n      \n      var cp = [rs.cp2cx, rs.cp2cy];\n      \n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(\n        target._private.position.x,\n        target._private.position.y,\n        this.getNodeWidth(target),\n        this.getNodeHeight(target),\n        cp[0],\n        cp[1], \n        tgtBorderW / 2\n      );\n      \n      var arrowEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));\n      var edgeEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));\n      \n      rs.endX = edgeEnd[0];\n      rs.endY = edgeEnd[1];\n      \n      rs.arrowEndX = arrowEnd[0];\n      rs.arrowEndY = arrowEnd[1];\n      \n      var cp = [rs.cp2ax, rs.cp2ay];\n\n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(\n        source._private.position.x,\n        source._private.position.y,\n        this.getNodeWidth(source),\n        this.getNodeHeight(source),\n        cp[0], //halfPointX,\n        cp[1], //halfPointY\n        srcBorderW / 2\n      );\n      \n      var arrowStart = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));\n      var edgeStart = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[srcArShape].gap(edge));\n      \n      rs.startX = edgeStart[0];\n      rs.startY = edgeStart[1];\n\n\n      rs.arrowStartX = arrowStart[0];\n      rs.arrowStartY = arrowStart[1];\n      \n    } else if (rs.edgeType == 'straight') {\n    \n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(\n        target._private.position.x,\n        target._private.position.y,\n        this.getNodeWidth(target),\n        this.getNodeHeight(target),\n        source.position().x,\n        source.position().y,\n        tgtBorderW / 2);\n        \n      if (intersect.length === 0) {\n        rs.noArrowPlacement = true;\n  //      return;\n      } else {\n        rs.noArrowPlacement = false;\n      }\n      \n      var arrowEnd = $$.math.shortenIntersection(intersect,\n        [source.position().x, source.position().y],\n        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));\n      var edgeEnd = $$.math.shortenIntersection(intersect,\n        [source.position().x, source.position().y],\n        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));\n\n      rs.endX = edgeEnd[0];\n      rs.endY = edgeEnd[1];\n      \n      rs.arrowEndX = arrowEnd[0];\n      rs.arrowEndY = arrowEnd[1];\n    \n      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(\n        source._private.position.x,\n        source._private.position.y,\n        this.getNodeWidth(source),\n        this.getNodeHeight(source),\n        target.position().x,\n        target.position().y,\n        srcBorderW / 2);\n      \n      if (intersect.length === 0) {\n        rs.noArrowPlacement = true;\n  //      return;\n      } else {\n        rs.noArrowPlacement = false;\n      }\n      \n      /*\n      console.log(\"1: \"\n        + CanvasRenderer.arrowShapes[srcArShape],\n          srcArShape);\n      */\n      var arrowStart = $$.math.shortenIntersection(intersect,\n        [target.position().x, target.position().y],\n        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));\n      var edgeStart = $$.math.shortenIntersection(intersect,\n        [target.position().x, target.position().y],\n        CanvasRenderer.arrowShapes[srcArShape].gap(edge));\n\n      rs.startX = edgeStart[0];\n      rs.startY = edgeStart[1];\n      \n      rs.arrowStartX = arrowStart[0];\n      rs.arrowStartY = arrowStart[1];\n            \n    } else if (rs.edgeType == 'bezier') {\n      // if( window.badArrow) debugger;\n      var cp = [rs.cp2x, rs.cp2y];\n      \n      intersect = CanvasRenderer.nodeShapes[\n        this.getNodeShape(target)].intersectLine(\n        target._private.position.x,\n        target._private.position.y,\n        this.getNodeWidth(target),\n        this.getNodeHeight(target),\n        cp[0], //halfPointX,\n        cp[1], //halfPointY\n        tgtBorderW / 2\n      );\n      \n      /*\n      console.log(\"2: \"\n        + CanvasRenderer.arrowShapes[srcArShape],\n          srcArShape);\n      */\n      var arrowEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));\n      var edgeEnd = $$.math.shortenIntersection(intersect, cp,\n        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));\n      \n      rs.endX = edgeEnd[0];\n      rs.endY = edgeEnd[1];\n      \n      rs.arrowEndX = arrowEnd[0];\n      rs.arrowEndY = arrowEnd[1];\n      \n      intersect = CanvasRenderer.nodeShapes[\n        this.getNodeShape(source)].intersectLine(\n        source._private.position.x,\n        source._private.position.y,\n        this.getNodeWidth(source),\n        this.getNodeHeight(source),\n        cp[0], //halfPointX,\n        cp[1], //halfPointY\n        srcBorderW / 2\n      );\n      \n      var arrowStart = $$.math.shortenIntersection(\n        intersect, \n        cp,\n        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)\n      );\n      var edgeStart = $$.math.shortenIntersection(\n        intersect, \n        cp,\n        CanvasRenderer.arrowShapes[srcArShape].gap(edge)\n      );\n    \n      rs.startX = edgeStart[0];\n      rs.startY = edgeStart[1];\n      \n      rs.arrowStartX = arrowStart[0];\n      rs.arrowStartY = arrowStart[1];\n      \n      // if( isNaN(rs.startX) || isNaN(rs.startY) ){\n      //   debugger;\n      // }\n\n    } else if (rs.isArcEdge) {\n      return;\n    }\n  };\n\n  // Find adjacent edges\n  CanvasRenderer.prototype.findEdges = function(nodeSet) {\n    \n    var edges = this.getCachedEdges();\n    \n    var hashTable = {};\n    var adjacentEdges = [];\n    \n    for (var i = 0; i < nodeSet.length; i++) {\n      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];\n    }\n    \n    for (var i = 0; i < edges.length; i++) {\n      if (hashTable[edges[i]._private.data.source]\n        || hashTable[edges[i]._private.data.target]) {\n        \n        adjacentEdges.push(edges[i]);\n      }\n    }\n    \n    return adjacentEdges;\n  };\n\n  CanvasRenderer.prototype.getArrowWidth = CanvasRenderer.prototype.getArrowHeight = function(edgeWidth) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n\n    var cachedVal = cache[edgeWidth];\n    if( cachedVal ){\n      return cachedVal;\n    }\n\n    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);\n    cache[edgeWidth] = cachedVal;\n\n    return cachedVal;\n  };\n\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n// Draw edge\n  CanvasRenderer.prototype.drawEdge = function(context, edge, drawOverlayInstead) {\n    var rs = edge._private.rscratch;\n    var usePaths = CanvasRenderer.usePaths();\n\n    // if bezier ctrl pts can not be calculated, then die\n    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs\n      return;\n    }\n\n    var style = edge._private.style;\n    \n    // Edge line width\n    if (style['width'].pxValue <= 0) {\n      return;\n    }\n\n    var overlayPadding = style['overlay-padding'].pxValue;\n    var overlayOpacity = style['overlay-opacity'].value;\n    var overlayColor = style['overlay-color'].value;\n\n    // Edge color & opacity\n    if( drawOverlayInstead ){\n\n      if( overlayOpacity === 0 ){ // exit early if no overlay\n        return;\n      }\n\n      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);\n      context.lineCap = 'round';\n\n      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){\n        context.lineCap = 'butt';\n      }\n\n    } else {\n      var lineColor = style['line-color'].value;\n\n      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);\n      \n      context.lineCap = 'butt'; \n    }\n    \n    var startNode, endNode, source, target;\n    source = startNode = edge._private.source;\n    target = endNode = edge._private.target;\n\n    var targetPos = target._private.position;\n    var targetW = target.width();\n    var targetH = target.height();\n    var sourcePos = source._private.position;\n    var sourceW = source.width();\n    var sourceH = source.height();\n\n\n    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);\n    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;\n    context.lineWidth = edgeWidth;\n    \n    if( rs.edgeType !== 'haystack' ){\n      //this.findEndpoints(edge);\n    }\n    \n    if( rs.edgeType === 'haystack' ){\n      var radius = style['haystack-radius'].value;\n      var halfRadius = radius/2; // b/c have to half width/height\n\n      this.drawStyledEdge(\n        edge, \n        context, \n        rs.haystackPts = [\n          rs.source.x * sourceW * halfRadius + sourcePos.x,\n          rs.source.y * sourceH * halfRadius + sourcePos.y,\n          rs.target.x * targetW * halfRadius + targetPos.x,\n          rs.target.y * targetH * halfRadius + targetPos.y\n        ],\n        lineStyle,\n        edgeWidth\n      );\n    } else if (rs.edgeType === 'self') {\n      \n      var details = edge._private.rscratch;\n      var points = [details.startX, details.startY, details.cp2ax,\n        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,\n        details.selfEdgeMidX, details.selfEdgeMidY,\n        details.cp2cx, details.cp2cy, details.endX, details.endY];\n\n      var details = edge._private.rscratch;\n      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);\n      \n    } else if (rs.edgeType === 'straight') {\n      \n      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;\n      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;\n      \n      var edgeDirectionX = rs.endX - rs.startX;\n      var edgeDirectionY = rs.endY - rs.startY;\n      \n      if (nodeDirectionX * edgeDirectionX\n        + nodeDirectionY * edgeDirectionY < 0) {\n        \n        rs.straightEdgeTooShort = true;  \n      } else {\n        \n        var details = rs;\n        this.drawStyledEdge(edge, context, [details.startX, details.startY,\n                                      details.endX, details.endY],\n                                      lineStyle,\n                                      edgeWidth);\n        \n        rs.straightEdgeTooShort = false;  \n      }  \n    } else {\n      \n      var details = rs;\n      \n      this.drawStyledEdge(edge, context, [details.startX, details.startY,\n        details.cp2x, details.cp2y, details.endX, details.endY],\n        lineStyle,\n        edgeWidth);\n      \n    }\n    \n    if( rs.edgeType === 'haystack' ){\n      this.drawArrowheads(context, edge, drawOverlayInstead);\n    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){\n      this.drawArrowheads(context, edge, drawOverlayInstead);\n    }\n\n  };\n  \n  \n  CanvasRenderer.prototype.drawStyledEdge = function(\n      edge, context, pts, type, width) {\n\n    // 3 points given -> assume Bezier\n    // 2 -> assume straight\n    \n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = CanvasRenderer.usePaths();\n\n\n    if( usePaths ){\n\n      var pathCacheKey = pts;\n      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;\n      var keyMatches = keyLengthMatches;\n\n      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){\n        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){\n          keyMatches = false;\n        }\n      }\n\n      if( keyMatches ){\n        path = context = rs.pathCache;\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        rs.pathCacheKey = pathCacheKey;\n        rs.pathCache = path;\n      }\n\n    }\n\n    if( canvasCxt.setLineDash ){ // for very outofdate browsers\n      switch( type ){\n        case 'dotted':\n          canvasCxt.setLineDash([ 1, 1 ]);\n          break;\n\n        case 'dashed':\n          canvasCxt.setLineDash([ 6, 3 ]);\n          break;\n\n        case 'solid':\n          canvasCxt.setLineDash([ ]);\n          break;\n      }\n    }\n\n    if( !pathCacheHit ){\n      if( context.beginPath ){ context.beginPath(); }\n      context.moveTo(pts[0], pts[1]);\n      \n      if (pts.length === 3 * 2) { // bezier\n        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);\n      } else if( pts.length === 3 * 2 * 2 ){ // double bezier loop\n        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);\n        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);\n      } else { // line\n        context.lineTo(pts[2], pts[3]);\n      }\n    }\n\n    context = canvasCxt;\n    if( usePaths ){\n      context.stroke( path );\n    } else {\n      context.stroke();\n    }\n  \n    // reset any line dashes\n    if( context.setLineDash ){ // for very outofdate browsers\n      context.setLineDash([ ]);\n    }\n\n  };\n\n  CanvasRenderer.prototype.drawArrowheads = function(context, edge, drawOverlayInstead) {\n    if( drawOverlayInstead ){ return; } // don't do anything for overlays \n\n    var rs = edge._private.rscratch;\n    var self = this;\n    var isHaystack = rs.edgeType === 'haystack';\n\n    // Displacement gives direction for arrowhead orientation\n    var dispX, dispY;\n    var startX, startY, endX, endY;\n\n    var srcPos = edge.source().position();\n    var tgtPos = edge.target().position();\n\n    if( isHaystack ){\n      startX = rs.haystackPts[0];\n      startY = rs.haystackPts[1];\n      endX = rs.haystackPts[2];\n      endY = rs.haystackPts[3];\n    } else {\n      startX = rs.arrowStartX;\n      startY = rs.arrowStartY;\n      endX = rs.arrowEndX;\n      endY = rs.arrowEndY;\n    }\n\n    var style = edge._private.style;\n    \n    function drawArrowhead( prefix, x, y, dispX, dispY ){\n      var arrowShape = style[prefix + '-arrow-shape'].value;\n\n      if( arrowShape === 'none' ){\n        return;\n      }\n\n      var gco = context.globalCompositeOperation;\n\n      context.globalCompositeOperation = 'destination-out';\n      \n      self.fillStyle(context, 255, 255, 255, 1);\n\n\n      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';\n      var arrowFill = style[prefix + '-arrow-fill'].value;\n\n      if( arrowShape === 'half-triangle-overshot' ){\n        arrowFill = 'hollow';\n        arrowClearFill = 'hollow';\n      }\n\n      self.drawArrowShape( edge, prefix, context, \n        arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, \n        x, y, dispX, dispY\n      );\n\n      context.globalCompositeOperation = gco;\n\n      var color = style[prefix + '-arrow-color'].value;\n      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);\n\n      self.drawArrowShape( edge, prefix, context, \n        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, \n        x, y, dispX, dispY\n      );\n    }\n\n    dispX = startX - srcPos.x;\n    dispY = startY - srcPos.y;\n\n    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){\n      drawArrowhead( 'source', startX, startY, dispX, dispY );\n\n    } else {\n      // window.badArrow = true;\n      // debugger;\n    }\n    \n    var midX = rs.midX;\n    var midY = rs.midY;\n\n    if( isHaystack ){\n      midX = ( startX + endX )/2;\n      midY = ( startY + endY )/2;\n    }\n\n    dispX = startX - endX;\n    dispY = startY - endY;\n\n    if( rs.edgeType === 'self' ){\n      dispX = 1;\n      dispY = -1;\n    }\n\n    if( !isNaN(midX) && !isNaN(midY) ){\n      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );\n    }\n\n    dispX *= -1;\n    dispY *= -1;\n\n    if( !isNaN(midX) && !isNaN(midY) ){\n      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );\n    }\n    \n    dispX = endX - tgtPos.x;\n    dispY = endY - tgtPos.y;\n    \n    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){\n      drawArrowhead( 'target', endX, endY, dispX, dispY );\n    }\n  };\n  \n  // Draw arrowshape\n  CanvasRenderer.prototype.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {\n    var usePaths = CanvasRenderer.usePaths();\n    var rs = edge._private.rscratch;\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = { x: x, y: y };\n\n    // Negative of the angle\n    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));\n  \n    if (dispX < 0) {\n      angle = angle + Math.PI / 2;\n    } else {\n      angle = - (Math.PI / 2 + angle);\n    }\n    \n    var size = this.getArrowWidth( edgeWidth );\n    var shapeImpl = CanvasRenderer.arrowShapes[shape];\n\n    // context.translate(x, y);\n\n    if( usePaths ){\n      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;\n      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};\n      rs.arrowPathCache = rs.arrowPathCache || {};\n\n      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;\n      if( alreadyCached ){\n        path = context = rs.arrowPathCache[arrowType];\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        rs.arrowPathCacheKey[arrowType] = pathCacheKey;\n        rs.arrowPathCache[arrowType] = path;\n      }\n    }\n\n    if( context.beginPath ){ context.beginPath(); }\n\n    if( !pathCacheHit ){\n      shapeImpl.draw(context, size, angle, translation);\n    }\n    \n    if( !shapeImpl.leavePathOpen && context.closePath ){\n      context.closePath();\n    }\n\n    context = canvasContext;\n\n    if( fill === 'filled' || fill === 'both' ){\n      if( usePaths ){\n        context.fill( path );\n      } else {\n        context.fill();\n      }\n    }\n\n    if( fill === 'hollow' || fill === 'both' ){\n      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );\n      context.lineJoin = 'miter';\n\n      if( usePaths ){\n        context.stroke( path );\n      } else {\n        context.stroke();\n      }\n      \n    }\n\n    // context.translate(-x, -y);\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.getCachedImage = function(url, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n\n    if( imageCache[url] && imageCache[url].image ){\n      return imageCache[url].image;\n    }\n    \n    var cache = imageCache[url] = imageCache[url] || {};\n\n    var image = cache.image = new Image();\n    image.addEventListener('load', onLoad);\n    image.src = url;\n    \n    return image;\n  };\n    \n  CanvasRenderer.prototype.drawInscribedImage = function(context, img, node) {\n    var r = this;\n    var nodeX = node._private.position.x;\n    var nodeY = node._private.position.y;\n    var style = node._private.style;\n    var fit = style['background-fit'].value;\n    var xPos = style['background-position-x'];\n    var yPos = style['background-position-y'];\n    var repeat = style['background-repeat'].value;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var rs = node._private.rscratch;\n    var clip = style['background-clip'].value;\n    var shouldClip = clip === 'node';\n    var imgOpacity = style['background-image-opacity'].value;\n    \n    var w = img.width;\n    var h = img.height;\n\n    if( w === 0 || h === 0 ){\n      return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n\n    if( fit === 'contain' ){\n      var scale = Math.min( nodeW/w, nodeH/h );\n\n      w *= scale;\n      h *= scale;\n\n    } else if( fit === 'cover' ){\n      var scale = Math.max( nodeW/w, nodeH/h );\n\n      w *= scale;\n      h *= scale;\n    }\n\n    var x = (nodeX - nodeW/2); // left\n    if( xPos.units === '%' ){\n      x += (nodeW - w) * xPos.value/100;\n    } else {\n      x += xPos.pxValue;\n    }\n\n    var y = (nodeY - nodeH/2); // top\n    if( yPos.units === '%' ){\n      y += (nodeH - h) * yPos.value/100;\n    } else {\n      y += yPos.pxValue;\n    }\n\n    if( rs.pathCache ){\n      x -= nodeX;\n      y -= nodeY;\n\n      nodeX = 0;\n      nodeY = 0;\n    }\n\n    var gAlpha = context.globalAlpha;\n\n    context.globalAlpha = imgOpacity;\n\n    if( repeat === 'no-repeat' ){\n\n      if( shouldClip ){\n        context.save();\n\n        if( rs.pathCache ){\n          context.clip( rs.pathCache );\n        } else {\n          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(\n            context,\n            nodeX, nodeY, \n            nodeW, nodeH);\n\n          context.clip();\n        }\n      }\n\n      context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );\n\n      if( shouldClip ){\n        context.restore();\n      }\n    } else {\n      var pattern = context.createPattern( img, repeat );\n      context.fillStyle = pattern;\n\n      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(\n          context,\n          nodeX, nodeY, \n          nodeW, nodeH);\n\n        context.translate(x, y);\n        context.fill();\n        context.translate(-x, -y);\n    }\n\n    context.globalAlpha = gAlpha;\n    \n  };\n\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // Draw edge text\n  CanvasRenderer.prototype.drawEdgeText = function(context, edge) {\n    var text = edge._private.style['content'].strValue;\n\n    if( !text || text.match(/^\\s+$/) ){\n      return;\n    }\n\n    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching\n\n    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();\n    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;\n\n    if( computedSize < minSize ){\n      return;\n    }\n  \n    // Calculate text draw position\n    \n    context.textAlign = 'center';\n    context.textBaseline = 'middle';\n    \n    // this.recalculateEdgeLabelProjection( edge );\n    \n    var rs = edge._private.rscratch;\n    this.drawText(context, edge, rs.labelX, rs.labelY);\n  };\n\n  // Draw node text\n  CanvasRenderer.prototype.drawNodeText = function(context, node) {\n    var text = node._private.style['content'].strValue;\n\n    if ( !text || text.match(/^\\s+$/) ) {\n      return;\n    }\n\n    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();\n    var minSize = node._private.style['min-zoomed-font-size'].pxValue;\n\n    if( computedSize < minSize ){\n      return;\n    }\n      \n    // this.recalculateNodeLabelProjection( node );\n\n    var textHalign = node._private.style['text-halign'].strValue;\n    var textValign = node._private.style['text-valign'].strValue;\n    var rs = node._private.rscratch;\n\n    switch( textHalign ){\n      case 'left':\n        context.textAlign = 'right';\n        break;\n\n      case 'right':\n        context.textAlign = 'left';\n        break;\n\n      default: // e.g. center\n        context.textAlign = 'center';\n    }\n\n    switch( textValign ){\n      case 'top':\n        context.textBaseline = 'bottom';\n        break;\n\n      case 'bottom':\n        context.textBaseline = 'top';\n        break;\n\n      default: // e.g. center\n        context.textBaseline = 'middle';\n    }\n\n    this.drawText(context, node, rs.labelX, rs.labelY);\n  };\n  \n  CanvasRenderer.prototype.getFontCache = function(context){\n    var cache;\n\n    this.fontCaches = this.fontCaches || [];\n\n    for( var i = 0; i < this.fontCaches.length; i++ ){\n      cache = this.fontCaches[i];\n\n      if( cache.context === context ){\n        return cache;\n      }\n    }\n\n    cache = {\n      context: context\n    };\n    this.fontCaches.push(cache);\n\n    return cache;\n  };\n\n  // set up canvas context with font\n  // returns transformed text string\n  CanvasRenderer.prototype.setupTextStyle = function( context, element ){\n    // Font style\n    var parentOpacity = element.effectiveOpacity();\n    var style = element._private.style;\n    var labelStyle = style['font-style'].strValue;\n    var labelSize = style['font-size'].pxValue + 'px';\n    var labelFamily = style['font-family'].strValue;\n    var labelWeight = style['font-weight'].strValue;\n    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;\n    var outlineOpacity = style['text-outline-opacity'].value * opacity;\n    var color = style['color'].value;\n    var outlineColor = style['text-outline-color'].value;\n\n    var fontCacheKey = element._private.fontKey;\n    var cache = this.getFontCache(context);\n\n    if( cache.key !== fontCacheKey ){\n      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n\n      cache.key = fontCacheKey;\n    }\n\n    var text = String(style['content'].value);\n    var textTransform = style['text-transform'].value;\n    \n    if (textTransform == 'none') {\n    } else if (textTransform == 'uppercase') {\n      text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n      text = text.toLowerCase();\n    }\n    \n    // Calculate text draw position based on text alignment\n    \n    // so text outlines aren't jagged\n    context.lineJoin = 'round';\n\n    this.fillStyle(context, color[0], color[1], color[2], opacity);\n    \n    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n\n    return text;\n  };\n\n  // Draw text\n  CanvasRenderer.prototype.drawText = function(context, element, textX, textY) {\n    var style = element._private.style;\n    var parentOpacity = element.effectiveOpacity();\n    if( parentOpacity === 0 ){ return; }\n\n    var text = this.setupTextStyle( context, element );\n    \n    if ( text != null && !isNaN(textX) && !isNaN(textY) ) {\n     \n      var lineWidth = 2  * style['text-outline-width'].value; // *2 b/c the stroke is drawn centred on the middle\n      if (lineWidth > 0) {\n        context.lineWidth = lineWidth;\n        context.strokeText(text, textX, textY);\n      }\n\n      context.fillText(text, textX, textY);\n    }\n  };\n\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // Draw node\n  CanvasRenderer.prototype.drawNode = function(context, node, drawOverlayInstead) {\n\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var style = node._private.style;\n    var rs = node._private.rscratch;\n    \n    var usePaths = CanvasRenderer.usePaths();\n    var canvasContext = context;\n    var path;\n    var pathCacheHit = false;\n\n    var overlayPadding = style['overlay-padding'].pxValue;\n    var overlayOpacity = style['overlay-opacity'].value;\n    var overlayColor = style['overlay-color'].value;\n\n    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw\n      return;\n    }\n\n    var parentOpacity = node.effectiveOpacity();\n    if( parentOpacity === 0 ){ return; }\n\n    nodeWidth = this.getNodeWidth(node);\n    nodeHeight = this.getNodeHeight(node);\n    \n    context.lineWidth = style['border-width'].pxValue;\n\n    if( drawOverlayInstead === undefined || !drawOverlayInstead ){\n\n      // Node color & opacity\n\n      var bgColor = style['background-color'].value;\n      var borderColor = style['border-color'].value;\n      var borderStyle = style['border-style'].value;\n\n      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * style['opacity'].value * parentOpacity);\n      \n      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * style['opacity'].value * parentOpacity);\n\n      context.lineJoin = 'miter'; // so borders are square with the node shape\n\n      if( context.setLineDash ){ // for very outofdate browsers\n        switch( borderStyle ){\n          case 'dotted':\n            context.setLineDash([ 1, 1 ]);\n            break;\n\n          case 'dashed':\n            context.setLineDash([ 4, 2 ]);\n            break;\n\n          case 'solid':\n          case 'double':\n            context.setLineDash([ ]);\n            break;\n        }\n      }\n\n      //var image = this.getCachedImage('url');\n      \n      var url = style['background-image'].value[2] ||\n        style['background-image'].value[1];\n      \n      var styleShape = style['shape'].strValue;\n\n      var pos = node._private.position;\n\n      if( usePaths ){\n        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;\n\n        context.translate( pos.x, pos.y );\n\n        if( rs.pathCacheKey === pathCacheKey ){\n          path = context = rs.pathCache;\n          pathCacheHit = true;\n        } else {\n          path = context = new Path2D();\n          rs.pathCacheKey = pathCacheKey;\n          rs.pathCache = path;\n        }\n      }\n\n      if( !pathCacheHit ){\n\n        var npos = pos;\n\n        if( usePaths ){\n          npos = {\n            x: 0,\n            y: 0\n          };\n        }\n\n        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(\n              context,\n              npos.x,\n              npos.y,\n              nodeWidth,\n              nodeHeight);\n      }\n\n      context = canvasContext;\n\n      if( usePaths ){\n        context.fill( path );\n      } else {\n        context.fill();\n      }\n\n      if (url !== undefined) {\n        \n        // get image, and if not loaded then ask to redraw when later loaded\n        var image = this.getCachedImage(url, function(){\n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n          \n          r.redraw();\n        });\n        \n        if( image.complete ){\n          this.drawInscribedImage(context, image, node);\n        }\n        \n      } \n      \n      var darkness = style['background-blacken'].value;\n      var borderWidth = style['border-width'].pxValue;\n\n      if( this.hasPie(node) ){\n        this.drawPie(context, node);\n\n        // redraw path for blacken and border\n        if( darkness !== 0 || borderWidth !== 0 ){\n\n          if( !usePaths ){\n            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(\n                context,\n                pos.x,\n                pos.y,\n                nodeWidth,\n                nodeHeight);\n          }\n        }\n      }\n\n      if( darkness > 0 ){\n        this.fillStyle(context, 0, 0, 0, darkness);\n\n        if( usePaths ){\n          context.fill( path );\n        } else {\n          context.fill();\n        }\n        \n      } else if( darkness < 0 ){\n        this.fillStyle(context, 255, 255, 255, -darkness);\n        \n        if( usePaths ){\n          context.fill( path );\n        } else {\n          context.fill();\n        }\n      }\n\n      // Border width, draw border\n      if (borderWidth > 0) {\n\n        if( usePaths ){\n          context.stroke( path );\n        } else {\n          context.stroke();\n        }\n\n        if( borderStyle === 'double' ){\n          context.lineWidth = style['border-width'].pxValue/3;\n\n          var gco = context.globalCompositeOperation;\n          context.globalCompositeOperation = 'destination-out';\n\n          if( usePaths ){\n            context.stroke( path );\n          } else {\n            context.stroke();\n          }\n\n          context.globalCompositeOperation = gco;\n        }\n\n      }\n\n      if( usePaths ){\n        context.translate( -pos.x, -pos.y );\n      }\n\n      // reset in case we changed the border style\n      if( context.setLineDash ){ // for very outofdate browsers\n        context.setLineDash([ ]);\n      }\n\n    // draw the overlay\n    } else {\n\n      if( overlayOpacity > 0 ){\n        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);\n\n        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(\n          context,\n          node._private.position.x,\n          node._private.position.y,\n          nodeWidth + overlayPadding * 2,\n          nodeHeight + overlayPadding * 2\n        );\n\n        context.fill();\n      }\n    }\n\n  };\n\n  // does the node have at least one pie piece?\n  CanvasRenderer.prototype.hasPie = function(node){\n    node = node[0]; // ensure ele ref\n    \n    return node._private.hasPie;\n  };\n\n  CanvasRenderer.prototype.drawPie = function(context, node){\n    node = node[0]; // ensure ele ref\n\n    var pieSize = node._private.style['pie-size'];\n    var nodeW = this.getNodeWidth( node );\n    var nodeH = this.getNodeHeight( node );\n    var x = node._private.position.x;\n    var y = node._private.position.y;\n    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = CanvasRenderer.usePaths();\n\n    if( usePaths ){\n      x = 0;\n      y = 0;\n    }\n\n    if( pieSize.units === '%' ){\n      radius = radius * pieSize.value / 100;\n    } else if( pieSize.pxValue !== undefined ){\n      radius = pieSize.pxValue / 2;\n    }\n\n    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N\n      var size = node._private.style['pie-' + i + '-background-size'].value;\n      var color = node._private.style['pie-' + i + '-background-color'].value;\n      var opacity = node._private.style['pie-' + i + '-background-opacity'].value;\n      var percent = size / 100; // map integer range [0, 100] to [0, 1]\n      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n      var angleDelta = 2 * Math.PI * percent;\n      var angleEnd = angleStart + angleDelta;\n\n      // ignore if\n      // - zero size\n      // - we're already beyond the full circle\n      // - adding the current slice would go beyond the full circle\n      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){\n        continue;\n      }\n\n      context.beginPath();\n      context.moveTo(x, y);\n      context.arc( x, y, radius, angleStart, angleEnd );\n      context.closePath();\n\n      this.fillStyle(context, color[0], color[1], color[2], opacity);\n\n      context.fill();\n\n      lastPercent += percent;\n    }\n\n  };\n\n  \n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // var isFirefox = typeof InstallTrigger !== 'undefined';\n\n  CanvasRenderer.prototype.getPixelRatio = function(){ \n    var context = this.data.contexts[0];\n\n    if( this.forcedPixelRatio != null ){\n      return this.forcedPixelRatio;\n    }\n\n    var backingStore = context.backingStorePixelRatio ||\n      context.webkitBackingStorePixelRatio ||\n      context.mozBackingStorePixelRatio ||\n      context.msBackingStorePixelRatio ||\n      context.oBackingStorePixelRatio ||\n      context.backingStorePixelRatio || 1;\n\n    //console.log(window.devicePixelRatio, backingStore);\n\n    // if( isFirefox ){ // because ff can't scale canvas properly\n    //   return 1;\n    // }\n\n    return (window.devicePixelRatio || 1) / backingStore;\n  };\n\n  CanvasRenderer.prototype.paintCache = function(context){\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n\n    for(var i = 0; i < caches.length; i++ ){\n      cache = caches[i];\n\n      if( cache.context === context ){\n        needToCreateCache = false;\n        break;\n      }\n    }\n\n    if( needToCreateCache ){\n      cache = {\n        context: context\n      };\n      caches.push( cache );\n    }\n\n    return cache;\n  };\n\n  CanvasRenderer.prototype.fillStyle = function(context, r, g, b, a){\n    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    \n    // turn off for now, seems context does its own caching\n\n    // var cache = this.paintCache(context);\n\n    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n    // if( cache.fillStyle !== fillStyle ){\n    //   context.fillStyle = cache.fillStyle = fillStyle;\n    // }\n  };\n\n  CanvasRenderer.prototype.strokeStyle = function(context, r, g, b, a){\n    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    \n    // turn off for now, seems context does its own caching\n\n    // var cache = this.paintCache(context);\n\n    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n    // if( cache.strokeStyle !== strokeStyle ){\n    //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n    // }\n  };\n\n  // Resize canvas\n  CanvasRenderer.prototype.matchCanvasSize = function(container) {\n    var data = this.data;\n    var width = container.clientWidth;\n    var height = container.clientHeight;\n    var pixelRatio = this.getPixelRatio();\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n\n    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){\n      return; // save cycles if same\n    }\n\n    this.fontCaches = null; // resizing resets the style\n\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + 'px';\n    canvasContainer.style.height = height + 'px';\n\n    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {\n\n      canvas = data.canvases[i];\n      \n      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n        \n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n      }\n    }\n    \n    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {\n      \n      canvas = data.bufferCanvases[i];\n      \n      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n        \n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n      }\n    }\n\n    this.textureMult = 1;\n    if( pixelRatio <= 1 ){\n      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];\n\n      this.textureMult = 2;\n      canvas.width = canvasWidth * this.textureMult;\n      canvas.height = canvasHeight * this.textureMult;\n    }\n\n    this.canvasWidth = canvasWidth;\n    this.canvasHeight = canvasHeight;\n\n  };\n\n  CanvasRenderer.prototype.renderTo = function( cxt, zoom, pan, pxRatio ){\n    this.redraw({\n      forcedContext: cxt,\n      forcedZoom: zoom,\n      forcedPan: pan,\n      drawAllLayers: true,\n      forcedPxRatio: pxRatio\n    });\n  };\n\n  CanvasRenderer.prototype.timeToRender = function(){\n    return this.redrawTotalTime / this.redrawCount;\n  };\n\n  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps\n  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth\n  CanvasRenderer.motionBlurDelay = 100;\n\n  // Redraw frame\n  CanvasRenderer.prototype.redraw = function( options ) {\n    options = options || {};\n\n    // console.log('redraw');\n\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var r = this;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var cy = r.data.cy; var data = r.data; \n    var needDraw = data.canvasNeedsRedraw;\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled;\n\n    if( motionBlur && r.motionBlurTimeout ){\n      clearTimeout( r.motionBlurTimeout );\n    }\n\n    if( !forcedContext && this.redrawTimeout ){\n      clearTimeout( this.redrawTimeout );\n    }\n    this.redrawTimeout = null;\n\n    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }\n\n    var minRedrawLimit = CanvasRenderer.minRedrawLimit; \n    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;\n\n    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw\n    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;\n    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;\n\n    //console.log('--\\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);\n\n    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }\n\n    var nowTime = +new Date();\n    var timeElapsed = nowTime - this.lastDrawTime;\n    var callAfterLimit = timeElapsed >= redrawLimit;\n\n    if( !forcedContext ){\n      if( !callAfterLimit || this.currentlyDrawing ){\n        // console.log('-- skip');\n\n        // we have new things to draw but we're busy, so try again when possibly free\n        this.redrawTimeout = setTimeout(function(){\n          r.redraw();\n        }, redrawLimit);\n        return;\n      }\n\n      this.lastDrawTime = nowTime;\n      this.currentlyDrawing = true;\n    }\n\n\n    var startTime = +new Date();\n\n    //console.log('-- redraw --')\n\n\n    function drawToContext(){ \n      // startTime = +new Date();\n      // console.profile('draw' + startTime)\n      var edges = r.getCachedEdges();\n      var coreStyle = cy.style()._private.coreStyle;\n      \n      var zoom = cy.zoom();\n      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n      var pan = cy.pan();\n      var effectivePan = {\n        x: pan.x,\n        y: pan.y\n      };\n\n      if( forcedPan ){\n        effectivePan = forcedPan;\n      }\n\n      // apply pixel ratio\n\n      effectiveZoom *= pixelRatio;\n      effectivePan.x *= pixelRatio;\n      effectivePan.y *= pixelRatio;\n      \n      var eles = {\n        drag: {\n          nodes: [],\n          edges: [],\n          eles: []\n        },\n        nondrag: {\n          nodes: [],\n          edges: [],\n          eles: []\n        }\n      };\n\n      function setContextTransform(context, clear){\n        context.setTransform(1, 0, 0, 1, 0, 0);\n\n        if( clear === 'motionBlur' ){\n          var gco = context.globalCompositeOperation;\n\n          context.globalCompositeOperation = 'destination-out';\n          r.fillStyle( context, 255, 255, 255, 0.666 );\n          context.fillRect(0, 0, r.canvasWidth, r.canvasHeight);\n\n          context.globalCompositeOperation = gco;\n        } else if( !forcedContext && (clear === undefined || clear) ){\n          context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        }\n        \n        if( !drawAllLayers ){\n          context.translate(effectivePan.x, effectivePan.y);\n          context.scale(effectiveZoom, effectiveZoom);\n        }\n        if( forcedPan ){\n          context.translate(forcedPan.x, forcedPan.y);\n        } \n        if( forcedZoom ){\n          context.scale(forcedZoom, forcedZoom);\n        }\n      }\n\n      var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n\n      if( textureDraw ){\n\n        var bb;\n\n        if( !r.textureCache ){\n          r.textureCache = {};\n\n          bb = r.textureCache.bb = cy.elements().boundingBox();\n\n          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];\n\n          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];\n\n          cxt.setTransform(1, 0, 0, 1, 0, 0);\n          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n          \n          r.redraw({\n            forcedContext: cxt,\n            drawOnlyNodeLayer: true,\n            forcedPxRatio: pixelRatio * r.textureMult\n          });\n\n          var vp = r.textureCache.viewport = {\n            zoom: cy.zoom(),\n            pan: cy.pan(),\n            width: r.canvasWidth,\n            height: r.canvasHeight\n          };\n\n          vp.mpan = {\n            x: (0 - vp.pan.x)/vp.zoom,\n            y: (0 - vp.pan.y)/vp.zoom\n          };\n        }\n\n        needDraw[CanvasRenderer.DRAG] = false;\n        needDraw[CanvasRenderer.NODE] = false;\n\n        var context = data.contexts[CanvasRenderer.NODE];\n\n        var texture = r.textureCache.texture;\n        var vp = r.textureCache.viewport;\n        bb = r.textureCache.bb;\n\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(0, 0, vp.width, vp.height);\n\n        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;\n        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;\n        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );\n        context.fillRect( 0, 0, vp.width, vp.height );\n\n        var zoom = cy.zoom();\n        \n        setContextTransform( context, false );\n\n        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );\n        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );\n\n      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it\n        r.textureCache = null;\n      }\n\n      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);\n      var hideEdges = r.hideEdgesOnViewport && vpManip;\n      var hideLabels = r.hideLabelsOnViewport && vpManip;\n\n      if (needDraw[CanvasRenderer.DRAG] || needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer) {\n        //NB : VERY EXPENSIVE\n\n        if( hideEdges ){ \n        } else {\n          r.findEdgeControlPoints(edges);\n        }\n\n        var zEles = r.getCachedZSortedEles();\n        var extent = cy.extent();\n\n        for (var i = 0; i < zEles.length; i++) {\n          var ele = zEles[i];\n          var list;\n          var bb = forcedContext ? null : ele.boundingBox();\n          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );\n\n          if( !insideExtent ){ continue; } // no need to render\n\n          if ( ele._private.rscratch.inDragLayer ) {\n            list = eles.drag;\n          } else {\n            list = eles.nondrag;\n          }\n\n          list.eles.push( ele );\n        }\n\n      }\n      \n      \n      function drawElements( list, context ){\n        var eles = list.eles;\n\n        for( var i = 0; i < eles.length; i++ ){\n          var ele = eles[i];\n\n          if( ele.isNode() ){\n            r.drawNode(context, ele);\n\n            if( !hideLabels ){\n              r.drawNodeText(context, ele);\n            }\n\n            r.drawNode(context, ele, true);\n          } else if( !hideEdges ) {\n            r.drawEdge(context, ele);\n\n            if( !hideLabels ){\n              r.drawEdgeText(context, ele);\n            }\n\n            r.drawEdge(context, ele, true);\n          }\n          \n          \n        }\n\n      }\n\n      var nodeLayerNeedsMotionClear = needDraw[CanvasRenderer.DRAG] && !needDraw[CanvasRenderer.NODE] && motionBlur && !r.clearedNodeLayerForMotionBlur;\n      if( nodeLayerNeedsMotionClear ){ r.clearedNodeLayerForMotionBlur = true; }\n\n      if( needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer || nodeLayerNeedsMotionClear ){\n        // console.log('redrawing node layer');\n        \n        var context = forcedContext || data.contexts[CanvasRenderer.NODE];\n\n        setContextTransform( context, motionBlur && !nodeLayerNeedsMotionClear ? 'motionBlur' : undefined );\n        drawElements(eles.nondrag, context);\n        \n        if( !drawAllLayers ){\n          needDraw[CanvasRenderer.NODE] = false; \n        }\n      }\n      \n      if ( !drawOnlyNodeLayer && (needDraw[CanvasRenderer.DRAG] || drawAllLayers) ) {\n        \n        var context = forcedContext || data.contexts[CanvasRenderer.DRAG];\n        \n        setContextTransform( context, motionBlur ? 'motionBlur' : undefined );\n        drawElements(eles.drag, context);\n        \n        if( !drawAllLayers ){\n          needDraw[CanvasRenderer.DRAG] = false;\n        }\n      }\n      \n      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CanvasRenderer.SELECT_BOX] && !drawAllLayers)) ) {\n        // console.log('redrawing selection box');\n        \n        var context = forcedContext || data.contexts[CanvasRenderer.SELECT_BOX];\n\n        setContextTransform( context );\n\n        if( data.select[4] == 1 && r.hoverData.selecting ){\n          var zoom = data.cy.zoom();\n          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;\n          \n          context.lineWidth = borderWidth;\n          context.fillStyle = \"rgba(\" \n            + coreStyle['selection-box-color'].value[0] + \",\"\n            + coreStyle['selection-box-color'].value[1] + \",\"\n            + coreStyle['selection-box-color'].value[2] + \",\"\n            + coreStyle['selection-box-opacity'].value + \")\";\n          \n          context.fillRect(\n            data.select[0],\n            data.select[1],\n            data.select[2] - data.select[0],\n            data.select[3] - data.select[1]);\n          \n          if (borderWidth > 0) {\n            context.strokeStyle = \"rgba(\" \n              + coreStyle['selection-box-border-color'].value[0] + \",\"\n              + coreStyle['selection-box-border-color'].value[1] + \",\"\n              + coreStyle['selection-box-border-color'].value[2] + \",\"\n              + coreStyle['selection-box-opacity'].value + \")\";\n            \n            context.strokeRect(\n              data.select[0],\n              data.select[1],\n              data.select[2] - data.select[0],\n              data.select[3] - data.select[1]);\n          }\n        }\n\n        if( data.bgActivePosistion && !r.hoverData.selecting ){\n          var zoom = data.cy.zoom();\n          var pos = data.bgActivePosistion;\n\n          context.fillStyle = \"rgba(\" \n            + coreStyle['active-bg-color'].value[0] + \",\"\n            + coreStyle['active-bg-color'].value[1] + \",\"\n            + coreStyle['active-bg-color'].value[2] + \",\"\n            + coreStyle['active-bg-opacity'].value + \")\";\n\n          context.beginPath();\n          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); \n          context.fill();\n        }\n        \n        var timeToRender = r.averageRedrawTime;\n        if( r.showFps && timeToRender ){\n          timeToRender = Math.round( timeToRender );\n          var fps = Math.round(1000/timeToRender);\n\n          context.setTransform(1, 0, 0, 1, 0, 0);\n\n          //context.font = '20px helvetica';\n          context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n          context.lineWidth = 1;\n          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n\n          var maxFps = 60;\n          context.strokeRect(0, 30, 250, 20);\n          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);\n        }\n\n        if( !drawAllLayers ){\n          needDraw[CanvasRenderer.SELECT_BOX] = false; \n        }\n      }\n\n\n      var endTime = +new Date();\n\n      if( r.averageRedrawTime === undefined ){\n        r.averageRedrawTime = endTime - startTime;\n      }\n\n      if( r.redrawCount === undefined ){\n        r.redrawCount = 0;\n      }\n\n      r.redrawCount++;\n\n      if( r.redrawTotalTime === undefined ){\n        r.redrawTotalTime = 0;\n      }\n\n      r.redrawTotalTime += endTime - startTime;\n      r.lastRedrawTime = endTime - startTime;\n\n      // use a weighted average with a bias from the previous average so we don't spike so easily\n      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;\n      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);\n\n      r.currentlyDrawing = false;\n\n      // console.profileEnd('draw' + startTime)\n\n      if( r.clearingMotionBlur ){\n        r.clearingMotionBlur = false;\n        r.motionBlurCleared = true;\n        r.motionBlur = true;\n      }\n\n      if( motionBlur ){ \n        r.motionBlurTimeout = setTimeout(function(){\n          r.motionBlurTimeout = null;\n          // console.log('motion blur clear');\n\n          r.clearedNodeLayerForMotionBlur = false;\n          r.motionBlur = false;\n          r.clearingMotionBlur = true;\n\n          needDraw[CanvasRenderer.NODE] = true; \n          needDraw[CanvasRenderer.DRAG] = true; \n\n          r.redraw();\n        }, CanvasRenderer.motionBlurDelay);\n      }\n    } // draw to context\n\n    if( !forcedContext ){\n      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive\n    } else {\n      drawToContext();\n    }\n\n    if( !forcedContext && !r.initrender ){\n      r.initrender = true;\n      cy.trigger('initrender');\n    }\n    \n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  // @O Polygon drawing\n  CanvasRenderer.prototype.drawPolygonPath = function(\n    context, x, y, width, height, points) {\n\n    var halfW = width / 2;\n    var halfH = height / 2;\n\n    if( context.beginPath ){ context.beginPath(); }\n\n    context.moveTo( x + halfW * points[0], y + halfH * points[1] );\n\n    for (var i = 1; i < points.length / 2; i++) {\n      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );\n    }\n    \n    context.closePath();\n  };\n  \n  CanvasRenderer.prototype.drawPolygon = function(\n    context, x, y, width, height, points) {\n\n    // Draw path\n    this.drawPolygonPath(context, x, y, width, height, points);\n    \n    // Fill path\n    context.fill();\n  };\n  \n  // Round rectangle drawing\n  CanvasRenderer.prototype.drawRoundRectanglePath = function(\n    context, x, y, width, height, radius) {\n    \n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);\n    \n    if( context.beginPath ){ context.beginPath(); }\n    \n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    // Arc from middle top to right side\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n    // Arc from right side to bottom\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    // Arc from bottom to left side\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    // Arc from left side to topBorder\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n    // Join line\n    context.lineTo(x, y - halfHeight);\n    \n    \n    context.closePath();\n  };\n  \n  CanvasRenderer.prototype.drawRoundRectangle = function(\n    context, x, y, width, height, radius) {\n    \n    this.drawRoundRectanglePath(context, x, y, width, height, radius);\n    \n    context.fill();\n  };\n\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.createBuffer = function(w, h) {\n    var buffer = document.createElement('canvas');\n    buffer.width = w;\n    buffer.height = h;\n    \n    return [buffer, buffer.getContext('2d')];\n  };\n\n  CanvasRenderer.prototype.bufferCanvasImage = function( options ){\n    var data = this.data;\n    var cy = data.cy;\n    var bb = cy.elements().boundingBox();\n    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;\n    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;\n    var scale = 1;\n\n    if( options.scale !== undefined ){\n      width *= options.scale;\n      height *= options.scale;\n\n      scale = options.scale;\n    }\n\n    var buffCanvas = document.createElement('canvas');\n\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n\n    buffCanvas.style.width = width + 'px';\n    buffCanvas.style.height = height + 'px';\n\n    var buffCxt = buffCanvas.getContext('2d');\n\n    // Rasterize the layers, but only if container has nonzero size\n    if (width > 0 && height > 0) {\n\n      buffCxt.clearRect( 0, 0, width, height );\n\n      if( options.bg ){\n        buffCxt.fillStyle = options.bg;\n        buffCxt.rect( 0, 0, width, height );\n        buffCxt.fill();\n      }\n\n      buffCxt.globalCompositeOperation = 'source-over';\n\n      if( options.full ){ // draw the full bounds of the graph\n        this.redraw({\n          forcedContext: buffCxt,\n          drawAllLayers: true,\n          forcedZoom: scale,\n          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },\n          forcedPxRatio: 1\n        });\n      } else { // draw the current view\n        var cyPan = cy.pan();\n        var pan = {\n          x: cyPan.x * scale,\n          y: cyPan.y * scale\n        };\n        var zoom = cy.zoom() * scale;\n\n        this.redraw({\n          forcedContext: buffCxt,\n          drawAllLayers: true,\n          forcedZoom: zoom,\n          forcedPan: pan,\n          forcedPxRatio: 1\n        });\n      }\n    }\n\n    return buffCanvas;\n  }; \n\n  CanvasRenderer.prototype.png = function( options ){\n    return this.bufferCanvasImage( options ).toDataURL('image/png');\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n\n  CanvasRenderer.prototype.registerBinding = function(target, event, handler, useCapture){\n    this.bindings.push({\n      target: target,\n      event: event,\n      handler: handler,\n      useCapture: useCapture\n    });\n\n    target.addEventListener(event, handler, useCapture);\n  };\n\n  CanvasRenderer.prototype.nodeIsDraggable = function(node) {\n    if (node._private.style['opacity'].value !== 0\n      && node._private.style['visibility'].value == 'visible'\n      && node._private.style['display'].value == 'element'\n      && !node.locked()\n      && node.grabbable() ) {\n\n      return true;\n    }\n    \n    return false;\n  };\n\n  CanvasRenderer.prototype.load = function() {\n    var r = this;\n\n    var getDragListIds = function(opts){\n      var listHasId;\n\n      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs\n        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist\n          opts.addToList.hasId = {};\n\n          for( var i = 0; i < opts.addToList.length; i++ ){\n            var ele = opts.addToList[i];\n\n            opts.addToList.hasId[ ele.id() ] = true;\n          }\n        }\n\n        listHasId = opts.addToList.hasId;\n      }\n\n      return listHasId || {};\n    };\n\n    // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n    var addDescendantsToDrag = function(node, opts){\n      if( !node._private.cy.hasCompoundNodes() ){\n        return;\n      }\n\n      var listHasId = getDragListIds( opts );\n\n      var innerNodes = node.descendants();\n\n      // TODO do not drag hidden children & children of hidden children?\n      for( var i = 0; i < innerNodes.size(); i++ ){\n        var iNode = innerNodes[i];\n        var _p = iNode._private;\n\n        if( opts.inDragLayer ){\n          _p.rscratch.inDragLayer = true;\n        }\n\n        if( opts.addToList && !listHasId[ iNode.id() ] ){\n          opts.addToList.push( iNode );\n          listHasId[ iNode.id() ] = true;\n\n          _p.grabbed = true; \n        }\n\n        var edges = _p.edges;\n        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){\n          edges[j]._private.rscratch.inDragLayer = true;\n        }\n      }\n    };\n\n    // adds the given nodes, and its edges to the drag layer\n    var addNodeToDrag = function(node, opts){\n\n      var _p = node._private;\n      var listHasId = getDragListIds( opts );\n\n      if( opts.inDragLayer ){\n        _p.rscratch.inDragLayer = true;\n      }\n\n      if( opts.addToList && !listHasId[ node.id() ] ){\n        opts.addToList.push( node );\n        listHasId[ node.id() ] = true;\n\n        _p.grabbed = true; \n      }\n\n      var edges = _p.edges;\n      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){\n        edges[i]._private.rscratch.inDragLayer = true;\n      }\n\n      addDescendantsToDrag( node, opts ); // always add to drag\n\n      // also add nodes and edges related to the topmost ancestor\n      updateAncestorsInDragLayer( node, {\n        inDragLayer: true\n      } );\n    };\n\n    // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n    var updateAncestorsInDragLayer = function(node, opts) {\n      // find top-level parent\n      var parent = node;\n\n      if( !node._private.cy.hasCompoundNodes() ){\n        return;\n      }\n\n      while( parent.parent().nonempty() ){\n        parent = parent.parent()[0];\n      }\n\n      // no parent node: no nodes to add to the drag layer\n      if( parent == node ){\n        return;\n      }\n\n      var nodes = parent\n        .descendants()\n        .add( parent )\n        .not( node )\n        .not( node.descendants() )\n      ;\n\n      var edges = nodes.connectedEdges();\n\n      var listHasId = getDragListIds( opts );\n\n      for( var i = 0; i < nodes.size(); i++ ){\n        if( opts.inDragLayer !== undefined ){\n          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;\n        }\n\n        if( opts.addToList && !listHasId[ nodes[i].id() ] ){\n          opts.addToList.push( nodes[i] );\n          listHasId[ nodes[i].id() ] = true;\n\n          nodes[i]._private.grabbed = true;\n        }\n      }\n\n      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {\n        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;\n      }\n    };\n\n    if( typeof MutationObserver !== 'undefined' ){\n      r.removeObserver = new MutationObserver(function( mutns ){\n        for( var i = 0; i < mutns.length; i++ ){\n          var mutn = mutns[i];\n          var rNodes = mutn.removedNodes;\n\n          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){\n            var rNode = rNodes[j];\n\n            if( rNode === r.data.container ){\n              r.destroy();\n              break;\n            }\n          } }\n        }\n      });\n\n      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );\n    } else {\n      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){\n        r.destroy();\n      });\n    }\n\n\n\n    // auto resize\n    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {\n      r.invalidateContainerClientCoordsCache();\n\n      r.matchCanvasSize(r.data.container);\n      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n      r.redraw();\n    }, 100 ) );\n\n    var invalCtnrBBOnScroll = function(domEle){\n      r.registerBinding(domEle, 'scroll', function(e){\n        r.invalidateContainerClientCoordsCache();\n      } );\n    };\n\n    var bbCtnr = r.data.cy.container();\n\n    for( ;; ){\n      \n      invalCtnrBBOnScroll( bbCtnr );\n\n      if( bbCtnr.parentNode ){\n        bbCtnr = bbCtnr.parentNode;\n      } else {\n        break;\n      }\n      \n    }\n\n    // stop right click menu from appearing on cy\n    r.registerBinding(r.data.container, 'contextmenu', function(e){\n      e.preventDefault();\n    });\n\n    var inBoxSelection = function(){\n      return r.data.select[4] !== 0;\n    };\n\n    // Primary key\n    r.registerBinding(r.data.container, 'mousedown', function(e) { \n      e.preventDefault();\n      r.hoverData.capture = true;\n      r.hoverData.which = e.which;\n      \n      var cy = r.data.cy; \n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var select = r.data.select;\n      var near = r.findNearestElement(pos[0], pos[1], true);\n      var draggedElements = r.dragData.possibleDragElements;\n\n      r.hoverData.mdownPos = pos;\n\n      var checkForTaphold = function(){\n        r.hoverData.tapholdCancelled = false;\n\n        clearTimeout( r.hoverData.tapholdTimeout );\n\n        r.hoverData.tapholdTimeout = setTimeout(function(){\n\n          if( r.hoverData.tapholdCancelled ){\n            return;\n          } else {\n            var ele = r.hoverData.down;\n\n            if( ele ){\n              ele.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }) );\n            } else {\n              cy.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }) );\n            }\n          }\n\n        }, r.tapholdDuration);\n      };\n\n      // Right click button\n      if( e.which == 3 ){\n\n        r.hoverData.cxtStarted = true;\n\n        var cxtEvt = new $$.Event(e, {\n          type: 'cxttapstart', \n          cyPosition: { x: pos[0], y: pos[1] } \n        });\n\n        if( near ){\n          near.activate();\n          near.trigger( cxtEvt );\n\n          r.hoverData.down = near;\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        r.hoverData.downTime = (new Date()).getTime();\n        r.hoverData.cxtDragged = false;\n\n      // Primary button\n      } else if (e.which == 1) {\n        \n        if( near ){\n          near.activate();\n        }\n\n        // Element dragging\n        {\n          // If something is under the cursor and it is draggable, prepare to grab it\n          if (near != null) {\n\n            if( r.nodeIsDraggable(near) ){\n\n              var grabEvent = new $$.Event(e, {\n                type: 'grab',\n                cyPosition: { x: pos[0], y: pos[1] }\n              });\n\n              if ( near.isNode() && !near.selected() ){\n\n                draggedElements = r.dragData.possibleDragElements = [];\n                addNodeToDrag( near, { addToList: draggedElements } );\n\n                near.trigger(grabEvent);\n\n              } else if ( near.isNode() && near.selected() ){\n                draggedElements = r.dragData.possibleDragElements = [  ];\n\n                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });\n\n                for( var i = 0; i < selectedNodes.length; i++ ){\n\n                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity\n                  if( r.nodeIsDraggable( selectedNodes[i] ) ){\n                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );\n                  }\n                }\n\n                near.trigger( grabEvent );\n              }\n\n              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n              r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            }\n            \n            near\n              .trigger(new $$.Event(e, {\n                type: 'mousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapstart',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n            \n          } else if (near == null) {\n            cy\n              .trigger(new $$.Event(e, {\n                type: 'mousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapstart',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmousedown',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n          }\n          \n          r.hoverData.down = near;\n          r.hoverData.downTime = (new Date()).getTime();\n\n        }\n      \n        // Selection box\n        if ( near == null || near.isEdge() ) {\n          select[4] = 1;\n          var timeUntilActive = Math.max( 0, CanvasRenderer.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );\n\n          clearTimeout( r.bgActiveTimeout );\n\n          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){\n            r.bgActiveTimeout = setTimeout(function(){\n              if( near ){\n                near.unactivate();\n              }\n\n              r.data.bgActivePosistion = {\n                x: pos[0],\n                y: pos[1]\n              };\n\n              checkForTaphold();\n\n              r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n      \n              r.redraw();\n            }, timeUntilActive);\n          } else {\n            r.data.bgActivePosistion = {\n              x: pos[0],\n              y: pos[1]\n            };\n\n            checkForTaphold();\n\n            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n    \n            r.redraw();\n          }\n          \n        }\n      \n      } \n      \n      // Initialize selection box coordinates\n      select[0] = select[2] = pos[0];\n      select[1] = select[3] = pos[1];\n      \n    }, false);\n    \n    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {\n      var preventDefault = false;\n      var capture = r.hoverData.capture;\n\n      // save cycles if mouse events aren't to be captured\n      if ( !capture ){\n        var containerPageCoords = r.findContainerClientCoords();\n\n        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth\n          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight\n        ) {\n          // inside container bounds so OK\n        } else {\n          return;\n        }\n\n        var cyContainer = r.data.container;\n        var target = e.target;\n        var tParent = target.parentNode;\n        var containerIsTarget = false;\n\n        while( tParent ){\n          if( tParent === cyContainer ){\n            containerIsTarget = true;\n            break;\n          }\n\n          tParent = tParent.parentNode;\n        }\n\n        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us\n      }\n\n      var cy = r.data.cy;\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var select = r.data.select;\n      \n      var near = null;\n      if( !r.hoverData.draggingEles ){\n        near = r.findNearestElement(pos[0], pos[1], true);\n      }\n      var last = r.hoverData.last;\n      var down = r.hoverData.down;\n      \n      var disp = [pos[0] - select[2], pos[1] - select[3]];\n\n      var draggedElements = r.dragData.possibleDragElements;\n\n      var dx = select[2] - select[0];\n      var dx2 = dx * dx;\n      var dy = select[3] - select[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      r.hoverData.tapholdCancelled = true;\n\n      var updateDragDelta = function(){\n        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n        if( dragDelta.length === 0 ){\n          dragDelta.push(0);\n          dragDelta.push(0);\n        } else {\n          dragDelta[0] += disp[0];\n          dragDelta[1] += disp[1];\n        }\n      };\n      \n\n      preventDefault = true;\n\n      // Mousemove event\n      {\n        if (near != null) {\n          near\n            .trigger(new $$.Event(e, {\n              type: 'mousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapdrag',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n          ;\n          \n        } else if (near == null) {\n          cy\n            .trigger(new $$.Event(e, {\n              type: 'mousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousemove',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapdrag',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }))\n          ;\n        }\n\n      }\n\n      // trigger context drag if rmouse down\n      if( r.hoverData.which === 3 ){\n        var cxtEvt = new $$.Event(e, {\n          type: 'cxtdrag',\n          cyPosition: { x: pos[0], y: pos[1] }\n        });\n\n        if( down ){\n          down.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        r.hoverData.cxtDragged = true;\n\n        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){\n\n          if( r.hoverData.cxtOver ){\n            r.hoverData.cxtOver.trigger( new $$.Event(e, {\n              type: 'cxtdragout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) );\n\n            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());\n          }\n\n          r.hoverData.cxtOver = near;\n\n          if( near ){\n            near.trigger( new $$.Event(e, {\n              type: 'cxtdragover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) );\n\n            // console.log('cxtdragover ' + near.id());\n          }\n\n        }\n\n      // Check if we are drag panning the entire graph\n      } else if (r.hoverData.dragging) {\n        preventDefault = true;\n\n        if( cy.panningEnabled() && cy.userPanningEnabled() ){\n          var deltaP;\n\n          if( r.hoverData.justStartedPan ){\n            var mdPos = r.hoverData.mdownPos;\n\n            deltaP = {\n              x: ( pos[0] - mdPos[0] ) * zoom,\n              y: ( pos[1] - mdPos[1] ) * zoom\n            };\n\n            r.hoverData.justStartedPan = false;\n\n          } else {\n            deltaP = {\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            };\n\n          }\n\n          cy.panBy( deltaP );\n          \n        }\n        \n        // Needs reproject due to pan changing viewport\n        pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      // Checks primary button down & out of time & mouse not moved much\n      } else if(\n          select[4] == 1 && (down == null || down.isEdge())\n          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CanvasRenderer.panOrBoxSelectDelay) )\n          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)\n          && !r.hoverData.selecting\n          && rdist2 >= r.tapThreshold2\n          && cy.panningEnabled() && cy.userPanningEnabled()\n      ){\n        r.hoverData.dragging = true;\n        r.hoverData.selecting = false;\n        r.hoverData.justStartedPan = true;\n        select[4] = 0;\n\n      } else {\n        // deactivate bg on box selection\n        if (cy.boxSelectionEnabled() && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){\n          clearTimeout( r.bgActiveTimeout );\n          r.data.bgActivePosistion = undefined;\n          r.hoverData.selecting = true;\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          r.redraw();\n        }\n        \n        if( down && down.isEdge() && down.active() ){ down.unactivate(); }\n\n        if (near != last) {\n          \n          if (last) {\n            last.trigger( new $$.Event(e, {\n              type: 'mouseout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n\n            last.trigger( new $$.Event(e, {\n              type: 'tapdragout',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n          }\n          \n          if (near) {\n            near.trigger( new $$.Event(e, {\n              type: 'mouseover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n\n            near.trigger( new $$.Event(e, {\n              type: 'tapdragover',\n              cyPosition: { x: pos[0], y: pos[1] }\n            }) ); \n          }\n          \n          r.hoverData.last = near;\n        }\n\n        if( down && down.isNode() && r.nodeIsDraggable(down) ){\n\n          if( rdist2 >= r.tapThreshold2 ){ // then drag\n\n            var justStartedDrag = !r.dragData.didDrag;\n\n            if( justStartedDrag ) {\n              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n            }\n\n            r.dragData.didDrag = true; // indicate that we actually did drag the node\n\n            var toTrigger = [];\n\n            for( var i = 0; i < draggedElements.length; i++ ){\n              var dEle = draggedElements[i];\n\n              // now, add the elements to the drag layer if not done already\n              if( !r.hoverData.draggingEles ){ \n                addNodeToDrag( dEle, { inDragLayer: true } );\n              }\n\n              // Locked nodes not draggable, as well as non-visible nodes\n              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){\n                var dPos = dEle._private.position;\n\n                toTrigger.push( dEle );\n                \n                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){\n                  dPos.x += disp[0];\n                  dPos.y += disp[1];\n\n                  if( justStartedDrag ){\n                    var dragDelta = r.hoverData.dragDelta;\n\n                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){\n                      dPos.x += dragDelta[0];\n                      dPos.y += dragDelta[1];\n                    }\n                  }\n                }\n\n              }\n            }\n\n            r.hoverData.draggingEles = true;\n            \n            var tcol = (new $$.Collection(cy, toTrigger));\n\n            tcol.updateCompoundBounds();\n            tcol.trigger('position drag');\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n            r.redraw();\n\n          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n            updateDragDelta();\n          }\n        }\n\n        // prevent the dragging from triggering text selection on the page\n        preventDefault = true;\n      }\n      \n      select[2] = pos[0]; select[3] = pos[1];\n      \n      if( preventDefault ){ \n        if(e.stopPropagation) e.stopPropagation();\n          if(e.preventDefault) e.preventDefault();\n          return false;\n        }\n    }, 1000/30, { trailing: true }), false);\n    \n    r.registerBinding(window, 'mouseup', function(e) {\n      // console.log('--\\nmouseup', e)\n\n      var capture = r.hoverData.capture;\n      if (!capture) { return; }\n      r.hoverData.capture = false;\n    \n      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;\n      var near = r.findNearestElement(pos[0], pos[1], true); \n      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;\n      var shiftDown = e.shiftKey;\n      \n      if( r.data.bgActivePosistion ){\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n        r.redraw();\n      }\n\n      r.data.bgActivePosistion = undefined; // not active bg now\n      clearTimeout( r.bgActiveTimeout );\n\n      r.hoverData.cxtStarted = false;\n      r.hoverData.draggingEles = false;\n      r.hoverData.selecting = false;\n\n      if( down ){\n        down.unactivate();\n      }\n\n      if( r.hoverData.which === 3 ){\n        var cxtEvt = new $$.Event(e, {\n          type: 'cxttapend',\n          cyPosition: { x: pos[0], y: pos[1] }\n        });\n\n        if( down ){\n          down.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        if( !r.hoverData.cxtDragged ){\n          var cxtTap = new $$.Event(e, {\n            type: 'cxttap',\n            cyPosition: { x: pos[0], y: pos[1] }\n          });\n\n          if( down ){\n            down.trigger( cxtTap );\n          } else {\n            cy.trigger( cxtTap );\n          }\n        }\n\n        r.hoverData.cxtDragged = false;\n        r.hoverData.which = null;\n\n      // if not right mouse\n      } else {\n\n        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n        if ( (down == null) // not mousedown on node\n          && !r.dragData.didDrag // didn't move the node around\n          && !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection\n          && !r.hoverData.dragging // not panning\n        ) {\n\n          cy.$(function(){\n            return this.selected();\n          }).unselect();\n          \n          if (draggedElements.length > 0) {\n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n          }\n          \n          r.dragData.possibleDragElements = draggedElements = [];\n        }\n      \n        \n        // Mouseup event\n        {\n          // console.log('trigger mouseup et al');\n\n          if (near != null) {\n            near\n              .trigger(new $$.Event(e, {\n                type: 'mouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n          } else if (near == null) {\n            cy\n              .trigger(new $$.Event(e, {\n                type: 'mouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: pos[0], y: pos[1] }\n              }))\n            ;\n          }\n        }\n        \n        // Click event\n        {\n          // console.log('trigger click et al');\n\n          if (Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0) {\n            if (near != null) {\n              near\n                .trigger( new $$.Event(e, {\n                  type: 'click',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'tap',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'vclick',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n              ;\n            } else if (near == null) {\n              cy\n                .trigger( new $$.Event(e, {\n                  type: 'click',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'tap',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n                .trigger( new $$.Event(e, {\n                  type: 'vclick',\n                  cyPosition: { x: pos[0], y: pos[1] }\n                }) )\n              ;\n            }\n          }\n        }\n\n        // Single selection\n        if (near == down && !r.dragData.didDrag) {\n          if (near != null && near._private.selectable) {\n            \n            // console.log('single selection')\n\n            if( r.hoverData.dragging ){\n              // if panning, don't change selection state\n            } else if( cy.selectionType() === 'additive' || shiftDown ){\n              if( near.selected() ){\n                near.unselect();\n              } else {\n                near.select();\n              }\n            } else {\n              if( !shiftDown ){\n                cy.$(':selected').not( near ).unselect();\n                near.select();\n              }               \n            }\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n            \n          }\n      \n        } \n        \n        if ( cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {         \n          var newlySelected = [];\n          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n          if( box.length > 0 ) { \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          }\n\n          for( var i = 0; i < box.length; i++ ){ \n            if( box[i]._private.selectable ){\n              newlySelected.push( box[i] );\n            }\n          }\n\n          var newlySelCol = new $$.Collection( cy, newlySelected );\n\n          if( cy.selectionType() === 'additive' ){\n            newlySelCol.select();\n          } else {\n            if( !shiftDown ){\n              cy.$(':selected').not( newlySelCol ).unselect();\n            }\n\n            newlySelCol.select();\n          }\n\n          // always need redraw in case eles unselectable\n          r.redraw();\n          \n        }\n        \n        // Cancel drag pan\n        if( r.hoverData.dragging ){\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          r.redraw();\n        }\n\n        r.hoverData.dragging = false;\n        \n        if (!select[4]) {\n          // console.log('free at end', draggedElements)\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; \n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          \n          for (var i=0; i < draggedElements.length; i++) {\n            \n            if(draggedElements[i]._private.group === 'nodes') { \n              draggedElements[i]._private.rscratch.inDragLayer = false;\n              draggedElements[i]._private.grabbed = false;\n              \n              var sEdges = draggedElements[i]._private.edges;\n              for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }\n\n              // for compound nodes, also remove related nodes and edges from the drag layer\n              updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });\n              \n            } else if( draggedElements[i]._private.group === 'edges' ){\n              draggedElements[i]._private.rscratch.inDragLayer = false;\n            }\n            \n          }\n\n          if( down ){ down.trigger('free'); }\n\n  //        draggedElements = r.dragData.possibleDragElements = [];\n          \n        }\n      \n      } // else not right mouse\n\n      select[4] = 0; r.hoverData.down = null;\n      \n      //r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true; \n      \n//      console.log('mu', pos[0], pos[1]);\n//      console.log('ss', select);\n      \n      r.dragData.didDrag = false;\n      r.hoverData.dragDelta = [];\n      \n    }, false);\n\n    var wheelHandler = function(e) { \n      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom\n\n      var cy = r.data.cy;\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var rpos = [pos[0] * cy.zoom() + cy.pan().x,\n                    pos[1] * cy.zoom() + cy.pan().y];\n      \n      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom\n        e.preventDefault();\n        return;\n      }\n\n      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){\n        e.preventDefault();\n        \n        r.data.wheelZooming = true;\n        clearTimeout( r.data.wheelTimeout );\n        r.data.wheelTimeout = setTimeout(function(){\n          r.data.wheelZooming = false;\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          r.redraw();\n        }, 150);\n\n        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;\n        diff = diff * r.wheelSensitivity;\n\n        var needsWheelFix = e.deltaMode === 1;\n        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows\n          diff *= 33;\n        }\n\n        cy.zoom({\n          level: cy.zoom() * Math.pow(10, diff),\n          renderedPosition: { x: rpos[0], y: rpos[1] }\n        });\n      }\n\n    };\n    \n    // Functions to help with whether mouse wheel should trigger zooming\n    // --\n    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);\n\n    // disable nonstandard wheel events\n    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n    r.registerBinding(window, 'scroll', function(e){\n      r.scrollingPage = true;\n\n      clearTimeout( r.scrollingPageTimeout );\n      r.scrollingPageTimeout = setTimeout(function(){\n        r.scrollingPage = false;\n      }, 250);\n    }, true);\n    \n    // Functions to help with handling mouseout/mouseover on the Cytoscape container\n          // Handle mouseout on Cytoscape container\n    r.registerBinding(r.data.container, 'mouseout', function(e) { \n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      r.data.cy.trigger(new $$.Event(e, {\n        type: 'mouseout',\n        cyPosition: { x: pos[0], y: pos[1] }\n      }));\n    }, false);\n    \n    r.registerBinding(r.data.container, 'mouseover', function(e) { \n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n\n      r.data.cy.trigger(new $$.Event(e, {\n        type: 'mouseover',\n        cyPosition: { x: pos[0], y: pos[1] }\n      }));\n    }, false);\n    \n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n    var center1, modelCenter1; // center point on start pinch to zoom\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n\n    var distance = function(x1, y1, x2, y2){\n      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );\n    };\n\n    var distanceSq = function(x1, y1, x2, y2){\n      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);\n    };\n\n    r.registerBinding(r.data.container, 'touchstart', function(e) {\n\n      clearTimeout( this.threeFingerSelectTimeout );\n\n      if( e.target !== r.data.link ){\n        e.preventDefault();\n      }\n    \n      r.touchData.capture = true;\n      r.data.bgActivePosistion = undefined;\n\n      var cy = r.data.cy; \n      var nodes = r.getCachedNodes();\n      var edges = r.getCachedEdges();\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n      \n      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n    \n\n      // record starting points for pinch-to-zoom\n      if( e.touches[1] ){\n\n        // anything in the set of dragged eles should be released\n        var release = function( eles ){\n          for( var i = 0; i < eles.length; i++ ){\n            eles[i]._private.grabbed = false;\n            eles[i]._private.rscratch.inDragLayer = false;\n            if( eles[i].active() ){ eles[i].unactivate(); }\n          }\n        };\n        release(nodes);\n        release(edges);\n\n        var offsets = r.findContainerClientCoords();\n        offsetLeft = offsets[0];\n        offsetTop = offsets[1];\n        containerWidth = offsets[2];\n        containerHeight = offsets[3];\n\n        f1x1 = e.touches[0].clientX - offsetLeft;\n        f1y1 = e.touches[0].clientY - offsetTop;\n        \n        f2x1 = e.touches[1].clientX - offsetLeft;\n        f2y1 = e.touches[1].clientY - offsetTop;\n\n        twoFingersStartInside = \n             0 <= f1x1 && f1x1 <= containerWidth\n          && 0 <= f2x1 && f2x1 <= containerWidth\n          && 0 <= f1y1 && f1y1 <= containerHeight\n          && 0 <= f2y1 && f2y1 <= containerHeight\n        ;\n\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n\n        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );\n        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );\n        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];\n        modelCenter1 = [ \n          (center1[0] - pan.x) / zoom,\n          (center1[1] - pan.y) / zoom\n        ];\n\n        // consider context tap\n        var cxtDistThreshold = 200;\n        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){\n\n          var near1 = r.findNearestElement(now[0], now[1], true);\n          var near2 = r.findNearestElement(now[2], now[3], true);\n\n          //console.log(distance1)\n\n          if( near1 && near1.isNode() ){\n            near1.activate().trigger( new $$.Event(e, {\n              type: 'cxttapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n            r.touchData.start = near1;\n          \n          } else if( near2 && near2.isNode() ){\n            near2.activate().trigger( new $$.Event(e, {\n              type: 'cxttapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n            r.touchData.start = near2;\n          \n          } else {\n            cy.trigger( new $$.Event(e, {\n              type: 'cxttapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n            r.touchData.start = null;\n          } \n\n          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n          r.touchData.cxt = true;\n          r.touchData.cxtDragged = false;\n          r.data.bgActivePosistion = undefined;\n\n          //console.log('cxttapstart')\n\n          r.redraw();\n          return;\n          \n        }\n\n        // console.log(center1);\n        // console.log('touchstart ptz');\n        // console.log(offsetLeft, offsetTop);\n        // console.log(f1x1, f1y1);\n        // console.log(f2x1, f2y1);\n        // console.log(distance1);\n        // console.log(center1);\n      }\n\n      // console.log('another tapstart')\n      \n      \n      if (e.touches[2]) {\n      \n      } else if (e.touches[1]) {\n        \n      } else if (e.touches[0]) {\n        var near = r.findNearestElement(now[0], now[1], true);\n\n        if (near != null) {\n          near.activate();\n\n          r.touchData.start = near;\n          \n          if( near.isNode() && r.nodeIsDraggable(near) ){\n\n            var draggedEles = r.dragData.touchDragEles = [];\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            if( near.selected() ){\n              // reset drag elements, since near will be added again\n\n              var selectedNodes = cy.$(function(){\n                return this.isNode() && this.selected();\n              });\n\n              for( var k = 0; k < selectedNodes.length; k++ ){\n                var selectedNode = selectedNodes[k];\n\n                if( r.nodeIsDraggable(selectedNode) ){\n                  addNodeToDrag( selectedNode, { addToList: draggedEles } );\n                }\n              }\n            } else {\n              addNodeToDrag( near, { addToList: draggedEles } );\n            }\n\n            near.trigger( new $$.Event(e, {\n              type: 'grab',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n          }\n          \n          near\n            .trigger(new $$.Event(e, {\n              type: 'touchstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousdown',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n          ;\n        } if (near == null) {\n          cy\n            .trigger(new $$.Event(e, {\n              type: 'touchstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapstart',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmousedown',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n          ;\n\n          r.data.bgActivePosistion = {\n            x: pos[0],\n            y: pos[1]\n          };\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n          r.redraw();\n        }\n        \n        \n        // Tap, taphold\n        // -----\n        \n        for (var i=0; i<now.length; i++) {\n          earlier[i] = now[i];\n          r.touchData.startPosition[i] = now[i];\n        }\n        \n        r.touchData.singleTouchMoved = false;\n        r.touchData.singleTouchStartTime = +new Date();\n        \n        clearTimeout( r.touchData.tapholdTimeout );\n        r.touchData.tapholdTimeout = setTimeout(function() {\n          if(\n              r.touchData.singleTouchMoved === false\n              && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n\n              // This time double constraint prevents multiple quick taps\n              // followed by a taphold triggering multiple taphold events\n              //&& Date.now() - r.touchData.singleTouchStartTime > 250\n          ){\n            if (r.touchData.start) {\n              r.touchData.start.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n            } else {\n              r.data.cy.trigger( new $$.Event(e, {\n                type: 'taphold',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n\n              cy.$(':selected').unselect();\n            }\n\n//            console.log('taphold');\n          }\n        }, r.tapholdDuration);\n      }\n      \n      //r.redraw();\n      \n    }, false);\n    \n// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };\n\n    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {\n    \n      var select = r.data.select;\n      var capture = r.touchData.capture; //if (!capture) { return; }; \n      if( capture ){ e.preventDefault(); }\n    \n      var cy = r.data.cy; \n      var now = r.touchData.now; var earlier = r.touchData.earlier;\n      var zoom = cy.zoom();\n      \n      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }\n      \n      var startPos = r.touchData.startPosition;\n\n      var dx = now[0] - startPos[0];\n      var dx2 = dx * dx;\n      var dy = now[1] - startPos[1];\n      var dy2 = dy * dy;\n      var dist2 = dx2 + dy2;\n      var rdist2 = dist2 * zoom * zoom;\n\n      if( capture && r.touchData.cxt ){\n        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n        var factorSq = distance2Sq / distance1Sq;\n\n        var distThreshold = 150;\n        var distThresholdSq = distThreshold * distThreshold;\n        var factorThreshold = 1.5;\n        var factorThresholdSq = factorThreshold * factorThreshold;\n\n        //console.log(factor, distance2)\n\n        // cancel ctx gestures if the distance b/t the fingers increases\n        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){\n          r.touchData.cxt = false;\n          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }\n          r.data.bgActivePosistion = undefined;\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n          var cxtEvt = new $$.Event(e, {\n            type: 'cxttapend',\n            cyPosition: { x: now[0], y: now[1] }\n          });\n          if( r.touchData.start ){\n            r.touchData.start.trigger( cxtEvt );\n          } else {\n            cy.trigger( cxtEvt );\n          }\n        }\n\n      }  \n\n      if( capture && r.touchData.cxt ){ \n        var cxtEvt = new $$.Event(e, {\n          type: 'cxtdrag',\n          cyPosition: { x: now[0], y: now[1] }\n        });\n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        if( r.touchData.start ){\n          r.touchData.start.trigger( cxtEvt );\n        } else {\n          cy.trigger( cxtEvt );\n        }\n\n        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n        r.touchData.cxtDragged = true;\n\n        //console.log('cxtdrag')\n\n        var near = r.findNearestElement(now[0], now[1], true);\n\n        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){\n\n          if( r.touchData.cxtOver ){\n            r.touchData.cxtOver.trigger( new $$.Event(e, {\n              type: 'cxtdragout',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n\n            // console.log('cxtdragout');\n          }\n\n          r.touchData.cxtOver = near;\n\n          if( near ){\n            near.trigger( new $$.Event(e, {\n              type: 'cxtdragover',\n              cyPosition: { x: now[0], y: now[1] }\n            }) );\n\n            // console.log('cxtdragover');\n          }\n\n        }\n\n      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){ \n        r.data.bgActivePosistion = undefined;\n        clearTimeout( this.threeFingerSelectTimeout );\n        this.lastThreeTouch = +new Date();\n\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        if( !select || select.length === 0 || select[0] === undefined ){\n          select[0] = (now[0] + now[2] + now[4])/3;\n          select[1] = (now[1] + now[3] + now[5])/3;\n          select[2] = (now[0] + now[2] + now[4])/3 + 1;\n          select[3] = (now[1] + now[3] + now[5])/3 + 1;\n        } else {\n          select[2] = (now[0] + now[2] + now[4])/3;\n          select[3] = (now[1] + now[3] + now[5])/3;\n        }\n\n        select[4] = 1;\n\n        r.redraw();\n\n      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom\n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        var draggedEles = r.dragData.touchDragEles;\n        if( draggedEles ){ \n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n          for( var i = 0; i < draggedEles.length; i++ ){\n            draggedEles[i]._private.grabbed = false;\n            draggedEles[i]._private.rscratch.inDragLayer = false;\n          }\n        }\n\n        // console.log('touchmove ptz');\n\n        // (x2, y2) for fingers 1 and 2\n        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n\n        // console.log( f1x2, f1y2 )\n        // console.log( f2x2, f2y2 )\n\n        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n        var factor = distance2 / distance1;\n\n        // console.log(distance2)\n        // console.log(factor)\n\n        if( factor != 1 && twoFingersStartInside){\n\n          // console.log(factor)\n          // console.log(distance2 + ' / ' + distance1);\n          // console.log('--');\n\n          // delta finger1\n          var df1x = f1x2 - f1x1;\n          var df1y = f1y2 - f1y1;\n\n          // delta finger 2\n          var df2x = f2x2 - f2x1;\n          var df2y = f2y2 - f2y1;\n\n          // translation is the normalised vector of the two fingers movement\n          // i.e. so pinching cancels out and moving together pans\n          var tx = (df1x + df2x)/2;\n          var ty = (df1y + df2y)/2;\n\n          // adjust factor by the speed multiplier\n          // var speed = 1.5;\n          // if( factor > 1 ){\n          //   factor = (factor - 1) * speed + 1;\n          // } else {\n          //   factor = 1 - (1 - factor) * speed;\n          // }\n\n          // now calculate the zoom\n          var zoom1 = cy.zoom();\n          var zoom2 = zoom1 * factor;\n          var pan1 = cy.pan();\n\n          // the model center point converted to the current rendered pos\n          var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n          var ctry = modelCenter1[1] * zoom1 + pan1.y;\n\n          var pan2 = {\n            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,\n            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry\n          };\n\n          // console.log(pan2);\n          // console.log(zoom2);\n\n          // remove dragged eles\n          if( r.touchData.start ){\n            var draggedEles = r.dragData.touchDragEles;\n\n            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){\n              draggedEles[i]._private.grabbed = false;\n              draggedEles[i]._private.rscratch.inDragLayer = false;\n            } }\n\n            r.touchData.start._private.active = false;\n            r.touchData.start._private.grabbed = false;\n            r.touchData.start._private.rscratch.inDragLayer = false;\n\n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            r.touchData.start\n              .trigger('free')\n              .trigger('unactivate')\n            ;\n          }\n\n          cy.viewport({\n            zoom: zoom2,\n            pan: pan2,\n            cancelOnFailedZoom: true\n          });\n\n          distance1 = distance2;  \n          f1x1 = f1x2;\n          f1y1 = f1y2;\n          f2x1 = f2x2;\n          f2y1 = f2y2;\n\n          r.pinching = true;\n        }\n        \n        // Re-project\n        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n\n      } else if (e.touches[0]) {\n        var start = r.touchData.start;\n        var last = r.touchData.last;\n        var near = near || r.findNearestElement(now[0], now[1], true);\n\n        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){\n\n          if( rdist2 >= r.tapThreshold2 ){ // then dragging can happen\n            var draggedEles = r.dragData.touchDragEles;\n\n            for( var k = 0; k < draggedEles.length; k++ ){\n              var draggedEle = draggedEles[k];\n\n              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){\n                r.dragData.didDrag = true;\n                var dPos = draggedEle._private.position;\n                var justStartedDrag = !r.hoverData.draggingEles;\n\n                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){\n                  dPos.x += disp[0];\n                  dPos.y += disp[1];\n                }\n\n                if( justStartedDrag ){\n                  addNodeToDrag( draggedEle, { inDragLayer: true } );\n\n                  var dragDelta = r.touchData.dragDelta;\n\n                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){\n                    dPos.x += dragDelta[0];\n                    dPos.y += dragDelta[1];\n                  }\n\n                }\n              }\n            }\n\n            var tcol = new $$.Collection(cy, draggedEle);\n            \n            tcol.updateCompoundBounds();\n            tcol.trigger('position drag');\n\n            r.hoverData.draggingEles = true;\n            \n            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;\n\n            if( \n                 r.touchData.startPosition[0] == earlier[0]\n              && r.touchData.startPosition[1] == earlier[1]\n            ){\n              \n              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;\n            }\n            \n            r.redraw();\n          } else { // otherise keep track of drag delta for later\n            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n            if( dragDelta.length === 0 ){\n              dragDelta.push(0);\n              dragDelta.push(0);\n            } else {\n              dragDelta[0] += disp[0];\n              dragDelta[1] += disp[1];\n            }\n          }\n        }\n        \n        // Touchmove event\n        {\n\n          if (start != null) {\n            start.trigger( new $$.Event(e, {\n              type: 'touchmove',\n              cyPosition: { x: now[0], y: now[1] }\n            }) ); \n\n            start.trigger( new $$.Event(e, {\n              type: 'tapdrag',\n              cyPosition: { x: now[0], y: now[1] }\n            }) ); \n\n            start.trigger( new $$.Event(e, {\n              type: 'vmousemove',\n              cyPosition: { x: now[0], y: now[1] }\n            }) ); \n          }\n          \n          if (start == null) { \n\n            if (near != null) { \n              near.trigger( new $$.Event(e, {\n                type: 'touchmove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n\n              near.trigger( new $$.Event(e, {\n                type: 'tapdrag',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n\n              near.trigger( new $$.Event(e, {\n                type: 'vmousemove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) );\n            }\n\n            if (near == null) { \n              cy.trigger( new $$.Event(e, {\n                type: 'touchmove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n\n              cy.trigger( new $$.Event(e, {\n                type: 'tapdrag',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n\n              cy.trigger( new $$.Event(e, {\n                type: 'vmousemove',\n                cyPosition: { x: now[0], y: now[1] }\n              }) ); \n            }\n          }\n\n          if (near != last) {\n            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }\n            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }\n          }\n\n          r.touchData.last = near;\n        }\n        \n        // Check to cancel taphold\n        for (var i=0;i<now.length;i++) {\n          if (now[i] \n            && r.touchData.startPosition[i]\n            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {\n            \n            r.touchData.singleTouchMoved = true;\n          }\n        }\n        \n        if(\n            capture\n            && ( start == null || start.isEdge() )\n            && cy.panningEnabled() && cy.userPanningEnabled()\n        ){\n\n          if( r.swipePanning ){\n            cy.panBy({\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            });\n\n          } else if( rdist2 >= r.tapThreshold2 ){\n            r.swipePanning = true;\n\n            cy.panBy({\n              x: dx * zoom,\n              y: dy * zoom\n            });\n          }\n\n          if( start ){\n            start.unactivate();\n\n            if( !r.data.bgActivePosistion ){\n              r.data.bgActivePosistion = {\n                x: now[0],\n                y: now[1]\n              };\n            }\n\n            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n            r.touchData.start = null;\n          }\n          \n          // Re-project\n          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n          now[0] = pos[0]; now[1] = pos[1];\n        }\n      }\n\n      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }\n      //r.redraw();\n      \n    }, 1000/30, { trailing: true }), false);\n    \n    r.registerBinding(window, 'touchcancel', function(e) {\n      var start = r.touchData.start;\n\n      r.touchData.capture = false;\n\n      if( start ){\n        start.unactivate();\n      }\n    });\n\n    r.registerBinding(window, 'touchend', function(e) {\n      var start = r.touchData.start;\n\n      var capture = r.touchData.capture; \n\n      if( capture ){\n        r.touchData.capture = false;\n      } else {\n        return;\n      }\n      \n      e.preventDefault();\n      var select = r.data.select;\n\n      r.swipePanning = false;\n      r.hoverData.draggingEles = false;\n      \n      var cy = r.data.cy; \n      var zoom = cy.zoom();\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n\n      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }\n      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }\n      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }\n      \n      if( start ){\n        start.unactivate();\n      }\n\n      var ctxTapend;\n      if( r.touchData.cxt ){\n        ctxTapend = new $$.Event(e, {\n          type: 'cxttapend',\n          cyPosition: { x: now[0], y: now[1] }\n        });\n\n        if( start ){\n          start.trigger( ctxTapend );\n        } else {\n          cy.trigger( ctxTapend );\n        }\n\n        //console.log('cxttapend')\n\n        if( !r.touchData.cxtDragged ){\n          var ctxTap = new $$.Event(e, {\n            type: 'cxttap',\n            cyPosition: { x: now[0], y: now[1] }\n          });\n\n          if( start ){\n            start.trigger( ctxTap );\n          } else {\n            cy.trigger( ctxTap );\n          }\n\n          //console.log('cxttap')\n        }\n\n        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }\n        r.touchData.cxt = false;\n        r.touchData.start = null;\n\n        r.redraw();\n        return;\n      }\n\n      // no more box selection if we don't have three fingers\n      if( !e.touches[2] && cy.boxSelectionEnabled() ){\n        clearTimeout( this.threeFingerSelectTimeout );\n        //this.threeFingerSelectTimeout = setTimeout(function(){\n          var newlySelected = [];\n          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );\n\n          select[0] = undefined;\n          select[1] = undefined;\n          select[2] = undefined;\n          select[3] = undefined;\n          select[4] = 0;\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n          // console.log(box);\n          for( var i = 0; i< box.length; i++ ) { \n            if( box[i]._private.selectable ){\n              newlySelected.push( box[i] );\n            }\n          }\n\n          var newlySelCol = new $$.Collection( cy, newlySelected );\n\n          if( cy.selectionType() === 'single' ){\n            cy.$(':selected').not( newlySelCol ).unselect();\n          }\n\n          newlySelCol.select();\n          \n          if( newlySelCol.length > 0 ) { \n            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          } else {\n            r.redraw();\n          }\n\n        //}, 100);\n      }\n\n      var updateStartStyle = false;\n\n      if( start != null ){\n        start._private.active = false;\n        updateStartStyle = true;\n        start.unactivate();\n      }\n\n      if (e.touches[2]) {\n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n      } else if (e.touches[1]) {\n        \n      } else if (e.touches[0]) {\n      \n      // Last touch released\n      } else if (!e.touches[0]) {\n        \n        r.data.bgActivePosistion = undefined;\n        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;\n\n        if (start != null ) {\n\n          if( start._private.grabbed ){\n            start._private.grabbed = false;\n            start.trigger('free');\n            start._private.rscratch.inDragLayer = false;\n          }\n          \n          var sEdges = start._private.edges;\n          for (var j=0;j<sEdges.length;j++) { sEdges[j]._private.rscratch.inDragLayer = false; }\n          updateAncestorsInDragLayer(start, false);\n          \n          if( start.selected() ){\n            var selectedNodes = cy.$('node:selected');\n\n            for( var k = 0; k < selectedNodes.length; k++ ){\n\n              var selectedNode = selectedNodes[k];\n              selectedNode._private.rscratch.inDragLayer = false;\n              selectedNode._private.grabbed = false;\n\n              var sEdges = selectedNode._private.edges;\n              for (var j=0; j<sEdges.length; j++) {\n                sEdges[j]._private.rscratch.inDragLayer = false;\n              }\n\n              updateAncestorsInDragLayer(selectedNode, false);\n            }\n          }\n\n          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; \n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n          \n          start\n            .trigger(new $$.Event(e, {\n              type: 'touchend',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'tapend',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n            .trigger(new $$.Event(e, {\n              type: 'vmouseup',\n              cyPosition: { x: now[0], y: now[1] }\n            }))\n          ;\n          \n          start.unactivate();\n\n          r.touchData.start = null;\n          \n        } else {\n          var near = r.findNearestElement(now[0], now[1], true);\n        \n          if (near != null) { \n            near\n              .trigger(new $$.Event(e, {\n                type: 'touchend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          }\n\n          if (near == null) { \n            cy\n              .trigger(new $$.Event(e, {\n                type: 'touchend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'tapend',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vmouseup',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          }\n        }\n\n        var dx = r.touchData.startPosition[0] - now[0];\n        var dx2 = dx * dx;\n        var dy = r.touchData.startPosition[1] - now[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        var rdist2 = dist2 * zoom * zoom;\n        \n        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n        if (start != null \n            && !r.dragData.didDrag // didn't drag nodes around\n            && start._private.selectable \n            && rdist2 < r.tapThreshold2\n            && !r.pinching // pinch to zoom should not affect selection\n        ) {\n\n          if( cy.selectionType() === 'single' ){\n            cy.$(':selected').not( start ).unselect();\n            start.select();\n          } else {\n            if( start.selected() ){\n              start.unselect();\n            } else {\n              start.select();\n            }\n          }\n\n          updateStartStyle = true;\n\n          \n          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n        }\n        \n        // Tap event, roughly same as mouse click event for touch\n        if ( r.touchData.singleTouchMoved === false ) {\n\n          if (start) {\n            start\n              .trigger(new $$.Event(e, {\n                type: 'tap',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vclick',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          } else {\n            cy\n              .trigger(new $$.Event(e, {\n                type: 'tap',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n              .trigger(new $$.Event(e, {\n                type: 'vclick',\n                cyPosition: { x: now[0], y: now[1] }\n              }))\n            ;\n          }\n          \n//          console.log('tap');\n        }\n        \n        r.touchData.singleTouchMoved = true;\n      }\n      \n      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }\n\n      r.dragData.didDrag = false; // reset for next mousedown\n\n      if( e.touches[0] ){\n        r.touchData.dragDelta = [];\n      }\n\n      if( updateStartStyle && start ){\n        start.updateStyle(false);\n      }\n\n      if( e.touches.length < 2 ){\n        r.pinching = false;\n        r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; \n        r.redraw();\n      }\n\n      //r.redraw();\n      \n    }, false);\n  };\n\n})( cytoscape );\n;(function($$){ 'use strict';\n\n  var CanvasRenderer = $$('renderer', 'canvas');\n  var renderer = CanvasRenderer.prototype;\n  var usePaths = CanvasRenderer.usePaths();\n\n  // Node shape contract:\n  //\n  // draw: draw\n  // intersectLine: report intersection from x, y, to node center\n  // checkPoint: check x, y in node\n\n  var nodeShapes = CanvasRenderer.nodeShapes = {};\n\n  var sin0 = Math.sin(0);\n  var cos0 = Math.cos(0);\n\n  var sin = {};\n  var cos = {};\n\n  var ellipseStepSize = 0.1;\n\n  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n  }\n\n  nodeShapes['ellipse'] = {\n    draw: function(context, centerX, centerY, width, height) {\n      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);\n      context.fill();\n      \n//      console.log('drawing ellipse');\n//      console.log(arguments);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      \n      if( usePaths ){\n        if( context.beginPath ){ context.beginPath(); }\n\n        var xPos, yPos;\n        var rw = width/2;\n        var rh = height/2;\n        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {\n            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;\n            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;\n\n            if (i === 0) {\n                context.moveTo(xPos, yPos);\n            } else {\n                context.lineTo(xPos, yPos);\n            }\n        }\n        context.closePath();\n\n      } else {\n\n        if( context.beginPath ){ context.beginPath(); }\n        context.translate(centerX, centerY);\n        context.scale(width / 2, height / 2);\n        // At origin, radius 1, 0 to 2pi\n        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle\n        context.closePath();\n\n        context.scale(2/width, 2/height);\n        context.translate(-centerX, -centerY);\n\n      }\n      \n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      var intersect = $$.math.intersectLineEllipse(\n        x, y,\n        nodeX,\n        nodeY,\n        width / 2 + padding,\n        height / 2 + padding);\n      \n      return intersect;\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      return $$.math.boxIntersectEllipse(\n        x1, y1, x2, y2, padding, width, height, centerX, centerY);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n//      console.log(arguments);\n      \n      x -= centerX;\n      y -= centerY;\n      \n      x /= (width / 2 + padding);\n      y /= (height / 2 + padding);\n      \n      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);\n    }\n  };\n  \n  nodeShapes['triangle'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(3, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['triangle'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['triangle'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.polygonIntersectLine(\n        x, y,\n        nodeShapes['triangle'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    \n      /*\n      polygonIntersectLine(x, y, basePoints, centerX, centerY, \n        width, height, padding);\n      */\n      \n      \n      /*\n      return renderer.polygonIntersectLine(\n        node, width, height,\n        x, y, nodeShapes['triangle'].points);\n      */\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['triangle'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(\n        x, y, nodeShapes['triangle'].points,\n        centerX, centerY, width, height,\n        [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['square'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['square'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['square'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.polygonIntersectLine(\n          x, y,\n          nodeShapes['square'].points,\n          nodeX,\n          nodeY,\n          width / 2, height / 2,\n          padding);\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2,\n      width, height, centerX, \n      centerY, padding) {\n      \n      var points = nodeShapes['square'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, \n        centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['square'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['rectangle'] = nodeShapes['square'];\n  \n  nodeShapes['octogon'] = {};\n  \n  nodeShapes['roundrectangle'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawRoundRectangle(context,\n        centerX, centerY,\n        width, height,\n        10);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawRoundRectanglePath(context,\n        centerX, centerY,\n        width, height,\n        10);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.roundRectangleIntersectLine(\n          x, y,\n          nodeX,\n          nodeY,\n          width, height,\n          padding);\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2,\n      width, height, centerX, \n      centerY, padding) {\n\n      return $$.math.roundRectangleIntersectBox(\n        x1, y1, x2, y2, \n        width, height, centerX, centerY, padding);\n    },\n    \n    // Looks like the width passed into this function is actually the total width / 2\n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);\n      \n      // Check hBox\n      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,\n        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {\n        return true;\n      }\n      \n      // Check vBox\n      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,\n        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {\n        return true;\n      }\n      \n      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {\n        x -= centerX;\n        y -= centerY;\n        \n        x /= (width / 2 + padding);\n        y /= (height / 2 + padding);\n        \n        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);\n      };\n      \n      \n      // Check top left quarter circle\n      if (checkInEllipse(x, y,\n        centerX - width / 2 + cornerRadius,\n        centerY - height / 2 + cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      /*\n      if (renderer.boxIntersectEllipse(x, y, x, y, padding, \n        cornerRadius * 2, cornerRadius * 2,\n        centerX - width + cornerRadius,\n        centerY - height + cornerRadius)) {\n        return true;\n      }\n      */\n      \n      // Check top right quarter circle\n      if (checkInEllipse(x, y,\n        centerX + width / 2 - cornerRadius,\n        centerY - height / 2 + cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      // Check bottom right quarter circle\n      if (checkInEllipse(x, y,\n        centerX + width / 2 - cornerRadius,\n        centerY + height / 2 - cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      // Check bottom left quarter circle\n      if (checkInEllipse(x, y,\n        centerX - width / 2 + cornerRadius,\n        centerY + height / 2 - cornerRadius,\n        cornerRadius * 2, cornerRadius * 2, padding)) {\n        \n        return true;\n      }\n      \n      return false;\n    }\n  };\n  \n  nodeShapes['pentagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(5, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height, nodeShapes['pentagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height, nodeShapes['pentagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['pentagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n      x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['pentagon'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['pentagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['hexagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(6, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['hexagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['hexagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return $$.math.polygonIntersectLine(\n        x, y,\n        nodeShapes['hexagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n        \n      var points = nodeShapes['hexagon'].points;\n      \n      return $$.math.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['hexagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['heptagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(7, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['heptagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['heptagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['heptagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['heptagon'].points;\n      \n      return renderer.boxIntersectPolygon(\n        x1, y1, x2, y2,\n        points, width, height, centerX, centerY, [0, -1], padding);\n    },\n\n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['heptagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  nodeShapes['octagon'] = {\n    points: $$.math.generateUnitNgonPointsFitToSquare(8, 0),\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['octagon'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['octagon'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['octagon'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['octagon'].points;\n      \n      return renderer.boxIntersectPolygon(\n          x1, y1, x2, y2,\n          points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['octagon'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n  \n  var star5Points = new Array(20);\n  {\n    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);\n    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);\n    \n//    console.log(outerPoints);\n//    console.log(innerPoints);\n    \n    // Outer radius is 1; inner radius of star is smaller\n    var innerRadius = 0.5 * (3 - Math.sqrt(5));\n    innerRadius *= 1.57;\n    \n    for (var i=0;i<innerPoints.length/2;i++) {\n      innerPoints[i*2] *= innerRadius;\n      innerPoints[i*2+1] *= innerRadius;\n    }\n    \n    for (var i=0;i<20/4;i++) {\n      star5Points[i*4] = outerPoints[i*2];\n      star5Points[i*4+1] = outerPoints[i*2+1];\n      \n      star5Points[i*4+2] = innerPoints[i*2];\n      star5Points[i*4+3] = innerPoints[i*2+1];\n    }\n    \n//    console.log(star5Points);\n  }\n\n  star5Points = $$.math.fitPolygonToSquare( star5Points );\n  \n  nodeShapes['star5'] = nodeShapes['star'] = {\n    points: star5Points,\n    \n    draw: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygon(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['star5'].points);\n    },\n    \n    drawPath: function(context, centerX, centerY, width, height) {\n      renderer.drawPolygonPath(context,\n        centerX, centerY,\n        width, height,\n        nodeShapes['star5'].points);\n    },\n    \n    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {\n      return renderer.polygonIntersectLine(\n        x, y,\n        nodeShapes['star5'].points,\n        nodeX,\n        nodeY,\n        width / 2, height / 2,\n        padding);\n    },\n    \n    intersectBox: function(\n        x1, y1, x2, y2, width, height, centerX, centerY, padding) {\n      \n      var points = nodeShapes['star5'].points;\n      \n      return renderer.boxIntersectPolygon(\n          x1, y1, x2, y2,\n          points, width, height, centerX, centerY, [0, -1], padding);\n    },\n    \n    checkPoint: function(\n      x, y, padding, width, height, centerX, centerY) {\n      \n      return $$.math.pointInsidePolygon(x, y, nodeShapes['star5'].points,\n        centerX, centerY, width, height, [0, -1], padding);\n    }\n  };\n\n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    animate: true, // whether to show the layout as it's running\n    maxSimulationTime: 4000, // max length in ms to run the layout\n    fit: true, // on every layout reposition of nodes, fit the viewport\n    padding: 30, // padding around the simulation\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n\n    // callbacks on layout events\n    ready: undefined, // callback on layoutready \n    stop: undefined, // callback on layoutstop\n\n    // forces used by arbor (use arbor default on undefined)\n    repulsion: undefined,\n    stiffness: undefined,\n    friction: undefined,\n    gravity: true,\n    fps: undefined,\n    precision: undefined,\n\n    // static numbers or functions that dynamically return what these\n    // values should be for each element\n    // e.g. nodeMass: function(n){ return n.data('weight') }\n    nodeMass: undefined, \n    edgeLength: undefined,\n\n    stepSize: 0.1, // smoothing of arbor bounding box\n\n    // function that returns true if the system is stable to indicate\n    // that the layout can be stopped\n    stableEnergy: function( energy ){\n      var e = energy; \n      return (e.max <= 0.5) || (e.mean <= 0.3);\n    },\n\n    // infinite layout options\n    infinite: false // overrides all other options for a forces-all-the-time mode\n  };\n  \n  function ArborLayout(options){\n    this._private = {};\n\n    this._private.options = $$.util.extend({}, defaults, options);\n  }\n    \n  ArborLayout.prototype.run = function(){\n    var layout = this;\n    var options = this._private.options;\n\n    $$.util.require('arbor', function(arbor){\n\n      var cy = options.cy;\n      var eles = options.eles;\n      var nodes = eles.nodes().not(':parent');\n      var edges = eles.edges();\n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n      var simUpdatingPos = false;\n\n      layout.trigger({ type: 'layoutstart', layout: layout });\n\n      // backward compatibility for old animation option\n      if( options.liveUpdate !== undefined ){\n        options.animate = options.liveUpdate;\n      }\n\n      // arbor doesn't work with just 1 node \n      if( cy.nodes().size() <= 1 ){\n        if( options.fit ){\n          cy.reset();\n        }\n\n        cy.nodes().position({\n          x: Math.round( (bb.x1 + bb.x2)/2 ),\n          y: Math.round( (bb.y1 + bb.y2)/2 )\n        });\n\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n\n        return;\n      }\n\n      var sys = layout._private.system = arbor.ParticleSystem();\n\n      sys.parameters({\n        repulsion: options.repulsion,\n        stiffness: options.stiffness, \n        friction: options.friction, \n        gravity: options.gravity, \n        fps: options.fps, \n        dt: options.dt, \n        precision: options.precision\n      });\n\n      if( options.animate && options.fit ){\n        cy.fit( bb, options.padding );\n      }\n      \n      var doneTime = 250;\n      var doneTimeout;\n      \n      var ready = false;\n      \n      var lastDraw = +new Date();\n      var sysRenderer = {\n        init: function(system){\n        },\n        redraw: function(){\n          var energy = sys.energy();\n\n          // if we're stable (according to the client), we're done\n          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){\n            layout.stop();\n            return;\n          }\n\n          if( !options.infinite && doneTime != Infinity ){\n            clearTimeout(doneTimeout);\n            doneTimeout = setTimeout(doneHandler, doneTime);\n          }\n          \n          var movedNodes = cy.collection();\n          \n          sys.eachNode(function(n, point){ \n            var data = n.data;\n            var node = data.element;\n            \n            if( node == null ){\n              return;\n            }\n\n            if( !node.locked() && !node.grabbed() ){\n              node.silentPosition({\n                x: bb.x1 + point.x,\n                y: bb.y1 + point.y\n              });\n\n              movedNodes.merge( node );\n            }\n          });\n          \n\n          if( options.animate && movedNodes.length > 0 ){\n            simUpdatingPos = true;\n\n            movedNodes.rtrigger('position');\n\n            if( options.fit ){\n              cy.fit( options.padding );\n            }\n\n            lastDraw = +new Date();\n            simUpdatingPos = false;\n          }\n\n          \n          if( !ready ){\n            ready = true;\n            layout.one('layoutready', options.ready);\n            layout.trigger({ type: 'layoutready', layout: layout });\n          }\n        }\n        \n      };\n      sys.renderer = sysRenderer;\n      sys.screenSize( bb.w, bb.h );\n      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );\n      sys.screenStep( options.stepSize );\n\n      function calculateValueForElement(element, value){\n        if( value == null ){\n          return undefined;\n        } else if( typeof value == typeof function(){} ){\n          return value.apply(element, [element._private.data, {\n            nodes: nodes.length,\n            edges: edges.length,\n            element: element\n          }]); \n        } else {\n          return value;\n        }\n      }\n\n      var grabHandler;\n      nodes.on('grab free position', grabHandler = function(e){\n        if( simUpdatingPos ){ return; }\n\n        var pos = this.position();\n        var apos = sys.fromScreen( pos );\n        if( !apos ){ return; }\n\n        var p = arbor.Point(apos.x, apos.y);\n        var padding = options.padding;\n\n        if(\n          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&\n          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding\n        ){\n          this.scratch().arbor.p = p;\n        }\n        \n        switch( e.type ){\n        case 'grab':\n          this.scratch().arbor.fixed = true;\n          break;\n        case 'free':\n          this.scratch().arbor.fixed = false;\n          //this.scratch().arbor.tempMass = 1000;\n          break;\n        }\n      });\n\n      var lockHandler;\n      nodes.on('lock unlock', lockHandler = function(e){\n        node.scratch().arbor.fixed = node.locked();\n      });\n            \n      var removeHandler;\n      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added\n        // var ele = this;\n        // var arborEle = ele.scratch().arbor;\n\n        // if( !arborEle ){ return; }\n\n        // if( ele.isNode() ){\n        //   sys.pruneNode( arborEle );\n        // } else {\n        //   sys.pruneEdge( arborEle );\n        // }\n      });\n\n      var addHandler;\n      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added\n        // var ele = this;\n\n        // if( ele.isNode() ){\n        //   addNode( ele );\n        // } else {\n        //   addEdge( ele );\n        // }\n      });\n\n      var resizeHandler;\n      cy.on('resize', resizeHandler = function(){\n        if( options.boundingBox == null && layout._private.system != null ){\n          var w = cy.width();\n          var h = cy.height();\n\n          sys.screenSize( w, h );\n        }\n      });\n\n      function addNode( node ){\n        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim\n\n        var id = node._private.data.id;\n        var mass = calculateValueForElement(node, options.nodeMass);\n        var locked = node._private.locked;\n        var nPos = node.position();\n        \n        var pos = sys.fromScreen({\n          x: nPos.x,\n          y: nPos.y\n        });\n\n        node.scratch().arbor = sys.addNode(id, {\n          element: node,\n          mass: mass,\n          fixed: locked,\n          x: locked ? pos.x : undefined,\n          y: locked ? pos.y : undefined\n        });\n      }\n\n      function addEdge( edge ){\n        var src = edge.source().id();\n        var tgt = edge.target().id();\n        var length = calculateValueForElement(edge, options.edgeLength);\n        \n        edge.scratch().arbor = sys.addEdge(src, tgt, {\n          length: length\n        }); \n      }\n\n      nodes.each(function(i, node){\n        addNode( node );\n      });\n      \n      edges.each(function(i, edge){\n        addEdge( edge );\n      });\n      \n      var grabbableNodes = nodes.filter(\":grabbable\");\n      // disable grabbing if so set\n      if( options.ungrabifyWhileSimulating ){\n        grabbableNodes.ungrabify();\n      }\n      \n      var doneHandler = layout._private.doneHandler = function(){\n        layout._private.doneHandler = null;\n\n        if( !options.animate ){\n          if( options.fit ){\n            cy.reset();\n          }\n\n          nodes.rtrigger('position');\n        }\n\n        // unbind handlers\n        nodes.off('grab free position', grabHandler);\n        nodes.off('lock unlock', lockHandler);\n        eles.off('remove', removeHandler);\n        cy.off('add', '*', addHandler);\n        cy.off('resize', resizeHandler);\n        \n        // enable back grabbing if so set\n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.grabify();\n        }\n\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      };\n      \n      sys.start();\n      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){\n        setTimeout(function(){\n          layout.stop();\n        }, options.maxSimulationTime);\n      }\n    \n    }); // require\n\n    return this; // chaining\n  };\n\n\n  ArborLayout.prototype.stop = function(){\n    if( this._private.system != null ){\n      this._private.system.stop();\n    }\n\n    if( this._private.doneHandler ){\n      this._private.doneHandler();\n    }\n\n    return this; // chaining\n  };\n  \n  $$('layout', 'arbor', ArborLayout);\n  \n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)\n    padding: 30, // padding on fit\n    circle: false, // put depths in concentric circles if true, put depths top down if false\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n    roots: undefined, // the roots of the trees\n    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function BreadthFirstLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  BreadthFirstLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    var graph = eles;\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var roots;\n    if( $$.is.elementOrCollection(options.roots) ){\n      roots = options.roots;\n    } else if( $$.is.array(options.roots) ){\n      var rootsArray = [];\n\n      for( var i = 0; i < options.roots.length; i++ ){\n        var id = options.roots[i];\n        var ele = cy.getElementById( id );\n        rootsArray.push( ele );\n      }\n\n      roots = new $$.Collection( cy, rootsArray );\n    } else if( $$.is.string(options.roots) ){\n      roots = cy.$( options.roots );\n\n    } else {\n      if( options.directed ){\n        roots = nodes.roots();\n      } else {\n        var components = [];\n        var unhandledNodes = nodes;\n\n        while( unhandledNodes.length > 0 ){\n          var currComp = cy.collection();\n\n          eles.bfs({\n            roots: unhandledNodes[0],\n            visit: function(i, depth, node, edge, pNode){\n              currComp = currComp.add( node );\n            },\n            directed: false\n          });\n\n          unhandledNodes = unhandledNodes.not( currComp );\n          components.push( currComp );\n        }\n\n        roots = cy.collection();\n        for( var i = 0; i < components.length; i++ ){\n          var comp = components[i];\n          var maxDegree = comp.maxDegree( false );\n          var compRoots = comp.filter(function(){\n            return this.degree(false) === maxDegree;\n          });\n\n          roots = roots.add( compRoots );\n        }\n        \n      }\n    }\n\n\n    var depths = [];\n    var foundByBfs = {};\n    var id2depth = {};\n    var prevNode = {};\n    var prevEdge = {};\n    var successors = {};\n\n    // find the depths of the nodes\n    graph.bfs({\n      roots: roots,\n      directed: options.directed,\n      visit: function(i, depth, node, edge, pNode){\n        var ele = this[0];\n        var id = ele.id();\n\n        if( !depths[depth] ){\n          depths[depth] = [];\n        }\n\n        depths[depth].push( ele );\n        foundByBfs[ id ] = true;\n        id2depth[ id ] = depth;\n        prevNode[ id ] = pNode;\n        prevEdge[ id ] = edge;\n\n        if( pNode ){\n          var prevId = pNode.id();\n          var succ = successors[ prevId ] = successors[ prevId ] || [];\n          \n          succ.push( node );\n        }\n      }\n    });\n\n    // check for nodes not found by bfs\n    var orphanNodes = [];\n    for( var i = 0; i < nodes.length; i++ ){\n      var ele = nodes[i];\n\n      if( foundByBfs[ ele.id() ] ){\n        continue;\n      } else {\n        orphanNodes.push( ele );\n      }\n    }\n\n    // assign orphan nodes a depth from their neighborhood\n    var maxChecks = orphanNodes.length * 3;\n    var checks = 0;\n    while( orphanNodes.length !== 0 && checks < maxChecks ){\n      var node = orphanNodes.shift();\n      var neighbors = node.neighborhood().nodes();\n      var assignedDepth = false;\n\n      for( var i = 0; i < neighbors.length; i++ ){\n        var depth = id2depth[ neighbors[i].id() ];\n\n        if( depth !== undefined ){\n          depths[depth].push( node );\n          assignedDepth = true;\n          break;\n        }\n      }\n\n      if( !assignedDepth ){\n        orphanNodes.push( node );\n      }\n\n      checks++;\n    }\n\n    // assign orphan nodes that are still left to the depth of their subgraph\n    while( orphanNodes.length !== 0 ){\n      var node = orphanNodes.shift();\n      //var subgraph = graph.bfs( node ).path;\n      var assignedDepth = false;\n\n      // for( var i = 0; i < subgraph.length; i++ ){\n      //   var depth = id2depth[ subgraph[i].id() ];\n\n      //   if( depth !== undefined ){\n      //     depths[depth].push( node );\n      //     assignedDepth = true;\n      //     break;\n      //   }\n      // }\n\n      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0\n        if( depths.length === 0 ){\n          depths.push([]);\n        }\n        \n        depths[0].push( node );\n      }\n    }\n\n    // assign the nodes a depth and index\n    var assignDepthsToEles = function(){\n      for( var i = 0; i < depths.length; i++ ){\n        var eles = depths[i];\n\n        for( var j = 0; j < eles.length; j++ ){\n          var ele = eles[j];\n\n          ele._private.scratch.breadthfirst = {\n            depth: i,\n            index: j\n          };\n        }\n      }\n    };\n    assignDepthsToEles();\n\n\n    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth\n      var edges = node.connectedEdges(function(){\n        return this.data('target') === node.id();\n      });\n      var thisInfo = node._private.scratch.breadthfirst;\n      var highestDepthOfOther = 0;\n      var highestOther;\n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[i];\n        var otherNode = edge.source()[0];\n        var otherInfo = otherNode._private.scratch.breadthfirst;\n\n        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){\n          highestDepthOfOther = otherInfo.depth;\n          highestOther = otherNode;\n        }\n      }\n\n      return highestOther;\n    };\n\n     // make maximal if so set by adjusting depths\n    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){\n\n      var nDepths = depths.length;\n      var elesToMove = [];\n      for( var i = 0; i < nDepths; i++ ){\n        var depth = depths[i];\n\n        var nDepth = depth.length;\n        for( var j = 0; j < nDepth; j++ ){\n          var ele = depth[j];\n          var info = ele._private.scratch.breadthfirst;\n          var intEle = intersectsDepth(ele);\n\n          if( intEle ){\n            info.intEle = intEle;\n            elesToMove.push( ele );\n          }\n        }\n      }\n\n      for( var i = 0; i < elesToMove.length; i++ ){ \n        var ele = elesToMove[i];\n        var info = ele._private.scratch.breadthfirst;\n        var intEle = info.intEle;\n        var intInfo = intEle._private.scratch.breadthfirst;\n\n        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index\n\n        // add to end of new depth\n        var newDepth = intInfo.depth + 1;\n        while( newDepth > depths.length - 1 ){\n          depths.push([]);\n        }\n        depths[ newDepth ].push( ele );\n\n        info.depth = newDepth;\n        info.index = depths[newDepth].length - 1;\n      }\n\n      assignDepthsToEles();\n    }\n\n    // find min distance we need to leave between nodes\n    var minDistance = 0;\n    if( options.avoidOverlap ){\n      for( var i = 0; i < nodes.length; i++ ){\n        var w = nodes[i].outerWidth();\n        var h = nodes[i].outerHeight();\n        \n        minDistance = Math.max(minDistance, w, h);\n      }\n      minDistance *= 1.75; // just to have some nice spacing\n    }\n\n    // get the weighted percent for an element based on its connectivity to other levels\n    var cachedWeightedPercent = {};\n    var getWeightedPercent = function( ele ){\n      if( cachedWeightedPercent[ ele.id() ] ){\n        return cachedWeightedPercent[ ele.id() ];\n      }\n\n      var eleDepth = ele._private.scratch.breadthfirst.depth;\n      var neighbors = ele.neighborhood().nodes();\n      var percent = 0;\n      var samples = 0;\n\n      for( var i = 0; i < neighbors.length; i++ ){\n        var neighbor = neighbors[i];\n        var index = neighbor._private.scratch.breadthfirst.index;\n        var depth = neighbor._private.scratch.breadthfirst.depth;\n        var nDepth = depths[depth].length;\n\n        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above\n          percent += index / nDepth;\n          samples++;\n        }\n      }\n\n      samples = Math.max(1, samples);\n      percent = percent / samples;\n\n      if( samples === 0 ){ // so lone nodes have a \"don't care\" state in sorting\n        percent = undefined;\n      }\n\n      cachedWeightedPercent[ ele.id() ] = percent;\n      return percent;\n    };\n\n\n    // rearrange the indices in each depth level based on connectivity\n\n    var sortFn = function(a, b){\n      var apct = getWeightedPercent( a );\n      var bpct = getWeightedPercent( b );\n\n      return apct - bpct;\n    };\n\n    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result\n\n      for( var i = 0; i < depths.length; i++ ){\n        depths[i] = depths[i].sort( sortFn );\n      }\n      assignDepthsToEles(); // and update\n\n    }\n\n    var biggestDepthSize = 0;\n    for( var i = 0; i < depths.length; i++ ){\n      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );\n    }\n\n    var center = {\n      x: bb.x1 + bb.w/2,\n      y: bb.x1 + bb.h/2\n    };\n   \n    var getPosition = function( ele, isBottomDepth ){\n      var info = ele._private.scratch.breadthfirst;\n      var depth = info.depth;\n      var index = info.index;\n      var depthSize = depths[depth].length;\n\n      if( options.strictHierarchy ){\n        depthSize = biggestDepthSize;\n      }\n\n      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );\n      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );\n      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );\n      radiusStepSize = Math.max( radiusStepSize, minDistance );\n\n      if( options.strictHierarchy && !options.circle ){\n        \n        var epos = {\n          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,\n          y: (depth + 1) * distanceY\n        };\n\n        if( isBottomDepth ){\n          return epos;\n        }\n\n        var succs = successors[ ele.id() ];\n        if( succs ){\n          epos.x = 0;\n\n          for( var i = 0 ; i < succs.length; i++ ){\n            var spos = pos[ succs[i].id() ];\n            \n            epos.x += spos.x;\n          }\n\n          epos.x /= succs.length;\n        } else {\n          //debugger;\n        }\n\n        return epos;\n\n      } else {\n        if( options.circle ){\n          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);\n          var theta = 2 * Math.PI / depths[depth].length * index;\n\n          if( depth === 0 && depths[0].length === 1 ){\n            radius = 1;\n          }\n\n          return {\n            x: center.x + radius * Math.cos(theta),\n            y: center.y + radius * Math.sin(theta)\n          };\n\n        } else {\n          return {\n            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,\n            y: (depth + 1) * distanceY\n          };\n        }\n      }\n      \n    };\n\n    // get positions in reverse depth order\n    var pos = {};\n    for( var i = depths.length - 1; i >=0; i-- ){\n      var depth = depths[i];\n\n      for( var j = 0; j < depth.length; j++ ){\n        var node = depth[j];\n\n        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );\n      }\n    }\n\n    nodes.layoutPositions(this, options, function(){\n      return pos[ this.id() ];\n    });\n    \n    return this; // chaining\n  };\n  \n  $$('layout', 'breadthfirst', BreadthFirstLayout);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // the padding on fit\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space\n    radius: undefined, // the radius of the circle\n    startAngle: 3/2 * Math.PI, // the position of the first node\n    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function CircleLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  CircleLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    var eles = options.eles;\n      \n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var center = {\n      x: bb.x1 + bb.w/2,\n      y: bb.y1 + bb.h/2\n    };\n    \n    var theta = options.startAngle;\n    var dTheta = 2 * Math.PI / nodes.length;\n    var r;\n\n    var minDistance = 0;\n    for( var i = 0; i < nodes.length; i++ ){\n      var w = nodes[i].outerWidth();\n      var h = nodes[i].outerHeight();\n      \n      minDistance = Math.max(minDistance, w, h);\n    }\n\n    if( $$.is.number(options.radius) ){\n      r = options.radius;\n    } else if( nodes.length <= 1 ){\n      r = 0;\n    } else {\n      r = Math.min( bb.h, bb.w )/2 - minDistance;\n    }\n\n    // calculate the radius\n    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n      minDistance *= 1.75; // just to have some nice spacing\n\n      var dTheta = 2 * Math.PI / nodes.length;\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping\n      r = Math.max( rMin, r );\n    }\n\n    var getPos = function( i, ele ){\n      var rx = r * Math.cos( theta );\n      var ry = r * Math.sin( theta );\n      var pos = {\n        x: center.x + rx,\n        y: center.y + ry\n      };\n\n      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;\n      return pos;\n    };\n    \n    nodes.layoutPositions( this, options, getPos );\n\n    return this; // chaining\n  };\n  \n  $$('layout', 'circle', CircleLayout);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // default layout options\n  var defaults = {\n    animate: true, // whether to show the layout as it's running\n    refresh: 1, // number of ticks per frame; higher is faster but more jerky\n    maxSimulationTime: 4000, // max length in ms to run the layout\n    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n    fit: true, // on every layout reposition of nodes, fit the viewport\n    padding: 30, // padding around the simulation\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n\n    // layout event callbacks\n    ready: function(){}, // on layoutready\n    stop: function(){}, // on layoutstop\n\n    // positioning options\n    randomize: false, // use random node positions at beginning of layout\n    avoidOverlap: true, // if true, prevents overlap of node bounding boxes\n    handleDisconnected: true, // if true, avoids disconnected components from overlapping\n    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes\n    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }\n    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }\n\n    // different methods of specifying edge length\n    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`\n    edgeLength: undefined, // sets edge length directly in simulation\n    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation\n    edgeJaccardLength: undefined, // jaccard edge length in simulation\n\n    // iterations of cola algorithm; uses default values on undefined\n    unconstrIter: undefined, // unconstrained initial layout iterations\n    userConstIter: undefined, // initial layout iterations with user-specified constraints\n    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap\n\n    // infinite layout options\n    infinite: false // overrides all other options for a forces-all-the-time mode\n  };\n\n  // constructor\n  // options : object containing layout options\n  function ColaLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options); \n  }\n\n  // runs the layout\n  ColaLayout.prototype.run = function(){\n    var layout = this;\n    var options = this.options;\n\n    $$.util.require('cola', function(cola){\n\n      var cy = options.cy; // cy is automatically populated for us in the constructor\n      var eles = options.eles;\n      var nodes = eles.nodes();\n      var edges = eles.edges();\n      var ready = false;\n      \n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n\n      var getOptVal = function( val, ele ){\n        if( $$.is.fn(val) ){\n          var fn = val;\n          return fn.apply( ele, [ ele ] );\n        } else {\n          return val;\n        }\n      };\n\n      var updateNodePositions = function(){\n        var x = { min: Infinity, max: -Infinity };\n        var y = { min: Infinity, max: -Infinity };\n\n        for( var i = 0; i < nodes.length; i++ ){\n          var node = nodes[i];\n          var scratch = node._private.scratch.cola;\n\n          x.min = Math.min( x.min, scratch.x );\n          x.max = Math.max( x.max, scratch.x );\n\n          y.min = Math.min( y.min, scratch.y );\n          y.max = Math.max( y.max, scratch.y );\n        }\n\n        nodes.positions(function(i, node){\n          var pos = node._private.position;\n          var scratch = node._private.scratch.cola;\n\n          if( !node.grabbed() ){\n            pos.x = bb.x1 + scratch.x - x.min;\n            pos.y = bb.y1 + scratch.y - y.min;\n          }\n        });\n\n        if( !ready ){\n          onReady();\n          ready = true;\n        }\n\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n      };\n\n      var onDone = function(){\n        layout.manuallyStopped = false;\n\n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.grabify();\n        }\n\n        nodes.off('grab free position', grabHandler);\n        nodes.off('lock unlock', lockHandler);\n\n        // trigger layoutstop when the layout stops (e.g. finishes)\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n      };\n\n      var onReady = function(){\n        // trigger layoutready when each node has had its position set at least once\n        layout.one('layoutready', options.ready);\n        layout.trigger({ type: 'layoutready', layout: layout });\n      };\n\n      var ticksPerFrame = options.refresh;\n      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging\n\n      if( options.refresh < 0 ){\n        tickSkip = Math.abs( options.refresh );\n        ticksPerFrame = 1;\n      } else {\n        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1\n      }\n\n      var adaptor = cola.adaptor({\n        trigger: function( e ){ // on sim event\n          switch( e.type ){\n            case 'tick':\n              if( options.animate ){\n                updateNodePositions();\n              }\n              break;\n\n            case 'end': \n              updateNodePositions();\n              if( !options.infinite || layout.manuallyStopped ){ onDone(); }           \n              break;\n          }\n        },\n\n        kick: function( tick ){ // kick off the simulation\n          var skip = 0;\n\n          var inftick = function(){\n            var ret = tick();\n\n            if( ret && options.infinite ){ // resume layout if done\n              adaptor.resume(); // resume => new kick\n            }\n            \n            return ret; // allow regular finish b/c of new kick\n          };\n\n          var multitick = function(){ // multiple ticks in a row\n            var ret;\n\n            // skip ticks to slow down layout for debugging\n            var thisSkip = skip;\n            skip = (skip + 1) % tickSkip;\n            if( thisSkip !== 0 ){\n              return false;\n            }\n\n            for( var i = 0; i < ticksPerFrame && !ret; i++ ){\n              ret = ret || inftick(); // pick up true ret vals => sim done\n            }\n\n            return ret;\n          };\n\n          if( options.animate ){\n            var frame = function(){\n              if( multitick() ){ return; }\n\n              $$.util.requestAnimationFrame( frame );\n            };\n\n            $$.util.requestAnimationFrame( frame );\n          } else {\n            while( !inftick() ){}\n          }\n        },\n\n        on: function( type, listener ){}, // dummy; not needed\n\n        drag: function(){} // TODO\n      });\n      layout.adaptor = adaptor;\n\n      // if set no grabbing during layout\n      var grabbableNodes = nodes.filter(':grabbable');\n      if( options.ungrabifyWhileSimulating ){\n        grabbableNodes.ungrabify();\n      }\n\n      // handle node dragging\n      var grabHandler;\n      nodes.on('grab free position', grabHandler = function(e){\n        var node = this;\n        var scrCola = node._private.scratch.cola;\n        var pos = node._private.position;\n\n        if( node.grabbed() ){\n          scrCola.x = pos.x - bb.x1;\n          scrCola.y = pos.y - bb.y1;\n\n          adaptor.dragstart( scrCola );\n        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){\n          pos.x = scrCola.x + bb.x1;\n          pos.y = scrCola.y + bb.y1;\n        }\n\n        switch( e.type ){\n          case 'grab':\n            adaptor.dragstart( scrCola );\n            adaptor.resume();\n            break;\n          case 'free':\n            adaptor.dragend( scrCola );\n            break;\n        }\n        \n      });\n\n      var lockHandler;\n      nodes.on('lock unlock', lockHandler = function(e){\n        var node = this;\n        var scrCola = node._private.scratch.cola;\n      \n        if( node.locked() ){\n          adaptor.dragstart( scrCola );\n        } else {\n          adaptor.dragend( scrCola );\n        }\n      });\n\n      var nonparentNodes = nodes.stdFilter(function( node ){\n        return !node.isParent();\n      });\n\n      // add nodes to cola\n      adaptor.nodes( nonparentNodes.map(function( node, i ){\n        var padding = getOptVal( options.nodeSpacing, node );\n        var pos = node.position();\n\n        var struct = node._private.scratch.cola = {\n          x: options.randomize ? Math.round( Math.random() * bb.w ) : pos.x,\n          y: options.randomize ? Math.round( Math.random() * bb.h ) : pos.y,\n          width: node.outerWidth() + 2*padding,\n          height: node.outerHeight() + 2*padding,\n          index: i\n        };\n\n        return struct;\n      }) );\n\n      if( options.alignment ){ // then set alignment constraints\n\n        var offsetsX = [];\n        var offsetsY = [];\n\n        nonparentNodes.forEach(function( node ){\n          var align = getOptVal( options.alignment, node );\n          var scrCola = node._private.scratch.cola;\n          var index = scrCola.index;\n\n          if( !align ){ return; }\n\n          if( align.x != null ){\n            offsetsX.push({\n              node: index,\n              offset: align.x\n            });\n          }\n\n          if( align.y != null ){\n            offsetsY.push({\n              node: index,\n              offset: align.y\n            });\n          }\n        });\n\n        // add alignment constraints on nodes\n        var constraints = [];\n\n        if( offsetsX.length > 0 ){\n          constraints.push({\n            type: 'alignment',\n            axis: 'x',\n            offsets: offsetsX\n          });\n        }\n\n        if( offsetsY.length > 0 ){\n          constraints.push({\n            type: 'alignment',\n            axis: 'y',\n            offsets: offsetsY\n          });\n        }\n        \n        adaptor.constraints( constraints );\n\n      }\n\n      // add compound nodes to cola\n      adaptor.groups( nodes.stdFilter(function( node ){\n        return node.isParent();\n      }).map(function( node, i ){ // add basic group incl leaf nodes\n        node._private.scratch.cola = {\n          index: i,\n\n          leaves: node.children().stdFilter(function( child ){\n            return !child.isParent();\n          }).map(function( child ){\n            return child[0]._private.scratch.cola.index;\n          })\n        };\n\n        return node;\n      }).map(function( node ){ // add subgroups\n        node._private.scratch.cola.groups = node.children().stdFilter(function( child ){\n          return child.isParent();\n        }).map(function( child ){\n          return child._private.scratch.cola.index;\n        });\n\n        return node._private.scratch.cola;\n      }) );\n\n      // get the edge length setting mechanism\n      var length;\n      var lengthFnName;\n      if( options.edgeLength != null ){\n        length = options.edgeLength;\n        lengthFnName = 'linkDistance';\n      } else if( options.edgeSymDiffLength != null ){\n        length = options.edgeSymDiffLength;\n        lengthFnName = 'symmetricDiffLinkLengths';\n      } else if( options.edgeJaccardLength != null ){\n        length = options.edgeJaccardLength;\n        lengthFnName = 'jaccardLinkLengths';\n      } else {\n        length = 100;\n        lengthFnName = 'linkDistance';\n      }\n\n      var lengthGetter = function( link ){\n        return link.calcLength;\n      };\n\n      // add the edges to cola\n      adaptor.links( edges.stdFilter(function( edge ){\n        return !edge.source().isParent() && !edge.target().isParent();\n      }).map(function( edge, i ){\n        var c = edge._private.scratch.cola = {\n          source: edge.source()[0]._private.scratch.cola.index,\n          target: edge.target()[0]._private.scratch.cola.index\n        };\n\n        if( length != null ){\n          c.calcLength = getOptVal( length, edge );\n        }\n\n        return c;\n      }) );\n\n      adaptor.size([ bb.w, bb.h ]);\n\n      if( length != null ){\n        adaptor[ lengthFnName ]( lengthGetter );\n      }\n\n      // set the flow of cola\n      if( options.flow ){\n        var flow;\n        var defAxis = 'y';\n        var defMinSep = 50;\n\n        if( $$.is.string(options.flow) ){\n          flow = {\n            axis: options.flow,\n            minSeparation: defMinSep\n          };\n        } else if( $$.is.number(options.flow) ){\n          flow = {\n            axis: defAxis,\n            minSeparation: options.flow\n          };\n        } else if( $$.is.plainObject(options.flow) ){\n          flow = options.flow;\n\n          flow.axis = flow.axis || defAxis;\n          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;\n        } else { // e.g. options.flow: true\n          flow = {\n            axis: defAxis,\n            minSeparation: defMinSep\n          };\n        }\n\n        adaptor.flowLayout( flow.axis , flow.minSeparation );\n      }\n\n      adaptor\n        .avoidOverlaps( options.avoidOverlap )\n        .handleDisconnected( options.handleDisconnected )\n        .start( options.unconstrIter, options.userConstIter, options.allConstIter)\n      ;\n\n      layout.trigger({ type: 'layoutstart', layout: layout });\n\n      if( !options.infinite ){\n        setTimeout(function(){\n          adaptor.stop();\n        }, options.maxSimulationTime);\n      }\n\n    }); // require\n\n    return this; // chaining\n  };\n\n  // called on continuous layouts to stop them before they finish\n  ColaLayout.prototype.stop = function(){\n    if( this.adaptor ){\n      this.manuallyStopped = true;\n      this.adaptor.stop();\n    }\n\n    return this; // chaining\n  };\n\n  // register the layout\n  $$('layout', 'cola', ColaLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // the padding on fit\n    startAngle: 3/2 * Math.PI, // the position of the first node\n    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)\n    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n    height: undefined, // height of layout area (overrides container height)\n    width: undefined, // width of layout area (overrides container width)\n    concentric: function(){ // returns numeric value for each node, placing higher nodes in levels towards the centre\n      return this.degree();\n    },\n    levelWidth: function(nodes){ // the variation of concentric values in each level\n      return nodes.maxDegree() / 4;\n    },\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function ConcentricLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  ConcentricLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    \n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var center = {\n      x: bb.x1 + bb.w/2,\n      y: bb.y1 + bb.h/2\n    };\n    \n    var nodeValues = []; // { node, value }\n    var theta = options.startAngle;\n    var maxNodeSize = 0;\n\n    for( var i = 0; i < nodes.length; i++ ){\n      var node = nodes[i];\n      var value;\n      \n      // calculate the node value\n      value = options.concentric.call(node);\n      nodeValues.push({\n        value: value,\n        node: node\n      });\n\n      // for style mapping\n      node._private.layoutData.concentric = value;\n    }\n\n    // in case we used the `concentric` in style\n    nodes.updateStyle();\n\n    // calculate max size now based on potentially updated mappers\n    for( var i = 0; i < nodes.length; i++ ){\n      var node = nodes[i];\n\n      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );\n    }\n\n    // sort node values in descreasing order\n    nodeValues.sort(function(a, b){\n      return b.value - a.value;\n    });\n\n    var levelWidth = options.levelWidth( nodes );\n\n    // put the values into levels\n    var levels = [ [] ];\n    var currentLevel = levels[0];\n    for( var i = 0; i < nodeValues.length; i++ ){\n      var val = nodeValues[i];\n\n      if( currentLevel.length > 0 ){\n        var diff = Math.abs( currentLevel[0].value - val.value );\n\n        if( diff >= levelWidth ){\n          currentLevel = [];\n          levels.push( currentLevel );\n        }\n      }\n\n      currentLevel.push( val );\n    }\n\n    // create positions from levels\n\n    var pos = {}; // id => position\n    var r = 0;\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n    if( !options.avoidOverlap ){ // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );\n      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );\n\n      minDist = Math.min( minDist, rStep );\n    }\n\n    for( var i = 0; i < levels.length; i++ ){\n      var level = levels[i];\n      var dTheta = 2 * Math.PI / level.length;\n\n      // calculate the radius\n      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping\n        r = Math.max( rMin, r );\n      }\n\n      for( var j = 0; j < level.length; j++ ){\n        var val = level[j];\n        var theta = options.startAngle + (options.counterclockwise ? 1 : -1) * dTheta * j;\n\n        var p = {\n          x: center.x + r * Math.cos(theta),\n          y: center.y + r * Math.sin(theta)\n        };\n\n        pos[ val.node.id() ] = p;\n      }\n\n      r += minDist;\n      \n    } \n\n    // position the nodes\n    nodes.layoutPositions(this, options, function(){\n      var id = this.id();\n\n      return pos[id];\n    });\n  \n    return this; // chaining\n  };\n  \n  $$('layout', 'concentric', ConcentricLayout);\n  \n})( cytoscape );\n\n/*\n  The CoSE layout was written by Gerardo Huck.\n\n  Modifications tracked on Github.\n*/\n\n;(function($$) { 'use strict';\n\n  var DEBUG;\n\n  /**\n   * @brief :  default layout options\n   */\n  var defaults = {\n    // Called on `layoutready`\n    ready               : function() {},\n\n    // Called on `layoutstop`\n    stop                : function() {},\n\n    // Whether to animate while running the layout\n    animate             : true,\n\n    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)\n    refresh             : 4,\n    \n    // Whether to fit the network view after when done\n    fit                 : true, \n\n    // Padding on fit\n    padding             : 30, \n\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox         : undefined,\n\n    // Whether to randomize node positions on the beginning\n    randomize           : true,\n    \n    // Whether to use the JS console to print debug messages\n    debug               : false,\n\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion       : 400000,\n    \n    // Node repulsion (overlapping) multiplier\n    nodeOverlap         : 10,\n    \n    // Ideal edge (non nested) length\n    idealEdgeLength     : 10,\n    \n    // Divisor to compute edge forces\n    edgeElasticity      : 100,\n    \n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor       : 5, \n    \n    // Gravity force (constant)\n    gravity             : 250, \n    \n    // Maximum number of iterations to perform\n    numIter             : 100,\n    \n    // Initial temperature (maximum node displacement)\n    initialTemp         : 200,\n    \n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor       : 0.95, \n    \n    // Lower temperature threshold (below this point the layout will end)\n    minTemp             : 1.0\n  };\n\n\n  /**\n   * @brief       : constructor\n   * @arg options : object containing layout options\n   */\n  function CoseLayout(options) {\n    this.options = $$.util.extend({}, defaults, options); \n  }\n\n\n  /**\n   * @brief : runs the layout\n   */\n  CoseLayout.prototype.run = function() {\n    var options = this.options;\n    var cy      = options.cy;\n    var layout  = this;\n\n    layout.stopped = false;\n\n    layout.trigger({ type: 'layoutstart', layout: layout });\n\n    // Set DEBUG - Global variable\n    if (true === options.debug) {\n      DEBUG = true;\n    } else {\n      DEBUG = false;\n    }\n\n    // Get start time\n    var startTime = new Date();\n\n    // Initialize layout info\n    var layoutInfo = createLayoutInfo(cy, layout, options);\n    \n    // Show LayoutInfo contents if debugging\n    if (DEBUG) {\n      printLayoutInfo(layoutInfo);\n    }\n\n    // If required, randomize node positions\n    if (true === options.randomize) {\n      randomizePositions(layoutInfo, cy);\n    }\n\n    updatePositions(layoutInfo, cy, options);\n\n    var mainLoop = function(i){\n      if( layout.stopped ){\n        logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n        return false;\n      }\n\n      // Do one step in the phisical simulation\n      step(layoutInfo, cy, options, i);\n      \n      // Update temperature\n      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n      logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n      if (layoutInfo.temperature < options.minTemp) {\n        logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n        return false;\n      }\n\n      return true;\n    };\n\n    var done = function(){\n      refreshPositions(layoutInfo, cy, options);\n\n      // Fit the graph if necessary\n      if (true === options.fit) {\n        cy.fit( options.padding );\n      }\n      \n      // Get end time\n      var endTime = new Date();\n\n      console.info('Layout took ' + (endTime - startTime) + ' ms');\n\n      // Layout has finished\n      layout.one('layoutstop', options.stop);\n      layout.trigger({ type: 'layoutstop', layout: layout });\n    };\n\n    if( options.animate ){\n      var i = 0;\n      var frame = function(){\n\n        var f = 0;\n        var loopRet;\n        while( f < options.refresh && i < options.numIter ){\n          var loopRet = mainLoop(i);\n          if( loopRet === false ){ break; }\n\n          f++;\n          i++;\n        }\n\n        refreshPositions(layoutInfo, cy, options);\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n\n        if ( loopRet !== false && i + 1 < options.numIter ) {\n          $$.util.requestAnimationFrame( frame );\n        } else {\n          done();\n        }\n      };\n\n      $$.util.requestAnimationFrame( frame );\n    } else {\n      for (var i = 0; i < options.numIter; i++) {\n        if( mainLoop(i) === false ){ break; }\n      }\n\n      done();\n    }\n   \n    return this; // chaining\n  };\n\n\n  /**\n   * @brief : called on continuous layouts to stop them before they finish\n   */\n  CoseLayout.prototype.stop = function(){\n    this.stopped = true;\n\n    return this; // chaining\n  };\n\n\n  /**\n   * @brief     : Creates an object which is contains all the data\n   *              used in the layout process\n   * @arg cy    : cytoscape.js object\n   * @return    : layoutInfo object initialized\n   */\n  var createLayoutInfo = function(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n\n    var layoutInfo   = {\n      layout       : layout,\n      layoutNodes  : [], \n      idToIndex    : {},\n      nodeSize     : nodes.size(),\n      graphSet     : [],\n      indexToGraph : [], \n      layoutEdges  : [],\n      edgeSize     : edges.size(),\n      temperature  : options.initialTemp,\n      clientWidth  : cy.width(),\n      clientHeight : cy.width(),\n      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n                       x1: 0, y1: 0, w: cy.width(), h: cy.height()\n                     } )\n    }; \n    \n    // Iterate over all nodes, creating layout nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var tempNode        = {};\n      tempNode.id         = nodes[i].data('id');\n      tempNode.parentId   = nodes[i].data('parent');      \n      tempNode.children   = [];\n      tempNode.positionX  = nodes[i].position('x');\n      tempNode.positionY  = nodes[i].position('y');\n      tempNode.offsetX    = 0;      \n      tempNode.offsetY    = 0;\n      tempNode.height     = nodes[i].height();\n      tempNode.width      = nodes[i].width();\n      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;\n      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;\n      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;\n      tempNode.minY       = tempNode.positionY - tempNode.height / 2;\n      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;\n      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;\n      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;\n      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;\n      \n      // Add new node\n      layoutInfo.layoutNodes.push(tempNode);\n      // Add entry to id-index map\n      layoutInfo.idToIndex[tempNode.id] = i;\n    }\n\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0;   // Points to the start the queue\n    var end   = -1;  // Points to the end of the queue\n\n    var tempGraph = [];\n\n    // Second pass to add child information and \n    // initialize queue for hierarchical traversal\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      var p_id = n.parentId;\n      // Check if node n has a parent node\n      if (null != p_id) {\n      // Add node Id to parent's list of children\n      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n      } else {\n      // If a node doesn't have a parent, then it's in the root graph\n      queue[++end] = n.id;\n      tempGraph.push(n.id);    \n      }\n    }\n    \n    // Add root graph to graphSet\n    layoutInfo.graphSet.push(tempGraph);\n\n    // Traverse the graph, level by level, \n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var node_id  = queue[start++];\n      var node_ix  = layoutInfo.idToIndex[node_id];\n      var node     = layoutInfo.layoutNodes[node_ix];\n      var children = node.children;\n      if (children.length > 0) {\n      // Add children nodes as a new graph to graph set\n      layoutInfo.graphSet.push(children);\n      // Add children to que queue to be visited\n      for (var i = 0; i < children.length; i++) {\n        queue[++end] = children[i];\n      }\n      }\n    }\n\n    // Create indexToGraph map\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      \n      var graph = layoutInfo.graphSet[i];\n      for (var j = 0; j < graph.length; j++) {\n      var index = layoutInfo.idToIndex[graph[j]];\n      layoutInfo.indexToGraph[index] = i;\n      }\n    }\n    \n    // Iterate over all edges, creating Layout Edges\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      var e = edges[i];\n      var tempEdge = {};      \n      tempEdge.id       = e.data('id');\n      tempEdge.sourceId = e.data('source');\n      tempEdge.targetId = e.data('target');\n\n      // Compute ideal length\n      var idealLength = options.idealEdgeLength;\n\n      // Check if it's an inter graph edge\n      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];\n      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];\n      var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n      var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n      if (sourceGraph != targetGraph) {\n      // Find lowest common graph ancestor\n      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n\n      // Compute sum of node depths, relative to lca graph\n      var lcaGraph = layoutInfo.graphSet[lca];\n      var depth    = 0;\n\n      // Source depth\n      var tempNode = layoutInfo.layoutNodes[sourceIx];\n      while (-1 === $.inArray(tempNode.id, lcaGraph)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      // Target depth\n      tempNode = layoutInfo.layoutNodes[targetIx];\n      while (-1 === $.inArray(tempNode.id, lcaGraph)) {\n        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n        depth++;\n      }\n\n      logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  \n         \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() + \n         \". Depth: \" + depth);\n\n      // Update idealLength\n      idealLength *= depth * options.nestingFactor;\n      }\n\n      tempEdge.idealLength = idealLength;\n\n      layoutInfo.layoutEdges.push(tempEdge);\n    }\n\n    // Finally, return layoutInfo object\n    return layoutInfo;\n  };\n\n  \n  /**\n   * @brief : This function finds the index of the lowest common \n   *          graph ancestor between 2 nodes in the subtree \n   *          (from the graph hierarchy induced tree) whose\n   *          root is graphIx\n   *\n   * @arg node1: node1's ID\n   * @arg node2: node2's ID\n   * @arg layoutInfo: layoutInfo object\n   *\n   */\n  var findLCA = function(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = findLCA_aux(node1, node2, 0, layoutInfo);\n    if (2 > res.count) {\n      // If aux function couldn't find the common ancester, \n      // then it is the root graph\n      return 0;\n    } else {\n      return res.graph;\n    }\n  };\n\n\n  /**\n   * @brief          : Auxiliary function used for LCA computation\n   * \n   * @arg node1      : node1's ID\n   * @arg node2      : node2's ID\n   * @arg graphIx    : subgraph index\n   * @arg layoutInfo : layoutInfo object\n   *\n   * @return         : object of the form {count: X, graph: Y}, where:\n   *                   X is the number of ancesters (max: 2) found in \n   *                   graphIx (and it's subgraphs),\n   *                   Y is the graph index of the lowest graph containing \n   *                   all X nodes\n   */\n  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx];\n    // If both nodes belongs to graphIx\n    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {\n      return {count:2, graph:graphIx};\n    }\n\n    // Make recursive calls for all subgraphs\n    var c = 0;\n    for (var i = 0; i < graph.length; i++) {\n      var nodeId   = graph[i];\n      var nodeIx   = layoutInfo.idToIndex[nodeId];\n      var children = layoutInfo.layoutNodes[nodeIx].children;\n\n      // If the node has no child, skip it\n      if (0 === children.length) {\n      continue;\n      }\n\n      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n      if (0 === result.count) {\n      // Neither node1 nor node2 are present in this subgraph\n      continue;\n      } else if (1 === result.count) {\n      // One of (node1, node2) is present in this subgraph\n      c++;\n      if (2 === c) {\n        // We've already found both nodes, no need to keep searching\n        break;\n      }\n      } else {\n      // Both nodes are present in this subgraph\n      return result;\n      }      \n    }\n    \n    return {count:c, graph:graphIx};\n  };\n\n\n  /**\n   * @brief: printsLayoutInfo into js console\n   *         Only used for debbuging \n   */\n  var printLayoutInfo = function(layoutInfo) {\n    if (!DEBUG) {\n      return;\n    }\n    console.debug(\"layoutNodes:\");\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      var s = \n      \"\\nindex: \"     + i + \n      \"\\nId: \"        + n.id + \n      \"\\nChildren: \"  + n.children.toString() +  \n      \"\\nparentId: \"  + n.parentId  + \n      \"\\npositionX: \" + n.positionX + \n      \"\\npositionY: \" + n.positionY +\n      \"\\nOffsetX: \" + n.offsetX + \n      \"\\nOffsetY: \" + n.offsetY + \n      \"\\npadLeft: \" + n.padLeft + \n      \"\\npadRight: \" + n.padRight + \n      \"\\npadTop: \" + n.padTop + \n      \"\\npadBottom: \" + n.padBottom;\n\n      console.debug(s);    \n    }  \n    \n    console.debug('idToIndex');\n    for (var i in layoutInfo.idToIndex) {\n      console.debug(\"Id: \" + i + \"\\nIndex: \" + layoutInfo.idToIndex[i]);\n    }\n\n    console.debug('Graph Set');\n    var set = layoutInfo.graphSet;\n    for (var i = 0; i < set.length; i ++) {\n      console.debug(\"Set : \" + i + \": \" + set[i].toString());\n    } \n\n    var s = 'IndexToGraph';\n    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {\n      s += \"\\nIndex : \" + i + \" Graph: \"+ layoutInfo.indexToGraph[i];\n    }\n    console.debug(s);\n\n    s = 'Layout Edges';\n    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {\n      var e = layoutInfo.layoutEdges[i];\n      s += \"\\nEdge Index: \" + i + \" ID: \" + e.id + \n      \" SouceID: \" + e.sourceId + \" TargetId: \" + e.targetId + \n      \" Ideal Length: \" + e.idealLength;\n    }\n    console.debug(s);\n\n    s =  \"nodeSize: \" + layoutInfo.nodeSize;\n    s += \"\\nedgeSize: \" + layoutInfo.edgeSize;\n    s += \"\\ntemperature: \" + layoutInfo.temperature;\n    console.debug(s);\n\n    return;\n  };\n\n\n  /**\n   * @brief : Randomizes the position of all nodes\n   */\n  var randomizePositions = function(layoutInfo, cy) {\n    var width     = layoutInfo.clientWidth;\n    var height    = layoutInfo.clientHeight;\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      // No need to randomize compound nodes\n      if (true) {\n        n.positionX = Math.random() * width;\n        n.positionY = Math.random() * height;\n      }\n    }\n  };\n\n  \n  /**\n   * @brief          : Updates the positions of nodes in the network\n   * @arg layoutInfo : LayoutInfo object\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n  var refreshPositions = function(layoutInfo, cy, options) {  \n    var s = 'Refreshing positions';\n    logDebug(s);\n\n    var layout = layoutInfo.layout;\n    var nodes = options.eles.nodes();\n    var bb = layoutInfo.boundingBox;\n    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n    \n    if( options.boundingBox ){\n      nodes.forEach(function( node ){\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n\n        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );\n        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );\n\n        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );\n        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );\n      });\n\n      coseBB.w = coseBB.x2 - coseBB.x1;\n      coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n\n    nodes.positions(function(i, ele) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n      s = \"Node: \" + lnode.id + \". Refreshed position: (\" + \n      lnode.positionX + \", \" + lnode.positionY + \").\";\n      logDebug(s);\n\n      if( options.boundingBox ){ // then add extra bounding box constraint\n        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n\n        return {\n          x: bb.x1 + pctX * bb.w,\n          y: bb.y1 + pctY * bb.h\n        };\n      } else {\n        return {\n          x: lnode.positionX,\n          y: lnode.positionY\n        };\n      }\n    });\n\n    // Trigger layoutReady only on first call\n    if (true !== layoutInfo.ready) {\n      s = 'Triggering layoutready';\n      logDebug(s);\n      layoutInfo.ready = true;\n      layout.one('layoutready', options.ready);\n      layout.trigger({ type: 'layoutready', layout: this });\n    }\n  };\n\n\n  /**\n   * @brief          : Performs one iteration of the physical simulation\n   * @arg layoutInfo : LayoutInfo object already initialized\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n  var step = function(layoutInfo, cy, options, step) {  \n    var s = \"\\n\\n###############################\";\n    s += \"\\nSTEP: \" + step;\n    s += \"\\n###############################\\n\";\n    logDebug(s);\n\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, cy, options);\n    // Calculate edge forces\n    calculateEdgeForces(layoutInfo, cy, options);\n    // Calculate gravity forces\n    calculateGravityForces(layoutInfo, cy, options);\n    // Propagate forces from parent to child\n    propagateForces(layoutInfo, cy, options);\n    // Update positions based on calculated forces\n    updatePositions(layoutInfo, cy, options);\n  };\n\n  \n  /**\n   * @brief : Computes the node repulsion forces\n   */\n  var calculateNodeForces = function(layoutInfo, cy, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    var s = 'calculateNodeForces';\n    logDebug(s);\n    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {\n      var graph    = layoutInfo.graphSet[i];\n      var numNodes = graph.length;\n\n      s = \"Set: \" + graph.toString();\n      logDebug(s);\n\n      // Now get all the pairs of nodes \n      // Only get each pair once, (A, B) = (B, A)\n      for (var j = 0; j < numNodes; j++) {\n      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n      for (var k = j + 1; k < numNodes; k++) {\n        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n        nodeRepulsion(node1, node2, layoutInfo, cy, options);\n      } \n      }\n    } \n  };\n\n\n  /**\n   * @brief : Compute the node repulsion forces between a pair of nodes\n   */\n  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {\n    var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n\n    // Get direction of line connecting both node centers\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n\n    // If both centers are the same, apply a random force\n    if (0 === directionX && 0 === directionY) {\n      s += \"\\nNodes have the same position.\";\n      return; // TODO\n    }\n\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n    \n    if (overlap > 0) {\n      s += \"\\nNodes DO overlap.\";\n      s += \"\\nOverlap: \" + overlap;\n      // If nodes overlap, repulsion force is proportional \n      // to the overlap\n      var force    = options.nodeOverlap * overlap;\n\n      // Compute the module and components of the force vector\n      var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n      s += \"\\nDistance: \" + distance;\n      var forceX   = force * directionX / distance;\n      var forceY   = force * directionY / distance;\n\n    } else {\n      s += \"\\nNodes do NOT overlap.\";\n      // If there's no overlap, force is inversely proportional \n      // to squared distance\n\n      // Get clipping points for both nodes\n      var point1 = findClippingPoint(node1, directionX, directionY);\n      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n\n      // Use clipping points to compute distance\n      var distanceX   = point2.x - point1.x;\n      var distanceY   = point2.y - point1.y;\n      var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n      var distance    = Math.sqrt(distanceSqr);\n      s += \"\\nDistance: \" + distance;\n\n      // Compute the module and components of the force vector\n      var force  = options.nodeRepulsion / distanceSqr;\n      var forceX = force * distanceX / distance;\n      var forceY = force * distanceY / distance;\n    }\n\n    // Apply force\n    node1.offsetX -= forceX;\n    node1.offsetY -= forceY;\n    node2.offsetX += forceX;\n    node2.offsetY += forceY;\n\n    s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    logDebug(s);\n\n    return;\n  };\n\n\n  /**\n   * @brief : Finds the point in which an edge (direction dX, dY) intersects \n   *          the rectangular bounding box of it's source/target node \n   */\n  var findClippingPoint = function(node, dX, dY) {\n\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height;\n    var W = node.width;\n    var dirSlope     = dY / dX;\n    var nodeSlope    = H / W;\n\n    var s = 'Computing clipping point of node ' + node.id + \n      \" . Height:  \" + H + \", Width: \" + W + \n      \"\\nDirection \" + dX + \", \" + dY; \n    \n    // Compute intersection\n    var res = {};\n    do {\n      // Case: Vertical direction (up)\n      if (0 === dX && 0 < dY) {\n        res.x = X;\n        s += \"\\nUp direction\";\n        res.y = Y + H / 2;\n        break;\n      }\n\n      // Case: Vertical direction (down)\n      if (0 === dX && 0 > dY) {\n        res.x = X;\n        res.y = Y + H / 2;\n        s += \"\\nDown direction\";\n        break;\n      }      \n\n      // Case: Intersects the right border\n      if (0 < dX && \n      -1 * nodeSlope <= dirSlope && \n      dirSlope <= nodeSlope) {\n        res.x = X + W / 2;\n        res.y = Y + (W * dY / 2 / dX);\n        s += \"\\nRightborder\";\n        break;\n      }\n\n      // Case: Intersects the left border\n      if (0 > dX && \n      -1 * nodeSlope <= dirSlope && \n      dirSlope <= nodeSlope) {\n        res.x = X - W / 2;\n        res.y = Y - (W * dY / 2 / dX);\n        s += \"\\nLeftborder\";\n        break;\n      }\n\n      // Case: Intersects the top border\n      if (0 < dY && \n      ( dirSlope <= -1 * nodeSlope ||\n        dirSlope >= nodeSlope )) {\n        res.x = X + (H * dX / 2 / dY);\n        res.y = Y + H / 2;\n        s += \"\\nTop border\";\n        break;\n      }\n\n      // Case: Intersects the bottom border\n      if (0 > dY && \n      ( dirSlope <= -1 * nodeSlope ||\n        dirSlope >= nodeSlope )) {\n        res.x = X - (H * dX / 2 / dY);\n        res.y = Y - H / 2;\n        s += \"\\nBottom border\";\n        break;\n      }\n\n    } while (false);\n\n    s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    logDebug(s);\n    return res;\n  };\n\n\n  /**\n   * @brief  : Determines whether two nodes overlap or not\n   * @return : Amount of overlapping (0 => no overlap)\n   */\n  var nodesOverlap = function(node1, node2, dX, dY) {\n\n    if (dX > 0) {\n      var overlapX = node1.maxX - node2.minX;\n    } else {\n      var overlapX = node2.maxX - node1.minX;\n    }\n\n    if (dY > 0) {\n      var overlapY = node1.maxY - node2.minY;\n    } else {\n      var overlapY = node2.maxY - node1.minY;\n    }\n\n    if (overlapX >= 0 && overlapY >= 0) {\n      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n      return 0;\n    }\n  };\n    \n  \n  /**\n   * @brief : Calculates all edge forces\n   */\n  var calculateEdgeForces = function(layoutInfo, cy, options) {\n    // Iterate over all edges\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      // Get edge, source & target nodes\n      var edge     = layoutInfo.layoutEdges[i];\n      var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n      var source   = layoutInfo.layoutNodes[sourceIx];\n      var targetIx = layoutInfo.idToIndex[edge.targetId];\n      var target   = layoutInfo.layoutNodes[targetIx];\n\n      // Get direction of line connecting both node centers\n      var directionX = target.positionX - source.positionX;\n      var directionY = target.positionY - source.positionY;\n      \n      // If both centers are the same, do nothing.\n      // A random force has already been applied as node repulsion\n      if (0 === directionX && 0 === directionY) {\n      return;\n      }\n\n      // Get clipping points for both nodes\n      var point1 = findClippingPoint(source, directionX, directionY);\n      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n\n\n      var lx = point2.x - point1.x;\n      var ly = point2.y - point1.y;\n      var l  = Math.sqrt(lx * lx + ly * ly);\n\n      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; \n\n      if (0 !== l) {\n        var forceX = force * lx / l;\n        var forceY = force * ly / l;\n      } else {\n        var forceX = 0;\n        var forceY = 0;\n      }\n\n      // Add this force to target and source nodes\n      source.offsetX += forceX;\n      source.offsetY += forceY;\n      target.offsetX -= forceX;\n      target.offsetY -= forceY;\n\n      var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n      s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n      logDebug(s);\n    }\n  };\n\n\n  /**\n   * @brief : Computes gravity forces for all nodes\n   */\n  var calculateGravityForces = function(layoutInfo, cy, options) {\n    var s = 'calculateGravityForces';\n    logDebug(s);\n    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {\n      var graph    = layoutInfo.graphSet[i];\n      var numNodes = graph.length;\n\n      s = \"Set: \" + graph.toString();\n      logDebug(s);\n          \n      // Compute graph center\n      if (0 === i) {\n        var centerX   = layoutInfo.clientHeight / 2;\n        var centerY   = layoutInfo.clientWidth  / 2;    \n      } else {\n        // Get Parent node for this graph, and use its position as center\n        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n        var centerX = parent.positionX;\n        var centerY = parent.positionY;\n      }\n      s = \"Center found at: \" + centerX + \", \" + centerY;\n      logDebug(s);\n\n      // Apply force to all nodes in graph\n      for (var j = 0; j < numNodes; j++) {\n        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n        s = \"Node: \" + node.id;\n        var dx = centerX - node.positionX;\n        var dy = centerY - node.positionY;\n        var d  = Math.sqrt(dx * dx + dy * dy);\n        if (d > 1.0) { // TODO: Use global variable for distance threshold\n          var fx = options.gravity * dx / d;\n          var fy = options.gravity * dy / d;\n          node.offsetX += fx;\n          node.offsetY += fy;\n          s += \": Applied force: \" + fx + \", \" + fy;\n        } else {\n          s += \": skypped since it's too close to center\";\n        }\n        logDebug(s);\n      }\n    }\n  };\n\n\n  /**\n   * @brief          : This function propagates the existing offsets from \n   *                   parent nodes to its descendents.\n   * @arg layoutInfo : layoutInfo Object\n   * @arg cy         : cytoscape Object\n   * @arg options    : Layout options\n   */\n  var propagateForces = function(layoutInfo, cy, options) {  \n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0;   // Points to the start the queue\n    var end   = -1;  // Points to the end of the queue\n\n    logDebug('propagateForces');\n\n    // Start by visiting the nodes in the root graph\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length;\n\n    // Traverse the graph, level by level, \n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var nodeId    = queue[start++];\n      var nodeIndex = layoutInfo.idToIndex[nodeId];\n      var node      = layoutInfo.layoutNodes[nodeIndex];\n      var children  = node.children;\n\n      // We only need to process the node if it's compound\n      if (0 < children.length) {    \n      var offX = node.offsetX;\n      var offY = node.offsetY;\n\n      var s = \"Propagating offset from parent node : \" + node.id + \n        \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n      s += \"\\n Children: \" + children.toString();\n      logDebug(s);\n      \n      for (var i = 0; i < children.length; i++) {\n        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n        // Propagate offset\n        childNode.offsetX += offX;\n        childNode.offsetY += offY;\n        // Add children to queue to be visited\n        queue[++end] = children[i];\n      }\n      \n      // Reset parent offsets\n      node.offsetX = 0;\n      node.offsetY = 0;\n      }\n      \n    }\n  };\n\n\n  /**\n   * @brief : Updates the layout model positions, based on \n   *          the accumulated forces\n   */\n  var updatePositions = function(layoutInfo, cy, options) {\n    var s = 'Updating positions';\n    logDebug(s);\n\n    // Reset boundaries for compound nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      if (0 < n.children.length) {\n        logDebug(\"Resetting boundaries of compound node: \" + n.id);\n        n.maxX = undefined;\n        n.minX = undefined;\n        n.maxY = undefined;\n        n.minY = undefined;\n      }\n    }\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      if (0 < n.children.length) {\n        // No need to set compound node position\n        logDebug(\"Skipping position update of node: \" + n.id);\n        continue;\n      }\n      s = \"Node: \" + n.id + \" Previous position: (\" + \n      n.positionX + \", \" + n.positionY + \").\"; \n\n      // Limit displacement in order to improve stability\n      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n      n.positionX += tempForce.x; \n      n.positionY += tempForce.y;\n      n.offsetX = 0;\n      n.offsetY = 0;\n      n.minX    = n.positionX - n.width; \n      n.maxX    = n.positionX + n.width; \n      n.minY    = n.positionY - n.height; \n      n.maxY    = n.positionY + n.height; \n      s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n      logDebug(s);\n\n      // Update ancestry boudaries\n      updateAncestryBoundaries(n, layoutInfo);\n    }\n\n    // Update size, position of compund nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      if (0 < n.children.length) {\n        n.positionX = (n.maxX + n.minX) / 2;\n        n.positionY = (n.maxY + n.minY) / 2;\n        n.width     = n.maxX - n.minX;\n        n.height    = n.maxY - n.minY;\n        s = \"Updating position, size of compound node \" + n.id;\n        s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        logDebug(s);\n      }\n    }  \n  };\n\n\n  /**\n   * @brief : Limits a force (forceX, forceY) to be not \n   *          greater (in modulo) than max. \n   8          Preserves force direction. \n   */\n  var limitForce = function(forceX, forceY, max) {\n    var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\n    if (force > max) {\n      var res = {\n      x : max * forceX / force,\n      y : max * forceY / force\n      };      \n\n    } else {\n      var res = {\n      x : forceX,\n      y : forceY\n      };\n    }\n\n    s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    logDebug(s);\n\n    return res;\n  };\n\n\n  /**\n   * @brief : Function used for keeping track of compound node \n   *          sizes, since they should bound all their subnodes.\n   */\n  var updateAncestryBoundaries = function(node, layoutInfo) {\n    var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n    if (null == parentId) {\n      // If there's no parent, we are done\n      s += \". No parent node.\";\n      logDebug(s);\n      return;\n    }\n\n    // Get Parent Node\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false;\n\n    // MaxX\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n      p.maxX = node.maxX + p.padRight;\n      flag = true;\n      s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    }\n\n    // MinX\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n      p.minX = node.minX - p.padLeft;\n      flag = true;\n      s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    }\n\n    // MaxY\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n      p.maxY = node.maxY + p.padBottom;\n      flag = true;\n      s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    }\n\n    // MinY\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n      p.minY = node.minY - p.padTop;\n      flag = true;\n      s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    }\n\n    // If updated boundaries, propagate changes upward\n    if (flag) {\n      logDebug(s);\n      return updateAncestryBoundaries(p, layoutInfo);\n    } \n\n    s += \". No changes in boundaries/position of parent node \" + p.id;  \n    logDebug(s);\n    return;\n  };\n\n\n  /**\n   * @brief : Logs a debug message in JS console, if DEBUG is ON\n   */\n  var logDebug = function(text) {\n    if (DEBUG) {\n      console.debug(text);\n    }\n  };\n\n\n  // register the layout\n  $$('layout', 'cose', CoseLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n\n  // default layout options\n  var defaults = {\n    // dagre algo options, uses default value on undefined\n    nodeSep: undefined, // the separation between adjacent nodes in the same rank\n    edgeSep: undefined, // the separation between adjacent edges in the same rank\n    rankSep: undefined, // the separation between adjacent nodes in the same rank\n    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right\n    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge\n    \n    // general layout options\n    fit: true, // whether to fit to viewport\n    padding: 30, // fit padding\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    ready: function(){}, // on layoutready\n    stop: function(){} // on layoutstop\n  };\n\n  // constructor\n  // options : object containing layout options\n  function DagreLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options); \n  }\n\n  // runs the layout\n  DagreLayout.prototype.run = function(){\n    var options = this.options;\n    var layout = this;\n\n    $$.util.require('dagre', function(dagre){\n\n      var cy = options.cy; // cy is automatically populated for us in the constructor\n      var eles = options.eles;\n\n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n\n      var g = new dagre.Digraph();\n\n      // add nodes to dagre\n      var nodes = eles.nodes().not(':parent');\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[i];\n\n        g.addNode( node.id(), {\n          width: node.width(),\n          height: node.height()\n        } );\n      }\n\n      // add edges to dagre\n      var edges = eles.edges();\n      for( var i = 0; i < edges.length; i++ ){\n        var edge = edges[i];\n\n        g.addEdge( edge.id(), edge.source().id(), edge.target().id(), {\n          minLen: $$.is.fn(options.minLen) ? options.minLen.apply( edge, [ edge ] ) : options.minLen\n        } );\n      }\n\n      var d = dagre.layout();\n\n      if( options.nodeSep ){\n        d.nodeSep( options.nodeSep );\n      }\n\n      if( options.edgeSep ){\n        d.edgeSep( options.edgeSep );\n      }\n      \n      if( options.rankSep ){\n        d.rankSep( options.rankSep );\n      }\n\n      if( options.rankDir ){\n        d.rankDir( options.rankDir );\n      }\n        \n      d = d.run(g);\n\n      d.eachNode(function(id, n) {\n        cy.getElementById(id).scratch().dagre = n;\n      });\n\n      var dagreBB;\n\n      if( options.boundingBox ){\n        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };\n        nodes.forEach(function( node ){\n          var dModel = node.scratch().dagre;\n\n          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );\n          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );\n\n          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );\n          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );\n        });\n\n        dagreBB.w = dagreBB.x2 - dagreBB.x1;\n        dagreBB.h = dagreBB.y2 - dagreBB.y1;\n      } else {\n        dagreBB = bb;\n      }\n\n      var constrainPos = function( p ){\n        if( options.boundingBox ){\n          var xPct = (p.x - dagreBB.x1) / dagreBB.w;\n          var yPct = (p.y - dagreBB.y1) / dagreBB.h;\n\n          return {\n            x: bb.x1 + xPct * bb.w,\n            y: bb.y1 + yPct * bb.h\n          };\n        } else {\n          return p;\n        }\n      };\n\n      nodes.layoutPositions(layout, options, function(){\n        var dModel = this.scratch().dagre;\n\n        return constrainPos({\n          x: dModel.x,\n          y: dModel.y\n        });\n      });\n\n    }); // require\n\n    return this; // chaining\n  };\n\n  // register the layout\n  $$('layout', 'dagre', DagreLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // padding used on fit\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space\n    rows: undefined, // force num of rows in the grid\n    columns: undefined, // force num of cols in the grid\n    position: function( node ){}, // returns { row, col } for element\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function GridLayout( options ){\n    this.options = $$.util.extend({}, defaults, options);\n  }\n  \n  GridLayout.prototype.run = function(){\n    var params = this.options;\n    var options = params;\n    \n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    if( bb.h === 0 || bb.w === 0){\n      nodes.layoutPositions(this, options, function(){\n        return { x: bb.x1, y: bb.y1 };\n      });\n      \n    } else {\n      \n      // width/height * splits^2 = cells where splits is number of times to split width\n      var cells = nodes.size();\n      var splits = Math.sqrt( cells * bb.h/bb.w );\n      var rows = Math.round( splits );\n      var cols = Math.round( bb.w/bb.h * splits );\n\n      var small = function(val){\n        if( val == null ){\n          return Math.min(rows, cols);\n        } else {\n          var min = Math.min(rows, cols);\n          if( min == rows ){\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n      \n      var large = function(val){\n        if( val == null ){\n          return Math.max(rows, cols);\n        } else {\n          var max = Math.max(rows, cols);\n          if( max == rows ){\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n      \n      // if rows or columns were set in options, use those values\n      if( options.rows != null && options.columns != null ){\n        rows = options.rows;\n        cols = options.columns;\n      } else if( options.rows != null && options.columns == null ){\n        rows = options.rows;\n        cols = Math.ceil( cells / rows );\n      } else if( options.rows == null && options.columns != null ){\n        cols = options.columns;\n        rows = Math.ceil( cells / cols );\n      }\n      \n      // otherwise use the automatic values and adjust accordingly\n      \n      // if rounding was up, see if we can reduce rows or columns\n      else if( cols * rows > cells ){\n        var sm = small();\n        var lg = large();\n        \n        // reducing the small side takes away the most cells, so try it first\n        if( (sm - 1) * lg >= cells ){\n          small(sm - 1);\n        } else if( (lg - 1) * sm >= cells ){\n          large(lg - 1);\n        } \n      } else {\n        \n        // if rounding was too low, add rows or columns\n        while( cols * rows < cells ){\n          var sm = small();\n          var lg = large();\n          \n          // try to add to larger side first (adds less in multiplication)\n          if( (lg + 1) * sm >= cells ){\n            large(lg + 1);\n          } else {\n            small(sm + 1);\n          }\n        }\n      }\n      \n      var cellWidth = bb.w / cols;\n      var cellHeight = bb.h / rows;\n\n      if( options.avoidOverlap ){\n        for( var i = 0; i < nodes.length; i++ ){\n          var node = nodes[i];\n          var w = node.outerWidth();\n          var h = node.outerHeight();\n\n          cellWidth = Math.max( cellWidth, w );\n          cellHeight = Math.max( cellHeight, h );\n        }\n      }\n      \n      var cellUsed = {}; // e.g. 'c-0-2' => true\n      \n      var used = function(row, col){\n        return cellUsed['c-' + row + '-' + col] ? true : false;\n      };\n      \n      var use = function(row, col){\n        cellUsed['c-' + row + '-' + col] = true;\n      };\n\n      // to keep track of current cell position\n      var row = 0;\n      var col = 0;\n      var moveToNextCell = function(){\n        col++;\n        if( col >= cols ){\n          col = 0;\n          row++;\n        }\n      };\n\n      // get a cache of all the manual positions\n      var id2manPos = {};\n      for( var i = 0; i < nodes.length; i++ ){\n        var node = nodes[i];\n        var rcPos = options.position( node );\n\n        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd\n          var pos = {\n            row: rcPos.row,\n            col: rcPos.col\n          };\n\n          if( pos.col === undefined ){ // find unused col\n            pos.col = 0;\n\n            while( used(pos.row, pos.col) ){\n              pos.col++;\n            }\n          } else if( pos.row === undefined ){ // find unused row\n            pos.row = 0;\n\n            while( used(pos.row, pos.col) ){\n              pos.row++;\n            }\n          }\n\n          id2manPos[ node.id() ] = pos;\n          use( pos.row, pos.col );\n        }\n      }\n\n      var getPos = function(i, element){\n        var x, y;\n\n        if( element.locked() || element.isFullAutoParent() ){\n          return false;\n        }\n\n        // see if we have a manual position set\n        var rcPos = id2manPos[ element.id() ];\n        if( rcPos ){\n          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;\n          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;\n        \n        } else { // otherwise set automatically\n        \n          while( used(row, col) ){\n            moveToNextCell();\n          }\n\n          x = col * cellWidth + cellWidth/2 + bb.x1;\n          y = row * cellHeight + cellHeight/2 + bb.y1;\n          use( row, col );\n          \n          moveToNextCell();\n        }\n        \n        return { x: x, y: y };\n        \n      };\n\n      nodes.layoutPositions( this, options, getPos );\n    }\n\n    return this; // chaining\n    \n  };\n  \n  $$('layout', 'grid', GridLayout);\n  \n})( cytoscape );\n\n;(function($$){ 'use strict';\n\n  // default layout options\n  var defaults = {\n    ready: function(){}, // on layoutready\n    stop: function(){} // on layoutstop\n  };\n\n  // constructor\n  // options : object containing layout options\n  function NullLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options); \n  }\n\n  // runs the layout\n  NullLayout.prototype.run = function(){\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n    var layout = this;\n\n    // cy is automatically populated for us in the constructor\n    var cy = options.cy; // jshint ignore:line\n\n    layout.trigger('layoutstart');\n\n    // puts all nodes at (0, 0)\n    eles.nodes().positions(function(){\n      return {\n        x: 0,\n        y: 0\n      };\n    });\n\n    // trigger layoutready when each node has had its position set at least once\n    layout.one('layoutready', options.ready);\n    layout.trigger('layoutready');\n\n    // trigger layoutstop when the layout stops (e.g. finishes)\n    layout.one('layoutstop', options.stop);\n    layout.trigger('layoutstop');\n\n    return this; // chaining\n  };\n\n  // called on continuous layouts to stop them before they finish\n  NullLayout.prototype.stop = function(){\n    return this; // chaining\n  };\n\n  // register the layout\n  $$('layout', 'null', NullLayout);\n\n})(cytoscape);\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined, // the zoom level to set (prob want fit = false if set)\n    pan: undefined, // the pan level to set (prob want fit = false if set)\n    fit: true, // whether to fit to viewport\n    padding: 30, // padding on fit\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function PresetLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options);\n  }\n  \n  PresetLayout.prototype.run = function(){\n    var options = this.options;\n    var eles = options.eles;\n\n    var nodes = eles.nodes();\n    var posIsFn = $$.is.fn( options.positions );\n\n    function getPosition(node){\n      if( options.positions == null ){\n        return null;\n      }\n\n      if( posIsFn ){\n        return options.positions.apply( node, [ node ] );\n      }\n      \n      var pos = options.positions[node._private.data.id];\n\n      if( pos == null ){\n        return null;\n      }\n      \n      return pos;\n    }\n    \n    nodes.layoutPositions(this, options, function(i, node){\n      var position = getPosition(node);\n      \n      if( node.locked() || position == null ){\n        return false;\n      }\n      \n      return position;\n    });\n        \n    return this; // chaining\n  };\n  \n  $$('layout', 'preset', PresetLayout);\n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    fit: true, // whether to fit to viewport\n    padding: 30, // fit padding\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false, // whether to transition the node positions\n    animationDuration: 500, // duration of animation in ms if enabled\n    ready: undefined, // callback on layoutready\n    stop: undefined // callback on layoutstop\n  };\n  \n  function RandomLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options);\n  }\n  \n  RandomLayout.prototype.run = function(){\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    \n    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n      x1: 0, y1: 0, w: cy.width(), h: cy.height()\n    } );\n\n    var getPos = function( i, node ){\n      return {\n        x: bb.x1 + Math.round( Math.random() * bb.w ),\n        y: bb.y1 + Math.round( Math.random() * bb.h )\n      };\n    };\n\n    nodes.layoutPositions( this, options, getPos );\n\n    return this; // chaining\n  };\n  \n  // register the layout\n  $$(\n    'layout', // we're registering a layout\n    'random', // the layout name\n    RandomLayout // the layout prototype\n  );\n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n  \n  var defaults = {\n    animate: true, // whether to show the layout as it's running\n    maxSimulationTime: 4000, // max length in ms to run the layout\n    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout\n    fit: true, // whether to fit the viewport to the graph\n    padding: 30, // padding on fit\n    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    random: false, // whether to use random initial positions\n    infinite: false, // overrides all other options for a forces-all-the-time mode\n    ready: undefined, // callback on layoutready\n    stop: undefined, // callback on layoutstop\n\n    // springy forces\n    stiffness: 400,\n    repulsion: 400,\n    damping: 0.5\n  };\n\n  function SpringyLayout( options ){\n    this.options = $$.util.extend(true, {}, defaults, options);\n  }\n  \n  SpringyLayout.prototype.run = function(){\n    var layout = this;\n    var self = this;\n    var options = this.options;\n\n    $$.util.require('Springy', function(Springy){\n\n      var simUpdatingPos = false;\n\n      var cy = options.cy;\n      layout.trigger({ type: 'layoutstart', layout: layout });\n      \n      var eles = options.eles;\n      var nodes = eles.nodes().not(':parent');\n      var edges = eles.edges();\n   \n      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {\n        x1: 0, y1: 0, w: cy.width(), h: cy.height()\n      } );\n      \n      // make a new graph\n      var graph = new Springy.Graph();\n\n      // make some nodes\n      nodes.each(function(i, node){\n        node.scratch('springy', {\n          model: graph.newNode({\n            element: node\n          })\n        });\n      });\n\n      // connect them with edges\n      edges.each(function(i, edge){\n        var fdSrc = edge.source().scratch('springy').model;\n        var fdTgt = edge.target().scratch('springy').model;\n        \n        edge.scratch('springy', {\n          model: graph.newEdge(fdSrc, fdTgt, {\n            element: edge\n          })\n        });\n      });\n      \n      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);\n\n      if( options.infinite ){\n        sim.minEnergyThreshold = -Infinity;\n      }\n\n      var currentBB = sim.getBoundingBox();\n      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};\n      \n      // convert to/from screen coordinates\n      var toScreen = function(p) {\n        currentBB = sim.getBoundingBox();\n\n        var size = currentBB.topright.subtract(currentBB.bottomleft);\n        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;\n        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;\n\n        return new Springy.Vector(sx, sy);\n      };\n\n      var fromScreen = function(s) {\n        currentBB = sim.getBoundingBox();\n\n        var size = currentBB.topright.subtract(currentBB.bottomleft);\n        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;\n        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;\n\n        return new Springy.Vector(px, py);\n      };\n      \n      var movedNodes = cy.collection();\n      \n      var numNodes = cy.nodes().size();\n      var drawnNodes = 1;\n      var fdRenderer = new Springy.Renderer(sim,\n        function clear() {\n          if( movedNodes.length > 0 && options.animate ){\n            simUpdatingPos = true;\n\n            movedNodes.rtrigger('position');\n\n            if( options.fit ){\n              cy.fit( options.padding );\n            }\n\n            movedNodes = cy.collection();\n\n            simUpdatingPos = false;\n          }\n        },\n\n        function drawEdge(edge, p1, p2) {\n          // draw an edge\n        },\n\n        function drawNode(node, p) {\n          var v = toScreen(p);\n          var element = node.data.element;\n          \n          if( !element.locked() && !element.grabbed() ){\n              element._private.position = {\n                x: v.x,\n                y: v.y\n              };\n              movedNodes.merge(element);\n          } else {\n            //setLayoutPositionForElement(element);\n          }\n          \n          if( drawnNodes == numNodes ){\n            layout.one('layoutready', options.ready);\n            layout.trigger({ type: 'layoutready', layout: layout });\n          } \n          \n          drawnNodes++;\n        \n        }\n      );\n      \n      // set initial node points\n      nodes.each(function(i, ele){\n        if( !options.random ){\n          setLayoutPositionForElement(ele);\n        }\n      });\n      \n      // update node positions when dragging\n      var dragHandler;\n      nodes.on('position', dragHandler = function(){\n        if( simUpdatingPos ){ return; }\n\n        setLayoutPositionForElement(this);\n      });\n      \n      function setLayoutPositionForElement(element){\n        var fdId = element.scratch('springy').model.id;\n        var fdP = fdRenderer.layout.nodePoints[fdId].p;\n        var pos = element.position();\n        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {\n          x: Math.random() * 4 - 2,\n          y: Math.random() * 4 - 2\n        };\n        \n        fdP.x = positionInFd.x;\n        fdP.y = positionInFd.y;\n      }\n      \n      var grabbableNodes = nodes.filter(\":grabbable\");\n      \n      function start(){\n        // disable grabbing if so set\n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.ungrabify();\n        }\n        \n        fdRenderer.start();\n      }\n      \n      self.stopSystem = function(){\n        graph.filterNodes(function(){\n          return false; // remove all nodes\n        });\n        \n        if( options.ungrabifyWhileSimulating ){\n          grabbableNodes.grabify();\n        }\n\n        if( options.fit ){\n          cy.fit( options.padding );\n        }\n        \n        nodes.off('drag position', dragHandler);\n\n        layout.one('layoutstop', options.stop);\n        layout.trigger({ type: 'layoutstop', layout: layout });\n\n        self.stopSystem = null;\n      };\n      \n      start();\n      if( !options.infinite ){\n        setTimeout(function(){\n          self.stop();\n        }, options.maxSimulationTime);\n      }\n\n    }); // require\n\n    return this; // chaining\n  };\n\n  SpringyLayout.prototype.stop = function(){\n    if( this.stopSystem != null ){\n      this.stopSystem();\n    }\n\n    return this; // chaining\n  };\n  \n  $$('layout', 'springy', SpringyLayout);\n\n  \n})(cytoscape);\n\n;(function($$){ 'use strict';\n    \n  function NullRenderer(options){\n    this.options = options;\n  }\n  \n  NullRenderer.prototype.recalculateRenderedStyle = function(){\n  };\n\n  NullRenderer.prototype.notify = function(){\n    // the null renderer does nothing\n  };\n  \n  $$('renderer', 'null', NullRenderer);\n  \n})( cytoscape );\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/dist/cytoscape.js\n ** module id = 125\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/cytoscape/dist/cytoscape.js?");

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule keyMirror\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Constructs an enumeration with keys equal to their value.\n *\n * For example:\n *\n *   var COLORS = keyMirror({blue: null, red: null});\n *   var myColor = COLORS.blue;\n *   var isColorValid = !!COLORS[myColor];\n *\n * The last line could not be performed if the values of the generated enum were\n * not equal to their keys.\n *\n *   Input:  {key1: val1, key2: val2}\n *   Output: {key1: key1, key2: key2}\n *\n * @param {object} obj\n * @return {object}\n */\nvar keyMirror = function(obj) {\n  var ret = {};\n  var key;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    obj instanceof Object && !Array.isArray(obj),\n    'keyMirror(...): Argument must be an object.'\n  ) : invariant(obj instanceof Object && !Array.isArray(obj)));\n  for (key in obj) {\n    if (!obj.hasOwnProperty(key)) {\n      continue;\n    }\n    ret[key] = key;\n  }\n  return ret;\n};\n\nmodule.exports = keyMirror;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/keyMirror.js\n ** module id = 126\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/keyMirror.js?");

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule accumulateInto\n */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\n/**\n *\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    next != null,\n    'accumulateInto(...): Accumulated items must not be null or undefined.'\n  ) : invariant(next != null));\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  var currentIsArray = Array.isArray(current);\n  var nextIsArray = Array.isArray(next);\n\n  if (currentIsArray && nextIsArray) {\n    current.push.apply(current, next);\n    return current;\n  }\n\n  if (currentIsArray) {\n    current.push(next);\n    return current;\n  }\n\n  if (nextIsArray) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\nmodule.exports = accumulateInto;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/accumulateInto.js\n ** module id = 127\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/accumulateInto.js?");

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule forEachAccumulated\n */\n\n\"use strict\";\n\n/**\n * @param {array} an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n */\nvar forEachAccumulated = function(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n};\n\nmodule.exports = forEachAccumulated;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/forEachAccumulated.js\n ** module id = 128\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/forEachAccumulated.js?");

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getUnboundedScrollPosition\n * @typechecks\n */\n\n\"use strict\";\n\n/**\n * Gets the scroll position of the supplied element or window.\n *\n * The return values are unbounded, unlike `getScrollPosition`. This means they\n * may be negative or exceed the element boundaries (which is possible using\n * inertial scrolling).\n *\n * @param {DOMWindow|DOMElement} scrollable\n * @return {object} Map with `x` and `y` keys.\n */\nfunction getUnboundedScrollPosition(scrollable) {\n  if (scrollable === window) {\n    return {\n      x: window.pageXOffset || document.documentElement.scrollLeft,\n      y: window.pageYOffset || document.documentElement.scrollTop\n    };\n  }\n  return {\n    x: scrollable.scrollLeft,\n    y: scrollable.scrollTop\n  };\n}\n\nmodule.exports = getUnboundedScrollPosition;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getUnboundedScrollPosition.js\n ** module id = 129\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getUnboundedScrollPosition.js?");

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isNode\n * @typechecks\n */\n\n/**\n * @param {*} object The object to check.\n * @return {boolean} Whether or not the object is a DOM node.\n */\nfunction isNode(object) {\n  return !!(object && (\n    typeof Node === 'function' ? object instanceof Node :\n      typeof object === 'object' &&\n      typeof object.nodeType === 'number' &&\n      typeof object.nodeName === 'string'\n  ));\n}\n\nmodule.exports = isNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isNode.js\n ** module id = 130\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isNode.js?");

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Returns a function that establishes the first prototype passed to it\n * as the \"source of truth\" and patches its methods on subsequent invocations,\n * also patching current and previous prototypes to forward calls to it.\n */\nmodule.exports = function makeAssimilatePrototype() {\n  var storedPrototype,\n      knownPrototypes = [];\n\n  function wrapMethod(key) {\n    return function () {\n      if (storedPrototype[key]) {\n        return storedPrototype[key].apply(this, arguments);\n      }\n    };\n  }\n\n  function patchProperty(proto, key) {\n    proto[key] = storedPrototype[key];\n\n    if (typeof proto[key] !== 'function' ||\n      key === 'type' ||\n      key === 'constructor') {\n      return;\n    }\n\n    proto[key] = wrapMethod(key);\n\n    if (storedPrototype[key].isReactClassApproved) {\n      proto[key].isReactClassApproved = storedPrototype[key].isReactClassApproved;\n    }\n\n    if (proto.__reactAutoBindMap && proto.__reactAutoBindMap[key]) {\n      proto.__reactAutoBindMap[key] = proto[key];\n    }\n  }\n\n  function updateStoredPrototype(freshPrototype) {\n    storedPrototype = {};\n\n    Object.getOwnPropertyNames(freshPrototype).forEach(function (key) {\n      storedPrototype[key] = freshPrototype[key];\n    });\n  }\n\n  function reconcileWithStoredPrototypes(freshPrototype) {\n    knownPrototypes.push(freshPrototype);\n    knownPrototypes.forEach(function (proto) {\n      Object.getOwnPropertyNames(storedPrototype).forEach(function (key) {\n        patchProperty(proto, key);\n      });\n    });\n  }\n\n  return function assimilatePrototype(freshPrototype) {\n    if (freshPrototype.__isAssimilatedByReactHotAPI) {\n      return;\n    }\n\n    updateStoredPrototype(freshPrototype);\n    reconcileWithStoredPrototypes(freshPrototype);\n    freshPrototype.__isAssimilatedByReactHotAPI = true;\n  };\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/makeAssimilatePrototype.js\n ** module id = 131\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/makeAssimilatePrototype.js?");

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	eval("var deepForceUpdate = __webpack_require__(205);\n\nvar isRequestPending = false;\n\nmodule.exports = function requestForceUpdateAll(getRootInstances) {\n  if (isRequestPending) {\n    return;\n  }\n\n  /**\n   * Forces deep re-render of all mounted React components.\n   * Hat's off to Omar Skalli (@Chetane) for suggesting this approach:\n   * https://gist.github.com/Chetane/9a230a9fdcdca21a4e29\n   */\n  function forceUpdateAll() {\n    isRequestPending = false;\n\n    var rootInstances = getRootInstances(),\n        rootInstance;\n\n    for (var key in rootInstances) {\n      if (rootInstances.hasOwnProperty(key)) {\n        deepForceUpdate(rootInstances[key]);\n      }\n    }\n  }\n\n  setTimeout(forceUpdateAll);\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/requestForceUpdateAll.js\n ** module id = 132\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/requestForceUpdateAll.js?");

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule escapeTextForBrowser\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar ESCAPE_LOOKUP = {\n  \"&\": \"&amp;\",\n  \">\": \"&gt;\",\n  \"<\": \"&lt;\",\n  \"\\\"\": \"&quot;\",\n  \"'\": \"&#x27;\"\n};\n\nvar ESCAPE_REGEX = /[&><\"']/g;\n\nfunction escaper(match) {\n  return ESCAPE_LOOKUP[match];\n}\n\n/**\n * Escapes text to prevent scripting attacks.\n *\n * @param {*} text Text value to escape.\n * @return {string} An escaped string.\n */\nfunction escapeTextForBrowser(text) {\n  return ('' + text).replace(ESCAPE_REGEX, escaper);\n}\n\nmodule.exports = escapeTextForBrowser;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/escapeTextForBrowser.js\n ** module id = 133\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/escapeTextForBrowser.js?");

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule memoizeStringOnly\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * Memoizes the return value of a function that accepts one string argument.\n *\n * @param {function} callback\n * @return {function}\n */\nfunction memoizeStringOnly(callback) {\n  var cache = {};\n  return function(string) {\n    if (cache.hasOwnProperty(string)) {\n      return cache[string];\n    } else {\n      return cache[string] = callback.call(this, string);\n    }\n  };\n}\n\nmodule.exports = memoizeStringOnly;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/memoizeStringOnly.js\n ** module id = 134\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/memoizeStringOnly.js?");

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule PooledClass\n */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Static poolers. Several custom versions for each potential number of\n * arguments. A completely generic pooler is easy to implement, but would\n * require accessing the `arguments` object. In each of these, `this` refers to\n * the Class itself, not an instance. If any others are needed, simply add them\n * here, or in their own files.\n */\nvar oneArgumentPooler = function(copyFieldsFrom) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, copyFieldsFrom);\n    return instance;\n  } else {\n    return new Klass(copyFieldsFrom);\n  }\n};\n\nvar twoArgumentPooler = function(a1, a2) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2);\n    return instance;\n  } else {\n    return new Klass(a1, a2);\n  }\n};\n\nvar threeArgumentPooler = function(a1, a2, a3) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3);\n  }\n};\n\nvar fiveArgumentPooler = function(a1, a2, a3, a4, a5) {\n  var Klass = this;\n  if (Klass.instancePool.length) {\n    var instance = Klass.instancePool.pop();\n    Klass.call(instance, a1, a2, a3, a4, a5);\n    return instance;\n  } else {\n    return new Klass(a1, a2, a3, a4, a5);\n  }\n};\n\nvar standardReleaser = function(instance) {\n  var Klass = this;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    instance instanceof Klass,\n    'Trying to release an instance into a pool of a different type.'\n  ) : invariant(instance instanceof Klass));\n  if (instance.destructor) {\n    instance.destructor();\n  }\n  if (Klass.instancePool.length < Klass.poolSize) {\n    Klass.instancePool.push(instance);\n  }\n};\n\nvar DEFAULT_POOL_SIZE = 10;\nvar DEFAULT_POOLER = oneArgumentPooler;\n\n/**\n * Augments `CopyConstructor` to be a poolable class, augmenting only the class\n * itself (statically) not adding any prototypical fields. Any CopyConstructor\n * you give this may have a `poolSize` property, and will look for a\n * prototypical `destructor` on instances (optional).\n *\n * @param {Function} CopyConstructor Constructor that can be used to reset.\n * @param {Function} pooler Customizable pooler.\n */\nvar addPoolingTo = function(CopyConstructor, pooler) {\n  var NewKlass = CopyConstructor;\n  NewKlass.instancePool = [];\n  NewKlass.getPooled = pooler || DEFAULT_POOLER;\n  if (!NewKlass.poolSize) {\n    NewKlass.poolSize = DEFAULT_POOL_SIZE;\n  }\n  NewKlass.release = standardReleaser;\n  return NewKlass;\n};\n\nvar PooledClass = {\n  addPoolingTo: addPoolingTo,\n  oneArgumentPooler: oneArgumentPooler,\n  twoArgumentPooler: twoArgumentPooler,\n  threeArgumentPooler: threeArgumentPooler,\n  fiveArgumentPooler: fiveArgumentPooler\n};\n\nmodule.exports = PooledClass;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/PooledClass.js\n ** module id = 135\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/PooledClass.js?");

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n\"use strict\";\n\nvar ReactElement = __webpack_require__(28);\nvar ReactInstanceHandles = __webpack_require__(30);\n\nvar invariant = __webpack_require__(36);\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that:\n * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.\n * 2. it('should fail when supplied duplicate key', function() {\n * 3. That a single child and an array with one item have the same key pattern.\n * });\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(\n    userProvidedKeyEscapeRegex,\n    userProvidedKeyEscaper\n  );\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nvar traverseAllChildrenImpl =\n  function(children, nameSoFar, indexSoFar, callback, traverseContext) {\n    var nextName, nextIndex;\n    var subtreeCount = 0;  // Count of children found in the current subtree.\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        nextName = (\n          nameSoFar +\n          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n          getComponentKey(child, i)\n        );\n        nextIndex = indexSoFar + subtreeCount;\n        subtreeCount += traverseAllChildrenImpl(\n          child,\n          nextName,\n          nextIndex,\n          callback,\n          traverseContext\n        );\n      }\n    } else {\n      var type = typeof children;\n      var isOnlyChild = nameSoFar === '';\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows\n      var storageName =\n        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;\n      if (children == null || type === 'boolean') {\n        // All of the above are perceived as null.\n        callback(traverseContext, null, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (type === 'string' || type === 'number' ||\n                 ReactElement.isValidElement(children)) {\n        callback(traverseContext, children, storageName, indexSoFar);\n        subtreeCount = 1;\n      } else if (type === 'object') {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !children || children.nodeType !== 1,\n          'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n          'elements are not valid children of React components.'\n        ) : invariant(!children || children.nodeType !== 1));\n        for (var key in children) {\n          if (children.hasOwnProperty(key)) {\n            nextName = (\n              nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +\n              wrapUserProvidedKey(key) + SUBSEPARATOR +\n              getComponentKey(children[key], 0)\n            );\n            nextIndex = indexSoFar + subtreeCount;\n            subtreeCount += traverseAllChildrenImpl(\n              children[key],\n              nextName,\n              nextIndex,\n              callback,\n              traverseContext\n            );\n          }\n        }\n      }\n    }\n    return subtreeCount;\n  };\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/traverseAllChildren.js\n ** module id = 136\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/traverseAllChildren.js?");

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactOwner\n */\n\n\"use strict\";\n\nvar emptyObject = __webpack_require__(206);\nvar invariant = __webpack_require__(36);\n\n/**\n * ReactOwners are capable of storing references to owned components.\n *\n * All components are capable of //being// referenced by owner components, but\n * only ReactOwner components are capable of //referencing// owned components.\n * The named reference is known as a \"ref\".\n *\n * Refs are available when mounted and updated during reconciliation.\n *\n *   var MyComponent = React.createClass({\n *     render: function() {\n *       return (\n *         <div onClick={this.handleClick}>\n *           <CustomComponent ref=\"custom\" />\n *         </div>\n *       );\n *     },\n *     handleClick: function() {\n *       this.refs.custom.handleClick();\n *     },\n *     componentDidMount: function() {\n *       this.refs.custom.initialize();\n *     }\n *   });\n *\n * Refs should rarely be used. When refs are used, they should only be done to\n * control data that is not handled by React's data flow.\n *\n * @class ReactOwner\n */\nvar ReactOwner = {\n\n  /**\n   * @param {?object} object\n   * @return {boolean} True if `object` is a valid owner.\n   * @final\n   */\n  isValidOwner: function(object) {\n    return !!(\n      object &&\n      typeof object.attachRef === 'function' &&\n      typeof object.detachRef === 'function'\n    );\n  },\n\n  /**\n   * Adds a component by ref to an owner component.\n   *\n   * @param {ReactComponent} component Component to reference.\n   * @param {string} ref Name by which to refer to the component.\n   * @param {ReactOwner} owner Component on which to record the ref.\n   * @final\n   * @internal\n   */\n  addComponentAsRefTo: function(component, ref, owner) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactOwner.isValidOwner(owner),\n      'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' +\n      'usually means that you\\'re trying to add a ref to a component that ' +\n      'doesn\\'t have an owner (that is, was not created inside of another ' +\n      'component\\'s `render` method). Try rendering this component inside of ' +\n      'a new top-level component which will hold the ref.'\n    ) : invariant(ReactOwner.isValidOwner(owner)));\n    owner.attachRef(ref, component);\n  },\n\n  /**\n   * Removes a component by ref from an owner component.\n   *\n   * @param {ReactComponent} component Component to dereference.\n   * @param {string} ref Name of the ref to remove.\n   * @param {ReactOwner} owner Component on which the ref is recorded.\n   * @final\n   * @internal\n   */\n  removeComponentAsRefFrom: function(component, ref, owner) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactOwner.isValidOwner(owner),\n      'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' +\n      'usually means that you\\'re trying to remove a ref to a component that ' +\n      'doesn\\'t have an owner (that is, was not created inside of another ' +\n      'component\\'s `render` method). Try rendering this component inside of ' +\n      'a new top-level component which will hold the ref.'\n    ) : invariant(ReactOwner.isValidOwner(owner)));\n    // Check that `component` is still the current ref because we do not want to\n    // detach the ref if another component stole it.\n    if (owner.refs[ref] === component) {\n      owner.detachRef(ref);\n    }\n  },\n\n  /**\n   * A ReactComponent must mix this in to have refs.\n   *\n   * @lends {ReactOwner.prototype}\n   */\n  Mixin: {\n\n    construct: function() {\n      this.refs = emptyObject;\n    },\n\n    /**\n     * Lazily allocates the refs object and stores `component` as `ref`.\n     *\n     * @param {string} ref Reference name.\n     * @param {component} component Component to store as `ref`.\n     * @final\n     * @private\n     */\n    attachRef: function(ref, component) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        component.isOwnedBy(this),\n        'attachRef(%s, ...): Only a component\\'s owner can store a ref to it.',\n        ref\n      ) : invariant(component.isOwnedBy(this)));\n      var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;\n      refs[ref] = component;\n    },\n\n    /**\n     * Detaches a reference name.\n     *\n     * @param {string} ref Name to dereference.\n     * @final\n     * @private\n     */\n    detachRef: function(ref) {\n      delete this.refs[ref];\n    }\n\n  }\n\n};\n\nmodule.exports = ReactOwner;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactOwner.js\n ** module id = 137\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactOwner.js?");

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n\"use strict\";\n\nvar CallbackQueue = __webpack_require__(207);\nvar PooledClass = __webpack_require__(135);\nvar ReactCurrentOwner = __webpack_require__(27);\nvar ReactPerf = __webpack_require__(31);\nvar Transaction = __webpack_require__(208);\n\nvar assign = __webpack_require__(51);\nvar invariant = __webpack_require__(36);\nvar warning = __webpack_require__(38);\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactUpdates.ReactReconcileTransaction && batchingStrategy,\n    'ReactUpdates: must inject a reconcile transaction class and batching ' +\n    'strategy'\n  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));\n}\n\nvar NESTED_UPDATES = {\n  initialize: function() {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function() {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function() {\n    this.callbackQueue.reset();\n  },\n  close: function() {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction =\n    ReactUpdates.ReactReconcileTransaction.getPooled();\n}\n\nassign(\n  ReactUpdatesFlushTransaction.prototype,\n  Transaction.Mixin, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function() {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function(method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(\n      this,\n      this.reconcileTransaction.perform,\n      this.reconcileTransaction,\n      method,\n      scope,\n      a\n    );\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b);\n}\n\n/**\n * Array comparator for ReactComponents by owner depth\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountDepthComparator(c1, c2) {\n  return c1._mountDepth - c2._mountDepth;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    len === dirtyComponents.length,\n    'Expected flush transaction\\'s stored dirty-components length (%s) to ' +\n    'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length\n  ) : invariant(len === dirtyComponents.length));\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountDepthComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, ignore them\n    // TODO: Queue unmounts in the same list to avoid this happening at all\n    var component = dirtyComponents[i];\n    if (component.isMounted()) {\n      // If performUpdateIfNecessary happens to enqueue any new updates, we\n      // shouldn't execute the callbacks until the next render happens, so\n      // stash the callbacks first\n      var callbacks = component._pendingCallbacks;\n      component._pendingCallbacks = null;\n      component.performUpdateIfNecessary(transaction.reconcileTransaction);\n\n      if (callbacks) {\n        for (var j = 0; j < callbacks.length; j++) {\n          transaction.callbackQueue.enqueue(\n            callbacks[j],\n            component\n          );\n        }\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = ReactPerf.measure(\n  'ReactUpdates',\n  'flushBatchedUpdates',\n  function() {\n    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n    // array and perform any updates enqueued by mount-ready handlers (i.e.,\n    // componentDidUpdate) but we need to check here too in order to catch\n    // updates enqueued by setState callbacks and asap calls.\n    while (dirtyComponents.length || asapEnqueued) {\n      if (dirtyComponents.length) {\n        var transaction = ReactUpdatesFlushTransaction.getPooled();\n        transaction.perform(runBatchedUpdates, null, transaction);\n        ReactUpdatesFlushTransaction.release(transaction);\n      }\n\n      if (asapEnqueued) {\n        asapEnqueued = false;\n        var queue = asapCallbackQueue;\n        asapCallbackQueue = CallbackQueue.getPooled();\n        queue.notifyAll();\n        CallbackQueue.release(queue);\n      }\n    }\n  }\n);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component, callback) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !callback || typeof callback === \"function\",\n    'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' +\n    '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n    'isn\\'t callable.'\n  ) : invariant(!callback || typeof callback === \"function\"));\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    ReactCurrentOwner.current == null,\n    'enqueueUpdate(): Render methods should be a pure function of props ' +\n    'and state; triggering nested component updates from render is not ' +\n    'allowed. If necessary, trigger nested updates in ' +\n    'componentDidUpdate.'\n  ) : null);\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);\n    return;\n  }\n\n  dirtyComponents.push(component);\n\n  if (callback) {\n    if (component._pendingCallbacks) {\n      component._pendingCallbacks.push(callback);\n    } else {\n      component._pendingCallbacks = [callback];\n    }\n  }\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    batchingStrategy.isBatchingUpdates,\n    'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' +\n    'updates are not being batched.'\n  ) : invariant(batchingStrategy.isBatchingUpdates));\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class'\n    ) : invariant(ReconcileTransaction));\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy'\n    ) : invariant(_batchingStrategy));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function'\n    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'\n    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactUpdates.js\n ** module id = 138\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactUpdates.js?");

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactErrorUtils\n * @typechecks\n */\n\n\"use strict\";\n\nvar ReactErrorUtils = {\n  /**\n   * Creates a guarded version of a function. This is supposed to make debugging\n   * of event handlers easier. To aid debugging with the browser's debugger,\n   * this currently simply returns the original function.\n   *\n   * @param {function} func Function to be executed\n   * @param {string} name The name of the guard\n   * @return {function}\n   */\n  guard: function(func, name) {\n    return func;\n  }\n};\n\nmodule.exports = ReactErrorUtils;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactErrorUtils.js\n ** module id = 139\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactErrorUtils.js?");

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTransferer\n */\n\n\"use strict\";\n\nvar assign = __webpack_require__(51);\nvar emptyFunction = __webpack_require__(59);\nvar invariant = __webpack_require__(36);\nvar joinClasses = __webpack_require__(209);\nvar warning = __webpack_require__(38);\n\nvar didWarn = false;\n\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\nfunction createTransferStrategy(mergeStrategy) {\n  return function(props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function(a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n  return props;\n}\n\n/**\n * ReactPropTransferer are capable of transferring props to another component\n * using a `transferPropsTo` method.\n *\n * @class ReactPropTransferer\n */\nvar ReactPropTransferer = {\n\n  TransferStrategies: TransferStrategies,\n\n  /**\n   * Merge two props objects using TransferStrategies.\n   *\n   * @param {object} oldProps original props (they take precedence)\n   * @param {object} newProps new props to merge in\n   * @return {object} a new object containing both sets of props merged.\n   */\n  mergeProps: function(oldProps, newProps) {\n    return transferInto(assign({}, oldProps), newProps);\n  },\n\n  /**\n   * @lends {ReactPropTransferer.prototype}\n   */\n  Mixin: {\n\n    /**\n     * Transfer props from this component to a target component.\n     *\n     * Props that do not have an explicit transfer strategy will be transferred\n     * only if the target component does not already have the prop set.\n     *\n     * This is usually used to pass down props to a returned root component.\n     *\n     * @param {ReactElement} element Component receiving the properties.\n     * @return {ReactElement} The supplied `component`.\n     * @final\n     * @protected\n     */\n    transferPropsTo: function(element) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        element._owner === this,\n        '%s: You can\\'t call transferPropsTo() on a component that you ' +\n        'don\\'t own, %s. This usually means you are calling ' +\n        'transferPropsTo() on a component passed in as props or children.',\n        this.constructor.displayName,\n        typeof element.type === 'string' ?\n        element.type :\n        element.type.displayName\n      ) : invariant(element._owner === this));\n\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (!didWarn) {\n          didWarn = true;\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'transferPropsTo is deprecated. ' +\n            'See http://fb.me/react-transferpropsto for more information.'\n          ) : null);\n        }\n      }\n\n      // Because elements are immutable we have to merge into the existing\n      // props object rather than clone it.\n      transferInto(element.props, this.props);\n\n      return element;\n    }\n\n  }\n};\n\nmodule.exports = ReactPropTransferer;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTransferer.js\n ** module id = 140\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTransferer.js?");

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypeLocations\n */\n\n\"use strict\";\n\nvar keyMirror = __webpack_require__(126);\n\nvar ReactPropTypeLocations = keyMirror({\n  prop: null,\n  context: null,\n  childContext: null\n});\n\nmodule.exports = ReactPropTypeLocations;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypeLocations.js\n ** module id = 141\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypeLocations.js?");

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPropTypeLocationNames\n */\n\n\"use strict\";\n\nvar ReactPropTypeLocationNames = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  ReactPropTypeLocationNames = {\n    prop: 'prop',\n    context: 'context',\n    childContext: 'child context'\n  };\n}\n\nmodule.exports = ReactPropTypeLocationNames;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPropTypeLocationNames.js\n ** module id = 142\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPropTypeLocationNames.js?");

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule keyOf\n */\n\n/**\n * Allows extraction of a minified key. Let's the build system minify keys\n * without loosing the ability to dynamically use key strings as values\n * themselves. Pass in an object with a single key/val pair and it will return\n * you the string key of that single record. Suppose you want to grab the\n * value for a key 'className' inside of an object. Key/val minification may\n * have aliased that key to be 'xa12'. keyOf({className: null}) will return\n * 'xa12' in that case. Resolve keys you want to use once at startup time, then\n * reuse those resolutions.\n */\nvar keyOf = function(oneKeyObj) {\n  var key;\n  for (key in oneKeyObj) {\n    if (!oneKeyObj.hasOwnProperty(key)) {\n      continue;\n    }\n    return key;\n  }\n  return null;\n};\n\n\nmodule.exports = keyOf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/keyOf.js\n ** module id = 143\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/keyOf.js?");

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule mapObject\n */\n\n'use strict';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Executes the provided `callback` once for each enumerable own property in the\n * object and constructs a new object from the results. The `callback` is\n * invoked with three arguments:\n *\n *  - the property value\n *  - the property name\n *  - the object being traversed\n *\n * Properties that are added after the call to `mapObject` will not be visited\n * by `callback`. If the values of existing properties are changed, the value\n * passed to `callback` will be the value at the time `mapObject` visits them.\n * Properties that are deleted before being visited are not visited.\n *\n * @grep function objectMap()\n * @grep function objMap()\n *\n * @param {?object} object\n * @param {function} callback\n * @param {*} context\n * @return {?object}\n */\nfunction mapObject(object, callback, context) {\n  if (!object) {\n    return null;\n  }\n  var result = {};\n  for (var name in object) {\n    if (hasOwnProperty.call(object, name)) {\n      result[name] = callback.call(context, object[name], name, object);\n    }\n  }\n  return result;\n}\n\nmodule.exports = mapObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/mapObject.js\n ** module id = 144\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/mapObject.js?");

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSPropertyOperations\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar CSSProperty = __webpack_require__(210);\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar camelizeStyleName = __webpack_require__(211);\nvar dangerousStyleValue = __webpack_require__(212);\nvar hyphenateStyleName = __webpack_require__(213);\nvar memoizeStringOnly = __webpack_require__(134);\nvar warning = __webpack_require__(38);\n\nvar processStyleName = memoizeStringOnly(function(styleName) {\n  return hyphenateStyleName(styleName);\n});\n\nvar styleFloatAccessor = 'cssFloat';\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8 only supports accessing cssFloat (standard) as styleFloat\n  if (document.documentElement.style.cssFloat === undefined) {\n    styleFloatAccessor = 'styleFloat';\n  }\n}\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var warnedStyleNames = {};\n\n  var warnHyphenatedStyleName = function(name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      false,\n      'Unsupported style property ' + name + '. Did you mean ' +\n      camelizeStyleName(name) + '?'\n    ) : null);\n  };\n}\n\n/**\n * Operations for dealing with CSS properties.\n */\nvar CSSPropertyOperations = {\n\n  /**\n   * Serializes a mapping of style properties for use as inline styles:\n   *\n   *   > createMarkupForStyles({width: '200px', height: 0})\n   *   \"width:200px;height:0;\"\n   *\n   * Undefined values are ignored so that declarative programming is easier.\n   * The result should be HTML-escaped before insertion into the DOM.\n   *\n   * @param {object} styles\n   * @return {?string}\n   */\n  createMarkupForStyles: function(styles) {\n    var serialized = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (styleName.indexOf('-') > -1) {\n          warnHyphenatedStyleName(styleName);\n        }\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        serialized += processStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue) + ';';\n      }\n    }\n    return serialized || null;\n  },\n\n  /**\n   * Sets the value for multiple styles on a node.  If a value is specified as\n   * '' (empty string), the corresponding style property will be unset.\n   *\n   * @param {DOMElement} node\n   * @param {object} styles\n   */\n  setValueForStyles: function(node, styles) {\n    var style = node.style;\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      if (\"production\" !== process.env.NODE_ENV) {\n        if (styleName.indexOf('-') > -1) {\n          warnHyphenatedStyleName(styleName);\n        }\n      }\n      var styleValue = dangerousStyleValue(styleName, styles[styleName]);\n      if (styleName === 'float') {\n        styleName = styleFloatAccessor;\n      }\n      if (styleValue) {\n        style[styleName] = styleValue;\n      } else {\n        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];\n        if (expansion) {\n          // Shorthand property that IE8 won't like unsetting, so unset each\n          // component to placate it\n          for (var individualStyleName in expansion) {\n            style[individualStyleName] = '';\n          }\n        } else {\n          style[styleName] = '';\n        }\n      }\n    }\n  }\n\n};\n\nmodule.exports = CSSPropertyOperations;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSPropertyOperations.js\n ** module id = 145\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSPropertyOperations.js?");

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactBrowserComponentMixin\n */\n\n\"use strict\";\n\nvar ReactEmptyComponent = __webpack_require__(58);\nvar ReactMount = __webpack_require__(10);\n\nvar invariant = __webpack_require__(36);\n\nvar ReactBrowserComponentMixin = {\n  /**\n   * Returns the DOM node rendered by this component.\n   *\n   * @return {DOMElement} The root node of this component.\n   * @final\n   * @protected\n   */\n  getDOMNode: function() {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      this.isMounted(),\n      'getDOMNode(): A component must be mounted to have a DOM node.'\n    ) : invariant(this.isMounted()));\n    if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {\n      return null;\n    }\n    return ReactMount.getNode(this._rootNodeID);\n  }\n};\n\nmodule.exports = ReactBrowserComponentMixin;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactBrowserComponentMixin.js\n ** module id = 146\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactBrowserComponentMixin.js?");

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule BeforeInputEventPlugin\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPropagators = __webpack_require__(214);\nvar ExecutionEnvironment = __webpack_require__(75);\nvar SyntheticInputEvent = __webpack_require__(215);\n\nvar keyOf = __webpack_require__(143);\n\nvar canUseTextInputEvent = (\n  ExecutionEnvironment.canUseDOM &&\n  'TextEvent' in window &&\n  !('documentMode' in document || isPresto())\n);\n\n/**\n * Opera <= 12 includes TextEvent in window, but does not fire\n * text input events. Rely on keypress instead.\n */\nfunction isPresto() {\n  var opera = window.opera;\n  return (\n    typeof opera === 'object' &&\n    typeof opera.version === 'function' &&\n    parseInt(opera.version(), 10) <= 12\n  );\n}\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onBeforeInput: null}),\n      captured: keyOf({onBeforeInputCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topCompositionEnd,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topTextInput,\n      topLevelTypes.topPaste\n    ]\n  }\n};\n\n// Track characters inserted via keypress and composition events.\nvar fallbackChars = null;\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (\n    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n    // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n    !(nativeEvent.ctrlKey && nativeEvent.altKey)\n  );\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n */\nvar BeforeInputEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    var chars;\n\n    if (canUseTextInputEvent) {\n      switch (topLevelType) {\n        case topLevelTypes.topKeyPress:\n          /**\n           * If native `textInput` events are available, our goal is to make\n           * use of them. However, there is a special case: the spacebar key.\n           * In Webkit, preventing default on a spacebar `textInput` event\n           * cancels character insertion, but it *also* causes the browser\n           * to fall back to its default spacebar behavior of scrolling the\n           * page.\n           *\n           * Tracking at:\n           * https://code.google.com/p/chromium/issues/detail?id=355103\n           *\n           * To avoid this issue, use the keypress event as if no `textInput`\n           * event is available.\n           */\n          var which = nativeEvent.which;\n          if (which !== SPACEBAR_CODE) {\n            return;\n          }\n\n          hasSpaceKeypress = true;\n          chars = SPACEBAR_CHAR;\n          break;\n\n        case topLevelTypes.topTextInput:\n          // Record the characters to be added to the DOM.\n          chars = nativeEvent.data;\n\n          // If it's a spacebar character, assume that we have already handled\n          // it at the keypress level and bail immediately. Android Chrome\n          // doesn't give us keycodes, so we need to blacklist it.\n          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n            return;\n          }\n\n          // Otherwise, carry on.\n          break;\n\n        default:\n          // For other native event types, do nothing.\n          return;\n      }\n    } else {\n      switch (topLevelType) {\n        case topLevelTypes.topPaste:\n          // If a paste event occurs after a keypress, throw out the input\n          // chars. Paste events should not lead to BeforeInput events.\n          fallbackChars = null;\n          break;\n        case topLevelTypes.topKeyPress:\n          /**\n           * As of v27, Firefox may fire keypress events even when no character\n           * will be inserted. A few possibilities:\n           *\n           * - `which` is `0`. Arrow keys, Esc key, etc.\n           *\n           * - `which` is the pressed key code, but no char is available.\n           *   Ex: 'AltGr + d` in Polish. There is no modified character for\n           *   this key combination and no character is inserted into the\n           *   document, but FF fires the keypress for char code `100` anyway.\n           *   No `input` event will occur.\n           *\n           * - `which` is the pressed key code, but a command combination is\n           *   being used. Ex: `Cmd+C`. No character is inserted, and no\n           *   `input` event will occur.\n           */\n          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {\n            fallbackChars = String.fromCharCode(nativeEvent.which);\n          }\n          break;\n        case topLevelTypes.topCompositionEnd:\n          fallbackChars = nativeEvent.data;\n          break;\n      }\n\n      // If no changes have occurred to the fallback string, no relevant\n      // event has fired and we're done.\n      if (fallbackChars === null) {\n        return;\n      }\n\n      chars = fallbackChars;\n    }\n\n    // If no characters are being inserted, no BeforeInput event should\n    // be fired.\n    if (!chars) {\n      return;\n    }\n\n    var event = SyntheticInputEvent.getPooled(\n      eventTypes.beforeInput,\n      topLevelTargetID,\n      nativeEvent\n    );\n\n    event.data = chars;\n    fallbackChars = null;\n    EventPropagators.accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nmodule.exports = BeforeInputEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/BeforeInputEventPlugin.js\n ** module id = 147\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/BeforeInputEventPlugin.js?");

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ChangeEventPlugin\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPluginHub = __webpack_require__(47);\nvar EventPropagators = __webpack_require__(214);\nvar ExecutionEnvironment = __webpack_require__(75);\nvar ReactUpdates = __webpack_require__(138);\nvar SyntheticEvent = __webpack_require__(216);\n\nvar isEventSupported = __webpack_require__(52);\nvar isTextInputElement = __webpack_require__(217);\nvar keyOf = __webpack_require__(143);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onChange: null}),\n      captured: keyOf({onChangeCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topChange,\n      topLevelTypes.topClick,\n      topLevelTypes.topFocus,\n      topLevelTypes.topInput,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topSelectionChange\n    ]\n  }\n};\n\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementID = null;\nvar activeElementValue = null;\nvar activeElementValueProp = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  return (\n    elem.nodeName === 'SELECT' ||\n    (elem.nodeName === 'INPUT' && elem.type === 'file')\n  );\n}\n\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (\n    !('documentMode' in document) || document.documentMode > 8\n  );\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = SyntheticEvent.getPooled(\n    eventTypes.change,\n    activeElementID,\n    nativeEvent\n  );\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue();\n}\n\nfunction startWatchingForChangeEventIE8(target, targetID) {\n  activeElement = target;\n  activeElementID = targetID;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementID = null;\n}\n\nfunction getTargetIDForChangeEvent(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topChange) {\n    return topLevelTargetID;\n  }\n}\nfunction handleEventsForChangeEventIE8(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topFocus) {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);\n  } else if (topLevelType === topLevelTypes.topBlur) {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events\n  isInputEventSupported = isEventSupported('input') && (\n    !('documentMode' in document) || document.documentMode > 9\n  );\n}\n\n/**\n * (For old IE.) Replacement getter/setter for the `value` property that gets\n * set on the active element.\n */\nvar newValueProp =  {\n  get: function() {\n    return activeElementValueProp.get.call(this);\n  },\n  set: function(val) {\n    // Cast to a string so we can do equality checks.\n    activeElementValue = '' + val;\n    activeElementValueProp.set.call(this, val);\n  }\n};\n\n/**\n * (For old IE.) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetID) {\n  activeElement = target;\n  activeElementID = targetID;\n  activeElementValue = target.value;\n  activeElementValueProp = Object.getOwnPropertyDescriptor(\n    target.constructor.prototype,\n    'value'\n  );\n\n  Object.defineProperty(activeElement, 'value', newValueProp);\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For old IE.) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  // delete restores the original property definition\n  delete activeElement.value;\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n\n  activeElement = null;\n  activeElementID = null;\n  activeElementValue = null;\n  activeElementValueProp = null;\n}\n\n/**\n * (For old IE.) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  var value = nativeEvent.srcElement.value;\n  if (value === activeElementValue) {\n    return;\n  }\n  activeElementValue = value;\n\n  manualDispatchChangeEvent(nativeEvent);\n}\n\n/**\n * If a `change` event should be fired, returns the target's ID.\n */\nfunction getTargetIDForInputEvent(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topInput) {\n    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly\n    // what we want so fall through here and trigger an abstract event\n    return topLevelTargetID;\n  }\n}\n\n// For IE8 and IE9.\nfunction handleEventsForInputEventIE(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topFocus) {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(topLevelTarget, topLevelTargetID);\n  } else if (topLevelType === topLevelTypes.topBlur) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetIDForInputEventIE(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topSelectionChange ||\n      topLevelType === topLevelTypes.topKeyUp ||\n      topLevelType === topLevelTypes.topKeyDown) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    if (activeElement && activeElement.value !== activeElementValue) {\n      activeElementValue = activeElement.value;\n      return activeElementID;\n    }\n  }\n}\n\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  return (\n    elem.nodeName === 'INPUT' &&\n    (elem.type === 'checkbox' || elem.type === 'radio')\n  );\n}\n\nfunction getTargetIDForClickEvent(\n    topLevelType,\n    topLevelTarget,\n    topLevelTargetID) {\n  if (topLevelType === topLevelTypes.topClick) {\n    return topLevelTargetID;\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    var getTargetIDFunc, handleEventFunc;\n    if (shouldUseChangeEvent(topLevelTarget)) {\n      if (doesChangeEventBubble) {\n        getTargetIDFunc = getTargetIDForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(topLevelTarget)) {\n      if (isInputEventSupported) {\n        getTargetIDFunc = getTargetIDForInputEvent;\n      } else {\n        getTargetIDFunc = getTargetIDForInputEventIE;\n        handleEventFunc = handleEventsForInputEventIE;\n      }\n    } else if (shouldUseClickEvent(topLevelTarget)) {\n      getTargetIDFunc = getTargetIDForClickEvent;\n    }\n\n    if (getTargetIDFunc) {\n      var targetID = getTargetIDFunc(\n        topLevelType,\n        topLevelTarget,\n        topLevelTargetID\n      );\n      if (targetID) {\n        var event = SyntheticEvent.getPooled(\n          eventTypes.change,\n          targetID,\n          nativeEvent\n        );\n        EventPropagators.accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(\n        topLevelType,\n        topLevelTarget,\n        topLevelTargetID\n      );\n    }\n  }\n\n};\n\nmodule.exports = ChangeEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ChangeEventPlugin.js\n ** module id = 148\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ChangeEventPlugin.js?");

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ClientReactRootIndex\n * @typechecks\n */\n\n\"use strict\";\n\nvar nextReactRootIndex = 0;\n\nvar ClientReactRootIndex = {\n  createReactRootIndex: function() {\n    return nextReactRootIndex++;\n  }\n};\n\nmodule.exports = ClientReactRootIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ClientReactRootIndex.js\n ** module id = 149\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ClientReactRootIndex.js?");

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CompositionEventPlugin\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPropagators = __webpack_require__(214);\nvar ExecutionEnvironment = __webpack_require__(75);\nvar ReactInputSelection = __webpack_require__(218);\nvar SyntheticCompositionEvent = __webpack_require__(219);\n\nvar getTextContentAccessor = __webpack_require__(220);\nvar keyOf = __webpack_require__(143);\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar useCompositionEvent = (\n  ExecutionEnvironment.canUseDOM &&\n  'CompositionEvent' in window\n);\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. In Korean, for example,\n// the compositionend event contains only one character regardless of\n// how many characters have been composed since compositionstart.\n// We therefore use the fallback data while still using the native\n// events as triggers.\nvar useFallbackData = (\n  !useCompositionEvent ||\n  (\n    'documentMode' in document &&\n    document.documentMode > 8 &&\n    document.documentMode <= 11\n  )\n);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\nvar currentComposition = null;\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCompositionEnd: null}),\n      captured: keyOf({onCompositionEndCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topCompositionEnd,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topMouseDown\n    ]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCompositionStart: null}),\n      captured: keyOf({onCompositionStartCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topCompositionStart,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topMouseDown\n    ]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCompositionUpdate: null}),\n      captured: keyOf({onCompositionUpdateCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topCompositionUpdate,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topKeyPress,\n      topLevelTypes.topKeyUp,\n      topLevelTypes.topMouseDown\n    ]\n  }\n};\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case topLevelTypes.topCompositionStart:\n      return eventTypes.compositionStart;\n    case topLevelTypes.topCompositionEnd:\n      return eventTypes.compositionEnd;\n    case topLevelTypes.topCompositionUpdate:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackStart(topLevelType, nativeEvent) {\n  return (\n    topLevelType === topLevelTypes.topKeyDown &&\n    nativeEvent.keyCode === START_KEYCODE\n  );\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case topLevelTypes.topKeyUp:\n      // Command keys insert or clear IME input.\n      return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);\n    case topLevelTypes.topKeyDown:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return (nativeEvent.keyCode !== START_KEYCODE);\n    case topLevelTypes.topKeyPress:\n    case topLevelTypes.topMouseDown:\n    case topLevelTypes.topBlur:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Helper class stores information about selection and document state\n * so we can figure out what changed at a later date.\n *\n * @param {DOMEventTarget} root\n */\nfunction FallbackCompositionState(root) {\n  this.root = root;\n  this.startSelection = ReactInputSelection.getSelection(root);\n  this.startValue = this.getText();\n}\n\n/**\n * Get current text of input.\n *\n * @return {string}\n */\nFallbackCompositionState.prototype.getText = function() {\n  return this.root.value || this.root[getTextContentAccessor()];\n};\n\n/**\n * Text that has changed since the start of composition.\n *\n * @return {string}\n */\nFallbackCompositionState.prototype.getData = function() {\n  var endValue = this.getText();\n  var prefixLength = this.startSelection.start;\n  var suffixLength = this.startValue.length - this.startSelection.end;\n\n  return endValue.substr(\n    prefixLength,\n    endValue.length - suffixLength - prefixLength\n  );\n};\n\n/**\n * This plugin creates `onCompositionStart`, `onCompositionUpdate` and\n * `onCompositionEnd` events on inputs, textareas and contentEditable\n * nodes.\n */\nvar CompositionEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    var eventType;\n    var data;\n\n    if (useCompositionEvent) {\n      eventType = getCompositionEventType(topLevelType);\n    } else if (!currentComposition) {\n      if (isFallbackStart(topLevelType, nativeEvent)) {\n        eventType = eventTypes.compositionStart;\n      }\n    } else if (isFallbackEnd(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionEnd;\n    }\n\n    if (useFallbackData) {\n      // The current composition is stored statically and must not be\n      // overwritten while composition continues.\n      if (!currentComposition && eventType === eventTypes.compositionStart) {\n        currentComposition = new FallbackCompositionState(topLevelTarget);\n      } else if (eventType === eventTypes.compositionEnd) {\n        if (currentComposition) {\n          data = currentComposition.getData();\n          currentComposition = null;\n        }\n      }\n    }\n\n    if (eventType) {\n      var event = SyntheticCompositionEvent.getPooled(\n        eventType,\n        topLevelTargetID,\n        nativeEvent\n      );\n      if (data) {\n        // Inject data generated from fallback path into the synthetic event.\n        // This matches the property of native CompositionEventInterface.\n        event.data = data;\n      }\n      EventPropagators.accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n  }\n};\n\nmodule.exports = CompositionEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CompositionEventPlugin.js\n ** module id = 150\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CompositionEventPlugin.js?");

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DefaultEventPluginOrder\n */\n\n\"use strict\";\n\n var keyOf = __webpack_require__(143);\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DefaultEventPluginOrder = [\n  keyOf({ResponderEventPlugin: null}),\n  keyOf({SimpleEventPlugin: null}),\n  keyOf({TapEventPlugin: null}),\n  keyOf({EnterLeaveEventPlugin: null}),\n  keyOf({ChangeEventPlugin: null}),\n  keyOf({SelectEventPlugin: null}),\n  keyOf({CompositionEventPlugin: null}),\n  keyOf({BeforeInputEventPlugin: null}),\n  keyOf({AnalyticsEventPlugin: null}),\n  keyOf({MobileSafariClickEventPlugin: null})\n];\n\nmodule.exports = DefaultEventPluginOrder;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DefaultEventPluginOrder.js\n ** module id = 151\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DefaultEventPluginOrder.js?");

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EnterLeaveEventPlugin\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPropagators = __webpack_require__(214);\nvar SyntheticMouseEvent = __webpack_require__(221);\n\nvar ReactMount = __webpack_require__(10);\nvar keyOf = __webpack_require__(143);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\nvar getFirstReactDOM = ReactMount.getFirstReactDOM;\n\nvar eventTypes = {\n  mouseEnter: {\n    registrationName: keyOf({onMouseEnter: null}),\n    dependencies: [\n      topLevelTypes.topMouseOut,\n      topLevelTypes.topMouseOver\n    ]\n  },\n  mouseLeave: {\n    registrationName: keyOf({onMouseLeave: null}),\n    dependencies: [\n      topLevelTypes.topMouseOut,\n      topLevelTypes.topMouseOver\n    ]\n  }\n};\n\nvar extractedEvents = [null, null];\n\nvar EnterLeaveEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    if (topLevelType === topLevelTypes.topMouseOver &&\n        (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n    if (topLevelType !== topLevelTypes.topMouseOut &&\n        topLevelType !== topLevelTypes.topMouseOver) {\n      // Must not be a mouse in or mouse out - ignoring.\n      return null;\n    }\n\n    var win;\n    if (topLevelTarget.window === topLevelTarget) {\n      // `topLevelTarget` is probably a window object.\n      win = topLevelTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = topLevelTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from, to;\n    if (topLevelType === topLevelTypes.topMouseOut) {\n      from = topLevelTarget;\n      to =\n        getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) ||\n        win;\n    } else {\n      from = win;\n      to = topLevelTarget;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var fromID = from ? ReactMount.getID(from) : '';\n    var toID = to ? ReactMount.getID(to) : '';\n\n    var leave = SyntheticMouseEvent.getPooled(\n      eventTypes.mouseLeave,\n      fromID,\n      nativeEvent\n    );\n    leave.type = 'mouseleave';\n    leave.target = from;\n    leave.relatedTarget = to;\n\n    var enter = SyntheticMouseEvent.getPooled(\n      eventTypes.mouseEnter,\n      toID,\n      nativeEvent\n    );\n    enter.type = 'mouseenter';\n    enter.target = to;\n    enter.relatedTarget = from;\n\n    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);\n\n    extractedEvents[0] = leave;\n    extractedEvents[1] = enter;\n\n    return extractedEvents;\n  }\n\n};\n\nmodule.exports = EnterLeaveEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EnterLeaveEventPlugin.js\n ** module id = 152\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EnterLeaveEventPlugin.js?");

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule HTMLDOMPropertyConfig\n */\n\n/*jslint bitwise: true*/\n\n\"use strict\";\n\nvar DOMProperty = __webpack_require__(25);\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;\nvar MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;\nvar HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;\nvar HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;\nvar HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;\nvar HAS_POSITIVE_NUMERIC_VALUE =\n  DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;\nvar HAS_OVERLOADED_BOOLEAN_VALUE =\n  DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;\n\nvar hasSVG;\nif (ExecutionEnvironment.canUseDOM) {\n  var implementation = document.implementation;\n  hasSVG = (\n    implementation &&\n    implementation.hasFeature &&\n    implementation.hasFeature(\n      'http://www.w3.org/TR/SVG11/feature#BasicStructure',\n      '1.1'\n    )\n  );\n}\n\n\nvar HTMLDOMPropertyConfig = {\n  isCustomAttribute: RegExp.prototype.test.bind(\n    /^(data|aria)-[a-z_][a-z\\d_.\\-]*$/\n  ),\n  Properties: {\n    /**\n     * Standard Properties\n     */\n    accept: null,\n    acceptCharset: null,\n    accessKey: null,\n    action: null,\n    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    allowTransparency: MUST_USE_ATTRIBUTE,\n    alt: null,\n    async: HAS_BOOLEAN_VALUE,\n    autoComplete: null,\n    // autoFocus is polyfilled/normalized by AutoFocusMixin\n    // autoFocus: HAS_BOOLEAN_VALUE,\n    autoPlay: HAS_BOOLEAN_VALUE,\n    cellPadding: null,\n    cellSpacing: null,\n    charSet: MUST_USE_ATTRIBUTE,\n    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    classID: MUST_USE_ATTRIBUTE,\n    // To set className on SVG elements, it's necessary to use .setAttribute;\n    // this works on HTML elements too in all browsers except IE8. Conveniently,\n    // IE8 doesn't support SVG and so we can simply use the attribute in\n    // browsers that support SVG and the property in browsers that don't,\n    // regardless of whether the element is HTML or SVG.\n    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,\n    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    colSpan: null,\n    content: null,\n    contentEditable: null,\n    contextMenu: MUST_USE_ATTRIBUTE,\n    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    coords: null,\n    crossOrigin: null,\n    data: null, // For `<object />` acts as `src`.\n    dateTime: MUST_USE_ATTRIBUTE,\n    defer: HAS_BOOLEAN_VALUE,\n    dir: null,\n    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    download: HAS_OVERLOADED_BOOLEAN_VALUE,\n    draggable: null,\n    encType: null,\n    form: MUST_USE_ATTRIBUTE,\n    formAction: MUST_USE_ATTRIBUTE,\n    formEncType: MUST_USE_ATTRIBUTE,\n    formMethod: MUST_USE_ATTRIBUTE,\n    formNoValidate: HAS_BOOLEAN_VALUE,\n    formTarget: MUST_USE_ATTRIBUTE,\n    frameBorder: MUST_USE_ATTRIBUTE,\n    height: MUST_USE_ATTRIBUTE,\n    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    href: null,\n    hrefLang: null,\n    htmlFor: null,\n    httpEquiv: null,\n    icon: null,\n    id: MUST_USE_PROPERTY,\n    label: null,\n    lang: null,\n    list: MUST_USE_ATTRIBUTE,\n    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    manifest: MUST_USE_ATTRIBUTE,\n    marginHeight: null,\n    marginWidth: null,\n    max: null,\n    maxLength: MUST_USE_ATTRIBUTE,\n    media: MUST_USE_ATTRIBUTE,\n    mediaGroup: null,\n    method: null,\n    min: null,\n    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    name: null,\n    noValidate: HAS_BOOLEAN_VALUE,\n    open: null,\n    pattern: null,\n    placeholder: null,\n    poster: null,\n    preload: null,\n    radioGroup: null,\n    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    rel: null,\n    required: HAS_BOOLEAN_VALUE,\n    role: MUST_USE_ATTRIBUTE,\n    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    rowSpan: null,\n    sandbox: null,\n    scope: null,\n    scrolling: null,\n    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,\n    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n    shape: null,\n    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,\n    sizes: MUST_USE_ATTRIBUTE,\n    span: HAS_POSITIVE_NUMERIC_VALUE,\n    spellCheck: null,\n    src: null,\n    srcDoc: MUST_USE_PROPERTY,\n    srcSet: MUST_USE_ATTRIBUTE,\n    start: HAS_NUMERIC_VALUE,\n    step: null,\n    style: null,\n    tabIndex: null,\n    target: null,\n    title: null,\n    type: null,\n    useMap: null,\n    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,\n    width: MUST_USE_ATTRIBUTE,\n    wmode: MUST_USE_ATTRIBUTE,\n\n    /**\n     * Non-standard Properties\n     */\n    autoCapitalize: null, // Supported in Mobile Safari for keyboard hints\n    autoCorrect: null, // Supported in Mobile Safari for keyboard hints\n    itemProp: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html\n    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, // Microdata: http://schema.org/docs/gs.html\n    itemType: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html\n    property: null // Supports OG in meta tags\n  },\n  DOMAttributeNames: {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n  },\n  DOMPropertyNames: {\n    autoCapitalize: 'autocapitalize',\n    autoComplete: 'autocomplete',\n    autoCorrect: 'autocorrect',\n    autoFocus: 'autofocus',\n    autoPlay: 'autoplay',\n    encType: 'enctype',\n    hrefLang: 'hreflang',\n    radioGroup: 'radiogroup',\n    spellCheck: 'spellcheck',\n    srcDoc: 'srcdoc',\n    srcSet: 'srcset'\n  }\n};\n\nmodule.exports = HTMLDOMPropertyConfig;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/HTMLDOMPropertyConfig.js\n ** module id = 153\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/HTMLDOMPropertyConfig.js?");

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule MobileSafariClickEventPlugin\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\n\nvar emptyFunction = __webpack_require__(59);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\n/**\n * Mobile Safari does not fire properly bubble click events on non-interactive\n * elements, which means delegated click listeners do not fire. The workaround\n * for this bug involves attaching an empty click listener on the target node.\n *\n * This particular plugin works around the bug by attaching an empty click\n * listener on `touchstart` (which does fire on every element).\n */\nvar MobileSafariClickEventPlugin = {\n\n  eventTypes: null,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    if (topLevelType === topLevelTypes.topTouchStart) {\n      var target = nativeEvent.target;\n      if (target && !target.onclick) {\n        target.onclick = emptyFunction;\n      }\n    }\n  }\n\n};\n\nmodule.exports = MobileSafariClickEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/MobileSafariClickEventPlugin.js\n ** module id = 154\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/MobileSafariClickEventPlugin.js?");

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactComponentBrowserEnvironment\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar ReactDOMIDOperations = __webpack_require__(222);\nvar ReactMarkupChecksum = __webpack_require__(174);\nvar ReactMount = __webpack_require__(10);\nvar ReactPerf = __webpack_require__(31);\nvar ReactReconcileTransaction = __webpack_require__(223);\n\nvar getReactRootElementInContainer = __webpack_require__(34);\nvar invariant = __webpack_require__(36);\nvar setInnerHTML = __webpack_require__(224);\n\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n\n/**\n * Abstracts away all functionality of `ReactComponent` requires knowledge of\n * the browser context.\n */\nvar ReactComponentBrowserEnvironment = {\n  ReactReconcileTransaction: ReactReconcileTransaction,\n\n  BackendIDOperations: ReactDOMIDOperations,\n\n  /**\n   * If a particular environment requires that some resources be cleaned up,\n   * specify this in the injected Mixin. In the DOM, we would likely want to\n   * purge any cached node ID lookups.\n   *\n   * @private\n   */\n  unmountIDFromEnvironment: function(rootNodeID) {\n    ReactMount.purgeID(rootNodeID);\n  },\n\n  /**\n   * @param {string} markup Markup string to place into the DOM Element.\n   * @param {DOMElement} container DOM Element to insert markup into.\n   * @param {boolean} shouldReuseMarkup Should reuse the existing markup in the\n   * container if possible.\n   */\n  mountImageIntoNode: ReactPerf.measure(\n    'ReactComponentBrowserEnvironment',\n    'mountImageIntoNode',\n    function(markup, container, shouldReuseMarkup) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        container && (\n          container.nodeType === ELEMENT_NODE_TYPE ||\n            container.nodeType === DOC_NODE_TYPE\n        ),\n        'mountComponentIntoNode(...): Target container is not valid.'\n      ) : invariant(container && (\n        container.nodeType === ELEMENT_NODE_TYPE ||\n          container.nodeType === DOC_NODE_TYPE\n      )));\n\n      if (shouldReuseMarkup) {\n        if (ReactMarkupChecksum.canReuseMarkup(\n          markup,\n          getReactRootElementInContainer(container))) {\n          return;\n        } else {\n          (\"production\" !== process.env.NODE_ENV ? invariant(\n            container.nodeType !== DOC_NODE_TYPE,\n            'You\\'re trying to render a component to the document using ' +\n            'server rendering but the checksum was invalid. This usually ' +\n            'means you rendered a different component type or props on ' +\n            'the client from the one on the server, or your render() ' +\n            'methods are impure. React cannot handle this case due to ' +\n            'cross-browser quirks by rendering at the document root. You ' +\n            'should look for environment dependent code in your components ' +\n            'and ensure the props are the same client and server side.'\n          ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n          if (\"production\" !== process.env.NODE_ENV) {\n            console.warn(\n              'React attempted to use reuse markup in a container but the ' +\n              'checksum was invalid. This generally means that you are ' +\n              'using server rendering and the markup generated on the ' +\n              'server was not what the client was expecting. React injected ' +\n              'new markup to compensate which works but you have lost many ' +\n              'of the benefits of server rendering. Instead, figure out ' +\n              'why the markup being generated is different on the client ' +\n              'or server.'\n            );\n          }\n        }\n      }\n\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        container.nodeType !== DOC_NODE_TYPE,\n        'You\\'re trying to render a component to the document but ' +\n          'you didn\\'t use server rendering. We can\\'t do this ' +\n          'without using server rendering due to cross-browser quirks. ' +\n          'See renderComponentToString() for server rendering.'\n      ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n      setInnerHTML(container, markup);\n    }\n  )\n};\n\nmodule.exports = ReactComponentBrowserEnvironment;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactComponentBrowserEnvironment.js\n ** module id = 155\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactComponentBrowserEnvironment.js?");

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultBatchingStrategy\n */\n\n\"use strict\";\n\nvar ReactUpdates = __webpack_require__(138);\nvar Transaction = __webpack_require__(208);\n\nvar assign = __webpack_require__(51);\nvar emptyFunction = __webpack_require__(59);\n\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  }\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)\n};\n\nvar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n\nfunction ReactDefaultBatchingStrategyTransaction() {\n  this.reinitializeTransaction();\n}\n\nassign(\n  ReactDefaultBatchingStrategyTransaction.prototype,\n  Transaction.Mixin,\n  {\n    getTransactionWrappers: function() {\n      return TRANSACTION_WRAPPERS;\n    }\n  }\n);\n\nvar transaction = new ReactDefaultBatchingStrategyTransaction();\n\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function(callback, a, b) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      callback(a, b);\n    } else {\n      transaction.perform(callback, null, a, b);\n    }\n  }\n};\n\nmodule.exports = ReactDefaultBatchingStrategy;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultBatchingStrategy.js\n ** module id = 156\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultBatchingStrategy.js?");

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMButton\n */\n\n\"use strict\";\n\nvar AutoFocusMixin = __webpack_require__(225);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\n\nvar keyMirror = __webpack_require__(126);\n\n// Store a reference to the <button> `ReactDOMComponent`. TODO: use string\nvar button = ReactElement.createFactory(ReactDOM.button.type);\n\nvar mouseListenerNames = keyMirror({\n  onClick: true,\n  onDoubleClick: true,\n  onMouseDown: true,\n  onMouseMove: true,\n  onMouseUp: true,\n  onClickCapture: true,\n  onDoubleClickCapture: true,\n  onMouseDownCapture: true,\n  onMouseMoveCapture: true,\n  onMouseUpCapture: true\n});\n\n/**\n * Implements a <button> native component that does not receive mouse events\n * when `disabled` is set.\n */\nvar ReactDOMButton = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMButton',\n\n  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],\n\n  render: function() {\n    var props = {};\n\n    // Copy the props; except the mouse listeners if we're disabled\n    for (var key in this.props) {\n      if (this.props.hasOwnProperty(key) &&\n          (!this.props.disabled || !mouseListenerNames[key])) {\n        props[key] = this.props[key];\n      }\n    }\n\n    return button(props, this.props.children);\n  }\n\n});\n\nmodule.exports = ReactDOMButton;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMButton.js\n ** module id = 157\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMButton.js?");

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMForm\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar LocalEventTrapMixin = __webpack_require__(226);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\n\n// Store a reference to the <form> `ReactDOMComponent`. TODO: use string\nvar form = ReactElement.createFactory(ReactDOM.form.type);\n\n/**\n * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need\n * to capture it on the <form> element itself. There are lots of hacks we could\n * do to accomplish this, but the most reliable is to make <form> a\n * composite component and use `componentDidMount` to attach the event handlers.\n */\nvar ReactDOMForm = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMForm',\n\n  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],\n\n  render: function() {\n    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,\n    // `jshint` fails to parse JSX so in order for linting to work in the open\n    // source repo, we need to just use `ReactDOM.form`.\n    return form(this.props);\n  },\n\n  componentDidMount: function() {\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');\n  }\n});\n\nmodule.exports = ReactDOMForm;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMForm.js\n ** module id = 158\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMForm.js?");

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMImg\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar LocalEventTrapMixin = __webpack_require__(226);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\n\n// Store a reference to the <img> `ReactDOMComponent`. TODO: use string\nvar img = ReactElement.createFactory(ReactDOM.img.type);\n\n/**\n * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to\n * capture it on the <img> element itself. There are lots of hacks we could do\n * to accomplish this, but the most reliable is to make <img> a composite\n * component and use `componentDidMount` to attach the event handlers.\n */\nvar ReactDOMImg = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMImg',\n  tagName: 'IMG',\n\n  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],\n\n  render: function() {\n    return img(this.props);\n  },\n\n  componentDidMount: function() {\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');\n    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');\n  }\n});\n\nmodule.exports = ReactDOMImg;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMImg.js\n ** module id = 159\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMImg.js?");

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMInput\n */\n\n\"use strict\";\n\nvar AutoFocusMixin = __webpack_require__(225);\nvar DOMPropertyOperations = __webpack_require__(61);\nvar LinkedValueUtils = __webpack_require__(227);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\nvar ReactMount = __webpack_require__(10);\nvar ReactUpdates = __webpack_require__(138);\n\nvar assign = __webpack_require__(51);\nvar invariant = __webpack_require__(36);\n\n// Store a reference to the <input> `ReactDOMComponent`. TODO: use string\nvar input = ReactElement.createFactory(ReactDOM.input.type);\n\nvar instancesByReactID = {};\n\nfunction forceUpdateIfMounted() {\n  /*jshint validthis:true */\n  if (this.isMounted()) {\n    this.forceUpdate();\n  }\n}\n\n/**\n * Implements an <input> native component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\nvar ReactDOMInput = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMInput',\n\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n\n  getInitialState: function() {\n    var defaultValue = this.props.defaultValue;\n    return {\n      initialChecked: this.props.defaultChecked || false,\n      initialValue: defaultValue != null ? defaultValue : null\n    };\n  },\n\n  render: function() {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n\n    props.defaultChecked = null;\n    props.defaultValue = null;\n\n    var value = LinkedValueUtils.getValue(this);\n    props.value = value != null ? value : this.state.initialValue;\n\n    var checked = LinkedValueUtils.getChecked(this);\n    props.checked = checked != null ? checked : this.state.initialChecked;\n\n    props.onChange = this._handleChange;\n\n    return input(props, this.props.children);\n  },\n\n  componentDidMount: function() {\n    var id = ReactMount.getID(this.getDOMNode());\n    instancesByReactID[id] = this;\n  },\n\n  componentWillUnmount: function() {\n    var rootNode = this.getDOMNode();\n    var id = ReactMount.getID(rootNode);\n    delete instancesByReactID[id];\n  },\n\n  componentDidUpdate: function(prevProps, prevState, prevContext) {\n    var rootNode = this.getDOMNode();\n    if (this.props.checked != null) {\n      DOMPropertyOperations.setValueForProperty(\n        rootNode,\n        'checked',\n        this.props.checked || false\n      );\n    }\n\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null) {\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);\n    }\n  },\n\n  _handleChange: function(event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n    // Here we use asap to wait until all updates have propagated, which\n    // is important when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    ReactUpdates.asap(forceUpdateIfMounted, this);\n\n    var name = this.props.name;\n    if (this.props.type === 'radio' && name != null) {\n      var rootNode = this.getDOMNode();\n      var queryRoot = rootNode;\n\n      while (queryRoot.parentNode) {\n        queryRoot = queryRoot.parentNode;\n      }\n\n      // If `rootNode.form` was non-null, then we could try `form.elements`,\n      // but that sometimes behaves strangely in IE8. We could also try using\n      // `form.getElementsByName`, but that will only return direct children\n      // and won't include inputs that use the HTML5 `form=` attribute. Since\n      // the input might not even be in a form, let's just use the global\n      // `querySelectorAll` to ensure we don't miss anything.\n      var group = queryRoot.querySelectorAll(\n        'input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n      for (var i = 0, groupLen = group.length; i < groupLen; i++) {\n        var otherNode = group[i];\n        if (otherNode === rootNode ||\n            otherNode.form !== rootNode.form) {\n          continue;\n        }\n        var otherID = ReactMount.getID(otherNode);\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          otherID,\n          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +\n          'same `name` is not supported.'\n        ) : invariant(otherID));\n        var otherInstance = instancesByReactID[otherID];\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          otherInstance,\n          'ReactDOMInput: Unknown radio button ID %s.',\n          otherID\n        ) : invariant(otherInstance));\n        // If this is a controlled radio button group, forcing the input that\n        // was previously checked to update will cause it to be come re-checked\n        // as appropriate.\n        ReactUpdates.asap(forceUpdateIfMounted, otherInstance);\n      }\n    }\n\n    return returnValue;\n  }\n\n});\n\nmodule.exports = ReactDOMInput;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMInput.js\n ** module id = 160\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMInput.js?");

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMOption\n */\n\n\"use strict\";\n\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\n\nvar warning = __webpack_require__(38);\n\n// Store a reference to the <option> `ReactDOMComponent`. TODO: use string\nvar option = ReactElement.createFactory(ReactDOM.option.type);\n\n/**\n * Implements an <option> native component that warns when `selected` is set.\n */\nvar ReactDOMOption = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMOption',\n\n  mixins: [ReactBrowserComponentMixin],\n\n  componentWillMount: function() {\n    // TODO (yungsters): Remove support for `selected` in <option>.\n    if (\"production\" !== process.env.NODE_ENV) {\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        this.props.selected == null,\n        'Use the `defaultValue` or `value` props on <select> instead of ' +\n        'setting `selected` on <option>.'\n      ) : null);\n    }\n  },\n\n  render: function() {\n    return option(this.props, this.props.children);\n  }\n\n});\n\nmodule.exports = ReactDOMOption;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMOption.js\n ** module id = 161\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMOption.js?");

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelect\n */\n\n\"use strict\";\n\nvar AutoFocusMixin = __webpack_require__(225);\nvar LinkedValueUtils = __webpack_require__(227);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\nvar ReactUpdates = __webpack_require__(138);\n\nvar assign = __webpack_require__(51);\n\n// Store a reference to the <select> `ReactDOMComponent`. TODO: use string\nvar select = ReactElement.createFactory(ReactDOM.select.type);\n\nfunction updateWithPendingValueIfMounted() {\n  /*jshint validthis:true */\n  if (this.isMounted()) {\n    this.setState({value: this._pendingValue});\n    this._pendingValue = 0;\n  }\n}\n\n/**\n * Validation function for `value` and `defaultValue`.\n * @private\n */\nfunction selectValueType(props, propName, componentName) {\n  if (props[propName] == null) {\n    return;\n  }\n  if (props.multiple) {\n    if (!Array.isArray(props[propName])) {\n      return new Error(\n        (\"The `\" + propName + \"` prop supplied to <select> must be an array if \") +\n        (\"`multiple` is true.\")\n      );\n    }\n  } else {\n    if (Array.isArray(props[propName])) {\n      return new Error(\n        (\"The `\" + propName + \"` prop supplied to <select> must be a scalar \") +\n        (\"value if `multiple` is false.\")\n      );\n    }\n  }\n}\n\n/**\n * If `value` is supplied, updates <option> elements on mount and update.\n * @param {ReactComponent} component Instance of ReactDOMSelect\n * @param {?*} propValue For uncontrolled components, null/undefined. For\n * controlled components, a string (or with `multiple`, a list of strings).\n * @private\n */\nfunction updateOptions(component, propValue) {\n  var multiple = component.props.multiple;\n  var value = propValue != null ? propValue : component.state.value;\n  var options = component.getDOMNode().options;\n  var selectedValue, i, l;\n  if (multiple) {\n    selectedValue = {};\n    for (i = 0, l = value.length; i < l; ++i) {\n      selectedValue['' + value[i]] = true;\n    }\n  } else {\n    selectedValue = '' + value;\n  }\n  for (i = 0, l = options.length; i < l; i++) {\n    var selected = multiple ?\n      selectedValue.hasOwnProperty(options[i].value) :\n      options[i].value === selectedValue;\n\n    if (selected !== options[i].selected) {\n      options[i].selected = selected;\n    }\n  }\n}\n\n/**\n * Implements a <select> native component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * string. If `multiple` is true, the prop must be an array of strings.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\nvar ReactDOMSelect = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMSelect',\n\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n\n  propTypes: {\n    defaultValue: selectValueType,\n    value: selectValueType\n  },\n\n  getInitialState: function() {\n    return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};\n  },\n\n  componentWillMount: function() {\n    this._pendingValue = null;\n  },\n\n  componentWillReceiveProps: function(nextProps) {\n    if (!this.props.multiple && nextProps.multiple) {\n      this.setState({value: [this.state.value]});\n    } else if (this.props.multiple && !nextProps.multiple) {\n      this.setState({value: this.state.value[0]});\n    }\n  },\n\n  render: function() {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n\n    props.onChange = this._handleChange;\n    props.value = null;\n\n    return select(props, this.props.children);\n  },\n\n  componentDidMount: function() {\n    updateOptions(this, LinkedValueUtils.getValue(this));\n  },\n\n  componentDidUpdate: function(prevProps) {\n    var value = LinkedValueUtils.getValue(this);\n    var prevMultiple = !!prevProps.multiple;\n    var multiple = !!this.props.multiple;\n    if (value != null || prevMultiple !== multiple) {\n      updateOptions(this, value);\n    }\n  },\n\n  _handleChange: function(event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n\n    var selectedValue;\n    if (this.props.multiple) {\n      selectedValue = [];\n      var options = event.target.options;\n      for (var i = 0, l = options.length; i < l; i++) {\n        if (options[i].selected) {\n          selectedValue.push(options[i].value);\n        }\n      }\n    } else {\n      selectedValue = event.target.value;\n    }\n\n    this._pendingValue = selectedValue;\n    ReactUpdates.asap(updateWithPendingValueIfMounted, this);\n    return returnValue;\n  }\n\n});\n\nmodule.exports = ReactDOMSelect;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelect.js\n ** module id = 162\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMSelect.js?");

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMTextarea\n */\n\n\"use strict\";\n\nvar AutoFocusMixin = __webpack_require__(225);\nvar DOMPropertyOperations = __webpack_require__(61);\nvar LinkedValueUtils = __webpack_require__(227);\nvar ReactBrowserComponentMixin = __webpack_require__(146);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\nvar ReactDOM = __webpack_require__(67);\nvar ReactUpdates = __webpack_require__(138);\n\nvar assign = __webpack_require__(51);\nvar invariant = __webpack_require__(36);\n\nvar warning = __webpack_require__(38);\n\n// Store a reference to the <textarea> `ReactDOMComponent`. TODO: use string\nvar textarea = ReactElement.createFactory(ReactDOM.textarea.type);\n\nfunction forceUpdateIfMounted() {\n  /*jshint validthis:true */\n  if (this.isMounted()) {\n    this.forceUpdate();\n  }\n}\n\n/**\n * Implements a <textarea> native component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\nvar ReactDOMTextarea = ReactCompositeComponent.createClass({\n  displayName: 'ReactDOMTextarea',\n\n  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],\n\n  getInitialState: function() {\n    var defaultValue = this.props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = this.props.children;\n    if (children != null) {\n      if (\"production\" !== process.env.NODE_ENV) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'Use the `defaultValue` or `value` props instead of setting ' +\n          'children on <textarea>.'\n        ) : null);\n      }\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        defaultValue == null,\n        'If you supply `defaultValue` on a <textarea>, do not pass children.'\n      ) : invariant(defaultValue == null));\n      if (Array.isArray(children)) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          children.length <= 1,\n          '<textarea> can only have at most one child.'\n        ) : invariant(children.length <= 1));\n        children = children[0];\n      }\n\n      defaultValue = '' + children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    var value = LinkedValueUtils.getValue(this);\n    return {\n      // We save the initial value so that `ReactDOMComponent` doesn't update\n      // `textContent` (unnecessary since we update value).\n      // The initial value can be a boolean or object so that's why it's\n      // forced to be a string.\n      initialValue: '' + (value != null ? value : defaultValue)\n    };\n  },\n\n  render: function() {\n    // Clone `this.props` so we don't mutate the input.\n    var props = assign({}, this.props);\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      props.dangerouslySetInnerHTML == null,\n      '`dangerouslySetInnerHTML` does not make sense on <textarea>.'\n    ) : invariant(props.dangerouslySetInnerHTML == null));\n\n    props.defaultValue = null;\n    props.value = null;\n    props.onChange = this._handleChange;\n\n    // Always set children to the same thing. In IE9, the selection range will\n    // get reset if `textContent` is mutated.\n    return textarea(props, this.state.initialValue);\n  },\n\n  componentDidUpdate: function(prevProps, prevState, prevContext) {\n    var value = LinkedValueUtils.getValue(this);\n    if (value != null) {\n      var rootNode = this.getDOMNode();\n      // Cast `value` to a string to ensure the value is set correctly. While\n      // browsers typically do this as necessary, jsdom doesn't.\n      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);\n    }\n  },\n\n  _handleChange: function(event) {\n    var returnValue;\n    var onChange = LinkedValueUtils.getOnChange(this);\n    if (onChange) {\n      returnValue = onChange.call(this, event);\n    }\n    ReactUpdates.asap(forceUpdateIfMounted, this);\n    return returnValue;\n  }\n\n});\n\nmodule.exports = ReactDOMTextarea;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMTextarea.js\n ** module id = 163\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMTextarea.js?");

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventListener\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar EventListener = __webpack_require__(228);\nvar ExecutionEnvironment = __webpack_require__(75);\nvar PooledClass = __webpack_require__(135);\nvar ReactInstanceHandles = __webpack_require__(30);\nvar ReactMount = __webpack_require__(10);\nvar ReactUpdates = __webpack_require__(138);\n\nvar assign = __webpack_require__(51);\nvar getEventTarget = __webpack_require__(229);\nvar getUnboundedScrollPosition = __webpack_require__(129);\n\n/**\n * Finds the parent React component of `node`.\n *\n * @param {*} node\n * @return {?DOMEventTarget} Parent container, or `null` if the specified node\n *                           is not nested.\n */\nfunction findParent(node) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  var nodeID = ReactMount.getID(node);\n  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n  var container = ReactMount.findReactContainerForID(rootID);\n  var parent = ReactMount.getFirstReactDOM(container);\n  return parent;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\nassign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function() {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(\n  TopLevelCallbackBookKeeping,\n  PooledClass.twoArgumentPooler\n);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  var topLevelTarget = ReactMount.getFirstReactDOM(\n    getEventTarget(bookKeeping.nativeEvent)\n  ) || window;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = topLevelTarget;\n  while (ancestor) {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = findParent(ancestor);\n  }\n\n  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {\n    topLevelTarget = bookKeeping.ancestors[i];\n    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';\n    ReactEventListener._handleTopLevel(\n      bookKeeping.topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      bookKeeping.nativeEvent\n    );\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n\n  setHandleTopLevel: function(handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function(enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function() {\n    return ReactEventListener._enabled;\n  },\n\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return;\n    }\n    return EventListener.listen(\n      element,\n      handlerBaseName,\n      ReactEventListener.dispatchEvent.bind(null, topLevelType)\n    );\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return;\n    }\n    return EventListener.capture(\n      element,\n      handlerBaseName,\n      ReactEventListener.dispatchEvent.bind(null, topLevelType)\n    );\n  },\n\n  monitorScrollValue: function(refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n    EventListener.listen(window, 'resize', callback);\n  },\n\n  dispatchEvent: function(topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(\n      topLevelType,\n      nativeEvent\n    );\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\n\nmodule.exports = ReactEventListener;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactEventListener.js\n ** module id = 164\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactEventListener.js?");

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInjection\n */\n\n\"use strict\";\n\nvar DOMProperty = __webpack_require__(25);\nvar EventPluginHub = __webpack_require__(47);\nvar ReactComponent = __webpack_require__(64);\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactEmptyComponent = __webpack_require__(58);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactNativeComponent = __webpack_require__(57);\nvar ReactPerf = __webpack_require__(31);\nvar ReactRootIndex = __webpack_require__(55);\nvar ReactUpdates = __webpack_require__(138);\n\nvar ReactInjection = {\n  Component: ReactComponent.injection,\n  CompositeComponent: ReactCompositeComponent.injection,\n  DOMProperty: DOMProperty.injection,\n  EmptyComponent: ReactEmptyComponent.injection,\n  EventPluginHub: EventPluginHub.injection,\n  EventEmitter: ReactBrowserEventEmitter.injection,\n  NativeComponent: ReactNativeComponent.injection,\n  Perf: ReactPerf.injection,\n  RootIndex: ReactRootIndex.injection,\n  Updates: ReactUpdates.injection\n};\n\nmodule.exports = ReactInjection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInjection.js\n ** module id = 165\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInjection.js?");

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SelectEventPlugin\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPropagators = __webpack_require__(214);\nvar ReactInputSelection = __webpack_require__(218);\nvar SyntheticEvent = __webpack_require__(216);\n\nvar getActiveElement = __webpack_require__(230);\nvar isTextInputElement = __webpack_require__(217);\nvar keyOf = __webpack_require__(143);\nvar shallowEqual = __webpack_require__(231);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onSelect: null}),\n      captured: keyOf({onSelectCapture: null})\n    },\n    dependencies: [\n      topLevelTypes.topBlur,\n      topLevelTypes.topContextMenu,\n      topLevelTypes.topFocus,\n      topLevelTypes.topKeyDown,\n      topLevelTypes.topMouseDown,\n      topLevelTypes.topMouseUp,\n      topLevelTypes.topSelectionChange\n    ]\n  }\n};\n\nvar activeElement = null;\nvar activeElementID = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @param {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node &&\n      ReactInputSelection.hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else if (window.getSelection) {\n    var selection = window.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  } else if (document.selection) {\n    var range = document.selection.createRange();\n    return {\n      parentElement: range.parentElement(),\n      text: range.text,\n      top: range.boundingTop,\n      left: range.boundingLeft\n    };\n  }\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  if (mouseDown ||\n      activeElement == null ||\n      activeElement != getActiveElement()) {\n    return;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(\n      eventTypes.select,\n      activeElementID,\n      nativeEvent\n    );\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement;\n\n    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case topLevelTypes.topFocus:\n        if (isTextInputElement(topLevelTarget) ||\n            topLevelTarget.contentEditable === 'true') {\n          activeElement = topLevelTarget;\n          activeElementID = topLevelTargetID;\n          lastSelection = null;\n        }\n        break;\n      case topLevelTypes.topBlur:\n        activeElement = null;\n        activeElementID = null;\n        lastSelection = null;\n        break;\n\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case topLevelTypes.topMouseDown:\n        mouseDown = true;\n        break;\n      case topLevelTypes.topContextMenu:\n      case topLevelTypes.topMouseUp:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent);\n\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't).\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      case topLevelTypes.topSelectionChange:\n      case topLevelTypes.topKeyDown:\n      case topLevelTypes.topKeyUp:\n        return constructSelectEvent(nativeEvent);\n    }\n  }\n};\n\nmodule.exports = SelectEventPlugin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SelectEventPlugin.js\n ** module id = 166\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SelectEventPlugin.js?");

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ServerReactRootIndex\n * @typechecks\n */\n\n\"use strict\";\n\n/**\n * Size of the reactRoot ID space. We generate random numbers for React root\n * IDs and if there's a collision the events and DOM update system will\n * get confused. In the future we need a way to generate GUIDs but for\n * now this will work on a smaller scale.\n */\nvar GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);\n\nvar ServerReactRootIndex = {\n  createReactRootIndex: function() {\n    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);\n  }\n};\n\nmodule.exports = ServerReactRootIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ServerReactRootIndex.js\n ** module id = 167\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ServerReactRootIndex.js?");

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SimpleEventPlugin\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPluginUtils = __webpack_require__(62);\nvar EventPropagators = __webpack_require__(214);\nvar SyntheticClipboardEvent = __webpack_require__(232);\nvar SyntheticEvent = __webpack_require__(216);\nvar SyntheticFocusEvent = __webpack_require__(233);\nvar SyntheticKeyboardEvent = __webpack_require__(234);\nvar SyntheticMouseEvent = __webpack_require__(221);\nvar SyntheticDragEvent = __webpack_require__(235);\nvar SyntheticTouchEvent = __webpack_require__(236);\nvar SyntheticUIEvent = __webpack_require__(237);\nvar SyntheticWheelEvent = __webpack_require__(238);\n\nvar getEventCharCode = __webpack_require__(239);\n\nvar invariant = __webpack_require__(36);\nvar keyOf = __webpack_require__(143);\nvar warning = __webpack_require__(38);\n\nvar topLevelTypes = EventConstants.topLevelTypes;\n\nvar eventTypes = {\n  blur: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onBlur: true}),\n      captured: keyOf({onBlurCapture: true})\n    }\n  },\n  click: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onClick: true}),\n      captured: keyOf({onClickCapture: true})\n    }\n  },\n  contextMenu: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onContextMenu: true}),\n      captured: keyOf({onContextMenuCapture: true})\n    }\n  },\n  copy: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCopy: true}),\n      captured: keyOf({onCopyCapture: true})\n    }\n  },\n  cut: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onCut: true}),\n      captured: keyOf({onCutCapture: true})\n    }\n  },\n  doubleClick: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDoubleClick: true}),\n      captured: keyOf({onDoubleClickCapture: true})\n    }\n  },\n  drag: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDrag: true}),\n      captured: keyOf({onDragCapture: true})\n    }\n  },\n  dragEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragEnd: true}),\n      captured: keyOf({onDragEndCapture: true})\n    }\n  },\n  dragEnter: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragEnter: true}),\n      captured: keyOf({onDragEnterCapture: true})\n    }\n  },\n  dragExit: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragExit: true}),\n      captured: keyOf({onDragExitCapture: true})\n    }\n  },\n  dragLeave: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragLeave: true}),\n      captured: keyOf({onDragLeaveCapture: true})\n    }\n  },\n  dragOver: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragOver: true}),\n      captured: keyOf({onDragOverCapture: true})\n    }\n  },\n  dragStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDragStart: true}),\n      captured: keyOf({onDragStartCapture: true})\n    }\n  },\n  drop: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onDrop: true}),\n      captured: keyOf({onDropCapture: true})\n    }\n  },\n  focus: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onFocus: true}),\n      captured: keyOf({onFocusCapture: true})\n    }\n  },\n  input: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onInput: true}),\n      captured: keyOf({onInputCapture: true})\n    }\n  },\n  keyDown: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onKeyDown: true}),\n      captured: keyOf({onKeyDownCapture: true})\n    }\n  },\n  keyPress: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onKeyPress: true}),\n      captured: keyOf({onKeyPressCapture: true})\n    }\n  },\n  keyUp: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onKeyUp: true}),\n      captured: keyOf({onKeyUpCapture: true})\n    }\n  },\n  load: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onLoad: true}),\n      captured: keyOf({onLoadCapture: true})\n    }\n  },\n  error: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onError: true}),\n      captured: keyOf({onErrorCapture: true})\n    }\n  },\n  // Note: We do not allow listening to mouseOver events. Instead, use the\n  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.\n  mouseDown: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseDown: true}),\n      captured: keyOf({onMouseDownCapture: true})\n    }\n  },\n  mouseMove: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseMove: true}),\n      captured: keyOf({onMouseMoveCapture: true})\n    }\n  },\n  mouseOut: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseOut: true}),\n      captured: keyOf({onMouseOutCapture: true})\n    }\n  },\n  mouseOver: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseOver: true}),\n      captured: keyOf({onMouseOverCapture: true})\n    }\n  },\n  mouseUp: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onMouseUp: true}),\n      captured: keyOf({onMouseUpCapture: true})\n    }\n  },\n  paste: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onPaste: true}),\n      captured: keyOf({onPasteCapture: true})\n    }\n  },\n  reset: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onReset: true}),\n      captured: keyOf({onResetCapture: true})\n    }\n  },\n  scroll: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onScroll: true}),\n      captured: keyOf({onScrollCapture: true})\n    }\n  },\n  submit: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onSubmit: true}),\n      captured: keyOf({onSubmitCapture: true})\n    }\n  },\n  touchCancel: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchCancel: true}),\n      captured: keyOf({onTouchCancelCapture: true})\n    }\n  },\n  touchEnd: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchEnd: true}),\n      captured: keyOf({onTouchEndCapture: true})\n    }\n  },\n  touchMove: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchMove: true}),\n      captured: keyOf({onTouchMoveCapture: true})\n    }\n  },\n  touchStart: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onTouchStart: true}),\n      captured: keyOf({onTouchStartCapture: true})\n    }\n  },\n  wheel: {\n    phasedRegistrationNames: {\n      bubbled: keyOf({onWheel: true}),\n      captured: keyOf({onWheelCapture: true})\n    }\n  }\n};\n\nvar topLevelEventsToDispatchConfig = {\n  topBlur:        eventTypes.blur,\n  topClick:       eventTypes.click,\n  topContextMenu: eventTypes.contextMenu,\n  topCopy:        eventTypes.copy,\n  topCut:         eventTypes.cut,\n  topDoubleClick: eventTypes.doubleClick,\n  topDrag:        eventTypes.drag,\n  topDragEnd:     eventTypes.dragEnd,\n  topDragEnter:   eventTypes.dragEnter,\n  topDragExit:    eventTypes.dragExit,\n  topDragLeave:   eventTypes.dragLeave,\n  topDragOver:    eventTypes.dragOver,\n  topDragStart:   eventTypes.dragStart,\n  topDrop:        eventTypes.drop,\n  topError:       eventTypes.error,\n  topFocus:       eventTypes.focus,\n  topInput:       eventTypes.input,\n  topKeyDown:     eventTypes.keyDown,\n  topKeyPress:    eventTypes.keyPress,\n  topKeyUp:       eventTypes.keyUp,\n  topLoad:        eventTypes.load,\n  topMouseDown:   eventTypes.mouseDown,\n  topMouseMove:   eventTypes.mouseMove,\n  topMouseOut:    eventTypes.mouseOut,\n  topMouseOver:   eventTypes.mouseOver,\n  topMouseUp:     eventTypes.mouseUp,\n  topPaste:       eventTypes.paste,\n  topReset:       eventTypes.reset,\n  topScroll:      eventTypes.scroll,\n  topSubmit:      eventTypes.submit,\n  topTouchCancel: eventTypes.touchCancel,\n  topTouchEnd:    eventTypes.touchEnd,\n  topTouchMove:   eventTypes.touchMove,\n  topTouchStart:  eventTypes.touchStart,\n  topWheel:       eventTypes.wheel\n};\n\nfor (var topLevelType in topLevelEventsToDispatchConfig) {\n  topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];\n}\n\nvar SimpleEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  /**\n   * Same as the default implementation, except cancels the event when return\n   * value is false. This behavior will be disabled in a future release.\n   *\n   * @param {object} Event to be dispatched.\n   * @param {function} Application-level callback.\n   * @param {string} domID DOM ID to pass to the callback.\n   */\n  executeDispatch: function(event, listener, domID) {\n    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);\n\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      typeof returnValue !== 'boolean',\n      'Returning `false` from an event handler is deprecated and will be ' +\n      'ignored in a future release. Instead, manually call ' +\n      'e.stopPropagation() or e.preventDefault(), as appropriate.'\n    ) : null);\n\n    if (returnValue === false) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  },\n\n  /**\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {DOMEventTarget} topLevelTarget The listening component root node.\n   * @param {string} topLevelTargetID ID of `topLevelTarget`.\n   * @param {object} nativeEvent Native browser event.\n   * @return {*} An accumulation of synthetic events.\n   * @see {EventPluginHub.extractEvents}\n   */\n  extractEvents: function(\n      topLevelType,\n      topLevelTarget,\n      topLevelTargetID,\n      nativeEvent) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor;\n    switch (topLevelType) {\n      case topLevelTypes.topInput:\n      case topLevelTypes.topLoad:\n      case topLevelTypes.topError:\n      case topLevelTypes.topReset:\n      case topLevelTypes.topSubmit:\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent;\n        break;\n      case topLevelTypes.topKeyPress:\n        // FireFox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n        /* falls through */\n      case topLevelTypes.topKeyDown:\n      case topLevelTypes.topKeyUp:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case topLevelTypes.topBlur:\n      case topLevelTypes.topFocus:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case topLevelTypes.topClick:\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n        /* falls through */\n      case topLevelTypes.topContextMenu:\n      case topLevelTypes.topDoubleClick:\n      case topLevelTypes.topMouseDown:\n      case topLevelTypes.topMouseMove:\n      case topLevelTypes.topMouseOut:\n      case topLevelTypes.topMouseOver:\n      case topLevelTypes.topMouseUp:\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case topLevelTypes.topDrag:\n      case topLevelTypes.topDragEnd:\n      case topLevelTypes.topDragEnter:\n      case topLevelTypes.topDragExit:\n      case topLevelTypes.topDragLeave:\n      case topLevelTypes.topDragOver:\n      case topLevelTypes.topDragStart:\n      case topLevelTypes.topDrop:\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case topLevelTypes.topTouchCancel:\n      case topLevelTypes.topTouchEnd:\n      case topLevelTypes.topTouchMove:\n      case topLevelTypes.topTouchStart:\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case topLevelTypes.topScroll:\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case topLevelTypes.topWheel:\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case topLevelTypes.topCopy:\n      case topLevelTypes.topCut:\n      case topLevelTypes.topPaste:\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n    }\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      EventConstructor,\n      'SimpleEventPlugin: Unhandled event type, `%s`.',\n      topLevelType\n    ) : invariant(EventConstructor));\n    var event = EventConstructor.getPooled(\n      dispatchConfig,\n      topLevelTargetID,\n      nativeEvent\n    );\n    EventPropagators.accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n\n};\n\nmodule.exports = SimpleEventPlugin;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SimpleEventPlugin.js\n ** module id = 168\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SimpleEventPlugin.js?");

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SVGDOMPropertyConfig\n */\n\n/*jslint bitwise: true*/\n\n\"use strict\";\n\nvar DOMProperty = __webpack_require__(25);\n\nvar MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;\n\nvar SVGDOMPropertyConfig = {\n  Properties: {\n    cx: MUST_USE_ATTRIBUTE,\n    cy: MUST_USE_ATTRIBUTE,\n    d: MUST_USE_ATTRIBUTE,\n    dx: MUST_USE_ATTRIBUTE,\n    dy: MUST_USE_ATTRIBUTE,\n    fill: MUST_USE_ATTRIBUTE,\n    fillOpacity: MUST_USE_ATTRIBUTE,\n    fontFamily: MUST_USE_ATTRIBUTE,\n    fontSize: MUST_USE_ATTRIBUTE,\n    fx: MUST_USE_ATTRIBUTE,\n    fy: MUST_USE_ATTRIBUTE,\n    gradientTransform: MUST_USE_ATTRIBUTE,\n    gradientUnits: MUST_USE_ATTRIBUTE,\n    markerEnd: MUST_USE_ATTRIBUTE,\n    markerMid: MUST_USE_ATTRIBUTE,\n    markerStart: MUST_USE_ATTRIBUTE,\n    offset: MUST_USE_ATTRIBUTE,\n    opacity: MUST_USE_ATTRIBUTE,\n    patternContentUnits: MUST_USE_ATTRIBUTE,\n    patternUnits: MUST_USE_ATTRIBUTE,\n    points: MUST_USE_ATTRIBUTE,\n    preserveAspectRatio: MUST_USE_ATTRIBUTE,\n    r: MUST_USE_ATTRIBUTE,\n    rx: MUST_USE_ATTRIBUTE,\n    ry: MUST_USE_ATTRIBUTE,\n    spreadMethod: MUST_USE_ATTRIBUTE,\n    stopColor: MUST_USE_ATTRIBUTE,\n    stopOpacity: MUST_USE_ATTRIBUTE,\n    stroke: MUST_USE_ATTRIBUTE,\n    strokeDasharray: MUST_USE_ATTRIBUTE,\n    strokeLinecap: MUST_USE_ATTRIBUTE,\n    strokeOpacity: MUST_USE_ATTRIBUTE,\n    strokeWidth: MUST_USE_ATTRIBUTE,\n    textAnchor: MUST_USE_ATTRIBUTE,\n    transform: MUST_USE_ATTRIBUTE,\n    version: MUST_USE_ATTRIBUTE,\n    viewBox: MUST_USE_ATTRIBUTE,\n    x1: MUST_USE_ATTRIBUTE,\n    x2: MUST_USE_ATTRIBUTE,\n    x: MUST_USE_ATTRIBUTE,\n    y1: MUST_USE_ATTRIBUTE,\n    y2: MUST_USE_ATTRIBUTE,\n    y: MUST_USE_ATTRIBUTE\n  },\n  DOMAttributeNames: {\n    fillOpacity: 'fill-opacity',\n    fontFamily: 'font-family',\n    fontSize: 'font-size',\n    gradientTransform: 'gradientTransform',\n    gradientUnits: 'gradientUnits',\n    markerEnd: 'marker-end',\n    markerMid: 'marker-mid',\n    markerStart: 'marker-start',\n    patternContentUnits: 'patternContentUnits',\n    patternUnits: 'patternUnits',\n    preserveAspectRatio: 'preserveAspectRatio',\n    spreadMethod: 'spreadMethod',\n    stopColor: 'stop-color',\n    stopOpacity: 'stop-opacity',\n    strokeDasharray: 'stroke-dasharray',\n    strokeLinecap: 'stroke-linecap',\n    strokeOpacity: 'stroke-opacity',\n    strokeWidth: 'stroke-width',\n    textAnchor: 'text-anchor',\n    viewBox: 'viewBox'\n  }\n};\n\nmodule.exports = SVGDOMPropertyConfig;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SVGDOMPropertyConfig.js\n ** module id = 169\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SVGDOMPropertyConfig.js?");

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createFullPageComponent\n * @typechecks\n */\n\n\"use strict\";\n\n// Defeat circular references by requiring this directly.\nvar ReactCompositeComponent = __webpack_require__(65);\nvar ReactElement = __webpack_require__(28);\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Create a component that will throw an exception when unmounted.\n *\n * Components like <html> <head> and <body> can't be removed or added\n * easily in a cross-browser way, however it's valuable to be able to\n * take advantage of React's reconciliation for styling and <title>\n * management. So we just document it and throw in dangerous cases.\n *\n * @param {string} tag The tag to wrap\n * @return {function} convenience constructor of new component\n */\nfunction createFullPageComponent(tag) {\n  var elementFactory = ReactElement.createFactory(tag);\n\n  var FullPageComponent = ReactCompositeComponent.createClass({\n    displayName: 'ReactFullPageComponent' + tag,\n\n    componentWillUnmount: function() {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        false,\n        '%s tried to unmount. Because of cross-browser quirks it is ' +\n        'impossible to unmount some top-level components (eg <html>, <head>, ' +\n        'and <body>) reliably and efficiently. To fix this, have a single ' +\n        'top-level component that never unmounts render these elements.',\n        this.constructor.displayName\n      ) : invariant(false));\n    },\n\n    render: function() {\n      return elementFactory(this.props);\n    }\n  });\n\n  return FullPageComponent;\n}\n\nmodule.exports = createFullPageComponent;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/createFullPageComponent.js\n ** module id = 170\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/createFullPageComponent.js?");

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerf\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar DOMProperty = __webpack_require__(25);\nvar ReactDefaultPerfAnalysis = __webpack_require__(240);\nvar ReactMount = __webpack_require__(10);\nvar ReactPerf = __webpack_require__(31);\n\nvar performanceNow = __webpack_require__(241);\n\nfunction roundFloat(val) {\n  return Math.floor(val * 100) / 100;\n}\n\nfunction addValue(obj, key, val) {\n  obj[key] = (obj[key] || 0) + val;\n}\n\nvar ReactDefaultPerf = {\n  _allMeasurements: [], // last item in the list is the current one\n  _mountStack: [0],\n  _injected: false,\n\n  start: function() {\n    if (!ReactDefaultPerf._injected) {\n      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);\n    }\n\n    ReactDefaultPerf._allMeasurements.length = 0;\n    ReactPerf.enableMeasure = true;\n  },\n\n  stop: function() {\n    ReactPerf.enableMeasure = false;\n  },\n\n  getLastMeasurements: function() {\n    return ReactDefaultPerf._allMeasurements;\n  },\n\n  printExclusive: function(measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);\n    console.table(summary.map(function(item) {\n      return {\n        'Component class name': item.componentName,\n        'Total inclusive time (ms)': roundFloat(item.inclusive),\n        'Exclusive mount time (ms)': roundFloat(item.exclusive),\n        'Exclusive render time (ms)': roundFloat(item.render),\n        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),\n        'Render time per instance (ms)': roundFloat(item.render / item.count),\n        'Instances': item.count\n      };\n    }));\n    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct\n    // number.\n  },\n\n  printInclusive: function(measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);\n    console.table(summary.map(function(item) {\n      return {\n        'Owner > component': item.componentName,\n        'Inclusive time (ms)': roundFloat(item.time),\n        'Instances': item.count\n      };\n    }));\n    console.log(\n      'Total time:',\n      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'\n    );\n  },\n\n  getMeasurementsSummaryMap: function(measurements) {\n    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(\n      measurements,\n      true\n    );\n    return summary.map(function(item) {\n      return {\n        'Owner > component': item.componentName,\n        'Wasted time (ms)': item.time,\n        'Instances': item.count\n      };\n    });\n  },\n\n  printWasted: function(measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));\n    console.log(\n      'Total time:',\n      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'\n    );\n  },\n\n  printDOM: function(measurements) {\n    measurements = measurements || ReactDefaultPerf._allMeasurements;\n    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);\n    console.table(summary.map(function(item) {\n      var result = {};\n      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;\n      result['type'] = item.type;\n      result['args'] = JSON.stringify(item.args);\n      return result;\n    }));\n    console.log(\n      'Total time:',\n      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'\n    );\n  },\n\n  _recordWrite: function(id, fnName, totalTime, args) {\n    // TODO: totalTime isn't that useful since it doesn't count paints/reflows\n    var writes =\n      ReactDefaultPerf\n        ._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1]\n        .writes;\n    writes[id] = writes[id] || [];\n    writes[id].push({\n      type: fnName,\n      time: totalTime,\n      args: args\n    });\n  },\n\n  measure: function(moduleName, fnName, func) {\n    return function() {for (var args=[],$__0=0,$__1=arguments.length;$__0<$__1;$__0++) args.push(arguments[$__0]);\n      var totalTime;\n      var rv;\n      var start;\n\n      if (fnName === '_renderNewRootComponent' ||\n          fnName === 'flushBatchedUpdates') {\n        // A \"measurement\" is a set of metrics recorded for each flush. We want\n        // to group the metrics for a given flush together so we can look at the\n        // components that rendered and the DOM operations that actually\n        // happened to determine the amount of \"wasted work\" performed.\n        ReactDefaultPerf._allMeasurements.push({\n          exclusive: {},\n          inclusive: {},\n          render: {},\n          counts: {},\n          writes: {},\n          displayNames: {},\n          totalTime: 0\n        });\n        start = performanceNow();\n        rv = func.apply(this, args);\n        ReactDefaultPerf._allMeasurements[\n          ReactDefaultPerf._allMeasurements.length - 1\n        ].totalTime = performanceNow() - start;\n        return rv;\n      } else if (moduleName === 'ReactDOMIDOperations' ||\n        moduleName === 'ReactComponentBrowserEnvironment') {\n        start = performanceNow();\n        rv = func.apply(this, args);\n        totalTime = performanceNow() - start;\n\n        if (fnName === 'mountImageIntoNode') {\n          var mountID = ReactMount.getID(args[1]);\n          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);\n        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {\n          // special format\n          args[0].forEach(function(update) {\n            var writeArgs = {};\n            if (update.fromIndex !== null) {\n              writeArgs.fromIndex = update.fromIndex;\n            }\n            if (update.toIndex !== null) {\n              writeArgs.toIndex = update.toIndex;\n            }\n            if (update.textContent !== null) {\n              writeArgs.textContent = update.textContent;\n            }\n            if (update.markupIndex !== null) {\n              writeArgs.markup = args[1][update.markupIndex];\n            }\n            ReactDefaultPerf._recordWrite(\n              update.parentID,\n              update.type,\n              totalTime,\n              writeArgs\n            );\n          });\n        } else {\n          // basic format\n          ReactDefaultPerf._recordWrite(\n            args[0],\n            fnName,\n            totalTime,\n            Array.prototype.slice.call(args, 1)\n          );\n        }\n        return rv;\n      } else if (moduleName === 'ReactCompositeComponent' && (\n        fnName === 'mountComponent' ||\n        fnName === 'updateComponent' || // TODO: receiveComponent()?\n        fnName === '_renderValidatedComponent')) {\n\n        var rootNodeID = fnName === 'mountComponent' ?\n          args[0] :\n          this._rootNodeID;\n        var isRender = fnName === '_renderValidatedComponent';\n        var isMount = fnName === 'mountComponent';\n\n        var mountStack = ReactDefaultPerf._mountStack;\n        var entry = ReactDefaultPerf._allMeasurements[\n          ReactDefaultPerf._allMeasurements.length - 1\n        ];\n\n        if (isRender) {\n          addValue(entry.counts, rootNodeID, 1);\n        } else if (isMount) {\n          mountStack.push(0);\n        }\n\n        start = performanceNow();\n        rv = func.apply(this, args);\n        totalTime = performanceNow() - start;\n\n        if (isRender) {\n          addValue(entry.render, rootNodeID, totalTime);\n        } else if (isMount) {\n          var subMountTime = mountStack.pop();\n          mountStack[mountStack.length - 1] += totalTime;\n          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);\n          addValue(entry.inclusive, rootNodeID, totalTime);\n        } else {\n          addValue(entry.inclusive, rootNodeID, totalTime);\n        }\n\n        entry.displayNames[rootNodeID] = {\n          current: this.constructor.displayName,\n          owner: this._owner ? this._owner.constructor.displayName : '<root>'\n        };\n\n        return rv;\n      } else {\n        return func.apply(this, args);\n      }\n    };\n  }\n};\n\nmodule.exports = ReactDefaultPerf;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultPerf.js\n ** module id = 171\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultPerf.js?");

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMultiChildUpdateTypes\n */\n\n\"use strict\";\n\nvar keyMirror = __webpack_require__(126);\n\n/**\n * When a component's children are updated, a series of update configuration\n * objects are created in order to batch and serialize the required changes.\n *\n * Enumerates all the possible types of update configurations.\n *\n * @internal\n */\nvar ReactMultiChildUpdateTypes = keyMirror({\n  INSERT_MARKUP: null,\n  MOVE_EXISTING: null,\n  REMOVE_NODE: null,\n  TEXT_CONTENT: null\n});\n\nmodule.exports = ReactMultiChildUpdateTypes;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMultiChildUpdateTypes.js\n ** module id = 172\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMultiChildUpdateTypes.js?");

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule flattenChildren\n */\n\n\"use strict\";\n\nvar ReactTextComponent = __webpack_require__(73);\n\nvar traverseAllChildren = __webpack_require__(136);\nvar warning = __webpack_require__(38);\n\n/**\n * @param {function} traverseContext Context passed through traversal.\n * @param {?ReactComponent} child React child component.\n * @param {!string} name String name of key path to child.\n */\nfunction flattenSingleChildIntoContext(traverseContext, child, name) {\n  // We found a component instance.\n  var result = traverseContext;\n  var keyUnique = !result.hasOwnProperty(name);\n  (\"production\" !== process.env.NODE_ENV ? warning(\n    keyUnique,\n    'flattenChildren(...): Encountered two children with the same key, ' +\n    '`%s`. Child keys must be unique; when two children share a key, only ' +\n    'the first child will be used.',\n    name\n  ) : null);\n  if (keyUnique && child != null) {\n    var type = typeof child;\n    var normalizedValue;\n\n    if (type === 'string') {\n      normalizedValue = ReactTextComponent(child);\n    } else if (type === 'number') {\n      normalizedValue = ReactTextComponent('' + child);\n    } else {\n      normalizedValue = child;\n    }\n\n    result[name] = normalizedValue;\n  }\n}\n\n/**\n * Flattens children that are typically specified as `props.children`. Any null\n * children will not be included in the resulting object.\n * @return {!object} flattened children keyed by name.\n */\nfunction flattenChildren(children) {\n  if (children == null) {\n    return children;\n  }\n  var result = {};\n  traverseAllChildren(children, flattenSingleChildIntoContext, result);\n  return result;\n}\n\nmodule.exports = flattenChildren;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/flattenChildren.js\n ** module id = 173\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/flattenChildren.js?");

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMarkupChecksum\n */\n\n\"use strict\";\n\nvar adler32 = __webpack_require__(242);\n\nvar ReactMarkupChecksum = {\n  CHECKSUM_ATTR_NAME: 'data-react-checksum',\n\n  /**\n   * @param {string} markup Markup string\n   * @return {string} Markup string with checksum attribute attached\n   */\n  addChecksumToMarkup: function(markup) {\n    var checksum = adler32(markup);\n    return markup.replace(\n      '>',\n      ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '=\"' + checksum + '\">'\n    );\n  },\n\n  /**\n   * @param {string} markup to use\n   * @param {DOMElement} element root React element\n   * @returns {boolean} whether or not the markup is the same\n   */\n  canReuseMarkup: function(markup, element) {\n    var existingChecksum = element.getAttribute(\n      ReactMarkupChecksum.CHECKSUM_ATTR_NAME\n    );\n    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);\n    var markupChecksum = adler32(markup);\n    return markupChecksum === existingChecksum;\n  }\n};\n\nmodule.exports = ReactMarkupChecksum;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactMarkupChecksum.js\n ** module id = 174\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactMarkupChecksum.js?");

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerRenderingTransaction\n * @typechecks\n */\n\n\"use strict\";\n\nvar PooledClass = __webpack_require__(135);\nvar CallbackQueue = __webpack_require__(207);\nvar ReactPutListenerQueue = __webpack_require__(243);\nvar Transaction = __webpack_require__(208);\n\nvar assign = __webpack_require__(51);\nvar emptyFunction = __webpack_require__(59);\n\n/**\n * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks\n * during the performing of the transaction.\n */\nvar ON_DOM_READY_QUEUEING = {\n  /**\n   * Initializes the internal `onDOMReady` queue.\n   */\n  initialize: function() {\n    this.reactMountReady.reset();\n  },\n\n  close: emptyFunction\n};\n\nvar PUT_LISTENER_QUEUEING = {\n  initialize: function() {\n    this.putListenerQueue.reset();\n  },\n\n  close: emptyFunction\n};\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [\n  PUT_LISTENER_QUEUEING,\n  ON_DOM_READY_QUEUEING\n];\n\n/**\n * @class ReactServerRenderingTransaction\n * @param {boolean} renderToStaticMarkup\n */\nfunction ReactServerRenderingTransaction(renderToStaticMarkup) {\n  this.reinitializeTransaction();\n  this.renderToStaticMarkup = renderToStaticMarkup;\n  this.reactMountReady = CallbackQueue.getPooled(null);\n  this.putListenerQueue = ReactPutListenerQueue.getPooled();\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array} Empty list of operation wrap proceedures.\n   */\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function() {\n    return this.reactMountReady;\n  },\n\n  getPutListenerQueue: function() {\n    return this.putListenerQueue;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be resused.\n   */\n  destructor: function() {\n    CallbackQueue.release(this.reactMountReady);\n    this.reactMountReady = null;\n\n    ReactPutListenerQueue.release(this.putListenerQueue);\n    this.putListenerQueue = null;\n  }\n};\n\n\nassign(\n  ReactServerRenderingTransaction.prototype,\n  Transaction.Mixin,\n  Mixin\n);\n\nPooledClass.addPoolingTo(ReactServerRenderingTransaction);\n\nmodule.exports = ReactServerRenderingTransaction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactServerRenderingTransaction.js\n ** module id = 175\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactServerRenderingTransaction.js?");

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * A module of methods that you want to include in all actions.\n * This module is consumed by `createAction`.\n */\nmodule.exports = {\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/ActionMethods.js\n ** module id = 176\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/ActionMethods.js?");

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _ = __webpack_require__(188),\n    maker = __webpack_require__(187).instanceJoinCreator;\n\n/**\n * Extract child listenables from a parent from their\n * children property and return them in a keyed Object\n *\n * @param {Object} listenable The parent listenable\n */\nvar mapChildListenables = function(listenable) {\n    var i = 0, children = {}, childName;\n    for (;i < (listenable.children||[]).length; ++i) {\n        childName = listenable.children[i];\n        if(listenable[childName]){\n            children[childName] = listenable[childName];\n        }\n    }\n    return children;\n};\n\n/**\n * Make a flat dictionary of all listenables including their\n * possible children (recursively), concatenating names in camelCase.\n *\n * @param {Object} listenables The top-level listenables\n */\nvar flattenListenables = function(listenables) {\n    var flattened = {};\n    for(var key in listenables){\n        var listenable = listenables[key];\n        var childMap = mapChildListenables(listenable);\n\n        // recursively flatten children\n        var children = flattenListenables(childMap);\n\n        // add the primary listenable and chilren\n        flattened[key] = listenable;\n        for(var childKey in children){\n            var childListenable = children[childKey];\n            flattened[key + _.capitalize(childKey)] = childListenable;\n        }\n    }\n\n    return flattened;\n};\n\n/**\n * A module of methods related to listening.\n */\nmodule.exports = {\n\n    /**\n     * An internal utility function used by `validateListening`\n     *\n     * @param {Action|Store} listenable The listenable we want to search for\n     * @returns {Boolean} The result of a recursive search among `this.subscriptions`\n     */\n    hasListener: function(listenable) {\n        var i = 0, j, listener, listenables;\n        for (;i < (this.subscriptions||[]).length; ++i) {\n            listenables = [].concat(this.subscriptions[i].listenable);\n            for (j = 0; j < listenables.length; j++){\n                listener = listenables[j];\n                if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n\n    /**\n     * A convenience method that listens to all listenables in the given object.\n     *\n     * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\n     */\n    listenToMany: function(listenables){\n        var allListenables = flattenListenables(listenables);\n        for(var key in allListenables){\n            var cbname = _.callbackName(key),\n                localname = this[cbname] ? cbname : this[key] ? key : undefined;\n            if (localname){\n                this.listenTo(allListenables[key],localname,this[cbname+\"Default\"]||this[localname+\"Default\"]||localname);\n            }\n        }\n    },\n\n    /**\n     * Checks if the current context can listen to the supplied listenable\n     *\n     * @param {Action|Store} listenable An Action or Store that should be\n     *  listened to.\n     * @returns {String|Undefined} An error message, or undefined if there was no problem.\n     */\n    validateListening: function(listenable){\n        if (listenable === this) {\n            return \"Listener is not able to listen to itself\";\n        }\n        if (!_.isFunction(listenable.listen)) {\n            return listenable + \" is missing a listen method\";\n        }\n        if (listenable.hasListener && listenable.hasListener(this)) {\n            return \"Listener cannot listen to this listenable because of circular loop\";\n        }\n    },\n\n    /**\n     * Sets up a subscription to the given listenable for the context object\n     *\n     * @param {Action|Store} listenable An Action or Store that should be\n     *  listened to.\n     * @param {Function|String} callback The callback to register as event handler\n     * @param {Function|String} defaultCallback The callback to register as default handler\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\n     */\n    listenTo: function(listenable, callback, defaultCallback) {\n        var desub, unsubscriber, subscriptionobj, subs = this.subscriptions = this.subscriptions || [];\n        _.throwIf(this.validateListening(listenable));\n        this.fetchInitialState(listenable, defaultCallback);\n        desub = listenable.listen(this[callback]||callback, this);\n        unsubscriber = function() {\n            var index = subs.indexOf(subscriptionobj);\n            _.throwIf(index === -1,'Tried to remove listen already gone from subscriptions list!');\n            subs.splice(index, 1);\n            desub();\n        };\n        subscriptionobj = {\n            stop: unsubscriber,\n            listenable: listenable\n        };\n        subs.push(subscriptionobj);\n        return subscriptionobj;\n    },\n\n    /**\n     * Stops listening to a single listenable\n     *\n     * @param {Action|Store} listenable The action or store we no longer want to listen to\n     * @returns {Boolean} True if a subscription was found and removed, otherwise false.\n     */\n    stopListeningTo: function(listenable){\n        var sub, i = 0, subs = this.subscriptions || [];\n        for(;i < subs.length; i++){\n            sub = subs[i];\n            if (sub.listenable === listenable){\n                sub.stop();\n                _.throwIf(subs.indexOf(sub)!==-1,'Failed to remove listen from subscriptions list!');\n                return true;\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Stops all subscriptions and empties subscriptions array\n     */\n    stopListeningToAll: function(){\n        var remaining, subs = this.subscriptions || [];\n        while((remaining=subs.length)){\n            subs[0].stop();\n            _.throwIf(subs.length!==remaining-1,'Failed to remove listen from subscriptions list!');\n        }\n    },\n\n    /**\n     * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\n     * @param {Action|Store} listenable The publisher we want to get initial state from\n     * @param {Function|String} defaultCallback The method to receive the data\n     */\n    fetchInitialState: function (listenable, defaultCallback) {\n        defaultCallback = (defaultCallback && this[defaultCallback]) || defaultCallback;\n        var me = this;\n        if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n            var data = listenable.getInitialState();\n            if (data && _.isFunction(data.then)) {\n                data.then(function() {\n                    defaultCallback.apply(me, arguments);\n                });\n            } else {\n                defaultCallback.call(this, data);\n            }\n        }\n    },\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with the last emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinTrailing: maker(\"last\"),\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with the first emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinLeading: maker(\"first\"),\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with all emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinConcat: maker(\"all\"),\n\n    /**\n     * The callback will be called once all listenables have triggered.\n     * If a callback triggers twice before that happens, an error is thrown.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinStrict: maker(\"strict\")\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/ListenerMethods.js\n ** module id = 177\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/ListenerMethods.js?");

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _ = __webpack_require__(188);\n\n/**\n * A module of methods for object that you want to be able to listen to.\n * This module is consumed by `createStore` and `createAction`\n */\nmodule.exports = {\n\n    /**\n     * Hook used by the publisher that is invoked before emitting\n     * and before `shouldEmit`. The arguments are the ones that the action\n     * is invoked with. If this function returns something other than\n     * undefined, that will be passed on as arguments for shouldEmit and\n     * emission.\n     */\n    preEmit: function() {},\n\n    /**\n     * Hook used by the publisher after `preEmit` to determine if the\n     * event should be emitted with given arguments. This may be overridden\n     * in your application, default implementation always returns true.\n     *\n     * @returns {Boolean} true if event should be emitted\n     */\n    shouldEmit: function() { return true; },\n\n    /**\n     * Subscribes the given callback for action triggered\n     *\n     * @param {Function} callback The callback to register as event handler\n     * @param {Mixed} [optional] bindContext The context to bind the callback with\n     * @returns {Function} Callback that unsubscribes the registered event handler\n     */\n    listen: function(callback, bindContext) {\n        bindContext = bindContext || this;\n        var eventHandler = function(args) {\n            callback.apply(bindContext, args);\n        }, me = this;\n        this.emitter.addListener(this.eventLabel, eventHandler);\n        return function() {\n            me.emitter.removeListener(me.eventLabel, eventHandler);\n        };\n    },\n\n    /**\n     * Attach handlers to promise that trigger the completed and failed\n     * child publishers, if available.\n     *\n     * @param {Object} The promise to attach to\n     */\n    promise: function(promise) {\n        var me = this;\n\n        var canHandlePromise =\n            this.children.indexOf('completed') >= 0 &&\n            this.children.indexOf('failed') >= 0;\n\n        if (!canHandlePromise){\n            throw new Error('Publisher must have \"completed\" and \"failed\" child publishers');\n        }\n\n        promise.then(function(response) {\n            return me.completed(response);\n        });\n        // IE compatibility - catch is a reserved word - without bracket notation source compilation will fail under IE\n        promise[\"catch\"](function(error) {\n            return me.failed(error);\n        });\n    },\n\n    /**\n     * Subscribes the given callback for action triggered, which should\n     * return a promise that in turn is passed to `this.promise`\n     *\n     * @param {Function} callback The callback to register as event handler\n     */\n    listenAndPromise: function(callback, bindContext) {\n        var me = this;\n        bindContext = bindContext || this;\n\n        return this.listen(function() {\n\n            if (!callback) {\n                throw new Error('Expected a function returning a promise but got ' + callback);\n            }\n\n            var args = arguments,\n                promise = callback.apply(bindContext, args);\n            return me.promise.call(me, promise);\n        }, bindContext);\n    },\n\n    /**\n     * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\n     */\n    trigger: function() {\n        var args = arguments,\n            pre = this.preEmit.apply(this, args);\n        args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n        if (this.shouldEmit.apply(this, args)) {\n            this.emitter.emit(this.eventLabel, args);\n        }\n    },\n\n    /**\n     * Tries to publish the event on the next tick\n     */\n    triggerAsync: function(){\n        var args = arguments,me = this;\n        _.nextTick(function() {\n            me.trigger.apply(me, args);\n        });\n    },\n\n    /**\n     * Returns a Promise for the triggered action\n     */\n    triggerPromise: function(){\n        var me = this;\n        var args = arguments;\n\n        var canHandlePromise =\n            this.children.indexOf('completed') >= 0 &&\n            this.children.indexOf('failed') >= 0;\n\n        if (!canHandlePromise){\n            throw new Error('Publisher must have \"completed\" and \"failed\" child publishers');\n        }\n\n        var promise = _.createPromise(function(resolve, reject) {\n            var removeSuccess = me.completed.listen(function(args) {\n                removeSuccess();\n                removeFailed();\n                resolve(args);\n            });\n\n            var removeFailed = me.failed.listen(function(args) {\n                removeSuccess();\n                removeFailed();\n                reject(args);\n            });\n\n            me.triggerAsync.apply(me, args);\n        });\n\n        return promise;\n    },\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/PublisherMethods.js\n ** module id = 178\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/PublisherMethods.js?");

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * A module of methods that you want to include in all stores.\n * This module is consumed by `createStore`.\n */\nmodule.exports = {\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/StoreMethods.js\n ** module id = 179\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/StoreMethods.js?");

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _ = __webpack_require__(188),\n    Reflux = __webpack_require__(76),\n    Keep = __webpack_require__(189),\n    allowed = {preEmit:1,shouldEmit:1};\n\n/**\n * Creates an action functor object. It is mixed in with functions\n * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\n * be overridden in the definition object.\n *\n * @param {Object} definition The action object definition\n */\nvar createAction = function(definition) {\n\n    definition = definition || {};\n    if (!_.isObject(definition)){\n        definition = {actionName: definition};\n    }\n\n    for(var a in Reflux.ActionMethods){\n        if (!allowed[a] && Reflux.PublisherMethods[a]) {\n            throw new Error(\"Cannot override API method \" + a +\n                \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\"\n            );\n        }\n    }\n\n    for(var d in definition){\n        if (!allowed[d] && Reflux.PublisherMethods[d]) {\n            throw new Error(\"Cannot override API method \" + d +\n                \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\"\n            );\n        }\n    }\n\n    definition.children = definition.children || [];\n    if (definition.asyncResult){\n        definition.children = definition.children.concat([\"completed\",\"failed\"]);\n    }\n\n    var i = 0, childActions = {};\n    for (; i < definition.children.length; i++) {\n        var name = definition.children[i];\n        childActions[name] = createAction(name);\n    }\n\n    var context = _.extend({\n        eventLabel: \"action\",\n        emitter: new _.EventEmitter(),\n        _isAction: true\n    }, Reflux.PublisherMethods, Reflux.ActionMethods, definition);\n\n    var functor = function() {\n        functor[functor.sync?\"trigger\":\"triggerAsync\"].apply(functor, arguments);\n    };\n\n    _.extend(functor,childActions,context);\n\n    Keep.createdActions.push(functor);\n\n    return functor;\n\n};\n\nmodule.exports = createAction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/createAction.js\n ** module id = 180\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/createAction.js?");

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _ = __webpack_require__(188),\n    Reflux = __webpack_require__(76),\n    Keep = __webpack_require__(189),\n    mixer = __webpack_require__(244),\n    allowed = {preEmit:1,shouldEmit:1},\n    bindMethods = __webpack_require__(245);\n\n/**\n * Creates an event emitting Data Store. It is mixed in with functions\n * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`\n * and `shouldEmit` may be overridden in the definition object.\n *\n * @param {Object} definition The data store object definition\n * @returns {Store} A data store instance\n */\nmodule.exports = function(definition) {\n\n    definition = definition || {};\n\n    for(var a in Reflux.StoreMethods){\n        if (!allowed[a] && (Reflux.PublisherMethods[a] || Reflux.ListenerMethods[a])){\n            throw new Error(\"Cannot override API method \" + a +\n                \" in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\"\n            );\n        }\n    }\n\n    for(var d in definition){\n        if (!allowed[d] && (Reflux.PublisherMethods[d] || Reflux.ListenerMethods[d])){\n            throw new Error(\"Cannot override API method \" + d +\n                \" in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\"\n            );\n        }\n    }\n\n    definition = mixer(definition);\n\n    function Store() {\n        var i=0, arr;\n        this.subscriptions = [];\n        this.emitter = new _.EventEmitter();\n        this.eventLabel = \"change\";\n        bindMethods(this, definition);\n        if (this.init && _.isFunction(this.init)) {\n            this.init();\n        }\n        if (this.listenables){\n            arr = [].concat(this.listenables);\n            for(;i < arr.length;i++){\n                this.listenToMany(arr[i]);\n            }\n        }\n    }\n\n    _.extend(Store.prototype, Reflux.ListenerMethods, Reflux.PublisherMethods, Reflux.StoreMethods, definition);\n\n    var store = new Store();\n    Keep.createdStores.push(store);\n\n    return store;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/createStore.js\n ** module id = 181\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/createStore.js?");

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Reflux = __webpack_require__(76),\n    _ = __webpack_require__(188);\n\nmodule.exports = function(listenable,key){\n    return {\n        getInitialState: function(){\n            if (!_.isFunction(listenable.getInitialState)) {\n                return {};\n            } else if (key === undefined) {\n                return listenable.getInitialState();\n            } else {\n                return _.object([key],[listenable.getInitialState()]);\n            }\n        },\n        componentDidMount: function(){\n            _.extend(this,Reflux.ListenerMethods);\n            var me = this, cb = (key === undefined ? this.setState : function(v){me.setState(_.object([key],[v]));});\n            this.listenTo(listenable,cb);\n        },\n        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount\n    };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/connect.js\n ** module id = 182\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/connect.js?");

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Reflux = __webpack_require__(76),\n  _ = __webpack_require__(188);\n\nmodule.exports = function(listenable, key, filterFunc) {\n    filterFunc = _.isFunction(key) ? key : filterFunc;\n    return {\n        getInitialState: function() {\n            if (!_.isFunction(listenable.getInitialState)) {\n                return {};\n            } else if (_.isFunction(key)) {\n                return filterFunc.call(this, listenable.getInitialState());\n            } else {\n                // Filter initial payload from store.\n                var result = filterFunc.call(this, listenable.getInitialState());\n                if (result) {\n                  return _.object([key], [result]);\n                } else {\n                  return {};\n                }\n            }\n        },\n        componentDidMount: function() {\n            _.extend(this, Reflux.ListenerMethods);\n            var me = this;\n            var cb = function(value) {\n                if (_.isFunction(key)) {\n                    me.setState(filterFunc.call(me, value));\n                } else {\n                    var result = filterFunc.call(me, value);\n                    me.setState(_.object([key], [result]));\n                }\n            };\n\n            this.listenTo(listenable, cb);\n        },\n        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount\n    };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/connectFilter.js\n ** module id = 183\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/connectFilter.js?");

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _ = __webpack_require__(188),\n    ListenerMethods = __webpack_require__(177);\n\n/**\n * A module meant to be consumed as a mixin by a React component. Supplies the methods from\n * `ListenerMethods` mixin and takes care of teardown of subscriptions.\n * Note that if you're using the `connect` mixin you don't need this mixin, as connect will\n * import everything this mixin contains!\n */\nmodule.exports = _.extend({\n\n    /**\n     * Cleans up all listener previously registered.\n     */\n    componentWillUnmount: ListenerMethods.stopListeningToAll\n\n}, ListenerMethods);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/ListenerMixin.js\n ** module id = 184\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/ListenerMixin.js?");

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Reflux = __webpack_require__(76);\n\n\n/**\n * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,\n * without having to manually set listeners in the `componentDidMount` method.\n *\n * @param {Action|Store} listenable An Action or Store that should be\n *  listened to.\n * @param {Function|String} callback The callback to register as event handler\n * @param {Function|String} defaultCallback The callback to register as default handler\n * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.\n */\nmodule.exports = function(listenable,callback,initial){\n    return {\n        /**\n         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n         * and then make the call to `listenTo` with the arguments provided to the factory function\n         */\n        componentDidMount: function() {\n            for(var m in Reflux.ListenerMethods){\n                if (this[m] !== Reflux.ListenerMethods[m]){\n                    if (this[m]){\n                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenTo!\";\n                    }\n                    this[m] = Reflux.ListenerMethods[m];\n                }\n            }\n            this.listenTo(listenable,callback,initial);\n        },\n        /**\n         * Cleans up all listener previously registered.\n         */\n        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll\n    };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/listenTo.js\n ** module id = 185\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/listenTo.js?");

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	eval("var Reflux = __webpack_require__(76);\n\n/**\n * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,\n * without having to manually set listeners in the `componentDidMount` method. This version is used\n * to automatically set up a `listenToMany` call.\n *\n * @param {Object} listenables An object of listenables\n * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.\n */\nmodule.exports = function(listenables){\n    return {\n        /**\n         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n         * and then make the call to `listenTo` with the arguments provided to the factory function\n         */\n        componentDidMount: function() {\n            for(var m in Reflux.ListenerMethods){\n                if (this[m] !== Reflux.ListenerMethods[m]){\n                    if (this[m]){\n                        throw \"Can't have other property '\"+m+\"' when using Reflux.listenToMany!\";\n                    }\n                    this[m] = Reflux.ListenerMethods[m];\n                }\n            }\n            this.listenToMany(listenables);\n        },\n        /**\n         * Cleans up all listener previously registered.\n         */\n        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll\n    };\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/listenToMany.js\n ** module id = 186\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/listenToMany.js?");

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Internal module used to create static and instance join methods\n */\n\nvar slice = Array.prototype.slice,\n    _ = __webpack_require__(188),\n    createStore = __webpack_require__(181),\n    strategyMethodNames = {\n        strict: \"joinStrict\",\n        first: \"joinLeading\",\n        last: \"joinTrailing\",\n        all: \"joinConcat\"\n    };\n\n/**\n * Used in `index.js` to create the static join methods\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\n */\nexports.staticJoinCreator = function(strategy){\n    return function(/* listenables... */) {\n        var listenables = slice.call(arguments);\n        return createStore({\n            init: function(){\n                this[strategyMethodNames[strategy]].apply(this,listenables.concat(\"triggerAsync\"));\n            }\n        });\n    };\n};\n\n/**\n * Used in `ListenerMethods.js` to create the instance join methods\n * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\n */\nexports.instanceJoinCreator = function(strategy){\n    return function(/* listenables..., callback*/){\n        _.throwIf(arguments.length < 3,'Cannot create a join with less than 2 listenables!');\n        var listenables = slice.call(arguments),\n            callback = listenables.pop(),\n            numberOfListenables = listenables.length,\n            join = {\n                numberOfListenables: numberOfListenables,\n                callback: this[callback]||callback,\n                listener: this,\n                strategy: strategy\n            }, i, cancels = [], subobj;\n        for (i = 0; i < numberOfListenables; i++) {\n            _.throwIf(this.validateListening(listenables[i]));\n        }\n        for (i = 0; i < numberOfListenables; i++) {\n            cancels.push(listenables[i].listen(newListener(i,join),this));\n        }\n        reset(join);\n        subobj = {listenable: listenables};\n        subobj.stop = makeStopper(subobj,cancels,this);\n        this.subscriptions = (this.subscriptions || []).concat(subobj);\n        return subobj;\n    };\n};\n\n// ---- internal join functions ----\n\nfunction makeStopper(subobj,cancels,context){\n    return function() {\n        var i, subs = context.subscriptions,\n            index = (subs ? subs.indexOf(subobj) : -1);\n        _.throwIf(index === -1,'Tried to remove join already gone from subscriptions list!');\n        for(i=0;i < cancels.length; i++){\n            cancels[i]();\n        }\n        subs.splice(index, 1);\n    };\n}\n\nfunction reset(join) {\n    join.listenablesEmitted = new Array(join.numberOfListenables);\n    join.args = new Array(join.numberOfListenables);\n}\n\nfunction newListener(i,join) {\n    return function() {\n        var callargs = slice.call(arguments);\n        if (join.listenablesEmitted[i]){\n            switch(join.strategy){\n                case \"strict\": throw new Error(\"Strict join failed because listener triggered twice.\");\n                case \"last\": join.args[i] = callargs; break;\n                case \"all\": join.args[i].push(callargs);\n            }\n        } else {\n            join.listenablesEmitted[i] = true;\n            join.args[i] = (join.strategy===\"all\"?[callargs]:callargs);\n        }\n        emitIfAllListenablesEmitted(join);\n    };\n}\n\nfunction emitIfAllListenablesEmitted(join) {\n    for (var i = 0; i < join.numberOfListenables; i++) {\n        if (!join.listenablesEmitted[i]) {\n            return;\n        }\n    }\n    join.callback.apply(join.listener,join.args);\n    reset(join);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/joins.js\n ** module id = 187\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/joins.js?");

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n * isObject, extend, isFunction, isArguments are taken from undescore/lodash in\n * order to remove the dependency\n */\nvar isObject = exports.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n};\n\nexports.extend = function(obj) {\n    if (!isObject(obj)) {\n        return obj;\n    }\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n        source = arguments[i];\n        for (prop in source) {\n            obj[prop] = source[prop];\n        }\n    }\n    return obj;\n};\n\nexports.isFunction = function(value) {\n    return typeof value === 'function';\n};\n\nexports.EventEmitter = __webpack_require__(246);\n\nexports.nextTick = function(callback) {\n    setTimeout(callback, 0);\n};\n\nexports.capitalize = function(string){\n    return string.charAt(0).toUpperCase()+string.slice(1);\n};\n\nexports.callbackName = function(string){\n    return \"on\"+exports.capitalize(string);\n};\n\nexports.object = function(keys,vals){\n    var o={}, i=0;\n    for(;i<keys.length;i++){\n        o[keys[i]] = vals[i];\n    }\n    return o;\n};\n\nexports.Promise = __webpack_require__(256);\n\nexports.createPromise = function(resolver) {\n    return new exports.Promise(resolver);\n};\n\nexports.isArguments = function(value) {\n    return typeof value === 'object' && ('callee' in value) && typeof value.length === 'number';\n};\n\nexports.throwIf = function(val,msg){\n    if (val){\n        throw Error(msg||val);\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/utils.js\n ** module id = 188\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/utils.js?");

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports.createdStores = [];\n\nexports.createdActions = [];\n\nexports.reset = function() {\n    while(exports.createdStores.length) {\n        exports.createdStores.pop();\n    }\n    while(exports.createdActions.length) {\n        exports.createdActions.pop();\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/Keep.js\n ** module id = 189\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/Keep.js?");

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.7.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.7.0';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var createCallback = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  _.iteratee = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return createCallback(value, context, argCount);\n    if (_.isObject(value)) return _.matches(value);\n    return _.property(value);\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    if (obj == null) return obj;\n    iteratee = createCallback(iteratee, context);\n    var i, length = obj.length;\n    if (length === +length) {\n      for (i = 0; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    if (obj == null) return [];\n    iteratee = _.iteratee(iteratee, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length),\n        currentKey;\n    for (var index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index = 0, currentKey;\n    if (arguments.length < 3) {\n      if (!length) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[index++] : index++];\n    }\n    for (; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== + obj.length && _.keys(obj),\n        index = (keys || obj).length,\n        currentKey;\n    if (arguments.length < 3) {\n      if (!index) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[--index] : --index];\n    }\n    while (index--) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    predicate = _.iteratee(predicate, context);\n    _.some(obj, function(value, index, list) {\n      if (predicate(value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    predicate = _.iteratee(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(_.iteratee(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    if (obj == null) return true;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    if (obj == null) return false;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (obj.length !== +obj.length) obj = _.values(obj);\n    return _.indexOf(obj, target) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = obj && obj.length === +obj.length ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = low + high >>> 1;\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = _.iteratee(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    for (var i = 0, length = input.length; i < length; i++) {\n      var value = input[i];\n      if (!_.isArray(value) && !_.isArguments(value)) {\n        if (!strict) output.push(value);\n      } else if (shallow) {\n        push.apply(output, value);\n      } else {\n        flatten(value, shallow, strict, output);\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (array == null) return [];\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = _.iteratee(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = array.length; i < length; i++) {\n      var value = array[i];\n      if (isSorted) {\n        if (!i || seen !== value) result.push(value);\n        seen = value;\n      } else if (iteratee) {\n        var computed = iteratee(value, i, array);\n        if (_.indexOf(seen, computed) < 0) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (_.indexOf(result, value) < 0) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true, []));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    if (array == null) return [];\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = array.length; i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(slice.call(arguments, 1), true, true, []);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function(array) {\n    if (array == null) return [];\n    var length = _.max(arguments, 'length').length;\n    var results = Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var idx = array.length;\n    if (typeof from == 'number') {\n      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n    }\n    while (--idx >= 0) if (array[idx] === item) return idx;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var Ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    args = slice.call(arguments, 2);\n    bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      Ctor.prototype = func.prototype;\n      var self = new Ctor;\n      Ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (_.isObject(result)) return result;\n      return self;\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = hasher ? hasher.apply(this, arguments) : key;\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last > 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed before being called N times.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      } else {\n        func = null;\n      }\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (hasOwnProperty.call(source, prop)) {\n            obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj, iteratee, context) {\n    var result = {}, key;\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      iteratee = createCallback(iteratee, context);\n      for (key in obj) {\n        var value = obj[key];\n        if (iteratee(value, key, obj)) result[key] = value;\n      }\n    } else {\n      var keys = concat.apply([], slice.call(arguments, 1));\n      obj = new Object(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        key = keys[i];\n        if (key in obj) result[key] = obj[key];\n      }\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      var source = arguments[i];\n      for (var prop in source) {\n        if (obj[prop] === void 0) obj[prop] = source[prop];\n      }\n    }\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (\n      aCtor !== bCtor &&\n      // Handle Object.create(x) cases\n      'constructor' in a && 'constructor' in b &&\n      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n        _.isFunction(bCtor) && bCtor instanceof bCtor)\n    ) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size, result;\n    // Recursively compare objects and arrays.\n    if (className === '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size === b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      size = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      result = _.keys(b).length === size;\n      if (result) {\n        while (size--) {\n          // Deep compare each member\n          key = keys[size];\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.\n  if (typeof /./ !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    var pairs = _.pairs(attrs), length = pairs.length;\n    return function(obj) {\n      if (obj == null) return !length;\n      obj = new Object(obj);\n      for (var i = 0; i < length; i++) {\n        var pair = pairs[i], key = pair[0];\n        if (pair[1] !== obj[key] || !(key in obj)) return false;\n      }\n      return true;\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = createCallback(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? object[property]() : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return _;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}.call(this));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/backbone/~/underscore/underscore.js\n ** module id = 190\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/backbone/~/underscore/underscore.js?");

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This file contains an unmodified version of:\n * https://github.com/facebook/react/blob/v0.12.0/src/utils/joinClasses.js\n *\n * This source code is licensed under the BSD-style license found here:\n * https://github.com/facebook/react/blob/v0.12.0/LICENSE\n * An additional grant of patent rights can be found here:\n * https://github.com/facebook/react/blob/v0.12.0/PATENTS\n */\n\n\"use strict\";\n\n/**\n * Combines multiple className strings into one.\n * http://jsperf.com/joinclasses-args-vs-array\n *\n * @param {...?string} classes\n * @return {string}\n */\nfunction joinClasses(className/*, ... */) {\n  if (!className) {\n    className = '';\n  }\n  var nextClass;\n  var argLength = arguments.length;\n  if (argLength > 1) {\n    for (var ii = 1; ii < argLength; ii++) {\n      nextClass = arguments[ii];\n      if (nextClass) {\n        className = (className ? className + ' ' : '') + nextClass;\n      }\n    }\n  }\n  return className;\n}\n\nmodule.exports = joinClasses;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/joinClasses.js\n ** module id = 191\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/joinClasses.js?");

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n/**\n * Shortcut to compute element style\n *\n * @param {HTMLElement} elem\n * @returns {CssStyle}\n */\nfunction getComputedStyles(elem) {\n  return elem.ownerDocument.defaultView.getComputedStyle(elem, null);\n}\n\n/**\n * Get elements offset\n *\n * TODO: REMOVE JQUERY!\n *\n * @param {HTMLElement} DOMNode\n * @returns {{top: number, left: number}}\n */\nfunction getOffset(DOMNode) {\n  if (window.jQuery) {\n    return window.jQuery(DOMNode).offset();\n  }\n\n  var docElem = document.documentElement;\n  var box = { top: 0, left: 0 };\n\n  // If we don't have gBCR, just use 0,0 rather than error\n  // BlackBerry 5, iOS 3 (original iPhone)\n  if ( typeof DOMNode.getBoundingClientRect !== 'undefined' ) {\n    box = DOMNode.getBoundingClientRect();\n  }\n\n  return {\n    top: box.top + window.pageYOffset - docElem.clientTop,\n    left: box.left + window.pageXOffset - docElem.clientLeft\n  };\n}\n\n/**\n * Get elements position\n *\n * TODO: REMOVE JQUERY!\n *\n * @param {HTMLElement} elem\n * @param {HTMLElement?} offsetParent\n * @returns {{top: number, left: number}}\n */\nfunction getPosition(elem, offsetParent) {\n  if (window.jQuery) {\n    return window.jQuery(elem).position();\n  }\n\n  var offset,\n      parentOffset = {top: 0, left: 0};\n\n  // Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent\n  if (getComputedStyles(elem).position === 'fixed' ) {\n    // We assume that getBoundingClientRect is available when computed position is fixed\n    offset = elem.getBoundingClientRect();\n\n  } else {\n    if (!offsetParent) {\n      // Get *real* offsetParent\n      offsetParent = offsetParent(elem);\n    }\n\n    // Get correct offsets\n    offset = getOffset(elem);\n    if ( offsetParent.nodeName !== 'HTML') {\n      parentOffset = getOffset(offsetParent);\n    }\n\n    // Add offsetParent borders\n    parentOffset.top += parseInt(getComputedStyles(offsetParent).borderTopWidth, 10);\n    parentOffset.left += parseInt(getComputedStyles(offsetParent).borderLeftWidth, 10);\n  }\n\n  // Subtract parent offsets and element margins\n  return {\n    top: offset.top - parentOffset.top - parseInt(getComputedStyles(elem).marginTop, 10),\n    left: offset.left - parentOffset.left - parseInt(getComputedStyles(elem).marginLeft, 10)\n  };\n}\n\n/**\n * Get parent element\n *\n * @param {HTMLElement?} elem\n * @returns {HTMLElement}\n */\nfunction offsetParent(elem) {\n  var docElem = document.documentElement;\n  var offsetParent = elem.offsetParent || docElem;\n\n  while ( offsetParent && ( offsetParent.nodeName !== 'HTML' &&\n    getComputedStyles(offsetParent).position === 'static' ) ) {\n    offsetParent = offsetParent.offsetParent;\n  }\n\n  return offsetParent || docElem;\n}\n\nmodule.exports = {\n  getComputedStyles: getComputedStyles,\n  getOffset: getOffset,\n  getPosition: getPosition,\n  offsetParent: offsetParent\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/domUtils.js\n ** module id = 192\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/domUtils.js?");

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * This file contains a modified version of:\n * https://github.com/facebook/react/blob/v0.12.0/src/vendor/stubs/EventListener.js\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * TODO: remove in favour of solution provided by:\n *  https://github.com/facebook/react/issues/285\n */\n\n/**\n * Does not take into account specific nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  }\n};\n\nmodule.exports = EventListener;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/EventListener.js\n ** module id = 193\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/EventListener.js?");

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = {\n  CLASSES: {\n    'alert': 'alert',\n    'button': 'btn',\n    'button-group': 'btn-group',\n    'button-toolbar': 'btn-toolbar',\n    'column': 'col',\n    'input-group': 'input-group',\n    'form': 'form',\n    'glyphicon': 'glyphicon',\n    'label': 'label',\n    'list-group-item': 'list-group-item',\n    'panel': 'panel',\n    'panel-group': 'panel-group',\n    'progress-bar': 'progress-bar',\n    'nav': 'nav',\n    'navbar': 'navbar',\n    'modal': 'modal',\n    'row': 'row',\n    'well': 'well'\n  },\n  STYLES: {\n    'default': 'default',\n    'primary': 'primary',\n    'success': 'success',\n    'info': 'info',\n    'warning': 'warning',\n    'danger': 'danger',\n    'link': 'link',\n    'inline': 'inline',\n    'tabs': 'tabs',\n    'pills': 'pills'\n  },\n  SIZES: {\n    'large': 'lg',\n    'medium': 'md',\n    'small': 'sm',\n    'xsmall': 'xs'\n  },\n  GLYPHS: [\n    'asterisk',\n    'plus',\n    'euro',\n    'minus',\n    'cloud',\n    'envelope',\n    'pencil',\n    'glass',\n    'music',\n    'search',\n    'heart',\n    'star',\n    'star-empty',\n    'user',\n    'film',\n    'th-large',\n    'th',\n    'th-list',\n    'ok',\n    'remove',\n    'zoom-in',\n    'zoom-out',\n    'off',\n    'signal',\n    'cog',\n    'trash',\n    'home',\n    'file',\n    'time',\n    'road',\n    'download-alt',\n    'download',\n    'upload',\n    'inbox',\n    'play-circle',\n    'repeat',\n    'refresh',\n    'list-alt',\n    'lock',\n    'flag',\n    'headphones',\n    'volume-off',\n    'volume-down',\n    'volume-up',\n    'qrcode',\n    'barcode',\n    'tag',\n    'tags',\n    'book',\n    'bookmark',\n    'print',\n    'camera',\n    'font',\n    'bold',\n    'italic',\n    'text-height',\n    'text-width',\n    'align-left',\n    'align-center',\n    'align-right',\n    'align-justify',\n    'list',\n    'indent-left',\n    'indent-right',\n    'facetime-video',\n    'picture',\n    'map-marker',\n    'adjust',\n    'tint',\n    'edit',\n    'share',\n    'check',\n    'move',\n    'step-backward',\n    'fast-backward',\n    'backward',\n    'play',\n    'pause',\n    'stop',\n    'forward',\n    'fast-forward',\n    'step-forward',\n    'eject',\n    'chevron-left',\n    'chevron-right',\n    'plus-sign',\n    'minus-sign',\n    'remove-sign',\n    'ok-sign',\n    'question-sign',\n    'info-sign',\n    'screenshot',\n    'remove-circle',\n    'ok-circle',\n    'ban-circle',\n    'arrow-left',\n    'arrow-right',\n    'arrow-up',\n    'arrow-down',\n    'share-alt',\n    'resize-full',\n    'resize-small',\n    'exclamation-sign',\n    'gift',\n    'leaf',\n    'fire',\n    'eye-open',\n    'eye-close',\n    'warning-sign',\n    'plane',\n    'calendar',\n    'random',\n    'comment',\n    'magnet',\n    'chevron-up',\n    'chevron-down',\n    'retweet',\n    'shopping-cart',\n    'folder-close',\n    'folder-open',\n    'resize-vertical',\n    'resize-horizontal',\n    'hdd',\n    'bullhorn',\n    'bell',\n    'certificate',\n    'thumbs-up',\n    'thumbs-down',\n    'hand-right',\n    'hand-left',\n    'hand-up',\n    'hand-down',\n    'circle-arrow-right',\n    'circle-arrow-left',\n    'circle-arrow-up',\n    'circle-arrow-down',\n    'globe',\n    'wrench',\n    'tasks',\n    'filter',\n    'briefcase',\n    'fullscreen',\n    'dashboard',\n    'paperclip',\n    'heart-empty',\n    'link',\n    'phone',\n    'pushpin',\n    'usd',\n    'gbp',\n    'sort',\n    'sort-by-alphabet',\n    'sort-by-alphabet-alt',\n    'sort-by-order',\n    'sort-by-order-alt',\n    'sort-by-attributes',\n    'sort-by-attributes-alt',\n    'unchecked',\n    'expand',\n    'collapse-down',\n    'collapse-up',\n    'log-in',\n    'flash',\n    'log-out',\n    'new-window',\n    'record',\n    'save',\n    'open',\n    'saved',\n    'import',\n    'export',\n    'send',\n    'floppy-disk',\n    'floppy-saved',\n    'floppy-remove',\n    'floppy-save',\n    'floppy-open',\n    'credit-card',\n    'transfer',\n    'cutlery',\n    'header',\n    'compressed',\n    'earphone',\n    'phone-alt',\n    'tower',\n    'stats',\n    'sd-video',\n    'hd-video',\n    'subtitles',\n    'sound-stereo',\n    'sound-dolby',\n    'sound-5-1',\n    'sound-6-1',\n    'sound-7-1',\n    'copyright-mark',\n    'registration-mark',\n    'cloud-download',\n    'cloud-upload',\n    'tree-conifer',\n    'tree-deciduous'\n  ]\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/constants.js\n ** module id = 194\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/constants.js?");

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This file contains an unmodified version of:\n * https://github.com/facebook/react/blob/v0.12.0/src/vendor/stubs/cx.js\n *\n * This source code is licensed under the BSD-style license found here:\n * https://github.com/facebook/react/blob/v0.12.0/LICENSE\n * An additional grant of patent rights can be found here:\n * https://github.com/facebook/react/blob/v0.12.0/PATENTS\n */\n\n/**\n * This function is used to mark string literals representing CSS class names\n * so that they can be transformed statically. This allows for modularization\n * and minification of CSS class names.\n *\n * In static_upstream, this function is actually implemented, but it should\n * eventually be replaced with something more descriptive, and the transform\n * that is used in the main stack should be ported for use elsewhere.\n *\n * @param string|object className to modularize, or an object of key/values.\n *                      In the object case, the values are conditions that\n *                      determine if the className keys should be included.\n * @param [string ...]  Variable list of classNames in the string case.\n * @return string       Renderable space-separated CSS className.\n */\nfunction cx(classNames) {\n  if (typeof classNames == 'object') {\n    return Object.keys(classNames).filter(function(className) {\n      return classNames[className];\n    }).join(' ');\n  } else {\n    return Array.prototype.join.call(arguments, ' ');\n  }\n}\n\nmodule.exports = cx;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/classSet.js\n ** module id = 195\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/classSet.js?");

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\n\n/**\n * Maps children that are typically specified as `props.children`,\n * but only iterates over children that are \"valid components\".\n *\n * The mapFunction provided index will be normalised to the components mapped,\n * so an invalid component would not increase the index.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} mapFunction.\n * @param {*} mapContext Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapValidComponents(children, func, context) {\n  var index = 0;\n\n  return React.Children.map(children, function (child) {\n    if (React.isValidElement(child)) {\n      var lastIndex = index;\n      index++;\n      return func.call(context, child, lastIndex);\n    }\n\n    return child;\n  });\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`,\n * but only iterates over children that are \"valid components\".\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child with the index reflecting the position relative to \"valid components\".\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc.\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachValidComponents(children, func, context) {\n  var index = 0;\n\n  return React.Children.forEach(children, function (child) {\n    if (React.isValidElement(child)) {\n      func.call(context, child, index);\n      index++;\n    }\n  });\n}\n\n/**\n * Count the number of \"valid components\" in the Children container.\n *\n * @param {?*} children Children tree container.\n * @returns {number}\n */\nfunction numberOfValidComponents(children) {\n  var count = 0;\n\n  React.Children.forEach(children, function (child) {\n    if (React.isValidElement(child)) { count++; }\n  });\n\n  return count;\n}\n\n/**\n * Determine if the Child container has one or more \"valid components\".\n *\n * @param {?*} children Children tree container.\n * @returns {boolean}\n */\nfunction hasValidComponent(children) {\n  var hasValid = false;\n\n  React.Children.forEach(children, function (child) {\n    if (!hasValid && React.isValidElement(child)) {\n      hasValid = true;\n    }\n  });\n\n  return hasValid;\n}\n\nmodule.exports = {\n  map: mapValidComponents,\n  forEach: forEachValidComponents,\n  numberOf: numberOfValidComponents,\n  hasValidComponent: hasValidComponent\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/ValidComponentChildren.js\n ** module id = 196\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/ValidComponentChildren.js?");

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This file contains modified versions of:\n * https://github.com/facebook/react/blob/v0.12.0/src/utils/cloneWithProps.js\n * https://github.com/facebook/react/blob/v0.12.0/src/core/ReactPropTransferer.js\n *\n * This source code is licensed under the BSD-style license found here:\n * https://github.com/facebook/react/blob/v0.12.0/LICENSE\n * An additional grant of patent rights can be found here:\n * https://github.com/facebook/react/blob/v0.12.0/PATENTS\n *\n * TODO: This should be replaced as soon as cloneWithProps is available via\n *  the core React package or a separate package.\n *  @see https://github.com/facebook/react/issues/1906\n */\n\nvar React = __webpack_require__(12);\nvar joinClasses = __webpack_require__(191);\nvar assign = __webpack_require__(201);\n\n/**\n * Creates a transfer strategy that will merge prop values using the supplied\n * `mergeStrategy`. If a prop was previously unset, this just sets it.\n *\n * @param {function} mergeStrategy\n * @return {function}\n */\nfunction createTransferStrategy(mergeStrategy) {\n  return function(props, key, value) {\n    if (!props.hasOwnProperty(key)) {\n      props[key] = value;\n    } else {\n      props[key] = mergeStrategy(props[key], value);\n    }\n  };\n}\n\nvar transferStrategyMerge = createTransferStrategy(function(a, b) {\n  // `merge` overrides the first object's (`props[key]` above) keys using the\n  // second object's (`value`) keys. An object's style's existing `propA` would\n  // get overridden. Flip the order here.\n  return assign({}, b, a);\n});\n\nfunction emptyFunction() {}\n\n/**\n * Transfer strategies dictate how props are transferred by `transferPropsTo`.\n * NOTE: if you add any more exceptions to this list you should be sure to\n * update `cloneWithProps()` accordingly.\n */\nvar TransferStrategies = {\n  /**\n   * Never transfer `children`.\n   */\n  children: emptyFunction,\n  /**\n   * Transfer the `className` prop by merging them.\n   */\n  className: createTransferStrategy(joinClasses),\n  /**\n   * Transfer the `style` prop (which is an object) by merging them.\n   */\n  style: transferStrategyMerge\n};\n\n/**\n * Mutates the first argument by transferring the properties from the second\n * argument.\n *\n * @param {object} props\n * @param {object} newProps\n * @return {object}\n */\nfunction transferInto(props, newProps) {\n  for (var thisKey in newProps) {\n    if (!newProps.hasOwnProperty(thisKey)) {\n      continue;\n    }\n\n    var transferStrategy = TransferStrategies[thisKey];\n\n    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {\n      transferStrategy(props, thisKey, newProps[thisKey]);\n    } else if (!props.hasOwnProperty(thisKey)) {\n      props[thisKey] = newProps[thisKey];\n    }\n  }\n  return props;\n}\n\n/**\n * Merge two props objects using TransferStrategies.\n *\n * @param {object} oldProps original props (they take precedence)\n * @param {object} newProps new props to merge in\n * @return {object} a new object containing both sets of props merged.\n */\nfunction mergeProps(oldProps, newProps) {\n  return transferInto(assign({}, oldProps), newProps);\n}\n\n\nvar ReactPropTransferer = {\n  mergeProps: mergeProps\n};\n\nvar CHILDREN_PROP = 'children';\n\n/**\n * Sometimes you want to change the props of a child passed to you. Usually\n * this is to add a CSS class.\n *\n * @param {object} child child component you'd like to clone\n * @param {object} props props you'd like to modify. They will be merged\n * as if you used `transferPropsTo()`.\n * @return {object} a clone of child with props merged in.\n */\nfunction cloneWithProps(child, props) {\n  var newProps = ReactPropTransferer.mergeProps(props, child.props);\n\n  // Use `child.props.children` if it is provided.\n  if (!newProps.hasOwnProperty(CHILDREN_PROP) &&\n    child.props.hasOwnProperty(CHILDREN_PROP)) {\n    newProps.children = child.props.children;\n  }\n\n  if (React.version.substr(0, 4) === '0.12'){\n    var mockLegacyFactory = function(){};\n    mockLegacyFactory.isReactLegacyFactory = true;\n    mockLegacyFactory.type = child.type;\n\n    return React.createElement(mockLegacyFactory, newProps);\n  }\n\n  // The current API doesn't retain _owner and _context, which is why this\n  // doesn't use ReactElement.cloneAndReplaceProps.\n  return React.createElement(child.type, newProps);\n}\n\nmodule.exports = cloneWithProps;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/cloneWithProps.js\n ** module id = 197\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/cloneWithProps.js?");

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This file contains a modified version of:\n * https://github.com/facebook/react/blob/v0.12.0/src/addons/transitions/ReactTransitionEvents.js\n *\n * This source code is licensed under the BSD-style license found here:\n * https://github.com/facebook/react/blob/v0.12.0/LICENSE\n * An additional grant of patent rights can be found here:\n * https://github.com/facebook/react/blob/v0.12.0/PATENTS\n */\n\nvar canUseDOM = !!(\n  typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  );\n\n/**\n * EVENT_NAME_MAP is used to determine which event fired when a\n * transition/animation ends, based on the style property used to\n * define that event.\n */\nvar EVENT_NAME_MAP = {\n  transitionend: {\n    'transition': 'transitionend',\n    'WebkitTransition': 'webkitTransitionEnd',\n    'MozTransition': 'mozTransitionEnd',\n    'OTransition': 'oTransitionEnd',\n    'msTransition': 'MSTransitionEnd'\n  },\n\n  animationend: {\n    'animation': 'animationend',\n    'WebkitAnimation': 'webkitAnimationEnd',\n    'MozAnimation': 'mozAnimationEnd',\n    'OAnimation': 'oAnimationEnd',\n    'msAnimation': 'MSAnimationEnd'\n  }\n};\n\nvar endEvents = [];\n\nfunction detectEvents() {\n  var testEl = document.createElement('div');\n  var style = testEl.style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are useable, and if not remove them\n  // from the map\n  if (!('AnimationEvent' in window)) {\n    delete EVENT_NAME_MAP.animationend.animation;\n  }\n\n  if (!('TransitionEvent' in window)) {\n    delete EVENT_NAME_MAP.transitionend.transition;\n  }\n\n  for (var baseEventName in EVENT_NAME_MAP) {\n    var baseEvents = EVENT_NAME_MAP[baseEventName];\n    for (var styleName in baseEvents) {\n      if (styleName in style) {\n        endEvents.push(baseEvents[styleName]);\n        break;\n      }\n    }\n  }\n}\n\nif (canUseDOM) {\n  detectEvents();\n}\n\n// We use the raw {add|remove}EventListener() call because EventListener\n// does not know how to remove event listeners and we really should\n// clean up. Also, these events are not triggered in older browsers\n// so we should be A-OK here.\n\nfunction addEventListener(node, eventName, eventListener) {\n  node.addEventListener(eventName, eventListener, false);\n}\n\nfunction removeEventListener(node, eventName, eventListener) {\n  node.removeEventListener(eventName, eventListener, false);\n}\n\nvar ReactTransitionEvents = {\n  addEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      // If CSS transitions are not supported, trigger an \"end animation\"\n      // event immediately.\n      window.setTimeout(eventListener, 0);\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      addEventListener(node, endEvent, eventListener);\n    });\n  },\n\n  removeEndEventListener: function(node, eventListener) {\n    if (endEvents.length === 0) {\n      return;\n    }\n    endEvents.forEach(function(endEvent) {\n      removeEventListener(node, endEvent, eventListener);\n    });\n  }\n};\n\nmodule.exports = ReactTransitionEvents;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/TransitionEvents.js\n ** module id = 198\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/TransitionEvents.js?");

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Safe chained function\n *\n * Will only create a new function if needed,\n * otherwise will pass back existing functions or null.\n *\n * @param {function} one\n * @param {function} two\n * @returns {function|null}\n */\nfunction createChainedFunction(one, two) {\n  var hasOne = typeof one === 'function';\n  var hasTwo = typeof two === 'function';\n\n  if (!hasOne && !hasTwo) { return null; }\n  if (!hasOne) { return two; }\n  if (!hasTwo) { return one; }\n\n  return function chainedFunction() {\n    one.apply(this, arguments);\n    two.apply(this, arguments);\n  };\n}\n\nmodule.exports = createChainedFunction;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/createChainedFunction.js\n ** module id = 199\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/createChainedFunction.js?");

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./cytoscape\": 125,\n\t\"./cytoscape.js\": 125,\n\t\"./cytoscape.min\": 204,\n\t\"./cytoscape.min.js\": 204\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 200;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/dist ^\\.\\/.*$\n ** module id = 200\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/cytoscape/dist_^\\.\\/.*$?");

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This file contains an unmodified version of:\n * https://github.com/facebook/react/blob/v0.12.0/src/vendor/stubs/Object.assign.js\n *\n * This source code is licensed under the BSD-style license found here:\n * https://github.com/facebook/react/blob/v0.12.0/LICENSE\n * An additional grant of patent rights can be found here:\n * https://github.com/facebook/react/blob/v0.12.0/PATENTS\n */\n\n// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\n\nfunction assign(target, sources) {\n  if (target == null) {\n    throw new TypeError('Object.assign target cannot be null or undefined');\n  }\n\n  var to = Object(target);\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {\n    var nextSource = arguments[nextIndex];\n    if (nextSource == null) {\n      continue;\n    }\n\n    var from = Object(nextSource);\n\n    // We don't currently support accessors nor proxies. Therefore this\n    // copy cannot throw. If we ever supported this then we must handle\n    // exceptions and side-effects. We don't support symbols so they won't\n    // be transferred.\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n  }\n\n  return to;\n};\n\nmodule.exports = assign;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/Object.assign.js\n ** module id = 201\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/Object.assign.js?");

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	eval("var React = __webpack_require__(12);\n\nvar ANONYMOUS = '<<anonymous>>';\n\nvar CustomPropTypes = {\n  /**\n   * Checks whether a prop provides a DOM element\n   *\n   * The element can be provided in two forms:\n   * - Directly passed\n   * - Or passed an object which has a `getDOMNode` method which will return the required DOM element\n   *\n   * @param props\n   * @param propName\n   * @param componentName\n   * @returns {Error|undefined}\n   */\n  mountable: createMountableChecker()\n};\n\n/**\n * Create chain-able isRequired validator\n *\n * Largely copied directly from:\n *  https://github.com/facebook/react/blob/0.11-stable/src/core/ReactPropTypes.js#L94\n */\nfunction createChainableTypeChecker(validate) {\n  function checkType(isRequired, props, propName, componentName) {\n    componentName = componentName || ANONYMOUS;\n    if (props[propName] == null) {\n      if (isRequired) {\n        return new Error(\n          'Required prop `' + propName + '` was not specified in ' +\n            '`' + componentName + '`.'\n        );\n      }\n    } else {\n      return validate(props, propName, componentName);\n    }\n  }\n\n  var chainedCheckType = checkType.bind(null, false);\n  chainedCheckType.isRequired = checkType.bind(null, true);\n\n  return chainedCheckType;\n}\n\nfunction createMountableChecker() {\n  function validate(props, propName, componentName) {\n    if (typeof props[propName] !== 'object' ||\n      typeof props[propName].getDOMNode !== 'function' && props[propName].nodeType !== 1) {\n      return new Error(\n        'Invalid prop `' + propName + '` supplied to ' +\n          '`' + componentName + '`, expected a DOM element or an object that has a `getDOMNode` method'\n      );\n    }\n  }\n\n  return createChainableTypeChecker(validate);\n}\n\nmodule.exports = CustomPropTypes;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-bootstrap/utils/CustomPropTypes.js\n ** module id = 202\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-bootstrap/utils/CustomPropTypes.js?");

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 203\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * This file is part of Cytoscape.js 2.3.8.\n * \n * Cytoscape.js is free software: you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n * \n * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n * \n * You should have received a copy of the GNU Lesser General Public License along with\n * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.\n */\nvar cytoscape;!function(e){\"use strict\";var t=cytoscape=function(){return cytoscape.init.apply(cytoscape,arguments)};t.version=\"2.3.8\",t.init=function(e){return void 0===e&&(e={}),t.is.plainObject(e)?new t.Core(e):t.is.string(e)?t.extension.apply(t.extension,arguments):void 0},t.fn={},\"undefined\"!=typeof module&&module.exports&&(module.exports=cytoscape),\"undefined\"!=\"function\"&&__webpack_require__(203)&&!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return cytoscape}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)),e&&(e.cytoscape=cytoscape)}(\"undefined\"==typeof window?null:window),function(e,t){\"use strict\";e.is={defined:function(e){return null!=e},string:function(e){return null!=e&&\"string\"==typeof e},fn:function(e){return null!=e&&\"function\"==typeof e},array:function(e){return Array.isArray?Array.isArray(e):null!=e&&e instanceof Array},plainObject:function(t){return null!=t&&typeof t==typeof{}&&!e.is.array(t)&&t.constructor===Object},number:function(e){return null!=e&&\"number\"==typeof e&&!isNaN(e)},integer:function(t){return e.is.number(t)&&Math.floor(t)===t},color:function(e){return null!=e&&\"string\"==typeof e&&\"\"!==$.Color(e).toString()},bool:function(e){return null!=e&&typeof e==typeof!0},elementOrCollection:function(t){return e.is.element(t)||e.is.collection(t)},element:function(t){return t instanceof e.Element&&t._private.single},collection:function(t){return t instanceof e.Collection&&!t._private.single},core:function(t){return t instanceof e.Core},style:function(t){return t instanceof e.Style},stylesheet:function(t){return t instanceof e.Stylesheet},event:function(t){return t instanceof e.Event},emptyString:function(t){return t?e.is.string(t)&&(\"\"===t||t.match(/^\\s+$/))?!0:!1:!0},nonemptyString:function(t){return t&&e.is.string(t)&&\"\"!==t&&!t.match(/^\\s+$/)?!0:!1},domElement:function(e){return\"undefined\"==typeof HTMLElement?!1:e instanceof HTMLElement},boundingBox:function(t){return e.is.plainObject(t)&&e.is.number(t.x1)&&e.is.number(t.x2)&&e.is.number(t.y1)&&e.is.number(t.y2)},touch:function(){return t&&(\"ontouchstart\"in t||t.DocumentTouch&&document instanceof DocumentTouch)},gecko:function(){return\"undefined\"!=typeof InstallTrigger||\"MozAppearance\"in document.documentElement.style},webkit:function(){return\"undefined\"!=typeof webkitURL||\"WebkitAppearance\"in document.documentElement.style},chromium:function(){return\"undefined\"!=typeof chrome},khtml:function(){return navigator.vendor.match(/kde/i)},khtmlEtc:function(){return e.is.khtml()||e.is.webkit()||e.is.blink()},trident:function(){/*@cc_on!@*/\nreturn\"undefined\"!=typeof ActiveXObject||!1},windows:function(){return\"undefined\"!=typeof navigator&&navigator.appVersion.match(/Win/i)},mac:function(){return\"undefined\"!=typeof navigator&&navigator.appVersion.match(/Mac/i)},linux:function(){return\"undefined\"!=typeof navigator&&navigator.appVersion.match(/Linux/i)},unix:function(){return\"undefined\"!=typeof navigator&&navigator.appVersion.match(/X11/i)}}}(cytoscape,\"undefined\"==typeof window?null:window),function(e,t){\"use strict\";e.util={extend:function(){var t,i,r,n,a,o,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for(\"boolean\"==typeof s&&(c=s,s=arguments[1]||{},l=2),\"object\"==typeof s||e.is.fn(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(t=arguments[l]))for(i in t)r=s[i],n=t[i],s!==n&&(c&&n&&(e.is.plainObject(n)||(a=e.is.array(n)))?(a?(a=!1,o=r&&e.is.array(r)?r:[]):o=r&&e.is.plainObject(r)?r:{},s[i]=e.util.extend(c,o,n)):void 0!==n&&(s[i]=n));return s},require:function(i,r,n){var a;n=e.util.extend({msgIfNotFound:!0},n);var o=!1,s=function(e){o=!0,r(e)},l=function(e){t&&(a=t[i]),void 0!==a&&s(a),e&&e()},u=function(){o||c(d)},c=function(e){\"undefined\"!=typeof module&&module.exports&&__webpack_require__(200)&&(a=__webpack_require__(200)(i)),void 0!==a&&s(a),e&&e()},d=function(){o||p(h)},p=function(e){\"undefined\"!=\"function\"&&__webpack_require__(203)&&__webpack_require__(200)&&!/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(200)(i)]; (function(t){a=t,void 0!==a&&s(a),e&&e()}.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}())},h=function(){!o&&n.msgIfNotFound&&e.util.error(\"Cytoscape.js tried to pull in dependency `\"+i+\"` but no module (i.e. CommonJS, AMD, or window) was found\")};l(u)},requires:function(t,i){for(var r=[],n=[],a=function(){for(var e=0;e<t.length;e++)if(!n[e])return;i.apply(i,r)},o=0;o<t.length;o++)!function(){var i=t[o],s=o;e.util.require(i,function(e){r[s]=e,n[s]=!0,a()})}()},throttle:function(t,i,r){var n=!0,a=!0;return r===!1?n=!1:e.is.plainObject(r)&&(n=\"leading\"in r?r.leading:n,a=\"trailing\"in r?r.trailing:a),r=r||{},r.leading=n,r.maxWait=i,r.trailing=a,e.util.debounce(t,i,r)},now:function(){return+new Date},debounce:function(t,i,r){var n,a,o,s,l,u,c,d=0,p=!1,h=!0;if(e.is.fn(t)){if(i=Math.max(0,i)||0,r===!0){var v=!0;h=!1}else e.is.plainObject(r)&&(v=r.leading,p=\"maxWait\"in r&&(Math.max(i,r.maxWait)||0),h=\"trailing\"in r?r.trailing:h);var g=function(){var r=i-(e.util.now()-s);if(0>=r){a&&clearTimeout(a);var p=c;a=u=c=void 0,p&&(d=e.util.now(),o=t.apply(l,n),u||a||(n=l=null))}else u=setTimeout(g,r)},f=function(){u&&clearTimeout(u),a=u=c=void 0,(h||p!==i)&&(d=e.util.now(),o=t.apply(l,n),u||a||(n=l=null))};return function(){if(n=arguments,s=e.util.now(),l=this,c=h&&(u||!v),p===!1)var r=v&&!u;else{a||v||(d=s);var y=p-(s-d),m=0>=y;m?(a&&(a=clearTimeout(a)),d=s,o=t.apply(l,n)):a||(a=setTimeout(f,y))}return m&&u?u=clearTimeout(u):u||i===p||(u=setTimeout(g,i)),r&&(m=!0,o=t.apply(l,n)),!m||u||a||(n=l=null),o}}},error:function(e){if(!console)throw e;if(console.error)console.error.apply(console,arguments);else{if(!console.log)throw e;console.log.apply(console,arguments)}},clone:function(e){var t={};for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t},copy:function(t){return null==t?t:e.is.array(t)?t.slice():e.is.plainObject(t)?e.util.clone(t):t},makeBoundingBox:function(e){if(null!=e.x1&&null!=e.y1){if(null!=e.x2&&null!=e.y2&&e.x2>=e.x1&&e.y2>=e.y1)return{x1:e.x1,y1:e.y1,x2:e.x2,y2:e.y2,w:e.x2-e.x1,h:e.y2-e.y1};if(null!=e.w&&null!=e.h&&e.w>=0&&e.h>=0)return{x1:e.x1,y1:e.y1,x2:e.x1+e.w,y2:e.y1+e.h,w:e.w,h:e.h}}},mapEmpty:function(e){var t=!0;if(null!=e)for(var i in e){t=!1;break}return t},pushMap:function(t){var i=e.util.getMap(t);null==i?e.util.setMap($.extend({},t,{value:[t.value]})):i.push(t.value)},setMap:function(t){for(var i,r=t.map,n=t.keys,a=n.length,o=0;a>o;o++){var i=n[o];e.is.plainObject(i)&&e.util.error(\"Tried to set map with object key\"),o<n.length-1?(null==r[i]&&(r[i]={}),r=r[i]):r[i]=t.value}},getMap:function(t){for(var i=t.map,r=t.keys,n=r.length,a=0;n>a;a++){var o=r[a];if(e.is.plainObject(o)&&e.util.error(\"Tried to get map with object key\"),i=i[o],null==i)return i}return i},deleteMap:function(t){for(var i=t.map,r=t.keys,n=r.length,a=t.keepChildren,o=0;n>o;o++){var s=r[o];e.is.plainObject(s)&&e.util.error(\"Tried to delete map with object key\");var l=o===t.keys.length-1;if(l)if(a)for(var u in i)a[u]||(i[u]=void 0);else i[s]=void 0;else i=i[s]}},capitalize:function(t){return e.is.emptyString(t)?t:t.charAt(0).toUpperCase()+t.substring(1)},camel2dash:function(e){for(var t=[],i=0;i<e.length;i++){var r=e[i],n=r.toLowerCase(),a=r!==n;a?(t.push(\"-\"),t.push(n)):t.push(r)}var o=t.length===e.length;return o?e:t.join(\"\")},dash2camel:function(e){for(var t=[],i=!1,r=0;r<e.length;r++){var n=e[r],a=\"-\"===n;a?i=!0:(t.push(i?n.toUpperCase():n),i=!1)}return t.join(\"\")},trim:function(e){var t,i;for(t=0;t<e.length&&\" \"===e[t];t++);for(i=e.length-1;i>t&&\" \"===e[i];i--);return e.substring(t,i+1)},hex2tuple:function(e){if((4===e.length||7===e.length)&&\"#\"===e[0]){var t,i,r,n=4===e.length,a=16;return n?(t=parseInt(e[1]+e[1],a),i=parseInt(e[2]+e[2],a),r=parseInt(e[3]+e[3],a)):(t=parseInt(e[1]+e[2],a),i=parseInt(e[3]+e[4],a),r=parseInt(e[5]+e[6],a)),[t,i,r]}},hsl2tuple:function(t){function i(e,t,i){return 0>i&&(i+=1),i>1&&(i-=1),1/6>i?e+6*(t-e)*i:.5>i?t:2/3>i?e+(t-e)*(2/3-i)*6:e}var r,n,a,o,s,l,u,c,d=new RegExp(\"^\"+e.util.regex.hsla+\"$\").exec(t);if(d){if(n=parseInt(d[1]),0>n?n=(360- -1*n%360)%360:n>360&&(n%=360),n/=360,a=parseFloat(d[2]),0>a||a>100)return;if(a/=100,o=parseFloat(d[3]),0>o||o>100)return;if(o/=100,s=d[4],void 0!==s&&(s=parseFloat(s),0>s||s>1))return;if(0===a)l=u=c=Math.round(255*o);else{var p=.5>o?o*(1+a):o+a-o*a,h=2*o-p;l=Math.round(255*i(h,p,n+1/3)),u=Math.round(255*i(h,p,n)),c=Math.round(255*i(h,p,n-1/3))}r=[l,u,c,s]}return r},rgb2tuple:function(t){var i,r=new RegExp(\"^\"+e.util.regex.rgba+\"$\").exec(t);if(r){i=[];for(var n=[],a=1;3>=a;a++){var o=r[a];if(\"%\"===o[o.length-1]&&(n[a]=!0),o=parseFloat(o),n[a]&&(o=o/100*255),0>o||o>255)return;i.push(Math.floor(o))}var s=n[1]||n[2]||n[3],l=n[1]&&n[2]&&n[3];if(s&&!l)return;var u=r[4];if(void 0!==u){if(u=parseFloat(u),0>u||u>1)return;i.push(u)}}return i},colorname2tuple:function(t){return e.util.colors[t.toLowerCase()]},color2tuple:function(t){return(e.is.array(t)?t:null)||e.util.colorname2tuple(t)||e.util.hex2tuple(t)||e.util.rgb2tuple(t)||e.util.hsl2tuple(t)},tuple2hex:function(e){function t(e){var t=e.toString(16);return 1===t.length&&(t=\"0\"+t),t}var i=e[0],r=e[1],n=e[2];return\"#\"+t(i)+t(r)+t(n)},colors:{transparent:[0,0,0,0],aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],grey:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}},e.util.regex={},e.util.regex.number=\"(?:[-]?\\\\d*\\\\.\\\\d+|[-]?\\\\d+|[-]?\\\\d*\\\\.\\\\d+[eE]\\\\d+)\",e.util.regex.rgba=\"rgb[a]?\\\\((\"+e.util.regex.number+\"[%]?)\\\\s*,\\\\s*(\"+e.util.regex.number+\"[%]?)\\\\s*,\\\\s*(\"+e.util.regex.number+\"[%]?)(?:\\\\s*,\\\\s*(\"+e.util.regex.number+\"))?\\\\)\",e.util.regex.rgbaNoBackRefs=\"rgb[a]?\\\\((?:\"+e.util.regex.number+\"[%]?)\\\\s*,\\\\s*(?:\"+e.util.regex.number+\"[%]?)\\\\s*,\\\\s*(?:\"+e.util.regex.number+\"[%]?)(?:\\\\s*,\\\\s*(?:\"+e.util.regex.number+\"))?\\\\)\",e.util.regex.hsla=\"hsl[a]?\\\\((\"+e.util.regex.number+\")\\\\s*,\\\\s*(\"+e.util.regex.number+\"[%])\\\\s*,\\\\s*(\"+e.util.regex.number+\"[%])(?:\\\\s*,\\\\s*(\"+e.util.regex.number+\"))?\\\\)\",e.util.regex.hslaNoBackRefs=\"hsl[a]?\\\\((?:\"+e.util.regex.number+\")\\\\s*,\\\\s*(?:\"+e.util.regex.number+\"[%])\\\\s*,\\\\s*(?:\"+e.util.regex.number+\"[%])(?:\\\\s*,\\\\s*(?:\"+e.util.regex.number+\"))?\\\\)\",e.util.regex.hex3=\"\\\\#[0-9a-fA-F]{3}\",e.util.regex.hex6=\"\\\\#[0-9a-fA-F]{6}\";var i=t?t.requestAnimationFrame||t.mozRequestAnimationFrame||t.webkitRequestAnimationFrame||t.msRequestAnimationFrame:null;i=i||function(e){e&&setTimeout(e,1e3/60)},e.util.requestAnimationFrame=function(e){i(e)}}(cytoscape,\"undefined\"==typeof window?null:window),function(e){\"use strict\";e.math={},e.math.signum=function(e){return e>0?1:0>e?-1:0},e.math.distance=function(e,t){var i=t.x-e.x,r=t.y-e.y;return Math.sqrt(i*i+r*r)},e.math.qbezierAt=function(e,t,i,r){return(1-r)*(1-r)*e+2*(1-r)*r*t+r*r*i},e.math.qbezierPtAt=function(t,i,r,n){return{x:e.math.qbezierAt(t.x,i.x,r.x,n),y:e.math.qbezierAt(t.y,i.y,r.y,n)}},e.math.boundingBoxesIntersect=function(e,t){return e.x1>t.x2?!1:t.x1>e.x2?!1:e.x2<t.x1?!1:t.x2<e.x1?!1:e.y2<t.y1?!1:t.y2<e.y1?!1:e.y1>t.y2?!1:t.y1>e.y2?!1:!0},e.math.inBoundingBox=function(e,t,i){return e.x1<=t&&t<=e.x2&&e.y1<=i&&i<=e.y2},e.math.pointInBoundingBox=function(e,t){return this.inBoundingBox(e,t.x,t.y)},e.math.roundRectangleIntersectLine=function(e,t,i,r,n,a,o){var s,l=this.getRoundRectangleRadius(n,a),u=n/2,c=a/2,d=i-u+l-o,p=r-c-o,h=i+u-l+o,v=p;if(s=this.finiteLinesIntersect(e,t,i,r,d,p,h,v,!1),s.length>0)return s;var g=i+u+o,f=r-c+l-o,y=g,m=r+c-l+o;if(s=this.finiteLinesIntersect(e,t,i,r,g,f,y,m,!1),s.length>0)return s;var x=i-u+l-o,b=r+c+o,w=i+u-l+o,_=b;if(s=this.finiteLinesIntersect(e,t,i,r,x,b,w,_,!1),s.length>0)return s;var E=i-u-o,S=r-c+l-o,P=E,D=r+c-l+o;if(s=this.finiteLinesIntersect(e,t,i,r,E,S,P,D,!1),s.length>0)return s;var k,C=i-u+l,T=r-c+l;if(k=this.intersectLineCircle(e,t,i,r,C,T,l+o),k.length>0&&k[0]<=C&&k[1]<=T)return[k[0],k[1]];var N=i+u-l,M=r-c+l;if(k=this.intersectLineCircle(e,t,i,r,N,M,l+o),k.length>0&&k[0]>=N&&k[1]<=M)return[k[0],k[1]];var B=i+u-l,I=r+c-l;if(k=this.intersectLineCircle(e,t,i,r,B,I,l+o),k.length>0&&k[0]>=B&&k[1]>=I)return[k[0],k[1]];var z=i-u+l,L=r+c-l;return k=this.intersectLineCircle(e,t,i,r,z,L,l+o),k.length>0&&k[0]<=z&&k[1]>=L?[k[0],k[1]]:[]},e.math.roundRectangleIntersectBox=function(e,t,i,r,n,a,o,s,l){var u=this.getRoundRectangleRadius(n,a),c=o-n/2-l,d=s-a/2+u-l,p=o+n/2+l,h=s+a/2-u+l,v=o-n/2+u-l,g=s-a/2-l,f=o+n/2-u+l,y=s+a/2+l,m=Math.min(e,i),x=Math.max(e,i),b=Math.min(t,r),w=Math.max(t,r);return c>x?!1:m>p?!1:g>w?!1:b>y?!1:c>=m&&x>=c&&d>=b&&w>=d?!0:p>=m&&x>=p&&d>=b&&w>=d?!0:p>=m&&x>=p&&h>=b&&w>=h?!0:c>=m&&x>=c&&h>=b&&w>=h?!0:m>=c&&p>=m&&b>=d&&h>=b?!0:x>=c&&p>=x&&b>=d&&h>=b?!0:x>=c&&p>=x&&w>=d&&h>=w?!0:m>=c&&p>=m&&w>=d&&h>=w?!0:v>=m&&x>=v&&g>=b&&w>=g?!0:f>=m&&x>=f&&g>=b&&w>=g?!0:f>=m&&x>=f&&y>=b&&w>=y?!0:v>=m&&x>=v&&y>=b&&w>=y?!0:m>=v&&f>=m&&b>=g&&y>=b?!0:x>=v&&f>=x&&b>=g&&y>=b?!0:x>=v&&f>=x&&w>=g&&y>=w?!0:m>=v&&f>=m&&w>=g&&y>=w?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,v+l,d+l)?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,f-l,d+l)?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,f-l,h-l)?!0:this.boxIntersectEllipse(m,b,x,w,l,2*u,2*u,v+l,h-l)?!0:!1},e.math.checkInBoundingCircle=function(e,t,i,r,n,a,o,s){return e=(e-o)/(n+r),t=(t-s)/(a+r),i>=e*e+t*t},e.math.boxInBezierVicinity=function(e,t,i,r,n,a,o,s,l,u,c){var d=.25*n+.5*o+.25*l,p=.25*a+.5*s+.25*u,h=Math.min(e,i)-c,v=Math.min(t,r)-c,g=Math.max(e,i)+c,f=Math.max(t,r)+c;if(n>=h&&g>=n&&a>=v&&f>=a)return 1;if(l>=h&&g>=l&&u>=v&&f>=u)return 1;if(d>=h&&g>=d&&p>=v&&f>=p)return 1;if(o>=h&&g>=o&&s>=v&&f>=s)return 1;var y=Math.min(n,d,l),m=Math.min(a,p,u),x=Math.max(n,d,l),b=Math.max(a,p,u);return y>g||h>x||m>f||v>b?0:1},e.math.checkBezierInBox=function(t,i,r,n,a,o,s,l,u,c){function d(d){var p=e.math.qbezierAt(a,s,u,d),h=e.math.qbezierAt(o,l,c,d);return p>=t&&r>=p&&h>=i&&n>=h}for(var p=0;1>=p;p+=.25)if(!d(p))return!1;return!0},e.math.checkStraightEdgeInBox=function(e,t,i,r,n,a,o,s){return n>=e&&i>=n&&o>=e&&i>=o&&a>=t&&r>=a&&s>=t&&r>=s},e.math.checkStraightEdgeCrossesBox=function(e,t,i,r,n,a,o,s,l){var u,c,d=Math.min(e,i)-l,p=Math.min(t,r)-l,h=Math.max(e,i)+l,v=Math.max(t,r)+l,g=o-n,f=n,y=s-a,m=a;if(Math.abs(g)<1e-4)return n>=d&&h>=n&&Math.min(a,s)<=p&&Math.max(a,s)>=v;var x=(d-f)/g;if(x>0&&1>=x&&(u=y*x+m,u>=p&&v>=u))return!0;var b=(h-f)/g;if(b>0&&1>=b&&(u=y*b+m,u>=p&&v>=u))return!0;var w=(p-m)/y;if(w>0&&1>=w&&(c=g*w+f,c>=d&&h>=c))return!0;var _=(v-m)/y;return _>0&&1>=_&&(c=g*_+f,c>=d&&h>=c)?!0:!1},e.math.checkBezierCrossesBox=function(e,t,i,r,n,a,o,s,l,u,c){var d=Math.min(e,i)-c,p=Math.min(t,r)-c,h=Math.max(e,i)+c,v=Math.max(t,r)+c;if(n>=d&&h>=n&&a>=p&&v>=a)return!0;if(l>=d&&h>=l&&u>=p&&v>=u)return!0;var g=n-2*o+l,f=-2*n+2*o,y=n,m=[];if(Math.abs(g)<1e-4){var x=(d-n)/f,b=(h-n)/f;m.push(x,b)}else{var w,_,E=f*f-4*g*(y-d);if(E>0){var S=Math.sqrt(E);w=(-f+S)/(2*g),_=(-f-S)/(2*g),m.push(w,_)}var P,D,k=f*f-4*g*(y-h);if(k>0){var S=Math.sqrt(k);P=(-f+S)/(2*g),D=(-f-S)/(2*g),m.push(P,D)}}m.sort(function(e,t){return e-t});var C=a-2*s+u,T=-2*a+2*s,N=a,M=[];if(Math.abs(C)<1e-4){var B=(p-a)/T,I=(v-a)/T;M.push(B,I)}else{var z,L,O=T*T-4*C*(N-p);if(O>0){var S=Math.sqrt(O);z=(-T+S)/(2*C),L=(-T-S)/(2*C),M.push(z,L)}var R,X,V=T*T-4*C*(N-v);if(V>0){var S=Math.sqrt(V);R=(-T+S)/(2*C),X=(-T-S)/(2*C),M.push(R,X)}}M.sort(function(e,t){return e-t});for(var Y=0;Y<m.length;Y+=2)for(var A=1;A<M.length;A+=2)if(m[Y]<M[A]&&M[A]>=0&&m[Y]<=1&&m[Y+1]>M[A-1]&&M[A-1]<=1&&m[Y+1]>=0)return!0;return!1},e.math.inLineVicinity=function(e,t,i,r,n,a,o){var s=o,l=Math.min(i,n),u=Math.max(i,n),c=Math.min(r,a),d=Math.max(r,a);return e>=l-s&&u+s>=e&&t>=c-s&&d+s>=t},e.math.inBezierVicinity=function(e,t,i,r,n,a,o,s){var l={x1:Math.min(i,o,n),x2:Math.max(i,o,n),y1:Math.min(r,s,a),y2:Math.max(r,s,a)};return e<l.x1||e>l.x2||t<l.y1||t>l.y2?!1:!0},e.math.solveCubic=function(e,t,i,r,n){t/=e,i/=e,r/=e;var a,o,s,l,u,c,d,p;return o=(3*i-t*t)/9,s=-(27*r)+t*(9*i-2*t*t),s/=54,a=o*o*o+s*s,n[1]=0,d=t/3,a>0?(u=s+Math.sqrt(a),u=0>u?-Math.pow(-u,1/3):Math.pow(u,1/3),c=s-Math.sqrt(a),c=0>c?-Math.pow(-c,1/3):Math.pow(c,1/3),n[0]=-d+u+c,d+=(u+c)/2,n[4]=n[2]=-d,d=Math.sqrt(3)*(-c+u)/2,n[3]=d,void(n[5]=-d)):(n[5]=n[3]=0,0===a?(p=0>s?-Math.pow(-s,1/3):Math.pow(s,1/3),n[0]=-d+2*p,void(n[4]=n[2]=-(p+d))):(o=-o,l=o*o*o,l=Math.acos(s/Math.sqrt(l)),p=2*Math.sqrt(o),n[0]=-d+p*Math.cos(l/3),n[2]=-d+p*Math.cos((l+2*Math.PI)/3),void(n[4]=-d+p*Math.cos((l+4*Math.PI)/3))))},e.math.sqDistanceToQuadraticBezier=function(e,t,i,r,n,a,o,s){var l=1*i*i-4*i*n+2*i*o+4*n*n-4*n*o+o*o+r*r-4*r*a+2*r*s+4*a*a-4*a*s+s*s,u=9*i*n-3*i*i-3*i*o-6*n*n+3*n*o+9*r*a-3*r*r-3*r*s-6*a*a+3*a*s,c=3*i*i-6*i*n+i*o-i*e+2*n*n+2*n*e-o*e+3*r*r-6*r*a+r*s-r*t+2*a*a+2*a*t-s*t,d=1*i*n-i*i+i*e-n*e+r*a-r*r+r*t-a*t,p=[];this.solveCubic(l,u,c,d,p);for(var h=1e-7,v=[],g=0;6>g;g+=2)Math.abs(p[g+1])<h&&p[g]>=0&&p[g]<=1&&v.push(p[g]);v.push(1),v.push(0);for(var f,y,m,x,b=-1,w=0;w<v.length;w++)y=Math.pow(1-v[w],2)*i+2*(1-v[w])*v[w]*n+v[w]*v[w]*o,m=Math.pow(1-v[w],2)*r+2*(1-v[w])*v[w]*a+v[w]*v[w]*s,x=Math.pow(y-e,2)+Math.pow(m-t,2),b>=0?b>x&&(b=x,f=v[w]):(b=x,f=v[w]);return b},e.math.sqDistanceToFiniteLine=function(e,t,i,r,n,a){var o=[e-i,t-r],s=[n-i,a-r],l=s[0]*s[0]+s[1]*s[1],u=o[0]*o[0]+o[1]*o[1],c=o[0]*s[0]+o[1]*s[1],d=c*c/l;return 0>c?u:d>l?(e-n)*(e-n)+(t-a)*(t-a):u-d},e.math.pointInsidePolygon=function(e,t,i,r,n,a,o,s,l){var u=new Array(i.length),c=Math.asin(s[1]/Math.sqrt(s[0]*s[0]+s[1]*s[1]));s[0]<0?c+=Math.PI/2:c=-c-Math.PI/2;for(var d=Math.cos(-c),p=Math.sin(-c),h=0;h<u.length/2;h++)u[2*h]=a/2*(i[2*h]*d-i[2*h+1]*p),u[2*h+1]=o/2*(i[2*h+1]*d+i[2*h]*p),u[2*h]+=r,u[2*h+1]+=n;var v;if(l>0){var g=this.expandPolygon(u,-l);v=this.joinLines(g)}else v=u;for(var f,y,m,x,b,w=0,_=0,h=0;h<v.length/2;h++)if(f=v[2*h],y=v[2*h+1],h+1<v.length/2?(m=v[2*(h+1)],x=v[2*(h+1)+1]):(m=v[2*(h+1-v.length/2)],x=v[2*(h+1-v.length/2)+1]),f==e&&m==e);else{if(!(f>=e&&e>=m||e>=f&&m>=e))continue;b=(e-f)/(m-f)*(x-y)+y,b>t&&w++,t>b&&_++}return w%2===0?!1:!0},e.math.joinLines=function(e){for(var t,i,r,n,a,o,s,l,u=new Array(e.length/2),c=0;c<e.length/4;c++){t=e[4*c],i=e[4*c+1],r=e[4*c+2],n=e[4*c+3],c<e.length/4-1?(a=e[4*(c+1)],o=e[4*(c+1)+1],s=e[4*(c+1)+2],l=e[4*(c+1)+3]):(a=e[0],o=e[1],s=e[2],l=e[3]);var d=this.finiteLinesIntersect(t,i,r,n,a,o,s,l,!0);u[2*c]=d[0],u[2*c+1]=d[1]}return u},e.math.expandPolygon=function(e,t){for(var i,r,n,a,o=new Array(2*e.length),s=0;s<e.length/2;s++){i=e[2*s],r=e[2*s+1],s<e.length/2-1?(n=e[2*(s+1)],a=e[2*(s+1)+1]):(n=e[0],a=e[1]);var l=a-r,u=-(n-i),c=Math.sqrt(l*l+u*u),d=l/c,p=u/c;o[4*s]=i+d*t,o[4*s+1]=r+p*t,o[4*s+2]=n+d*t,o[4*s+3]=a+p*t}return o},e.math.intersectLineEllipse=function(e,t,i,r,n,a){var o=i-e,s=r-t;o/=n,s/=a;var l=Math.sqrt(o*o+s*s),u=l-1;if(0>u)return[];var c=u/l;return[(i-e)*c+e,(r-t)*c+t]},e.math.dotProduct=function(e,t){if(2!=e.length||2!=t.length)throw\"dot product: arguments are not vectors\";return e[0]*t[0]+e[1]*t[1]},e.math.intersectLineCircle=function(e,t,i,r,n,a,o){var s=[i-e,r-t],l=[n,a],u=[e-n,t-a],c=s[0]*s[0]+s[1]*s[1],d=2*(u[0]*s[0]+u[1]*s[1]),l=u[0]*u[0]+u[1]*u[1]-o*o,p=d*d-4*c*l;if(0>p)return[];var h=(-d+Math.sqrt(p))/(2*c),v=(-d-Math.sqrt(p))/(2*c),g=Math.min(h,v),f=Math.max(h,v),y=[];if(g>=0&&1>=g&&y.push(g),f>=0&&1>=f&&y.push(f),0===y.length)return[];var m=y[0]*s[0]+e,x=y[0]*s[1]+t;if(y.length>1){if(y[0]==y[1])return[m,x];var b=y[1]*s[0]+e,w=y[1]*s[1]+t;return[m,x,b,w]}return[m,x]},e.math.findCircleNearPoint=function(e,t,i,r,n){var a=r-e,o=n-t,s=Math.sqrt(a*a+o*o),l=a/s,u=o/s;return[e+l*i,t+u*i]},e.math.findMaxSqDistanceToOrigin=function(e){for(var t,i=1e-6,r=0;r<e.length/2;r++)t=e[2*r]*e[2*r]+e[2*r+1]*e[2*r+1],t>i&&(i=t);return i},e.math.finiteLinesIntersect=function(e,t,i,r,n,a,o,s,l){var u=(o-n)*(t-a)-(s-a)*(e-n),c=(i-e)*(t-a)-(r-t)*(e-n),d=(s-a)*(i-e)-(o-n)*(r-t);if(0!==d){var p=u/d,h=c/d;return p>=0&&1>=p&&h>=0&&1>=h?[e+p*(i-e),t+p*(r-t)]:l?[e+p*(i-e),t+p*(r-t)]:[]}return 0===u||0===c?[e,i,o].sort()[1]===o?[o,s]:[e,i,n].sort()[1]===n?[n,a]:[n,o,i].sort()[1]===i?[i,r]:[]:[]},e.math.boxIntersectEllipse=function(e,t,i,r,n,a,o,s,l){if(e>i){var u=e;e=i,i=u}if(t>r){var c=t;t=r,r=c}var d=[s-a/2-n,l],p=[s+a/2+n,l],h=[s,l-o/2-n],v=[s,l+o/2+n];return i<d[0]?!1:e>p[0]?!1:t>v[1]?!1:r<h[1]?!1:e<=p[0]&&p[0]<=i&&t<=p[1]&&p[1]<=r?!0:e<=d[0]&&d[0]<=i&&t<=d[1]&&d[1]<=r?!0:e<=h[0]&&h[0]<=i&&t<=h[1]&&h[1]<=r?!0:e<=v[0]&&v[0]<=i&&t<=v[1]&&v[1]<=r?!0:(e=(e-s)/(a/2+n),i=(i-s)/(a/2+n),t=(t-l)/(o/2+n),r=(r-l)/(o/2+n),1>=e*e+t*t?!0:1>=i*i+t*t?!0:1>=i*i+r*r?!0:1>=e*e+r*r?!0:!1)},e.math.boxIntersectPolygon=function(t,i,r,n,a,o,s,l,u,c,d){if(t>r){var p=t;t=r,r=p}if(i>n){var h=i;i=n,n=h}var v=new Array(a.length),g=Math.asin(c[1]/Math.sqrt(c[0]*c[0]+c[1]*c[1]));c[0]<0?g+=Math.PI/2:g=-g-Math.PI/2;for(var f=Math.cos(-g),y=Math.sin(-g),m=0;m<v.length/2;m++)v[2*m]=o/2*(a[2*m]*f-a[2*m+1]*y),v[2*m+1]=s/2*(a[2*m+1]*f+a[2*m]*y),v[2*m]+=l,v[2*m+1]+=u;for(var x=v[0],b=v[0],w=v[1],_=v[1],m=1;m<v.length/2;m++)v[2*m]>b&&(b=v[2*m]),v[2*m]<x&&(x=v[2*m]),v[2*m+1]>_&&(_=v[2*m+1]),v[2*m+1]<w&&(w=v[2*m+1]);if(x-d>r)return!1;if(t>b+d)return!1;if(w-d>n)return!1;if(i>_+d)return!1;var E;if(d>0){var S=e.math.expandPolygon(v,-d);E=e.math.joinLines(S)}else E=v;for(var m=0;m<v.length/2;m++)if(t<=v[2*m]&&v[2*m]<=r&&i<=v[2*m+1]&&v[2*m+1]<=n)return!0;for(var m=0;m<E.length/2;m++){var P,D,k=E[2*m],C=E[2*m+1];if(m<E.length/2-1?(P=E[2*(m+1)],D=E[2*(m+1)+1]):(P=E[0],D=E[1]),e.math.finiteLinesIntersect(k,C,P,D,t,i,r,i,!1).length>0)return!0;if(e.math.finiteLinesIntersect(k,C,P,D,t,n,r,n,!1).length>0)return!0;if(e.math.finiteLinesIntersect(k,C,P,D,t,i,t,n,!1).length>0)return!0;if(e.math.finiteLinesIntersect(k,C,P,D,r,i,r,n,!1).length>0)return!0}return!1},e.math.polygonIntersectLine=function(t,i,r,n,a,o,s,l){for(var u,c=[],d=new Array(r.length),p=0;p<d.length/2;p++)d[2*p]=r[2*p]*o+n,d[2*p+1]=r[2*p+1]*s+a;var h;if(l>0){var v=e.math.expandPolygon(d,-l);h=e.math.joinLines(v)}else h=d;for(var g,f,y,m,p=0;p<h.length/2;p++)g=h[2*p],f=h[2*p+1],p<h.length/2-1?(y=h[2*(p+1)],m=h[2*(p+1)+1]):(y=h[0],m=h[1]),u=this.finiteLinesIntersect(t,i,n,a,g,f,y,m),0!==u.length&&c.push(u[0],u[1]);return c},e.math.shortenIntersection=function(e,t,i){var r=[e[0]-t[0],e[1]-t[1]],n=Math.sqrt(r[0]*r[0]+r[1]*r[1]),a=(n-i)/n;return 0>a&&(a=1e-5),[t[0]+a*r[0],t[1]+a*r[1]]},e.math.generateUnitNgonPointsFitToSquare=function(t,i){var r=e.math.generateUnitNgonPoints(t,i);return r=e.math.fitPolygonToSquare(r)},e.math.fitPolygonToSquare=function(e){for(var t,i,r=e.length/2,n=1/0,a=1/0,o=-1/0,s=-1/0,l=0;r>l;l++)t=e[2*l],i=e[2*l+1],n=Math.min(n,t),o=Math.max(o,t),a=Math.min(a,i),s=Math.max(s,i);for(var u=2/(o-n),c=2/(s-a),l=0;r>l;l++)t=e[2*l]=e[2*l]*u,i=e[2*l+1]=e[2*l+1]*c,n=Math.min(n,t),o=Math.max(o,t),a=Math.min(a,i),s=Math.max(s,i);if(-1>a)for(var l=0;r>l;l++)i=e[2*l+1]=e[2*l+1]+(-1-a);return e},e.math.generateUnitNgonPoints=function(e,t){var i=1/e*2*Math.PI,r=e%2===0?Math.PI/2+i/2:Math.PI/2;r+=t;for(var n,a,o,s=new Array(2*e),l=0;e>l;l++)n=l*i+r,a=s[2*l]=Math.cos(n),o=s[2*l+1]=Math.sin(-n);return s},e.math.getRoundRectangleRadius=function(e,t){return Math.min(e/4,t/4,8)}}(cytoscape),function(e){\"use strict\";function t(t,i,r){var n={};switch(n[i]=r,t){case\"core\":case\"collection\":e.fn[t](n)}if(\"layout\"===t){for(var o=r.prototype,s=[\"stop\"],l=0;l<s.length;l++){var u=s[l];o[u]=o[u]||function(){return this}}o.start&&!o.run?o.run=function(){return this.start(),this}:!o.start&&o.run&&(o.start=function(){return this.run(),this}),o.on=e.define.on({layout:!0}),o.one=e.define.on({layout:!0,unbindSelfOnTrigger:!0}),o.once=e.define.on({layout:!0,unbindAllBindersOnTrigger:!0}),o.off=e.define.off({layout:!0}),o.trigger=e.define.trigger({layout:!0}),o.bind=o.on,o.unbind=o.off}return e.util.setMap({map:a,keys:[t,i],value:r})}function i(t,i){return e.util.getMap({map:a,keys:[t,i]})}function r(t,i,r,n,a){return e.util.setMap({map:o,keys:[t,i,r,n],value:a})}function n(t,i,r,n){return e.util.getMap({map:o,keys:[t,i,r,n]})}var a={};e.extensions=a;var o={};e.modules=o,e.extension=function(){return 2==arguments.length?i.apply(this,arguments):3==arguments.length?t.apply(this,arguments):4==arguments.length?n.apply(this,arguments):5==arguments.length?r.apply(this,arguments):void e.util.error(\"Invalid extension access syntax\")}}(cytoscape),function(e,t){\"use strict\";if(e){var i=function(e){var t=e[0]._cyreg=e[0]._cyreg||{};return t};e.fn.cytoscape=function(r){var n=e(this);if(\"get\"===r)return i(n).cy;if(t.is.fn(r)){var a=r,o=i(n).cy;if(o&&o.isReady())o.trigger(\"ready\",[],a);else{var s=i(n),l=s.readies=s.readies||[];l.push(a)}}else if(t.is.plainObject(r))return n.each(function(){var t=e.extend({},r,{container:e(this)[0]});cytoscape(t)})},e.cytoscape=cytoscape,null==e.fn.cy&&null==e.cy&&(e.fn.cy=e.fn.cytoscape,e.cy=e.cytoscape)}}(\"undefined\"!=typeof jQuery?jQuery:null,cytoscape),function(e){\"use strict\";function t(){return!1}function i(){return!0}e.Event=function(r,n){return this instanceof e.Event?(r&&r.type?(this.originalEvent=r,this.type=r.type,this.isDefaultPrevented=r.defaultPrevented?i:t):this.type=r,n&&(this.type=void 0!==n.type?n.type:this.type,this.cy=n.cy,this.cyTarget=n.cyTarget,this.cyPosition=n.cyPosition,this.cyRenderedPosition=n.cyRenderedPosition,this.namespace=n.namespace,this.layout=n.layout,this.data=n.data),void(this.timeStamp=r&&r.timeStamp||+new Date)):new e.Event(r,n)},e.Event.prototype={preventDefault:function(){this.isDefaultPrevented=i;var e=this.originalEvent;e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){this.isPropagationStopped=i;var e=this.originalEvent;e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=i,this.stopPropagation()},isDefaultPrevented:t,isPropagationStopped:t,isImmediatePropagationStopped:t}}(cytoscape),function(e){\"use strict\";e.define={data:function(t){var i={field:\"data\",bindingEvent:\"data\",allowBinding:!1,allowSetting:!1,allowGetting:!1,settingEvent:\"data\",settingTriggersEvent:!1,triggerFnName:\"trigger\",immutableKeys:{},updateStyle:!1,onSet:function(){},canSet:function(){return!0}};return t=e.util.extend({},i,t),function(i,r){var n=t,a=this,o=void 0!==a.length,s=o?a:[a],l=o?a[0]:a;if(e.is.string(i)){if(n.allowGetting&&void 0===r){var u;return l&&(u=l._private[n.field][i]),u}if(n.allowSetting&&void 0!==r){var c=!n.immutableKeys[i];if(c){for(var d=0,p=s.length;p>d;d++)n.canSet(s[d])&&(s[d]._private[n.field][i]=r);n.updateStyle&&a.updateStyle(),n.onSet(a),n.settingTriggersEvent&&a[n.triggerFnName](n.settingEvent)}}}else if(n.allowSetting&&e.is.plainObject(i)){var h,v,g=i;for(h in g){v=g[h];var c=!n.immutableKeys[h];if(c)for(var d=0,p=s.length;p>d;d++)n.canSet(s[d])&&(s[d]._private[n.field][h]=v)}n.updateStyle&&a.updateStyle(),n.onSet(a),n.settingTriggersEvent&&a[n.triggerFnName](n.settingEvent)}else if(n.allowBinding&&e.is.fn(i)){var f=i;a.bind(n.bindingEvent,f)}else if(n.allowGetting&&void 0===i){var u;return l&&(u=l._private[n.field]),u}return a}},removeData:function(t){var i={field:\"data\",event:\"data\",triggerFnName:\"trigger\",triggerEvent:!1,immutableKeys:{}};return t=e.util.extend({},i,t),function(i){var r=t,n=this,a=void 0!==n.length,o=a?n:[n];if(e.is.string(i)){for(var s=i.split(/\\s+/),l=s.length,u=0;l>u;u++){var c=s[u];if(!e.is.emptyString(c)){var d=!r.immutableKeys[c];if(d)for(var p=0,h=o.length;h>p;p++)o[p]._private[r.field][c]=void 0}}r.triggerEvent&&n[r.triggerFnName](r.event)}else if(void 0===i){for(var p=0,h=o.length;h>p;p++){var v=o[p]._private[r.field];for(var c in v){var g=!r.immutableKeys[c];g&&(v[c]=void 0)}}r.triggerEvent&&n[r.triggerFnName](r.event)}return n}},event:{regex:/(\\w+)(\\.\\w+)?/,optionalTypeRegex:/(\\w+)?(\\.\\w+)?/,falseCallback:function(){return!1}},on:function(t){var i={unbindSelfOnTrigger:!1,unbindAllBindersOnTrigger:!1};return t=e.util.extend({},i,t),function(i,r,n,a){var o=this,s=void 0!==o.length,l=s?o:[o],u=e.is.string(i),c=t;if(e.is.plainObject(r)?(a=n,n=r,r=void 0):(e.is.fn(r)||r===!1)&&(a=r,n=void 0,r=void 0),(e.is.fn(n)||n===!1)&&(a=n,n=void 0),!e.is.fn(a)&&a!==!1&&u)return o;if(u){var d={};d[i]=a,i=d}for(var p in i)if(a=i[p],a===!1&&(a=e.define.event.falseCallback),e.is.fn(a)){p=p.split(/\\s+/);for(var h=0;h<p.length;h++){var v=p[h];if(!e.is.emptyString(v)){var g=v.match(e.define.event.regex);if(g)for(var f=g[1],y=g[2]?g[2]:void 0,m={callback:a,data:n,delegated:r?!0:!1,selector:r,selObj:new e.Selector(r),type:f,namespace:y,unbindSelfOnTrigger:c.unbindSelfOnTrigger,unbindAllBindersOnTrigger:c.unbindAllBindersOnTrigger,binders:l},x=0;x<l.length;x++)l[x]._private.listeners.push(m)}}}return o}},off:function(t){var i={};return t=e.util.extend({},i,t),function(t,i,r){var n=this,a=void 0!==n.length,o=a?n:[n],s=e.is.string(t);if(0===arguments.length){for(var l=0;l<o.length;l++)o[l]._private.listeners=[];return n}if((e.is.fn(i)||i===!1)&&(r=i,i=void 0),s){var u={};u[t]=r,t=u}for(var c in t){r=t[c],r===!1&&(r=e.define.event.falseCallback),c=c.split(/\\s+/);for(var d=0;d<c.length;d++){var p=c[d];if(!e.is.emptyString(p)){var h=p.match(e.define.event.optionalTypeRegex);if(h)for(var v=h[1]?h[1]:void 0,g=h[2]?h[2]:void 0,l=0;l<o.length;l++)for(var f=o[l]._private.listeners,y=0;y<f.length;y++){var m=f[y],x=!g||g===m.namespace,b=!v||m.type===v,w=!r||r===m.callback,_=x&&b&&w;_&&(f.splice(y,1),y--)}}}}return n}},trigger:function(t){var i={};return t=e.util.extend({},i,t),function(i,r,n){var a=this,o=void 0!==a.length,s=o?a:[a],l=e.is.string(i),u=e.is.plainObject(i),c=e.is.event(i),d=this._private.cy||this,p=d.hasCompoundNodes();if(l){var h=i.split(/\\s+/);i=[];for(var v=0;v<h.length;v++){var g=h[v];if(!e.is.emptyString(g)){var f=g.match(e.define.event.regex),y=f[1],m=f[2]?f[2]:void 0;i.push({type:y,namespace:m})}}}else if(u){var x=i;i=[x]}r?e.is.array(r)||(r=[r]):r=[];for(var v=0;v<i.length;v++)for(var b=i[v],w=0;w<s.length;w++){var g,_=s[w],E=_._private.listeners,S=e.is.element(_),P=S||t.layout;if(c?(g=b,g.cyTarget=g.cyTarget||_,g.cy=g.cy||d):g=new e.Event(b,{cyTarget:_,cy:d,namespace:b.namespace}),b.layout&&(g.layout=b.layout),t.layout&&(g.layout=_),g.cyPosition){var D=g.cyPosition,k=d.zoom(),C=d.pan();g.cyRenderedPosition={x:D.x*k+C.x,y:D.y*k+C.y}}n&&(E=[{namespace:g.namespace,type:g.type,callback:n}]);for(var T=0;T<E.length;T++){var N=E[T],M=!N.namespace||N.namespace===g.namespace,B=N.type===g.type,I=N.delegated?_!==g.cyTarget&&e.is.element(g.cyTarget)&&N.selObj.matches(g.cyTarget):!0,z=M&&B&&I;if(z){var L=[g];if(L=L.concat(r),g.data=N.data?N.data:void 0,(N.unbindSelfOnTrigger||N.unbindAllBindersOnTrigger)&&(E.splice(T,1),T--),N.unbindAllBindersOnTrigger)for(var O=N.binders,R=0;R<O.length;R++){var X=O[R];if(X&&X!==_)for(var V=X._private.listeners,Y=0;Y<V.length;Y++){var A=V[Y];A===N&&(V.splice(Y,1),Y--)}}var q=N.delegated?g.cyTarget:_,F=N.callback.apply(q,L);(F===!1||g.isPropagationStopped())&&(P=!1,F===!1&&(g.stopPropagation(),g.preventDefault()))}}if(P){var j=p?_._private.parent:null,W=null!=j&&0!==j.length;W?(j=j[0],j.trigger(g)):d.trigger(g)}}return a}},animated:function(t){var i={};return t=e.util.extend({},i,t),function(){var e=this,t=void 0!==e.length,i=t?e:[e],r=this._private.cy||this;if(!r.styleEnabled())return!1;var n=i[0];return n?n._private.animation.current.length>0:void 0}},clearQueue:function(t){var i={};return t=e.util.extend({},i,t),function(){var e=this,t=void 0!==e.length,i=t?e:[e],r=this._private.cy||this;if(!r.styleEnabled())return this;for(var n=0;n<i.length;n++){var a=i[n];a._private.animation.queue=[]}return this}},delay:function(t){var i={};return t=e.util.extend({},i,t),function(e,t){var i=this._private.cy||this;return i.styleEnabled()?(this.animate({delay:e},{duration:e,complete:t}),this):this}},animate:function(t){var i={};return t=e.util.extend({},i,t),function(e,t){var i=this,r=void 0!==i.length,n=r?i:[i],a=this._private.cy||this,o=!r,s=!o;\nif(!a.styleEnabled())return this;var l,u=+new Date,c=a.style();switch(void 0===t&&(t={}),void 0===t.duration&&(t.duration=400),t.duration){case\"slow\":t.duration=600;break;case\"fast\":t.duration=200}var d=!0;if(e)for(var p in e){d=!1;break}if(d)return this;if(e.css&&s&&(e.css=c.getValueStyle(e.css,{array:!0})),e.renderedPosition&&s){var h=e.renderedPosition,v=a.pan(),g=a.zoom();e.position={x:(h.x-v.x)/g,y:(h.y-v.y)/g}}if(e.panBy&&o){var f=e.panBy,y=a.pan();e.pan={x:y.x+f.x,y:y.y+f.y}}var m=e.center||e.centre;if(m&&o){var x=a.getCenterPan(m.eles,e.zoom);x&&(e.pan=x)}if(e.fit&&o){var b=e.fit,w=a.getFitViewport(b.eles||b.boundingBox,b.padding);w&&(e.pan=w.pan,e.zoom=w.zoom)}for(var p=0;p<n.length;p++){var _=n[p];l=_.animated()&&(void 0===t.queue||t.queue)?_._private.animation.queue:_._private.animation.current,l.push({properties:e,duration:t.duration,params:t,callTime:u})}return s&&a.addToAnimationPool(this),this}},stop:function(t){var i={};return t=e.util.extend({},i,t),function(e,t){var i=this,r=void 0!==i.length,n=r?i:[i],a=this._private.cy||this;if(!a.styleEnabled())return this;for(var o=0;o<n.length;o++){for(var s=n[o],l=s._private.animation.current,u=0;u<l.length;u++){var c=l[u];t&&(c.duration=0)}e&&(s._private.animation.queue=[]),t||(s._private.animation.current=[])}return a.notify({collection:this,type:\"draw\"}),this}}}}(cytoscape),function(e){\"use strict\";e.fn.selector=function(t){for(var i in t){var r=t[i];e.Selector.prototype[i]=r}},e.Selector=function(t,i){if(!(this instanceof e.Selector))return new e.Selector(t,i);void 0===i&&void 0!==t&&(i=t,t=void 0);var r=this;if(r._private={selectorText:null,invalid:!0},!i||e.is.string(i)&&i.match(/^\\s*$/))null==t?r.length=0:(r[0]=o(),r[0].group=t,r.length=1);else if(e.is.element(i)){var n=new e.Collection(r.cy(),[i]);r[0]=o(),r[0].collection=n,r.length=1}else if(e.is.collection(i))r[0]=o(),r[0].collection=i,r.length=1;else if(e.is.fn(i))r[0]=o(),r[0].filter=i,r.length=1;else{if(!e.is.string(i))return void e.util.error(\"A selector must be created from a string; found \"+i);var a=null,o=function(){return{classes:[],colonSelectors:[],data:[],group:null,ids:[],meta:[],collection:null,filter:null,parent:null,ancestor:null,subject:null,child:null,descendant:null}},s={metaChar:\"[\\\\!\\\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]\",comparatorOp:\"=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=\",boolOp:\"\\\\?|\\\\!|\\\\^\",string:'\"(?:\\\\\\\\\"|[^\"])+\"|'+\"'(?:\\\\\\\\'|[^'])+'\",number:e.util.regex.number,meta:\"degree|indegree|outdegree\",separator:\"\\\\s*,\\\\s*\",descendant:\"\\\\s+\",child:\"\\\\s+>\\\\s+\",subject:\"\\\\$\"};s.variable=\"(?:[\\\\w-]|(?:\\\\\\\\\"+s.metaChar+\"))+\",s.value=s.string+\"|\"+s.number,s.className=s.variable,s.id=s.variable;for(var l=function(e){return e.replace(new RegExp(\"\\\\\\\\(\"+s.metaChar+\")\",\"g\"),function(e,t){return t})},u=s.comparatorOp.split(\"|\"),c=0;c<u.length;c++){var d=u[c];s.comparatorOp+=\"|@\"+d}for(var u=s.comparatorOp.split(\"|\"),c=0;c<u.length;c++){var d=u[c];d.indexOf(\"!\")>=0||\"=\"!==d&&(s.comparatorOp+=\"|\\\\!\"+d)}var p={group:{query:!0,regex:\"(node|edge|\\\\*)\",populate:function(e){this.group=\"*\"==e?e:e+\"s\"}},state:{query:!0,regex:\"(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch)\",populate:function(e){this.colonSelectors.push(e)}},id:{query:!0,regex:\"\\\\#(\"+s.id+\")\",populate:function(e){this.ids.push(l(e))}},className:{query:!0,regex:\"\\\\.(\"+s.className+\")\",populate:function(e){this.classes.push(l(e))}},dataExists:{query:!0,regex:\"\\\\[\\\\s*(\"+s.variable+\")\\\\s*\\\\]\",populate:function(e){this.data.push({field:l(e)})}},dataCompare:{query:!0,regex:\"\\\\[\\\\s*(\"+s.variable+\")\\\\s*(\"+s.comparatorOp+\")\\\\s*(\"+s.value+\")\\\\s*\\\\]\",populate:function(e,t,i){var r=null!=new RegExp(\"^\"+s.string+\"$\").exec(i);i=r?i.substring(1,i.length-1):parseFloat(i),this.data.push({field:l(e),operator:t,value:i})}},dataBool:{query:!0,regex:\"\\\\[\\\\s*(\"+s.boolOp+\")\\\\s*(\"+s.variable+\")\\\\s*\\\\]\",populate:function(e,t){this.data.push({field:l(t),operator:e})}},metaCompare:{query:!0,regex:\"\\\\[\\\\[\\\\s*(\"+s.meta+\")\\\\s*(\"+s.comparatorOp+\")\\\\s*(\"+s.number+\")\\\\s*\\\\]\\\\]\",populate:function(e,t,i){this.meta.push({field:l(e),operator:t,value:parseFloat(i)})}},nextQuery:{separator:!0,regex:s.separator,populate:function(){r[++c]=o(),a=null}},child:{separator:!0,regex:s.child,populate:function(){var e=o();e.parent=this,e.subject=a,r[c]=e}},descendant:{separator:!0,regex:s.descendant,populate:function(){var e=o();e.ancestor=this,e.subject=a,r[c]=e}},subject:{modifier:!0,regex:s.subject,populate:function(){return null!=a&&this.subject!=this?(e.util.error(\"Redefinition of subject in selector `\"+i+\"`\"),!1):(a=this,void(this.subject=this))}}},h=0;for(var v in p)p[h]=p[v],p[h].name=v,h++;p.length=h,r._private.selectorText=i;var g=i,c=0,f=function(t){for(var i,r,n,a=0;a<p.length;a++){var o=p[a],s=o.name;if(!e.is.fn(t)||t(s,o)){var l=g.match(new RegExp(\"^\"+o.regex));if(null!=l){r=l,i=o,n=s;var u=l[0];g=g.substring(u.length);break}}}return{expr:i,match:r,name:n}},y=function(){var e=g.match(/^\\s+/);if(e){var t=e[0];g=g.substring(t.length)}};for(r[0]=o(),y();;){var m=f();if(null==m.expr)return void e.util.error(\"The selector `\"+i+\"`is invalid\");for(var x=[],h=1;h<m.match.length;h++)x.push(m.match[h]);var b=m.expr.populate.apply(r[c],x);if(b===!1)return;if(g.match(/^\\s*$/))break}for(r.length=c+1,h=0;h<r.length;h++){var w=r[h];if(null!=w.subject){for(;w.subject!=w;)if(null!=w.parent){var _=w.parent,E=w;E.parent=null,_.child=E,w=_}else{if(null==w.ancestor){e.util.error(\"When adjusting references for the selector `\"+w+\"`, neither parent nor ancestor was found\");break}var S=w.ancestor,P=w;P.ancestor=null,S.descendant=P,w=S}r[h]=w.subject}}if(null!=t)for(var h=0;h<r.length;h++){if(null!=r[h].group&&r[h].group!=t)return void e.util.error(\"Group `\"+r[h].group+\"` conflicts with implicit group `\"+t+\"` in selector `\"+i+\"`\");r[h].group=t}}r._private.invalid=!1},e.selfn=e.Selector.prototype,e.selfn.size=function(){return this.length},e.selfn.eq=function(e){return this[e]},e.selfn.find=function(){};var t=function(i,r){if(null!=i.group&&\"*\"!=i.group&&i.group!=r._private.group)return!1;for(var n=r.cy(),a=!0,o=0;o<i.colonSelectors.length;o++){var s=i.colonSelectors[o];switch(s){case\":selected\":a=r.selected();break;case\":unselected\":a=!r.selected();break;case\":selectable\":a=r.selectable();break;case\":unselectable\":a=!r.selectable();break;case\":locked\":a=r.locked();break;case\":unlocked\":a=!r.locked();break;case\":visible\":a=r.visible();break;case\":hidden\":a=!r.visible();break;case\":transparent\":a=r.transparent();break;case\":grabbed\":a=r.grabbed();break;case\":free\":a=!r.grabbed();break;case\":removed\":a=r.removed();break;case\":inside\":a=!r.removed();break;case\":grabbable\":a=r.grabbable();break;case\":ungrabbable\":a=!r.grabbable();break;case\":animated\":a=r.animated();break;case\":unanimated\":a=!r.animated();break;case\":parent\":a=r.isNode()&&r.children().nonempty();break;case\":child\":case\":nonorphan\":a=r.isNode()&&r.parent().nonempty();break;case\":orphan\":a=r.isNode()&&r.parent().empty();break;case\":loop\":a=r.isEdge()&&r.data(\"source\")===r.data(\"target\");break;case\":simple\":a=r.isEdge()&&r.data(\"source\")!==r.data(\"target\");break;case\":active\":a=r.active();break;case\":inactive\":a=!r.active();break;case\":touch\":a=e.is.touch()}if(!a)break}if(!a)return!1;for(var l=!0,o=0;o<i.ids.length;o++){var u=i.ids[o],c=r._private.data.id;if(l=l&&u==c,!l)break}if(!l)return!1;for(var d=!0,o=0;o<i.classes.length;o++){var p=i.classes[o];if(d=d&&r.hasClass(p),!d)break}if(!d)return!1;var h=function(t){for(var r=!0,n=0;n<i[t.name].length;n++){var a,o=i[t.name][n],s=o.operator,l=o.value,u=o.field;if(null!=s&&null!=l){var c=t.fieldValue(u),d=e.is.string(c)||e.is.number(c)?\"\"+c:\"\",p=\"\"+l,h=!1;s.indexOf(\"@\")>=0&&(d=d.toLowerCase(),p=p.toLowerCase(),s=s.replace(\"@\",\"\"),h=!0);var v=!1,g=!1;switch(s.indexOf(\"!\")>=0&&(s=s.replace(\"!\",\"\"),v=!0),h&&(l=p.toLowerCase(),c=d.toLowerCase()),s){case\"*=\":a=d.search(p)>=0;break;case\"$=\":a=null!=new RegExp(p+\"$\").exec(d);break;case\"^=\":a=null!=new RegExp(\"^\"+p).exec(d);break;case\"=\":a=c===l;break;case\"!=\":a=c!==l;break;case\">\":a=v?l>=c:c>l,g=!0;break;case\">=\":a=v?l>c:c>=l,g=!0;break;case\"<\":a=v?c>=l:l>c,g=!0;break;case\"<=\":a=v?c>l:l>=c,g=!0;break;default:a=!1}}else if(null!=s)switch(s){case\"?\":a=t.fieldTruthy(u);break;case\"!\":a=!t.fieldTruthy(u);break;case\"^\":a=t.fieldUndefined(u)}else a=!t.fieldUndefined(u);if(v&&!g&&(a=!a,g=!0),!a){r=!1;break}}return r},v=h({name:\"data\",fieldValue:function(e){return r._private.data[e]},fieldRef:function(e){return\"element._private.data.\"+e},fieldUndefined:function(e){return void 0===r._private.data[e]},fieldTruthy:function(e){return r._private.data[e]?!0:!1}});if(!v)return!1;var g=h({name:\"meta\",fieldValue:function(e){return r[e]()},fieldRef:function(e){return\"element.\"+e+\"()\"},fieldUndefined:function(e){return null==r[e]()},fieldTruthy:function(e){return r[e]()?!0:!1}});if(!g)return!1;if(null!=i.collection){var f=null!=i.collection._private.ids[r.id()];if(!f)return!1}if(null!=i.filter&&0===r.collection().filter(i.filter).size())return!1;var y=function(e,i){if(null!=e){var r=!1;if(!n.hasCompoundNodes())return!1;i=i();for(var a=0;a<i.length;a++)if(t(e,i[a])){r=!0;break}return r}return!0};return y(i.parent,function(){return r.parent()})&&y(i.ancestor,function(){return r.parents()})&&y(i.child,function(){return r.children()})&&y(i.descendant,function(){return r.descendants()})?!0:!1};e.selfn.filter=function(i){var r=this,n=i.cy();if(r._private.invalid)return new e.Collection(n);var a=function(e,i){for(var n=0;n<r.length;n++){var a=r[n];if(t(a,i))return!0}return!1};null==r._private.selectorText&&(a=function(){return!0});var o=i.filter(a);return o},e.selfn.matches=function(e){var i=this;if(i._private.invalid)return!1;for(var r=0;r<i.length;r++){var n=i[r];if(t(n,e))return!0}return!1},e.selfn.toString=e.selfn.selector=function(){for(var t=\"\",i=function(t){return e.is.string(t)?t:\"\"},r=function(e){var t=\"\",a=i(e.group);t+=a.substring(0,a.length-1);for(var o=0;o<e.data.length;o++){var s=e.data[o];t+=s.value?\"[\"+s.field+i(s.operator)+i(s.value)+\"]\":\"[\"+i(s.operator)+s.field+\"]\"}for(var o=0;o<e.meta.length;o++){var l=e.meta[o];t+=\"[[\"+l.field+i(l.operator)+i(l.value)+\"]]\"}for(var o=0;o<e.colonSelectors.length;o++){var u=e.colonSelectors[n];t+=u}for(var o=0;o<e.ids.length;o++){var u=\"#\"+e.ids[n];t+=u}for(var o=0;o<e.classes.length;o++){var u=\".\"+e.classes[n];t+=u}return null!=e.parent&&(t=r(e.parent)+\" > \"+t),null!=e.ancestor&&(t=r(e.ancestor)+\" \"+t),null!=e.child&&(t+=\" > \"+r(e.child)),null!=e.descendant&&(t+=\" \"+r(e.descendant)),t},n=0;n<this.length;n++){var a=this[n];t+=r(a),this.length>1&&n<this.length-1&&(t+=\", \")}return t}}(cytoscape),function(e){\"use strict\";e.Style=function(t){return this instanceof e.Style?e.is.core(t)?(this._private={cy:t,coreStyle:{},newStyle:!0},this.length=0,void this.addDefaultStylesheet()):void e.util.error(\"A style must have a core reference\"):new e.Style(t)},e.style=e.Style,e.styfn=e.Style.prototype,e.fn.style=function(t){for(var i in t){var r=t[i];e.Style.prototype=r}},function(){var t=e.util.regex.number,i=e.util.regex.rgbaNoBackRefs,r=e.util.regex.hslaNoBackRefs,n=e.util.regex.hex3,a=e.util.regex.hex6,o=function(e){return\"^\"+e+\"\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$\"},s=function(e){return\"^\"+e+\"\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(\"+t+\")\\\\s*\\\\,\\\\s*(\"+t+\")\\\\s*,\\\\s*(\"+t+\"|\\\\w+|\"+i+\"|\"+r+\"|\"+n+\"|\"+a+\")\\\\s*\\\\,\\\\s*(\"+t+\"|\\\\w+|\"+i+\"|\"+r+\"|\"+n+\"|\"+a+\")\\\\)$\"};e.style.types={time:{number:!0,min:0,units:\"s|ms\",implicitUnits:\"ms\"},percent:{number:!0,min:0,max:100,units:\"%\"},zeroOneNumber:{number:!0,min:0,max:1,unitless:!0},nOneOneNumber:{number:!0,min:-1,max:1,unitless:!0},nonNegativeInt:{number:!0,min:0,integer:!0,unitless:!0},position:{enums:[\"parent\",\"origin\"]},autoSize:{number:!0,min:0,enums:[\"auto\"]},number:{number:!0},size:{number:!0,min:0},bgSize:{number:!0,min:0,allowPercent:!0},bgPos:{number:!0,allowPercent:!0},bgRepeat:{enums:[\"repeat\",\"repeat-x\",\"repeat-y\",\"no-repeat\"]},bgFit:{enums:[\"none\",\"contain\",\"cover\"]},bgClip:{enums:[\"none\",\"node\"]},color:{color:!0},lineStyle:{enums:[\"solid\",\"dotted\",\"dashed\"]},borderStyle:{enums:[\"solid\",\"dotted\",\"dashed\",\"double\"]},curveStyle:{enums:[\"bezier\",\"unbundled-bezier\",\"haystack\"]},fontFamily:{regex:\"^([\\\\w- ]+(?:\\\\s*,\\\\s*[\\\\w- ]+)*)$\"},fontVariant:{enums:[\"small-caps\",\"normal\"]},fontStyle:{enums:[\"italic\",\"normal\",\"oblique\"]},fontWeight:{enums:[\"normal\",\"bold\",\"bolder\",\"lighter\",\"100\",\"200\",\"300\",\"400\",\"500\",\"600\",\"800\",\"900\",100,200,300,400,500,600,700,800,900]},textDecoration:{enums:[\"none\",\"underline\",\"overline\",\"line-through\"]},textTransform:{enums:[\"none\",\"uppercase\",\"lowercase\"]},nodeShape:{enums:[\"rectangle\",\"roundrectangle\",\"ellipse\",\"triangle\",\"square\",\"pentagon\",\"hexagon\",\"heptagon\",\"octagon\",\"star\"]},arrowShape:{enums:[\"tee\",\"triangle\",\"triangle-tee\",\"triangle-backcurve\",\"half-triangle-overshot\",\"square\",\"circle\",\"diamond\",\"none\"]},arrowFill:{enums:[\"filled\",\"hollow\"]},display:{enums:[\"element\",\"none\"]},visibility:{enums:[\"hidden\",\"visible\"]},valign:{enums:[\"top\",\"center\",\"bottom\"]},halign:{enums:[\"left\",\"center\",\"right\"]},text:{string:!0},data:{mapping:!0,regex:o(\"data\")},layoutData:{mapping:!0,regex:o(\"layoutData\")},mapData:{mapping:!0,regex:s(\"mapData\")},mapLayoutData:{mapping:!0,regex:s(\"mapLayoutData\")},url:{regex:\"^url\\\\s*\\\\(\\\\s*([^\\\\s]+)\\\\s*\\\\s*\\\\)|none|(.+)$\"},propList:{propList:!0},angle:{number:!0,units:\"deg|rad\"}};var l=e.style.types,u=e.style.properties=[{name:\"text-valign\",type:l.valign},{name:\"text-halign\",type:l.halign},{name:\"color\",type:l.color},{name:\"content\",type:l.text},{name:\"text-outline-color\",type:l.color},{name:\"text-outline-width\",type:l.size},{name:\"text-outline-opacity\",type:l.zeroOneNumber},{name:\"text-opacity\",type:l.zeroOneNumber},{name:\"text-transform\",type:l.textTransform},{name:\"font-family\",type:l.fontFamily},{name:\"font-style\",type:l.fontStyle},{name:\"font-weight\",type:l.fontWeight},{name:\"font-size\",type:l.size},{name:\"min-zoomed-font-size\",type:l.size},{name:\"display\",type:l.display},{name:\"visibility\",type:l.visibility},{name:\"opacity\",type:l.zeroOneNumber},{name:\"z-index\",type:l.nonNegativeInt},{name:\"overlay-padding\",type:l.size},{name:\"overlay-color\",type:l.color},{name:\"overlay-opacity\",type:l.zeroOneNumber},{name:\"transition-property\",type:l.propList},{name:\"transition-duration\",type:l.time},{name:\"transition-delay\",type:l.time},{name:\"height\",type:l.autoSize},{name:\"width\",type:l.autoSize},{name:\"shape\",type:l.nodeShape},{name:\"background-color\",type:l.color},{name:\"background-opacity\",type:l.zeroOneNumber},{name:\"background-blacken\",type:l.nOneOneNumber},{name:\"border-color\",type:l.color},{name:\"border-opacity\",type:l.zeroOneNumber},{name:\"border-width\",type:l.size},{name:\"border-style\",type:l.borderStyle},{name:\"background-image\",type:l.url},{name:\"background-image-opacity\",type:l.zeroOneNumber},{name:\"background-position-x\",type:l.bgPos},{name:\"background-position-y\",type:l.bgPos},{name:\"background-repeat\",type:l.bgRepeat},{name:\"background-fit\",type:l.bgFit},{name:\"background-clip\",type:l.bgClip},{name:\"padding-left\",type:l.size},{name:\"padding-right\",type:l.size},{name:\"padding-top\",type:l.size},{name:\"padding-bottom\",type:l.size},{name:\"position\",type:l.position},{name:\"line-style\",type:l.lineStyle},{name:\"line-color\",type:l.color},{name:\"control-point-step-size\",type:l.size},{name:\"control-point-distance\",type:l.number},{name:\"control-point-weight\",type:l.zeroOneNumber},{name:\"curve-style\",type:l.curveStyle},{name:\"haystack-radius\",type:l.zeroOneNumber},{name:\"source-arrow-shape\",type:l.arrowShape},{name:\"target-arrow-shape\",type:l.arrowShape},{name:\"mid-source-arrow-shape\",type:l.arrowShape},{name:\"mid-target-arrow-shape\",type:l.arrowShape},{name:\"source-arrow-color\",type:l.color},{name:\"target-arrow-color\",type:l.color},{name:\"mid-source-arrow-color\",type:l.color},{name:\"mid-target-arrow-color\",type:l.color},{name:\"source-arrow-fill\",type:l.arrowFill},{name:\"target-arrow-fill\",type:l.arrowFill},{name:\"mid-source-arrow-fill\",type:l.arrowFill},{name:\"mid-target-arrow-fill\",type:l.arrowFill},{name:\"selection-box-color\",type:l.color},{name:\"selection-box-opacity\",type:l.zeroOneNumber},{name:\"selection-box-border-color\",type:l.color},{name:\"selection-box-border-width\",type:l.size},{name:\"active-bg-color\",type:l.color},{name:\"active-bg-opacity\",type:l.zeroOneNumber},{name:\"active-bg-size\",type:l.size},{name:\"outside-texture-bg-color\",type:l.color},{name:\"outside-texture-bg-opacity\",type:l.zeroOneNumber}];e.style.pieBackgroundN=16,u.push({name:\"pie-size\",type:l.bgSize});for(var c=1;c<=e.style.pieBackgroundN;c++)u.push({name:\"pie-\"+c+\"-background-color\",type:l.color}),u.push({name:\"pie-\"+c+\"-background-size\",type:l.percent}),u.push({name:\"pie-\"+c+\"-background-opacity\",type:l.zeroOneNumber});for(var c=0;c<u.length;c++){var d=u[c];u[d.name]=d}}(),e.styfn.addDefaultStylesheet=function(){var t=\"Helvetica\",i=\"normal\",r=\"normal\",n=\"#000\",a=\"none\",o=16;this.selector(\"node, edge\").css({\"text-valign\":\"top\",\"text-halign\":\"center\",color:n,\"text-outline-color\":\"#000\",\"text-outline-width\":0,\"text-outline-opacity\":1,\"text-opacity\":1,\"text-decoration\":\"none\",\"text-transform\":a,\"font-family\":t,\"font-style\":i,\"font-weight\":r,\"font-size\":o,\"min-zoomed-font-size\":0,visibility:\"visible\",display:\"element\",opacity:1,\"z-index\":0,content:\"\",\"overlay-opacity\":0,\"overlay-color\":\"#000\",\"overlay-padding\":10,\"transition-property\":\"none\",\"transition-duration\":0,\"transition-delay\":0,\"background-blacken\":0,\"background-color\":\"#888\",\"background-opacity\":1,\"background-image\":\"none\",\"background-image-opacity\":1,\"background-position-x\":\"50%\",\"background-position-y\":\"50%\",\"background-repeat\":\"no-repeat\",\"background-fit\":\"none\",\"background-clip\":\"node\",\"border-color\":\"#000\",\"border-opacity\":1,\"border-width\":0,\"border-style\":\"solid\",height:30,width:30,shape:\"ellipse\",\"padding-top\":0,\"padding-bottom\":0,\"padding-left\":0,\"padding-right\":0,position:\"origin\",\"pie-size\":\"100%\",\"pie-1-background-color\":\"black\",\"pie-2-background-color\":\"black\",\"pie-3-background-color\":\"black\",\"pie-4-background-color\":\"black\",\"pie-5-background-color\":\"black\",\"pie-6-background-color\":\"black\",\"pie-7-background-color\":\"black\",\"pie-8-background-color\":\"black\",\"pie-9-background-color\":\"black\",\"pie-10-background-color\":\"black\",\"pie-11-background-color\":\"black\",\"pie-12-background-color\":\"black\",\"pie-13-background-color\":\"black\",\"pie-14-background-color\":\"black\",\"pie-15-background-color\":\"black\",\"pie-16-background-color\":\"black\",\"pie-1-background-size\":\"0%\",\"pie-2-background-size\":\"0%\",\"pie-3-background-size\":\"0%\",\"pie-4-background-size\":\"0%\",\"pie-5-background-size\":\"0%\",\"pie-6-background-size\":\"0%\",\"pie-7-background-size\":\"0%\",\"pie-8-background-size\":\"0%\",\"pie-9-background-size\":\"0%\",\"pie-10-background-size\":\"0%\",\"pie-11-background-size\":\"0%\",\"pie-12-background-size\":\"0%\",\"pie-13-background-size\":\"0%\",\"pie-14-background-size\":\"0%\",\"pie-15-background-size\":\"0%\",\"pie-16-background-size\":\"0%\",\"pie-1-background-opacity\":1,\"pie-2-background-opacity\":1,\"pie-3-background-opacity\":1,\"pie-4-background-opacity\":1,\"pie-5-background-opacity\":1,\"pie-6-background-opacity\":1,\"pie-7-background-opacity\":1,\"pie-8-background-opacity\":1,\"pie-9-background-opacity\":1,\"pie-10-background-opacity\":1,\"pie-11-background-opacity\":1,\"pie-12-background-opacity\":1,\"pie-13-background-opacity\":1,\"pie-14-background-opacity\":1,\"pie-15-background-opacity\":1,\"pie-16-background-opacity\":1,\"source-arrow-shape\":\"none\",\"mid-source-arrow-shape\":\"none\",\"target-arrow-shape\":\"none\",\"mid-target-arrow-shape\":\"none\",\"source-arrow-color\":\"#ddd\",\"mid-source-arrow-color\":\"#ddd\",\"target-arrow-color\":\"#ddd\",\"mid-target-arrow-color\":\"#ddd\",\"source-arrow-fill\":\"filled\",\"mid-source-arrow-fill\":\"filled\",\"target-arrow-fill\":\"filled\",\"mid-target-arrow-fill\":\"filled\",\"line-style\":\"solid\",\"line-color\":\"#ddd\",\"control-point-step-size\":40,\"control-point-weight\":.5,\"curve-style\":\"bezier\",\"haystack-radius\":.8}).selector(\"$node > node\").css({width:\"auto\",height:\"auto\",shape:\"rectangle\",\"background-opacity\":.5,\"padding-top\":10,\"padding-right\":10,\"padding-left\":10,\"padding-bottom\":10}).selector(\"edge\").css({width:1}).selector(\":active\").css({\"overlay-color\":\"black\",\"overlay-padding\":10,\"overlay-opacity\":.25}).selector(\"core\").css({\"selection-box-color\":\"#ddd\",\"selection-box-opacity\":.65,\"selection-box-border-color\":\"#aaa\",\"selection-box-border-width\":1,\"active-bg-color\":\"black\",\"active-bg-opacity\":.15,\"active-bg-size\":e.is.touch()?40:15,\"outside-texture-bg-color\":\"#000\",\"outside-texture-bg-opacity\":.125})},e.styfn.clear=function(){for(var e=0;e<this.length;e++)this[e]=void 0;return this.length=0,this._private.newStyle=!0,this},e.styfn.resetToDefault=function(){return this.clear(),this.addDefaultStylesheet(),this},e.styfn.core=function(){return this._private.coreStyle},e.styfn.parse=function(t,i,r,n){t=e.util.camel2dash(t);var a=e.style.properties[t],o=i;if(!a)return null;if(void 0===i||null===i)return null;var s=e.is.string(i);s&&(i=e.util.trim(i));var l=a.type;if(!l)return null;if(r&&(\"\"===i||null===i))return{name:t,value:i,bypass:!0,deleteBypass:!0};var u,c,d,p;if(!s||n);else{if((u=new RegExp(e.style.types.data.regex).exec(i))||(d=new RegExp(e.style.types.layoutData.regex).exec(i))){if(r)return!1;var h=void 0!==d;return u=u||d,{name:t,value:u,strValue:\"\"+i,mapped:h?e.style.types.layoutData:e.style.types.data,field:u[1],bypass:r,hasPie:t.match(/pie-(\\d+)-background-size/)}}if((c=new RegExp(e.style.types.mapData.regex).exec(i))||(p=new RegExp(e.style.types.mapLayoutData.regex).exec(i))){if(r)return!1;var h=void 0!==p;if(c=c||p,!l.color&&!l.number)return!1;var v=this.parse(t,c[4]);if(!v||v.mapped)return!1;var g=this.parse(t,c[5]);if(!g||g.mapped)return!1;if(v.value===g.value)return!1;if(l.color){var f=v.value,y=g.value,m=!(f[0]!==y[0]||f[1]!==y[1]||f[2]!==y[2]||f[3]!==y[3]&&(null!=f[3]&&1!==f[3]||null!=y[3]&&1!==y[3]));if(m)return!1}return{name:t,value:c,strValue:\"\"+i,mapped:h?e.style.types.mapLayoutData:e.style.types.mapData,field:c[1],fieldMin:parseFloat(c[2]),fieldMax:parseFloat(c[3]),valueMin:v.value,valueMax:g.value,bypass:r,hasPie:t.match(/pie-(\\d+)-background-size/)}}}if(l.number){var x,b=\"px\";if(l.units&&(x=l.units),l.implicitUnits&&(b=l.implicitUnits),!l.unitless)if(s){var w=\"px|em\"+(l.allowPercent?\"|\\\\%\":\"\");x&&(w=x);var _=i.match(\"^(\"+e.util.regex.number+\")(\"+w+\")?$\");_&&(i=_[1],x=_[2]||b)}else(!x||l.implicitUnits)&&(x=b);if(i=parseFloat(i),isNaN(i)&&void 0===l.enums)return null;if(isNaN(i)&&void 0!==l.enums){i=o;for(var E=0;E<l.enums.length;E++){var S=l.enums[E];if(S===i)return{name:t,value:i,strValue:\"\"+i,bypass:r}}return null}if(l.integer&&!e.is.integer(i))return null;if(void 0!==l.min&&i<l.min||void 0!==l.max&&i>l.max)return null;var P={name:t,value:i,strValue:\"\"+i+(x?x:\"\"),units:x,bypass:r,hasPie:t.match(/pie-(\\d+)-background-size/)&&null!=i&&0!==i&&\"\"!==i};return l.unitless||\"px\"!==x&&\"em\"!==x||(P.pxValue=\"px\"!==x&&x?this.getEmSizeInPixels()*i:i),(\"ms\"===x||\"s\"===x)&&(P.msValue=\"ms\"===x?i:1e3*i),P}if(l.propList){var D=[],k=\"\"+i;if(\"none\"===k);else{for(var C=k.split(\",\"),E=0;E<C.length;E++){var T=e.util.trim(C[E]);e.style.properties[T]&&D.push(T)}if(0===D.length)return null}return{name:t,value:D,strValue:0===D.length?\"none\":D.join(\", \"),bypass:r}}if(l.color){var N=e.util.color2tuple(i);return N?{name:t,value:N,strValue:\"\"+i,bypass:r}:null}if(l.enums){for(var E=0;E<l.enums.length;E++){var S=l.enums[E];if(S===i)return{name:t,value:i,strValue:\"\"+i,bypass:r}}return null}if(l.regex){var M=new RegExp(l.regex),B=M.exec(i);return B?{name:t,value:B,strValue:\"\"+i,bypass:r}:null}return l.string?{name:t,value:i,strValue:\"\"+i,bypass:r}:null},e.styfn.selector=function(t){var i=\"core\"===t?null:new e.Selector(t),r=this.length++;return this[r]={selector:i,properties:[],mappedProperties:[],index:r},this},e.styfn.css=function(){var t=arguments;switch(t.length){case 1:for(var i=t[0],r=0;r<e.style.properties.length;r++){var n=e.style.properties[r],a=i[n.name];void 0===a&&(a=i[e.util.dash2camel(n.name)]),void 0!==a&&this.cssRule(n.name,a)}break;case 2:this.cssRule(t[0],t[1])}return this},e.styfn.cssRule=function(e,t){var i=this.parse(e,t);if(i){var r=this.length-1;this[r].properties.push(i),this[r].properties[i.name]=i,i.hasPie&&(this._private.hasPie=!0),i.mapped&&this[r].mappedProperties.push(i);var n=!this[r].selector;n&&(this._private.coreStyle[i.name]=i)}return this}}(cytoscape),function(e){\"use strict\";e.styfn.apply=function(e){var t=this;t._private.newStyle&&(this._private.contextStyles={},this._private.propDiffs={});for(var i=0;i<e.length;i++){var r=e[i],n=t.getContextMeta(r),a=t.getContextStyle(n),o=t.applyContextStyle(n,a,r);t.updateTransitions(r,o.diffProps),t.updateStyleHints(r)}t._private.newStyle=!1},e.styfn.getPropertiesDiff=function(e,t){var i=this,r=i._private.propDiffs=i._private.propDiffs||{},n=e+\"-\"+t,a=r[n];if(a)return a;for(var o=[],s={},l=0;l<i.length;l++){var u=i[l],c=\"t\"===e[l],d=\"t\"===t[l],p=c!==d,h=u.mappedProperties.length>0;if(p||h){var v;p&&h?v=u.properties:p?v=u.properties:h&&(v=u.mappedProperties);for(var g=0;g<v.length;g++){for(var f=v[g],y=f.name,m=!1,x=l+1;x<i.length;x++){var b=i[x],w=\"t\"===t[x];if(w&&(m=null!=b.properties[f.name]))break}s[y]||m||(s[y]=!0,o.push(y))}}}return r[n]=o,o},e.styfn.getContextMeta=function(e){var t,i=this,r=\"\",n=e._private.styleCxtKey||\"\";i._private.newStyle&&(n=\"\");for(var a=0;a<i.length;a++){var o=i[a],s=o.selector&&o.selector.matches(e);r+=s?\"t\":\"f\"}return t=i.getPropertiesDiff(n,r),e._private.styleCxtKey=r,{key:r,diffPropNames:t}},e.styfn.getContextStyle=function(e){var t=e.key,i=this,r=this._private.contextStyles=this._private.contextStyles||{};if(r[t])return r[t];for(var n={_private:{key:t}},a=0;a<i.length;a++){var o=i[a],s=\"t\"===t[a];if(s)for(var l=0;l<o.properties.length;l++){var u=o.properties[l],c=n[u.name]=u;c.context=o}}return r[t]=n,n},e.styfn.applyContextStyle=function(e,t,i){for(var r=this,n=e.diffPropNames,a={},o=0;o<n.length;o++){var s=n[o],l=t[s],u=i._private.style[s];if(l&&u!==l){var c=a[s]={prev:u};r.applyParsedProperty(i,l),c.next=i._private.style[s],c.next.bypass&&(c.next=c.next.bypassed)}}return{diffProps:a}},e.styfn.updateStyleHints=function(t){var i=t._private,r=this,n=i.style,a=!1;if(\"nodes\"===i.group&&r._private.hasPie)for(var o=1;o<=e.style.pieBackgroundN;o++){var s=i.style[\"pie-\"+o+\"-background-size\"].value;if(s>0){a=!0;break}}i.hasPie=a;var l=n[\"text-transform\"].strValue,u=n.content.strValue,c=n[\"font-style\"].strValue,s=n[\"font-size\"].pxValue+\"px\",d=n[\"font-family\"].strValue,p=n[\"font-weight\"].strValue,h=n[\"text-valign\"].strValue,v=n[\"text-valign\"].strValue,g=n[\"text-outline-width\"].pxValue;i.labelKey=c+\"$\"+s+\"$\"+d+\"$\"+p+\"$\"+u+\"$\"+l+\"$\"+h+\"$\"+v+\"$\"+g,i.fontKey=c+\"$\"+p+\"$\"+s+\"$\"+d;var f=n.width.pxValue,y=n.height.pxValue,m=n[\"border-width\"].pxValue;if(i.boundingBoxKey=f+\"$\"+y+\"$\"+m,\"edges\"===t._private.group){var x=n[\"control-point-step-size\"].pxValue,b=n[\"control-point-distance\"]?n[\"control-point-distance\"].pxValue:void 0,w=n[\"control-point-weight\"].value,_=n[\"curve-style\"].strValue;i.boundingBoxKey+=\"$\"+x+\"$\"+b+\"$\"+w+\"$\"+_}i.styleKey=Date.now()},e.styfn.applyParsedProperty=function(t,i){var r,n,a=i,o=t._private.style,s=e.style.properties[a.name].type,l=a.bypass,u=o[a.name],c=u&&u.bypass;if((\"height\"===i.name||\"width\"===i.name)&&\"auto\"===i.value&&t.isNode()&&!t.isParent())return!1;if(l&&a.deleteBypass){var d=o[a.name];return d?d.bypass&&d.bypassed?(o[a.name]=d.bypassed,!0):!1:!0}var p=function(){e.util.error(\"Do not assign mappings to elements without corresponding data (e.g. ele `\"+t.id()+\"` for property `\"+a.name+\"` with data field `\"+a.field+\"`); try a `[\"+a.field+\"]` selector to limit scope to elements with `\"+a.field+\"` defined\")};switch(a.mapped){case e.style.types.mapData:case e.style.types.mapLayoutData:for(var h=a.mapped===e.style.types.mapLayoutData,v=a.field.split(\".\"),r=h?t._private.layoutData:t._private.data,g=0;g<v.length&&r;g++){var f=v[g];r=r[f]}var y;if(y=e.is.number(r)?(r-a.fieldMin)/(a.fieldMax-a.fieldMin):0,0>y?y=0:y>1&&(y=1),s.color){var m=a.valueMin[0],x=a.valueMax[0],b=a.valueMin[1],w=a.valueMax[1],_=a.valueMin[2],E=a.valueMax[2],S=null==a.valueMin[3]?1:a.valueMin[3],P=null==a.valueMax[3]?1:a.valueMax[3],D=[Math.round(m+(x-m)*y),Math.round(b+(w-b)*y),Math.round(_+(E-_)*y),Math.round(S+(P-S)*y)];n={bypass:a.bypass,name:a.name,value:D,strValue:\"rgb(\"+D[0]+\", \"+D[1]+\", \"+D[2]+\")\"}}else{if(!s.number)return!1;var k=a.valueMin+(a.valueMax-a.valueMin)*y;n=this.parse(a.name,k,a.bypass,!0)}n||(n=this.parse(a.name,u.strValue,a.bypass,!0)),n||p(),n.mapping=a,a=n;break;case e.style.types.data:case e.style.types.layoutData:for(var h=a.mapped===e.style.types.layoutData,v=a.field.split(\".\"),r=h?t._private.layoutData:t._private.data,g=0;g<v.length&&r;g++){var f=v[g];r=r[f]}if(n=this.parse(a.name,r,a.bypass,!0),!n){var C=u?u.strValue:\"\";n=this.parse(a.name,C,a.bypass,!0)}n||p(),n.mapping=a,a=n;break;case void 0:break;default:return!1}return l?(a.bypassed=c?u.bypassed:u,o[a.name]=a):c?u.bypassed=a:o[a.name]=a,!0},e.styfn.update=function(){var e=this._private.cy,t=e.elements();t.updateStyle()},e.styfn.updateMappers=function(t){for(var i=0;i<t.length;i++){for(var r=t[i],n=r._private.style,a=0;a<e.style.properties.length;a++){var o=e.style.properties[a],s=n[o.name];if(s&&s.mapping){var l=s.mapping;this.applyParsedProperty(r,l)}}this.updateStyleHints(r)}},e.styfn.updateTransitions=function(t,i,r){var n=this,a=t._private.style,o=a[\"transition-property\"].value,s=a[\"transition-duration\"].msValue,l=a[\"transition-delay\"].msValue,u={};if(o.length>0&&s>0){for(var c=!1,d=0;d<o.length;d++){var p=o[d],h=a[p],v=i[p];if(v){var g=v.prev,f=g,y=null!=v.next?v.next:h,m=!1;f&&(e.is.number(f.pxValue)&&e.is.number(y.pxValue)?m=f.pxValue!==y.pxValue:e.is.number(f.value)&&e.is.number(y.value)?m=f.value!==y.value:e.is.array(f.value)&&e.is.array(y.value)&&(m=f.value[0]!==y.value[0]||f.value[1]!==y.value[1]||f.value[2]!==y.value[2]),m&&(u[p]=y.strValue,this.applyBypass(t,p,f.strValue),c=!0))}}if(!c)return;t._private.transitioning=!0,t.stop(),l>0&&t.delay(l),t.animate({css:u},{duration:s,queue:!1,complete:function(){r||n.removeBypasses(t,o),t._private.transitioning=!1}})}else t._private.transitioning&&(t.stop(),this.removeBypasses(t,o),t._private.transitioning=!1)}}(cytoscape),function(e){\"use strict\";e.styfn.applyBypass=function(t,i,r,n){var a=[],o=!0;if(\"*\"===i||\"**\"===i){if(void 0!==r)for(var s=0;s<e.style.properties.length;s++){var l=e.style.properties[s],i=l.name,u=this.parse(i,r,!0);u&&a.push(u)}}else if(e.is.string(i)){var u=this.parse(i,r,!0);u&&a.push(u)}else{if(!e.is.plainObject(i))return!1;var c=i;n=r;for(var s=0;s<e.style.properties.length;s++){var l=e.style.properties[s],i=l.name,r=c[i];if(void 0===r&&(r=c[e.util.dash2camel(i)]),void 0!==r){var u=this.parse(i,r,!0);u&&a.push(u)}}}if(0===a.length)return!1;for(var d=!1,s=0;s<t.length;s++){for(var p,h=t[s],v=h._private.style,g={},f=0;f<a.length;f++){var l=a[f];if(n){var y=v[l.name];p=g[l.name]={prev:y}}d=this.applyParsedProperty(h,l)||d,n&&(p.next=v[l.name])}n&&this.updateTransitions(h,g,o)}return d},e.styfn.overrideBypass=function(t,i,r){for(var n=0;n<t.length;n++){var a=t[n],o=a._private.style[e.util.camel2dash(i)];o.bypass?(o.value=r,o.pxValue=r):this.applyBypass(a,i,r)}},e.styfn.removeAllBypasses=function(t,i){for(var r=!0,n=0;n<t.length;n++){for(var a=t[n],o={},s=a._private.style,l=0;l<e.style.properties.length;l++){var u=e.style.properties[l],c=u.name,d=\"\",p=this.parse(c,d,!0),h=s[u.name],v=o[u.name]={prev:h};this.applyParsedProperty(a,p),v.next=s[u.name]}i&&this.updateTransitions(a,o,r)}},e.styfn.removeBypasses=function(t,i,r){for(var n=!0,a=0;a<t.length;a++){for(var o=t[a],s={},l=o._private.style,u=0;u<i.length;u++){var c=i[u],d=e.style.properties[c],p=\"\",h=this.parse(c,p,!0),v=l[d.name],g=s[d.name]={prev:v};this.applyParsedProperty(o,h),g.next=l[d.name]}r&&this.updateTransitions(o,s,n)}}}(cytoscape),function(e,t){\"use strict\";\ne.styfn.getEmSizeInPixels=function(){var e=this._private.cy,i=e.container();if(t&&i&&t.getComputedStyle){var r=t.getComputedStyle(i).getPropertyValue(\"font-size\"),n=parseFloat(r);return n}return 1},e.styfn.containerCss=function(e){var i=this._private.cy,r=i.container();return t&&r&&t.getComputedStyle?t.getComputedStyle(r).getPropertyValue(e):void 0},e.styfn.containerProperty=function(e){var t=this.containerCss(e),i=this.parse(e,t);return i},e.styfn.containerPropertyAsString=function(e){var t=this.containerProperty(e);return t?t.strValue:void 0}}(cytoscape,\"undefined\"==typeof window?null:window),function(e){\"use strict\";e.styfn.getRenderedStyle=function(t){var t=t[0];if(t){for(var i={},r=t._private.style,n=this._private.cy,a=n.zoom(),o=0;o<e.style.properties.length;o++){var s=e.style.properties[o],l=r[s.name];if(l){var u=l.unitless?l.strValue:l.pxValue*a+\"px\";i[s.name]=u,i[e.util.dash2camel(s.name)]=u}}return i}},e.styfn.getRawStyle=function(t){var t=t[0];if(t){for(var i={},r=t._private.style,n=0;n<e.style.properties.length;n++){var a=e.style.properties[n],o=r[a.name];o&&(i[a.name]=o.strValue,i[e.util.dash2camel(a.name)]=o.strValue)}return i}},e.styfn.getValueStyle=function(t,i){i=i||{};var r,n=i.array?[]:{};if(r=e.is.element(t)?t._private.style:t)for(var a=0;a<e.style.properties.length;a++){var o=e.style.properties[a],s=r[o.name]||r[e.util.dash2camel(o.name)];void 0===s||e.is.plainObject(s)||(s=this.parse(o.name,s)),s&&(i.array?n.push(s):(n[o.name]=s,n[e.util.dash2camel(o.name)]=s))}return n}}(cytoscape),function(e){\"use strict\";e.style.applyFromJson=function(e,t){for(var i=0;i<t.length;i++){var r=t[i],n=r.selector,a=r.css;e.selector(n);for(var o in a){var s=a[o];e.css(o,s)}}return e},e.style.fromJson=function(t,i){var r=new e.Style(t);return e.style.applyFromJson(r,i),r},e.styfn.fromJson=function(t){var i=this;return i.resetToDefault(),e.style.applyFromJson(i,t),i},e.styfn.json=function(){for(var e=[],t=0;t<this.length;t++){for(var i=this[t],r=i.selector,n=i.properties,a={},o=0;o<n.length;o++){var s=n[o];a[s.name]=s.strValue}e.push({selector:r?r.toString():\"core\",css:a})}return e}}(cytoscape),function(e){\"use strict\";e.style.applyFromString=function(t,i){function r(){l=l.length>a.length?l.substr(a.length):\"\"}function n(){o=o.length>s.length?o.substr(s.length):\"\"}var a,o,s,l=\"\"+i;for(l=l.replace(/[/][*](\\s|.)+?[*][/]/g,\"\");;){var u=l.match(/^\\s*$/);if(u)break;var c=l.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);if(!c){e.util.error(\"Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: \"+l);break}a=c[0];var d=c[1],p=new e.Selector(d);if(p._private.invalid&&\"core\"!==d)e.util.error(\"Skipping parsing of block: Invalid selector found in string stylesheet: \"+d),r();else{var h=c[2],v=!1;o=h;for(var g=[];;){var u=o.match(/^\\s*$/);if(u)break;var f=o.match(/^\\s*(.+?)\\s*:\\s*(.+?)\\s*;/);if(!f){e.util.error(\"Skipping parsing of block: Invalid formatting of style property and value definitions found in:\"+h),v=!0;break}s=f[0];var y=f[1],m=f[2],x=e.style.properties[y];if(x){var b=t.parse(y,m);b?(g.push({name:y,val:m}),n()):(e.util.error(\"Skipping property: Invalid property definition in: \"+s),n())}else e.util.error(\"Skipping property: Invalid property name in: \"+s),n()}if(v){r();break}t.selector(d);for(var w=0;w<g.length;w++){var x=g[w];t.css(x.name,x.val)}r()}}return t},e.style.fromString=function(t,i){var r=new e.Style(t);return e.style.applyFromString(r,i),r},e.styfn.fromString=function(t){var i=this;return i.resetToDefault(),e.style.applyFromString(i,t),i}}(cytoscape),function(e){\"use strict\";e.stylesheet=e.Stylesheet=function(){return this instanceof e.Stylesheet?void(this.length=0):new e.Stylesheet},e.Stylesheet.prototype.selector=function(e){var t=this.length++;return this[t]={selector:e,properties:[]},this},e.Stylesheet.prototype.css=function(t,i){var r=this.length-1;if(e.is.string(t))this[r].properties.push({name:t,value:i});else if(e.is.plainObject(t))for(var n=t,a=0;a<e.style.properties.length;a++){var o=e.style.properties[a],s=n[o.name];if(void 0===s&&(s=n[e.util.dash2camel(o.name)]),void 0!==s){var t=o.name,i=s;this[r].properties.push({name:t,value:i})}}return this},e.Stylesheet.prototype.generateStyle=function(t){for(var i=new e.Style(t),r=0;r<this.length;r++){var n=this[r],a=n.selector,o=n.properties;i.selector(a);for(var s=0;s<o.length;s++){var l=o[s];i.css(l.name,l.value)}}return i}}(cytoscape),function(e,t){\"use strict\";var i=e.is.touch(),r={},n=e.util.copy(r);e.defaults=function(t){r=e.util.extend({},n,t)},e.fn.core=function(t){for(var i in t){var r=t[i];e.Core.prototype[i]=r}},e.Core=function(n){if(!(this instanceof e.Core))return new e.Core(n);var a=this;n=e.util.extend({},r,n);var o=n.container,s=o?o._cyreg:null;if(s=s||{},s&&s.cy){if(o)for(;o.firstChild;)o.removeChild(o.firstChild);s.cy.notify({type:\"destroy\"}),s={}}var l=s.readies=s.readies||[];o&&(o._cyreg=s),s.cy=a;var u=void 0!==t&&void 0!==o&&!n.headless,c=n;c.layout=e.util.extend({name:u?\"grid\":\"null\"},c.layout),c.renderer=e.util.extend({name:u?\"canvas\":\"null\"},c.renderer);var d=function(e,t,i){return void 0!==t?t:void 0!==i?i:e},p=this._private={container:c.container,ready:!1,initrender:!1,options:c,elements:[],id2index:{},listeners:[],aniEles:e.Collection(this),scratch:{},layout:null,renderer:null,notificationsEnabled:!0,minZoom:1e-50,maxZoom:1e50,zoomingEnabled:d(!0,c.zoomingEnabled),userZoomingEnabled:d(!0,c.userZoomingEnabled),panningEnabled:d(!0,c.panningEnabled),userPanningEnabled:d(!0,c.userPanningEnabled),boxSelectionEnabled:d(!1,c.boxSelectionEnabled),autolock:d(!1,c.autolock,c.autolockNodes),autoungrabify:d(!1,c.autoungrabify,c.autoungrabifyNodes),autounselectify:d(!1,c.autounselectify),styleEnabled:void 0===c.styleEnabled?u:c.styleEnabled,zoom:e.is.number(c.zoom)?c.zoom:1,pan:{x:e.is.plainObject(c.pan)&&e.is.number(c.pan.x)?c.pan.x:0,y:e.is.plainObject(c.pan)&&e.is.number(c.pan.y)?c.pan.y:0},animation:{current:[],queue:[]},hasCompoundNodes:!1,deferredExecQueue:[]},h=c.selectionType;p.selectionType=void 0===h||\"additive\"!==h&&\"single\"!==h?i?\"additive\":\"single\":h,e.is.number(c.minZoom)&&e.is.number(c.maxZoom)&&c.minZoom<c.maxZoom?(p.minZoom=c.minZoom,p.maxZoom=c.maxZoom):e.is.number(c.minZoom)&&void 0===c.maxZoom?p.minZoom=c.minZoom:e.is.number(c.maxZoom)&&void 0===c.minZoom&&(p.maxZoom=c.maxZoom),p.styleEnabled&&this.setStyle(c.style),a.initRenderer(e.util.extend({hideEdgesOnViewport:c.hideEdgesOnViewport,hideLabelsOnViewport:c.hideLabelsOnViewport,textureOnViewport:c.textureOnViewport,wheelSensitivity:e.is.number(c.wheelSensitivity)&&c.wheelSensitivity>0?c.wheelSensitivity:1,motionBlur:c.motionBlur,pixelRatio:e.is.number(c.pixelRatio)&&c.pixelRatio>0?c.pixelRatio:\"auto\"===c.pixelRatio?void 0:1,tapThreshold:d(e.is.touch()?8:4,e.is.touch()?c.touchTapThreshold:c.desktopTapThreshold)},c.renderer)),c.initrender&&(a.on(\"initrender\",c.initrender),a.on(\"initrender\",function(){a._private.initrender=!0})),a.load(c.elements,function(){a.startAnimationLoop(),a._private.ready=!0,e.is.fn(c.ready)&&a.on(\"ready\",c.ready);for(var t=0;t<l.length;t++){var i=l[t];a.on(\"ready\",i)}s&&(s.readies=[]),a.trigger(\"ready\")},c.done)},e.corefn=e.Core.prototype,e.fn.core({isReady:function(){return this._private.ready},ready:function(e){this.isReady()?this.trigger(\"ready\",[],e):this.on(\"ready\",e)},initrender:function(){return this._private.initrender},destroy:function(){this.notify({type:\"destroy\"});var e=this.container(),t=e.parentNode;return t&&t.removeChild(e),this},getElementById:function(t){var i=this._private.id2index[t];return void 0!==i?this._private.elements[i]:new e.Collection(this)},selectionType:function(){return this._private.selectionType},hasCompoundNodes:function(){return this._private.hasCompoundNodes},styleEnabled:function(){return this._private.styleEnabled},addToPool:function(e){for(var t=this._private.elements,i=this._private.id2index,r=0;r<e.length;r++){var n=e[r],a=n._private.data.id,o=i[a],s=void 0!==o;s||(o=t.length,t.push(n),i[a]=o,n._private.index=o)}return this},removeFromPool:function(e){for(var t=this._private.elements,i=this._private.id2index,r=0;r<e.length;r++){var n=e[r],a=n._private.data.id,o=i[a],s=void 0!==o;if(s){this._private.id2index[a]=void 0,t.splice(o,1);for(var l=o;l<t.length;l++){var u=t[l]._private.data.id;i[u]--}}}},container:function(){return this._private.container},options:function(){return e.util.copy(this._private.options)},json:function(){var e={},t=this;return e.elements={},t.elements().each(function(t,i){var r=i.group();e.elements[r]||(e.elements[r]=[]),e.elements[r].push(i.json())}),this._private.styleEnabled&&(e.style=t.style().json()),e.zoomingEnabled=t._private.zoomingEnabled,e.userZoomingEnabled=t._private.userZoomingEnabled,e.zoom=t._private.zoom,e.minZoom=t._private.minZoom,e.maxZoom=t._private.maxZoom,e.panningEnabled=t._private.panningEnabled,e.userPanningEnabled=t._private.userPanningEnabled,e.pan=t._private.pan,e.boxSelectionEnabled=t._private.boxSelectionEnabled,e.layout=t._private.options.layout,e.renderer=t._private.options.renderer,e.hideEdgesOnViewport=t._private.options.hideEdgesOnViewport,e.hideLabelsOnViewport=t._private.options.hideLabelsOnViewport,e.textureOnViewport=t._private.options.textureOnViewport,e.wheelSensitivity=t._private.options.wheelSensitivity,e.motionBlur=t._private.options.motionBlur,e},defer:function(e){var t=this,i=t._private,r=i.deferredExecQueue;r.push(e),i.deferredTimeout||(i.deferredTimeout=setTimeout(function(){for(;r.length>0;)r.shift()();i.deferredTimeout=null},0))}})}(cytoscape,\"undefined\"==typeof window?null:window),function(e,t){\"use strict\";function i(e){var t=!document||\"interactive\"!==document.readyState&&\"complete\"!==document.readyState?i:e;setTimeout(t,9,e)}e.fn.core({add:function(t){var i,r=this;if(e.is.elementOrCollection(t)){var n=t;if(n._private.cy===r)i=n.restore();else{for(var a=[],o=0;o<n.length;o++){var s=n[o];a.push(s.json())}i=new e.Collection(r,a)}}else if(e.is.array(t)){var a=t;i=new e.Collection(r,a)}else if(e.is.plainObject(t)&&(e.is.array(t.nodes)||e.is.array(t.edges))){for(var l=t,a=[],u=[\"nodes\",\"edges\"],o=0,c=u.length;c>o;o++){var d=u[o],p=l[d];if(e.is.array(p))for(var h=0,v=p.length;v>h;h++){var g=p[h];g.group=d,a.push(g)}}i=new e.Collection(r,a)}else{var g=t;i=new e.Element(r,g).collection()}return i},remove:function(t){if(e.is.elementOrCollection(t))t=t;else if(e.is.string(t)){var i=t;t=this.$(i)}return t.remove()},load:function(r,n,a){function o(){s.one(\"layoutready\",function(e){s.notifications(!0),s.trigger(e),s.notify({type:\"load\",collection:s.elements()}),s.one(\"load\",n),s.trigger(\"load\")}).one(\"layoutstop\",function(){s.one(\"done\",a),s.trigger(\"done\")});var t=e.util.extend({},s._private.options.layout);t.eles=s.$(),s.layout(t)}var s=this,l=s.elements();return l.length>0&&l.remove(),s.notifications(!1),null!=r&&(e.is.plainObject(r)||e.is.array(r))&&s.add(r),t?i(o):o(),this}})}(cytoscape,\"undefined\"==typeof window?null:window),function(e,t){\"use strict\";e.fn.core({animated:e.define.animated(),clearQueue:e.define.clearQueue(),delay:e.define.delay(),animate:e.define.animate(),stop:e.define.stop(),addToAnimationPool:function(e){var t=this;t.styleEnabled()&&t._private.aniEles.merge(e)},startAnimationLoop:function(){function i(){e.util.requestAnimationFrame(function(e){r(e),i()})}function r(t){function i(i,r){var s=i._private.animation.current,l=i._private.animation.queue,u=!1;if(0===s.length){var c=l.length>0?l.shift():null;c&&(c.callTime=t,s.push(c))}for(var d=[],p=s.length-1;p>=0;p--){var h=s[p];h.started||n(i,h),a(i,h,t,r),h.done&&(d.push(h),s.splice(p,1)),u=!0}for(var p=0;p<d.length;p++){var h=d[p],v=h.params.complete;e.is.fn(v)&&v.apply(i,[t])}return r||0!==s.length||0!==l.length||o.push(i),u}t=+new Date;for(var r=l._private.aniEles,o=[],s=0;s<r.length;s++){var u=r[s];i(u)}var c=i(l,!0);if(r.length>0||c){var d;if(r.length>0){var p=r.updateCompoundBounds();d=p.length>0?r.add(p):r}l.notify({type:\"draw\",collection:d})}r.unmerge(o)}function n(t,i){var r=e.is.core(t),n=!r,a=t,o=l._private.style;if(n)var s=a._private.position,u={x:s.x,y:s.y},c=o.getValueStyle(a);if(r)var d=l._private.pan,p={x:d.x,y:d.y},h=l._private.zoom;i.started=!0,i.startTime=Date.now(),i.startPosition=u,i.startStyle=c,i.startPan=p,i.startZoom=h}function a(t,i,r,n){var a,u=l._private.style,c=i.properties,d=i.params,p=i.startTime,h=!n;if(a=0===i.duration?1:Math.min(1,(r-p)/i.duration),0>a?a=0:a>1&&(a=1),null==c.delay){var v=i.startPosition,g=c.position,f=t._private.position;g&&h&&(o(v.x,g.x)&&(f.x=s(v.x,g.x,a)),o(v.y,g.y)&&(f.y=s(v.y,g.y,a)));var y=i.startPan,m=c.pan,x=t._private.pan,b=null!=m&&n;b&&(o(y.x,m.x)&&(x.x=s(y.x,m.x,a)),o(y.y,m.y)&&(x.y=s(y.y,m.y,a)),t.trigger(\"pan\"));var w=i.startZoom,_=c.zoom,E=null!=_&&n;if(E&&(o(w,_)&&(t._private.zoom=s(w,_,a)),t.trigger(\"zoom\")),(b||E)&&t.trigger(\"viewport\"),c.css&&h)for(var S=c.css,P=0;P<S.length;P++){var D=S[P].name,k=S[P],C=k,T=i.startStyle[D],N=s(T,C,a);u.overrideBypass(t,D,N)}}return e.is.fn(d.step)&&d.step.apply(t,[r]),a>=1&&(i.done=!0),a}function o(t,i){return null==t||null==i?!1:e.is.number(t)&&e.is.number(i)?!0:t&&i?!0:!1}function s(t,i,r){0>r?r=0:r>1&&(r=1);var n,a;if(n=null!=t.pxValue||null!=t.value?null!=t.pxValue?t.pxValue:t.value:t,a=null!=i.pxValue||null!=i.value?null!=i.pxValue?i.pxValue:i.value:i,e.is.number(n)&&e.is.number(a))return n+(a-n)*r;if(e.is.number(n[0])&&e.is.number(a[0])){var o=n,s=a,l=function(e,t){var i=t-e,n=e;return Math.round(r*i+n)},u=l(o[0],s[0]),c=l(o[1],s[1]),d=l(o[2],s[2]);return[u,c,d]}return void 0}var l=this;l.styleEnabled()&&t&&i()}})}(cytoscape,\"undefined\"==typeof window?null:window),function(e){\"use strict\";e.fn.core({data:e.define.data({field:\"data\",bindingEvent:\"data\",allowBinding:!0,allowSetting:!0,settingEvent:\"data\",settingTriggersEvent:!0,triggerFnName:\"trigger\",allowGetting:!0}),removeData:e.define.removeData({field:\"data\",event:\"data\",triggerFnName:\"trigger\",triggerEvent:!0}),scratch:e.define.data({field:\"scratch\",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeScratch:e.define.removeData({field:\"scratch\",triggerEvent:!1})})}(cytoscape),function(e){\"use strict\";e.fn.core({on:e.define.on(),one:e.define.on({unbindSelfOnTrigger:!0}),once:e.define.on({unbindAllBindersOnTrigger:!0}),off:e.define.off(),trigger:e.define.trigger()}),e.corefn.bind=e.corefn.on,e.corefn.unbind=e.corefn.off}(cytoscape),function(e){\"use strict\";e.fn.core({png:function(e){var t=this._private.renderer;return e=e||{},t.png(e)}})}(cytoscape),function(e){\"use strict\";e.fn.core({layout:function(e){var t=this._private.prevLayout=null==e?this._private.prevLayout:this.initLayout(e);return t.run(),this},makeLayout:function(e){return this.initLayout(e)},initLayout:function(t){if(null==t)return void e.util.error(\"Layout options must be specified to make a layout\");if(null==t.name)return void e.util.error(\"A `name` must be specified to make a layout\");var i=t.name,r=e.extension(\"layout\",i);if(null==r)return void e.util.error(\"Can not apply layout: No such layout `\"+i+\"` found; did you include its JS file?\");t.eles=null!=t.eles?t.eles:this.$(),e.is.string(t.eles)&&(t.eles=this.$(t.eles));var n=new r(e.util.extend({},t,{cy:this}));return e.is.plainObject(n._private)||(n._private={}),n._private.cy=this,n._private.listeners=[],n}})}(cytoscape),function(e){\"use strict\";e.fn.core({notify:function(e){if(this._private.batchingNotify){var t=this._private.batchNotifyEles,i=this._private.batchNotifyTypes;if(e.collection)for(var r=0;r<e.collection.length;r++){var n=e.collection[r];t.ids[n._private.id]||t.push(n)}return void(i.ids[e.type]||i.push(e.type))}if(this._private.notificationsEnabled){var a=this.renderer();a.notify(e)}},notifications:function(e){var t=this._private;return void 0===e?t.notificationsEnabled:void(t.notificationsEnabled=e?!0:!1)},noNotifications:function(e){this.notifications(!1),e(),this.notifications(!0)},startBatch:function(){var e=this._private;return e.batchingStyle=e.batchingNotify=!0,e.batchStyleEles=[],e.batchNotifyEles=[],e.batchNotifyTypes=[],e.batchStyleEles.ids={},e.batchNotifyEles.ids={},e.batchNotifyTypes.ids={},this},endBatch:function(){var t=this._private;return t.batchingStyle=!1,new e.Collection(this,t.batchStyleEles).updateStyle(),t.batchingNotify=!1,this.notify({type:t.batchNotifyTypes,collection:t.batchNotifyEles}),this},batch:function(e){return this.startBatch(),e(),this.endBatch(),this},batchData:function(e){var t=this;return this.batch(function(){for(var i in e){var r=e[i],n=t.getElementById(i);n.data(r)}})}})}(cytoscape),function(e){\"use strict\";e.fn.core({renderTo:function(e,t,i,r){var n=this._private.renderer;return n.renderTo(e,t,i,r),this},renderer:function(){return this._private.renderer},forceRender:function(){return this.notify({type:\"draw\"}),this},resize:function(){return this.notify({type:\"resize\"}),this.trigger(\"resize\"),this},initRenderer:function(t){var i=this,r=e.extension(\"renderer\",t.name);return null==r?void e.util.error(\"Can not initialise: No such renderer `%s` found; did you include its JS file?\",t.name):void(this._private.renderer=new r(e.util.extend({},t,{cy:i,style:i._private.style})))}})}(cytoscape),function(e){\"use strict\";e.fn.core({collection:function(t){return e.is.string(t)?this.$(t):e.is.elementOrCollection(t)?t.collection():e.is.array(t)?new e.Collection(this,t):new e.Collection(this)},nodes:function(e){var t=this.$(function(){return this.isNode()});return e?t.filter(e):t},edges:function(e){var t=this.$(function(){return this.isEdge()});return e?t.filter(e):t},$:function(t){var i=new e.Collection(this,this._private.elements);return t?i.filter(t):i}}),e.corefn.elements=e.corefn.filter=e.corefn.$}(cytoscape),function(e){\"use strict\";e.fn.core({style:function(e){if(e){var t=this.setStyle(e);t.update()}return this._private.style},setStyle:function(t){var i=this._private;return i.style=e.is.stylesheet(t)?t.generateStyle(this):e.is.array(t)?e.style.fromJson(this,t):e.is.string(t)?e.style.fromString(this,t):new e.Style(this),i.style}})}(cytoscape),function(e){\"use strict\";e.fn.core({autolock:function(e){return void 0===e?this._private.autolock:(this._private.autolock=e?!0:!1,this)},autoungrabify:function(e){return void 0===e?this._private.autoungrabify:(this._private.autoungrabify=e?!0:!1,this)},autounselectify:function(e){return void 0===e?this._private.autounselectify:(this._private.autounselectify=e?!0:!1,this)},panningEnabled:function(e){return void 0===e?this._private.panningEnabled:(this._private.panningEnabled=e?!0:!1,this)},userPanningEnabled:function(e){return void 0===e?this._private.userPanningEnabled:(this._private.userPanningEnabled=e?!0:!1,this)},zoomingEnabled:function(e){return void 0===e?this._private.zoomingEnabled:(this._private.zoomingEnabled=e?!0:!1,this)},userZoomingEnabled:function(e){return void 0===e?this._private.userZoomingEnabled:(this._private.userZoomingEnabled=e?!0:!1,this)},boxSelectionEnabled:function(e){return void 0===e?this._private.boxSelectionEnabled:(this._private.boxSelectionEnabled=e?!0:!1,this)},pan:function(){var t,i,r,n,a,o=arguments,s=this._private.pan;switch(o.length){case 0:return s;case 1:if(e.is.string(o[0]))return t=o[0],s[t];if(e.is.plainObject(o[0])){if(!this._private.panningEnabled)return this;r=o[0],n=r.x,a=r.y,e.is.number(n)&&(s.x=n),e.is.number(a)&&(s.y=a),this.trigger(\"pan viewport\")}break;case 2:if(!this._private.panningEnabled)return this;t=o[0],i=o[1],\"x\"!==t&&\"y\"!==t||!e.is.number(i)||(s[t]=i),this.trigger(\"pan viewport\")}return this.notify({type:\"viewport\"}),this},panBy:function(){var t,i,r,n,a,o=arguments,s=this._private.pan;if(!this._private.panningEnabled)return this;switch(o.length){case 1:e.is.plainObject(o[0])&&(r=o[0],n=r.x,a=r.y,e.is.number(n)&&(s.x+=n),e.is.number(a)&&(s.y+=a),this.trigger(\"pan viewport\"));break;case 2:t=o[0],i=o[1],\"x\"!==t&&\"y\"!==t||!e.is.number(i)||(s[t]+=i),this.trigger(\"pan viewport\")}return this.notify({type:\"viewport\"}),this},fit:function(e,t){var i=this.getFitViewport(e,t);if(i){var r=this._private;r.zoom=i.zoom,r.pan=i.pan,this.trigger(\"pan zoom viewport\"),this.notify({type:\"viewport\"})}return this},getFitViewport:function(t,i){if(e.is.number(t)&&void 0===i&&(i=t,t=void 0),this._private.panningEnabled&&this._private.zoomingEnabled){var r;if(e.is.string(t)){var n=t;t=this.$(n)}else if(e.is.boundingBox(t)){var a=t;r={x1:a.x1,y1:a.y1,x2:a.x2,y2:a.y2},r.w=r.x2-r.x1,r.h=r.y2-r.y1}else e.is.elementOrCollection(t)||(t=this.elements());r=r||t.boundingBox();var o,s=this.width(),l=this.height();if(i=e.is.number(i)?i:0,!isNaN(s)&&!isNaN(l)&&s>0&&l>0&&!isNaN(r.w)&&!isNaN(r.h)&&r.w>0&&r.h>0){o=Math.min((s-2*i)/r.w,(l-2*i)/r.h),o=o>this._private.maxZoom?this._private.maxZoom:o,o=o<this._private.minZoom?this._private.minZoom:o;var u={x:(s-o*(r.x1+r.x2))/2,y:(l-o*(r.y1+r.y2))/2};return{zoom:o,pan:u}}}},minZoom:function(t){return void 0===t?this._private.minZoom:(e.is.number(t)&&(this._private.minZoom=t),this)},maxZoom:function(t){return void 0===t?this._private.maxZoom:(e.is.number(t)&&(this._private.maxZoom=t),this)},zoom:function(t){var i,r;if(void 0===t)return this._private.zoom;if(e.is.number(t))r=t;else if(e.is.plainObject(t)){if(r=t.level,t.position){var n=t.position,a=this._private.pan,o=this._private.zoom;i={x:n.x*o+a.x,y:n.y*o+a.y}}else t.renderedPosition&&(i=t.renderedPosition);if(i&&!this._private.panningEnabled)return this}if(!this._private.zoomingEnabled)return this;if(!e.is.number(r)||i&&(!e.is.number(i.x)||!e.is.number(i.y)))return this;if(r=r>this._private.maxZoom?this._private.maxZoom:r,r=r<this._private.minZoom?this._private.minZoom:r,i){var s=this._private.pan,l=this._private.zoom,u=r,c={x:-u/l*(i.x-s.x)+i.x,y:-u/l*(i.y-s.y)+i.y};this._private.zoom=r,this._private.pan=c;var d=s.x!==c.x||s.y!==c.y;this.trigger(\" zoom \"+(d?\" pan \":\"\")+\" viewport \")}else this._private.zoom=r,this.trigger(\"zoom viewport\");return this.notify({type:\"viewport\"}),this},viewport:function(t){var i=this._private,r=!0,n=!0,a=[],o=!1,s=!1;if(!t)return this;if(e.is.number(t.zoom)||(r=!1),e.is.plainObject(t.pan)||(n=!1),!r&&!n)return this;if(r){var l=t.zoom;l<i.minZoom||l>i.maxZoom||!i.zoomingEnabled?o=!0:(i.zoom=l,a.push(\"zoom\"))}if(n&&(!o||!t.cancelOnFailedZoom)&&i.panningEnabled){var u=t.pan;e.is.number(u.x)&&(i.pan.x=u.x,s=!1),e.is.number(u.y)&&(i.pan.y=u.y,s=!1),s||a.push(\"pan\")}return a.length>0&&(a.push(\"viewport\"),this.trigger(a.join(\" \")),this.notify({type:\"viewport\"})),this},center:function(e){var t=this.getCenterPan(e);return t&&(this._private.pan=t,this.trigger(\"pan viewport\"),this.notify({type:\"viewport\"})),this},getCenterPan:function(t,i){if(this._private.panningEnabled){if(e.is.string(t)){var r=t;t=this.elements(r)}else e.is.elementOrCollection(t)||(t=this.elements());var n=t.boundingBox(),a=this.width(),o=this.height();i=void 0===i?this._private.zoom:i;var s={x:(a-i*(n.x1+n.x2))/2,y:(o-i*(n.y1+n.y2))/2};return s}},reset:function(){return this._private.panningEnabled&&this._private.zoomingEnabled?(this.viewport({pan:{x:0,y:0},zoom:1}),this):this},width:function(){var e=this._private.container;return e?e.clientWidth:1},height:function(){var e=this._private.container;return e?e.clientHeight:1},extent:function(){var e=this._private.pan,t=this._private.zoom,i=this.renderedExtent(),r={x1:(i.x1-e.x)/t,x2:(i.x2-e.x)/t,y1:(i.y1-e.y)/t,y2:(i.y2-e.y)/t};return r.w=r.x2-r.x1,r.h=r.y2-r.y1,r},renderedExtent:function(){var e=this.width(),t=this.height();return{x1:0,y1:0,x2:e,y2:t,w:e,h:t}}}),e.corefn.centre=e.corefn.center,e.corefn.autolockNodes=e.corefn.autolock,e.corefn.autoungrabifyNodes=e.corefn.autoungrabify}(cytoscape),function(e){\"use strict\";e.fn.collection=e.fn.eles=function(t){for(var i in t){var r=t[i];e.Collection.prototype[i]=r}};var t={prefix:{nodes:\"n\",edges:\"e\"},id:{nodes:0,edges:0},generate:function(t,i,r){var n=e.is.element(i)?i._private:i,a=n.group,o=null!=r?r:this.prefix[a]+this.id[a];if(t.getElementById(o).empty())this.id[a]++;else for(;!t.getElementById(o).empty();)o=this.prefix[a]+ ++this.id[a];return o}};e.Element=function(t,i,r){if(!(this instanceof e.Element))return new e.Element(t,i,r);var n=this;if(r=void 0===r||r?!0:!1,void 0===t||void 0===i||!e.is.core(t))return void e.util.error(\"An element must have a core reference and parameters set\");if(\"nodes\"!==i.group&&\"edges\"!==i.group)return void e.util.error(\"An element must be of type `nodes` or `edges`; you specified `\"+i.group+\"`\");if(this.length=1,this[0]=this,this._private={cy:t,single:!0,data:i.data||{},layoutData:{},position:i.position||{},autoWidth:void 0,autoHeight:void 0,listeners:[],group:i.group,style:{},rstyle:{},styleCxts:[],removed:!0,selected:i.selected?!0:!1,selectable:void 0===i.selectable?!0:i.selectable?!0:!1,locked:i.locked?!0:!1,grabbed:!1,grabbable:void 0===i.grabbable?!0:i.grabbable?!0:!1,active:!1,classes:{},animation:{current:[],queue:[]},rscratch:{},scratch:{},edges:[],children:[]},i.renderedPosition){var a=i.renderedPosition,o=t.pan(),s=t.zoom();this._private.position={x:(a.x-o.x)/s,y:(a.y-o.y)/s}}if(e.is.string(i.classes))for(var l=i.classes.split(/\\s+/),u=0,c=l.length;c>u;u++){var d=l[u];d&&\"\"!==d&&(n._private.classes[d]=!0)}i.css&&t.style().applyBypass(this,i.css),(void 0===r||r)&&this.restore()},e.Collection=function(i,r,n){if(!(this instanceof e.Collection))return new e.Collection(i,r);if(void 0===i||!e.is.core(i))return void e.util.error(\"A collection must have a reference to the core\");var a={},o={},s=!1;if(r){if(r.length>0&&e.is.plainObject(r[0])&&!e.is.element(r[0])){s=!0;for(var l=[],u={},c=0,d=r.length;d>c;c++){var p=r[c];null==p.data&&(p.data={});var h=p.data;if(null==h.id)h.id=t.generate(i,p);else if(0!==i.getElementById(h.id).length||u[h.id])continue;var v=new e.Element(i,p,!1);l.push(v),u[h.id]=!0}r=l}}else r=[];this.length=0;for(var c=0,d=r.length;d>c;c++){var g=r[c];if(g){var f=g._private.data.id;(!n||n.unique&&!a[f])&&(a[f]=g,o[f]=this.length,this[this.length]=g,this.length++)}}this._private={cy:i,ids:a,indexes:o},s&&this.restore()},e.elefn=e.elesfn=e.Element.prototype=e.Collection.prototype,e.elesfn.cy=function(){return this._private.cy},e.elesfn.element=function(){return this[0]},e.elesfn.collection=function(){return e.is.collection(this)?this:new e.Collection(this._private.cy,[this])},e.elesfn.unique=function(){return new e.Collection(this._private.cy,this,{unique:!0})},e.elesfn.getElementById=function(t){var i=this._private.cy,r=this._private.ids[t];return r?r:e.Collection(i)},e.elesfn.json=function(){var t=this.element();if(null==t)return void 0;var i=t._private,r=e.util.copy({data:i.data,position:i.position,group:i.group,bypass:i.bypass,removed:i.removed,selected:i.selected,selectable:i.selectable,locked:i.locked,grabbed:i.grabbed,grabbable:i.grabbable,classes:\"\"}),n=[];for(var a in i.classes)i.classes[a]&&n.push(a);for(var o=0;o<n.length;o++){var a=n[o];r.classes+=a+(o<n.length-1?\" \":\"\")}return r},e.elesfn.jsons=function(){for(var e=[],t=0;t<this.length;t++){var i=this[t],r=i.json();e.push(r)}return e},e.elesfn.clone=function(){for(var t=this.cy(),i=[],r=0;r<this.length;r++){var n=this[r],a=n.json(),o=new e.Element(t,a,!1);i.push(o)}return new e.Collection(t,i)},e.elesfn.restore=function(i){var r=this,n=[],a=r.cy();void 0===i&&(i=!0);for(var o=[],s=[],l=[],u=0,c=0,d=0,p=r.length;p>d;d++){var h=r[d];h.isNode()?(s.push(h),u++):(l.push(h),c++)}o=s.concat(l);for(var d=0,p=o.length;p>d;d++){var h=o[d];if(h.removed()){var v=h._private,g=v.data;if(void 0===g.id)g.id=t.generate(a,h);else{if(e.is.emptyString(g.id)||!e.is.string(g.id)){e.util.error(\"Can not create element with invalid string ID `\"+g.id+\"`\");continue}if(0!==a.getElementById(g.id).length){e.util.error(\"Can not create second element with ID `\"+g.id+\"`\");continue}}var f=g.id;if(h.isEdge()){for(var y=h,m=[\"source\",\"target\"],x=m.length,b=!1,w=0;x>w;w++){var _=m[w],E=g[_];null==E||\"\"===E?(e.util.error(\"Can not create edge `\"+f+\"` with unspecified \"+_),b=!0):a.getElementById(E).empty()&&(e.util.error(\"Can not create edge `\"+f+\"` with nonexistant \"+_+\" `\"+E+\"`\"),b=!0)}if(b)continue;var S=a.getElementById(g.source),P=a.getElementById(g.target);S._private.edges.push(y),P._private.edges.push(y),y._private.source=S,y._private.target=P}v.ids={},v.ids[f]=h,v.removed=!1,a.addToPool(h),n.push(h)}}for(var d=0;u>d;d++){var D=o[d],g=D._private.data,k=D._private.data.parent,C=null!=k;if(C){var T=a.getElementById(k);if(T.empty())g.parent=void 0;else{for(var N=!1,M=T;!M.empty();){if(D.same(M)){N=!0,g.parent=void 0;break}M=M.parent()}N||(T[0]._private.children.push(D),D._private.parent=T[0],a._private.hasCompoundNodes=!0)}}}if(n=new e.Collection(a,n),n.length>0){var B=n.add(n.connectedNodes()).add(n.parent());B.updateStyle(i),i?n.rtrigger(\"add\"):n.trigger(\"add\")}return r},e.elesfn.removed=function(){var e=this[0];return e&&e._private.removed},e.elesfn.inside=function(){var e=this[0];return e&&!e._private.removed},e.elesfn.remove=function(t){function i(e){for(var t=e._private.edges,i=0;i<t.length;i++)n(t[i])}function r(e){for(var t=e._private.children,i=0;i<t.length;i++)n(t[i])}function n(e){var t=c[e.id()];t||(c[e.id()]=!0,e.isNode()?(u.push(e),i(e),r(e)):u.unshift(e))}function a(e,t){for(var i=e._private.edges,r=0;r<i.length;r++){var n=i[r];if(t===n){i.splice(r,1);break}}}function o(e,t){t=t[0],e=e[0];for(var i=e._private.children,r=0;r<i.length;r++)if(i[r][0]===t[0]){i.splice(r,1);break}}var s=this,l=[],u=[],c={},d=s._private.cy;void 0===t&&(t=!0);for(var p=0,h=s.length;h>p;p++){var v=s[p];n(v)}for(var p=0;p<u.length;p++){var v=u[p];if(v._private.removed=!0,d.removeFromPool(v),l.push(v),v.isEdge()){var g=v.source()[0],f=v.target()[0];a(g,v),a(f,v)}else{var y=v.parent();0!==y.length&&o(y,v)}}var m=d._private.elements;d._private.hasCompoundNodes=!1;for(var p=0;p<m.length;p++){var v=m[p];if(v.isParent()){d._private.hasCompoundNodes=!0;break}}var x=new e.Collection(this.cy(),l);x.size()>0&&(t&&this.cy().notify({type:\"remove\",collection:x}),x.trigger(\"remove\"));for(var b={},p=0;p<u.length;p++){var v=u[p],w=\"nodes\"===v._private.group,_=v._private.data.parent;if(w&&void 0!==_&&!b[_]){b[_]=!0;var y=d.getElementById(_);y&&0!==y.length&&!y._private.removed&&0===y.children().length&&y.updateStyle()}}return this},e.elesfn.move=function(e){var t=this._private.cy;if(void 0!==e.source||void 0!==e.target){var i=e.source,r=e.target,n=t.getElementById(i).length>0,a=t.getElementById(r).length>0;if(n||a){var o=this.jsons();this.remove();for(var s=0;s<o.length;s++){var l=o[s];\"edges\"===l.group&&(n&&(l.data.source=i),a&&(l.data.target=r))}return t.add(o)}}else if(void 0!==e.parent){var u=e.parent,c=null===u||t.getElementById(u).length>0;if(c){var o=this.jsons(),d=this.descendants(),p=d.merge(d.add(this).connectedEdges());this.remove();for(var s=0;s<this.length;s++){var l=o[s];\"nodes\"===l.group&&(l.data.parent=null===u?void 0:u)}}return t.add(o).merge(p.restore())}return this}}(cytoscape),function(e){\"use strict\";e.fn.eles({stdBreadthFirstSearch:function(t){return t=e.util.extend({},t,{std:!0}),this.breadthFirstSearch(t)},breadthFirstSearch:function(t,i,r){var n,a,o;e.is.plainObject(t)&&!e.is.elementOrCollection(t)&&(n=t,t=n.roots,i=n.visit,r=n.directed,a=n.std,o=n.thisArg),r=2!==arguments.length||e.is.fn(i)?r:i,i=e.is.fn(i)?i:function(){};for(var s,l=this._private.cy,u=e.is.string(t)?this.filter(t):t,c=[],d=[],p={},h={},v={},g=0,f=this.nodes(),y=this.edges(),m=0;m<u.length;m++)u[m].isNode()&&(c.unshift(u[m]),v[u[m].id()]=!0,d.push(u[m]),h[u[m].id()]=0);for(;0!==c.length;){var x,u=c.shift(),b=h[u.id()],w=p[u.id()],_=null==w?void 0:w.connectedNodes().not(u)[0];if(x=a?i.call(o,u,w,_,g++,b):i.call(u,g++,b,u,w,_),x===!0){s=u;break}if(x===!1)break;for(var E=u.connectedEdges(r?function(){return this.data(\"source\")===u.id()}:void 0).intersect(y),m=0;m<E.length;m++){var S=E[m],P=S.connectedNodes(function(){return this.id()!==u.id()}).intersect(f);0===P.length||v[P.id()]||(P=P[0],c.push(P),v[P.id()]=!0,h[P.id()]=h[u.id()]+1,d.push(P),p[P.id()]=S)}}for(var D=[],m=0;m<d.length;m++){var k=d[m],C=p[k.id()];C&&D.push(C),D.push(k)}return{path:new e.Collection(l,D,{unique:!0}),found:new e.Collection(l,s,{unique:!0})}\n},stdDepthFirstSearch:function(t){return t=e.util.extend({},t,{std:!0}),this.depthFirstSearch(t)},depthFirstSearch:function(t,i,r){var n,a,o;e.is.plainObject(t)&&!e.is.elementOrCollection(t)&&(n=t,t=n.roots,i=n.visit,r=n.directed,a=n.std,o=n.thisArg),r=2!==arguments.length||e.is.fn(i)?r:i,i=e.is.fn(i)?i:function(){};for(var s,l=this._private.cy,u=e.is.string(t)?this.filter(t):t,c=[],d=[],p={},h={},v={},g=0,f=this.edges(),y=this.nodes(),m=0;m<u.length;m++)u[m].isNode()&&(c.push(u[m]),d.push(u[m]),h[u[m].id()]=0);for(;0!==c.length;){var u=c.pop();if(!v[u.id()]){v[u.id()]=!0;var x,b=h[u.id()],w=p[u.id()],_=null==w?void 0:w.connectedNodes().not(u)[0];if(x=a?i.call(o,u,w,_,g++,b):i.call(u,g++,b,u,w,_),x===!0){s=u;break}if(x===!1)break;for(var E=u.connectedEdges(r?function(){return this.data(\"source\")===u.id()}:void 0).intersect(f),m=0;m<E.length;m++){var S=E[m],P=S.connectedNodes(function(){return this.id()!==u.id()}).intersect(y);0===P.length||v[P.id()]||(P=P[0],c.push(P),h[P.id()]=h[u.id()]+1,d.push(P),p[P.id()]=S)}}}for(var D=[],m=0;m<d.length;m++){var k=d[m],C=p[k.id()];C&&D.push(C),D.push(k)}return{path:new e.Collection(l,D,{unique:!0}),found:new e.Collection(l,s,{unique:!0})}},kruskal:function(t){function i(e){for(var t=0;t<n.length;t++){var i=n[t];if(i.anySame(e))return{eles:i,index:t}}}t=e.is.fn(t)?t:function(){return 1};for(var r=new e.Collection(this._private.cy,[]),n=[],a=this.nodes(),o=0;o<a.length;o++)n.push(a[o].collection());for(var s=this.edges(),l=s.toArray().sort(function(e,i){var r=t.call(e,e),n=t.call(i,i);return r-n}),o=0;o<l.length;o++){var u=l[o],c=u.source()[0],d=u.target()[0],p=i(c),h=i(d);p.index!==h.index&&(r=r.add(u),n[p.index]=p.eles.add(h.eles),n.splice(h.index,1))}return a.add(r)},dijkstra:function(t,i,r){var n;e.is.plainObject(t)&&!e.is.elementOrCollection(t)&&(n=t,t=n.root,i=n.weight,r=n.directed);var a=this._private.cy;r=e.is.fn(i)?r:i,i=e.is.fn(i)?i:function(){return 1};for(var o=e.is.string(t)?this.filter(t).eq(0):t.eq(0),s={},l={},u={},c=this.edges().filter(function(){return!this.isLoop()}),d=this.nodes(),p=[],h=0;h<d.length;h++)s[d[h].id()]=d[h].same(o)?0:1/0,p.push(d[h]);var v=function(e){return s[e.id()]};p=new e.Collection(a,p);for(var g=e.Minheap(a,p,v),f=function(e,t){for(var n,a=(r?e.edgesTo(t):e.edgesWith(t)).intersect(c),o=1/0,s=0;s<a.length;s++){var l=a[s],u=i.apply(l,[l]);(o>u||!n)&&(o=u,n=l)}return{edge:n,dist:o}};g.size()>0;){var y=g.pop(),m=y.value,x=y.id,b=a.getElementById(x);if(u[x]=m,m===Math.Infinite)break;for(var w=b.neighborhood().intersect(d),h=0;h<w.length;h++){var _=w[h],E=_.id(),S=f(b,_),P=m+S.dist;P<g.getValueById(E)&&(g.edit(E,P),l[E]={node:b,edge:S.edge})}}return{distanceTo:function(t){var i=e.is.string(t)?d.filter(t).eq(0):t.eq(0);return u[i.id()]},pathTo:function(t){var i=e.is.string(t)?d.filter(t).eq(0):t.eq(0),r=[],n=i;if(i.length>0)for(r.unshift(i);l[n.id()];){var o=l[n.id()];r.unshift(o.edge),r.unshift(o.node),n=o.node}return new e.Collection(a,r)}}}}),e.elesfn.bfs=e.elesfn.breadthFirstSearch,e.elesfn.dfs=e.elesfn.depthFirstSearch,e.elesfn.stdBfs=e.elesfn.stdBreadthFirstSearch,e.elesfn.stdDfs=e.elesfn.stdDepthFirstSearch}(cytoscape),function(e){\"use strict\";e.fn.eles({aStar:function(t){t=t||{};var i=function(){a&&console.log.apply(console,arguments)},r=function(e,t,i,n){if(e==t)return n.push(o.getElementById(t)),n;if(t in i){var a=i[t],s=g[t];return n.push(o.getElementById(t)),n.push(o.getElementById(s)),r(e,a,i,n)}return void 0},n=function(e,t){if(0===e.length)return void 0;for(var i=0,r=t[e[0]],n=1;n<e.length;n++){var a=t[e[n]];r>a&&(r=a,i=n)}return i};if(null!=t.debug)var a=t.debug;else var a=!1;i(\"Starting aStar...\");var o=this._private.cy;if(null==t||null==t.root)return void 0;var s=e.is.string(t.root)?this.filter(t.root)[0]:t.root[0];if(i(\"Source node: %s\",s.id()),null==t.goal)return void 0;var l=e.is.string(t.goal)?this.filter(t.goal)[0]:t.goal[0];if(i(\"Target node: %s\",l.id()),null!=t.heuristic&&e.is.fn(t.heuristic))var u=t.heuristic;else var u=function(){return 0};if(null!=t.weight&&e.is.fn(t.weight))var c=t.weight;else var c=function(){return 1};if(null!=t.directed)var d=t.directed;else var d=!1;var p=[],h=[s.id()],v={},g={},f={},y={};f[s.id()]=0,y[s.id()]=u(s);for(var m=this.edges().not(\":loop\"),x=this.nodes(),b=0;h.length>0;){var w=n(h,y),_=this.filter(\"#\"+h[w])[0];if(b++,i(\"\\nStep: %s\",b),i(\"Processing node: %s, fScore = %s\",_.id(),y[_.id()]),_.id()==l.id()){i(\"Found goal node!\");var E=r(s.id(),l.id(),v,[]);return E.reverse(),i(\"Path: %s\",E),{found:!0,distance:f[_.id()],path:new e.Collection(o,E),steps:b}}p.push(_.id()),h.splice(w,1),i(\"Added node to closedSet, removed from openSet.\"),i(\"Processing neighbors...\");for(var S=_.connectedEdges(d?'[source = \"'+_.id()+'\"]':void 0).intersect(m),P=0;P<S.length;P++){var D=S[P],k=D.connectedNodes('[id != \"'+_.id()+'\"]').intersect(x);if(i(\"   processing neighbor: %s\",k.id()),-1==p.indexOf(k.id())){var C=f[_.id()]+c.apply(D,[D]);i(\"   tentative gScore: %d\",C),-1!=h.indexOf(k.id())?C<f[k.id()]&&(f[k.id()]=C,y[k.id()]=C+u(k),v[k.id()]=_.id(),i(\"   better score, replacing gScore. \"),i(\"   fScore(%s) = %s\",k.id(),C)):(f[k.id()]=C,y[k.id()]=C+u(k),h.push(k.id()),v[k.id()]=_.id(),g[k.id()]=D.id(),i(\"   not in openSet, adding it. \"),i(\"   fScore(%s) = %s\",k.id(),C))}else i(\"   already in closedSet, ignoring it.\")}}return i(\"Reached end of computation without finding our goal\"),{found:!1,distance:void 0,path:void 0,steps:b}},floydWarshall:function(t){t=t||{};var i=function(){r&&console.log.apply(console,arguments)};if(null!=t.debug)var r=t.debug;else var r=!1;i(\"Starting floydWarshall...\");var n=this._private.cy;if(null!=t.weight&&e.is.fn(t.weight))var a=t.weight;else var a=function(){return 1};if(null!=t.directed)var o=t.directed;else var o=!1;for(var s=this.edges().not(\":loop\"),l=this.nodes(),u=l.length,c={},d=0;u>d;d++)c[l[d].id()]=d;for(var p=[],d=0;u>d;d++){for(var h=new Array(u),v=0;u>v;v++)h[v]=d==v?0:1/0;p.push(h)}var g=[],f=[],y=function(e){for(var t=0;u>t;t++){for(var i=new Array(u),r=0;u>r;r++)i[r]=void 0;e.push(i)}};y(g),y(f);for(var d=0;d<s.length;d++){var m=c[s[d].source().id()],x=c[s[d].target().id()],b=a.apply(s[d],[s[d]]);p[m][x]>b&&(p[m][x]=b,g[m][x]=x,f[m][x]=s[d])}if(!o)for(var d=0;d<s.length;d++){var m=c[s[d].target().id()],x=c[s[d].source().id()],b=a.apply(s[d],[s[d]]);p[m][x]>b&&(p[m][x]=b,g[m][x]=x,f[m][x]=s[d])}for(var w=0;u>w;w++)for(var d=0;u>d;d++)for(var v=0;u>v;v++)p[d][w]+p[w][v]<p[d][v]&&(p[d][v]=p[d][w]+p[w][v],g[d][v]=g[d][w]);for(var _=[],d=0;u>d;d++)_.push(l[d].id());var E={distance:function(t,i){if(e.is.string(t))var r=n.filter(t)[0].id();else var r=t.id();if(e.is.string(i))var a=n.filter(i)[0].id();else var a=i.id();return p[c[r]][c[a]]},path:function(t,i){var r=function(e,t,i,r,a){if(e===t)return n.getElementById(r[e]);if(void 0===i[e][t])return void 0;for(var o=[n.getElementById(r[e])],s=e;e!==t;){s=e,e=i[e][t];var l=a[s][e];o.push(l),o.push(n.getElementById(r[e]))}return o};if(e.is.string(t))var a=n.filter(t)[0].id();else var a=t.id();if(e.is.string(i))var o=n.filter(i)[0].id();else var o=i.id();var s=r(c[a],c[o],g,_,f);return new e.Collection(n,s)}};return E},bellmanFord:function(t){t=t||{};var i=function(){r&&console.log.apply(console,arguments)};if(null!=t.debug)var r=t.debug;else var r=!1;if(i(\"Starting bellmanFord...\"),null!=t.weight&&e.is.fn(t.weight))var n=t.weight;else var n=function(){return 1};if(null!=t.directed)var a=t.directed;else var a=!1;if(null==t.root)return void e.util.error(\"options.root required\");if(e.is.string(t.root))var o=this.filter(t.root)[0];else var o=t.root[0];i(\"Source node: %s\",o.id());for(var s=this._private.cy,l=this.edges().not(\":loop\"),u=this.nodes(),c=u.length,d={},p=0;c>p;p++)d[u[p].id()]=p;for(var h=[],v=[],g=[],p=0;c>p;p++)h[p]=u[p].id()===o.id()?0:1/0,v[p]=void 0;for(var f=!1,p=1;c>p;p++){f=!1;for(var y=0;y<l.length;y++){var m=d[l[y].source().id()],x=d[l[y].target().id()],b=n.apply(l[y],[l[y]]),w=h[m]+b;if(w<h[x]&&(h[x]=w,v[x]=m,g[x]=l[y],f=!0),!a){var w=h[x]+b;w<h[m]&&(h[m]=w,v[m]=x,g[m]=l[y],f=!0)}}if(!f)break}if(f)for(var y=0;y<l.length;y++){var m=d[l[y].source().id()],x=d[l[y].target().id()],b=n.apply(l[y],[l[y]]);if(h[m]+b<h[x])return e.util.error(\"Error: graph contains a negative weigth cycle!\"),{pathTo:void 0,distanceTo:void 0,hasNegativeWeightCycle:!0}}for(var _=[],p=0;c>p;p++)_.push(u[p].id());var E={distanceTo:function(t){if(e.is.string(t))var i=s.filter(t)[0].id();else var i=t.id();return h[d[i]]},pathTo:function(t){var i=function(e,t,i,r,n,a){for(;;){if(n.push(s.getElementById(r[i])),n.push(a[i]),t===i)return n;var o=e[i];if(\"undefined\"==typeof o)return void 0;i=o}};if(e.is.string(t))var r=s.filter(t)[0].id();else var r=t.id();var n=[],a=i(v,d[o.id()],d[r],_,n,g);return null!=a&&a.reverse(),new e.Collection(s,a)},hasNegativeWeightCycle:!1};return E},kargerStein:function(t){t=t||{};var i=function(){a&&console.log.apply(console,arguments)},r=function(e,t,i){for(var r=i[e],n=r[1],a=r[2],o=t[n],s=t[a],l=i.filter(function(e){return t[e[1]]===o&&t[e[2]]===s?!1:t[e[1]]===s&&t[e[2]]===o?!1:!0}),u=0;u<l.length;u++){var c=l[u];c[1]===s?(l[u]=c.slice(0),l[u][1]=o):c[2]===s&&(l[u]=c.slice(0),l[u][2]=o)}for(var u=0;u<t.length;u++)t[u]===s&&(t[u]=o);return l},n=function(e,t,i,a){if(a>=i)return t;var o=Math.floor(Math.random()*t.length),s=r(o,e,t);return n(e,s,i-1,a)};if(null!=t&&null!=t.debug)var a=t.debug;else var a=!1;i(\"Starting kargerStein...\");var o=this._private.cy,s=this.edges().not(\":loop\"),l=this.nodes(),u=l.length,c=s.length,d=Math.ceil(Math.pow(Math.log(u)/Math.LN2,2)),p=Math.floor(u/Math.sqrt(2));if(2>u)return void e.util.error(\"At least 2 nodes are required for KargerSteing algorithm!\");for(var h={},v=0;u>v;v++)h[l[v].id()]=v;for(var g=[],v=0;c>v;v++){var f=s[v];g.push([v,h[f.source().id()],h[f.target().id()]])}for(var y,m=1/0,x=[],v=0;u>v;v++)x.push(v);for(var b=0;d>=b;b++){var w=x.slice(0),_=n(w,g,u,p),E=w.slice(0),S=n(w,_,p,2),P=n(E,_,p,2);S.length<=P.length&&S.length<m?(m=S.length,y=[S,w]):P.length<=S.length&&P.length<m&&(m=P.length,y=[P,E])}for(var D=y[0].map(function(e){return s[e[0]]}),k=[],C=[],T=y[1][0],v=0;v<y[1].length;v++){var N=y[1][v];N===T?k.push(l[v]):C.push(l[v])}var M={cut:new e.Collection(o,D),partition1:new e.Collection(o,k),partition2:new e.Collection(o,C)};return M},pageRank:function(t){t=t||{};var i=function(e){for(var t=e.length,i=0,r=0;t>r;r++)i+=e[r];for(var r=0;t>r;r++)e[r]=e[r]/i},r=function(){n&&console.log.apply(console,arguments)};if(null!=t&&null!=t.debug)var n=t.debug;else var n=!1;if(r(\"Starting pageRank...\"),null!=t&&null!=t.dampingfactor)var a=t.dampingFactor;else var a=.8;if(null!=t&&null!=t.precision)var o=t.precision;else var o=1e-6;if(null!=t&&null!=t.iterations)var s=t.iterations;else var s=200;if(null!=t&&null!=t.weight&&e.is.fn(t.weight))var l=t.weight;else var l=function(){return 1};for(var u=this._private.cy,c=this.edges().not(\":loop\"),d=this.nodes(),p=d.length,h=c.length,v={},g=0;p>g;g++)v[d[g].id()]=g;for(var f=[],y=[],m=(1-a)/p,g=0;p>g;g++){for(var x=[],b=0;p>b;b++)x.push(0);f.push(x),y.push(0)}for(var g=0;h>g;g++){var w=c[g],_=v[w.source().id()],E=v[w.target().id()],S=l.apply(w,[w]);f[E][_]+=S,y[_]+=S}for(var P=1/p+m,b=0;p>b;b++)if(0===y[b])for(var g=0;p>g;g++)f[g][b]=P;else for(var g=0;p>g;g++)f[g][b]=f[g][b]/y[b]+m;for(var D,k=[],C=[],g=0;p>g;g++)k.push(1),C.push(0);for(var T=0;s>T;T++){for(var N=C.slice(0),g=0;p>g;g++)for(var b=0;p>b;b++)N[g]+=f[g][b]*k[b];i(N),D=k,k=N;for(var M=0,g=0;p>g;g++)M+=Math.pow(D[g]-k[g],2);if(o>M){r(\"Stoped at iteration %s\",T);break}}r(\"Result:\\n\"+k);var B={rank:function(t){if(e.is.string(t))var i=u.filter(t)[0].id();else var i=t.id();return k[v[i]]}};return B}})}(cytoscape),function(e){\"use strict\";e.fn.eles({animated:e.define.animated(),clearQueue:e.define.clearQueue(),delay:e.define.delay(),animate:e.define.animate(),stop:e.define.stop()})}(cytoscape),function(e){\"use strict\";e.fn.eles({classes:function(t){var i,r=this,n=[];if(e.is.fn(t))i=t;else if(!e.is.plainObject(t))return this;for(var a=0;a<r.length;a++){var o=r[a],s=!1;if(t=i?i.apply(o,[a,o]):t,t.add)for(var l=0;l<t.add.length;l++){var u=t.add[l],c=o._private.classes[u];o._private.classes[u]=!0,c||s||(n.push(o),s=!0)}if(t.remove)for(var l=0;l<t.remove.length;l++){var u=t.remove[l],c=o._private.classes[u];o._private.classes[u]=!1,c&&!s&&(n.push(o),s=!0)}if(t.toggle)for(var l=0;l<t.toggle.length;l++){var u=t.toggle[l],c=o._private.classes[u];o._private.classes[u]=!c,s||(n.push(o),s=!0)}}return n.length>0&&new e.Collection(this.cy(),n).updateStyle().trigger(\"class\"),this},addClass:function(t){t=t.split(/\\s+/);for(var i=this,r=[],n=0;n<t.length;n++){var a=t[n];if(!e.is.emptyString(a))for(var o=0;o<i.length;o++){var s=i[o],l=s._private.classes[a];s._private.classes[a]=!0,l||r.push(s)}}return r.length>0&&new e.Collection(this._private.cy,r).updateStyle().trigger(\"class\"),i},hasClass:function(e){var t=this[0];return null!=t&&t._private.classes[e]?!0:!1},toggleClass:function(t,i){for(var r=t.split(/\\s+/),n=this,a=[],o=0,s=n.length;s>o;o++)for(var l=n[o],u=0;u<r.length;u++){var c=r[u];if(!e.is.emptyString(c)){var d=l._private.classes[c],p=i||void 0===i&&!d;p?(l._private.classes[c]=!0,d||a.push(l)):(l._private.classes[c]=!1,d&&a.push(l))}}return a.length>0&&new e.Collection(this._private.cy,a).updateStyle().trigger(\"class\"),n},removeClass:function(t){t=t.split(/\\s+/);for(var i=this,r=[],n=0;n<i.length;n++)for(var a=i[n],o=0;o<t.length;o++){var s=t[o];if(s&&\"\"!==s){var l=a._private.classes[s];a._private.classes[s]=void 0,l&&r.push(a)}}return r.length>0&&new e.Collection(i._private.cy,r).updateStyle(),i.trigger(\"class\"),i},flashClass:function(e,t){var i=this;if(null==t)t=250;else if(0===t)return i;return i.addClass(e),setTimeout(function(){i.removeClass(e)},t),i}})}(cytoscape),function(e){\"use strict\";e.fn.eles({allAre:function(e){return this.filter(e).length===this.length},is:function(e){return this.filter(e).length>0},some:function(e,t){for(var i=0;i<this.length;i++){var r=e.apply(t,[this[i],i,this]);if(r)return!0}return!1},every:function(e,t){for(var i=0;i<this.length;i++){var r=e.apply(t,[this[i],i,this]);if(!r)return!1}return!0},same:function(e){return e=this.cy().collection(e),this.length!==e.length?!1:this.intersect(e).length===this.length},anySame:function(e){return e=this.cy().collection(e),this.intersect(e).length>0},allAreNeighbors:function(e){return e=this.cy().collection(e),this.neighborhood().intersect(e).length===e.length}})}(cytoscape),function(e){\"use strict\";e.fn.eles({parent:function(t){for(var i=[],r=this._private.cy,n=0;n<this.length;n++){var a=this[n],o=r.getElementById(a._private.data.parent);o.size()>0&&i.push(o)}return new e.Collection(r,i,{unique:!0}).filter(t)},parents:function(t){for(var i=[],r=this.parent();r.nonempty();){for(var n=0;n<r.length;n++){var a=r[n];i.push(a)}r=r.parent()}return new e.Collection(this.cy(),i,{unique:!0}).filter(t)},commonAncestors:function(e){for(var t,i=0;i<this.length;i++){var r=this[i],n=r.parents();t=t||n,t=t.intersect(n)}return t.filter(e)},orphans:function(e){return this.stdFilter(function(e){return e.isNode()&&e.parent().empty()}).filter(e)},nonorphans:function(e){return this.stdFilter(function(e){return e.isNode()&&e.parent().nonempty()}).filter(e)},children:function(t){for(var i=[],r=0;r<this.length;r++){var n=this[r];i=i.concat(n._private.children)}return new e.Collection(this.cy(),i,{unique:!0}).filter(t)},siblings:function(e){return this.parent().children().not(this).filter(e)},isParent:function(){var e=this[0];return e?0!==e._private.children.length:void 0},isChild:function(){var e=this[0];return e?void 0!==e._private.data.parent&&0!==e.parent().length:void 0},descendants:function(t){function i(e){for(var t=0;t<e.length;t++){var n=e[t];r.push(n),n.children().nonempty()&&i(n.children())}}var r=[];return i(this.children()),new e.Collection(this.cy(),r,{unique:!0}).filter(t)}}),e.elesfn.ancestors=e.elesfn.parents}(cytoscape),function(e){\"use strict\";var t=1,i=0;e.fn.eles({data:e.define.data({field:\"data\",bindingEvent:\"data\",allowBinding:!0,allowSetting:!0,settingEvent:\"data\",settingTriggersEvent:!0,triggerFnName:\"trigger\",allowGetting:!0,immutableKeys:{id:!0,source:!0,target:!0,parent:!0},updateStyle:!0}),removeData:e.define.removeData({field:\"data\",event:\"data\",triggerFnName:\"trigger\",triggerEvent:!0,immutableKeys:{id:!0,source:!0,target:!0,parent:!0},updateStyle:!0}),scratch:e.define.data({field:\"scratch\",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeScratch:e.define.removeData({field:\"scratch\",triggerEvent:!1}),rscratch:e.define.data({field:\"rscratch\",allowBinding:!1,allowSetting:!0,settingTriggersEvent:!1,allowGetting:!0}),removeRscratch:e.define.removeData({field:\"rscratch\",triggerEvent:!1}),id:function(){var e=this[0];return e?e._private.data.id:void 0},position:e.define.data({field:\"position\",bindingEvent:\"position\",allowBinding:!0,allowSetting:!0,settingEvent:\"position\",settingTriggersEvent:!0,triggerFnName:\"rtrigger\",allowGetting:!0,validKeys:[\"x\",\"y\"],onSet:function(e){var t=e.updateCompoundBounds();t.rtrigger(\"position\")},canSet:function(e){return!e.locked()}}),silentPosition:e.define.data({field:\"position\",bindingEvent:\"position\",allowBinding:!1,allowSetting:!0,settingEvent:\"position\",settingTriggersEvent:!1,triggerFnName:\"trigger\",allowGetting:!0,validKeys:[\"x\",\"y\"],onSet:function(e){e.updateCompoundBounds()},canSet:function(e){return!e.locked()}}),positions:function(t,i){if(e.is.plainObject(t))this.position(t);else if(e.is.fn(t)){for(var r=t,n=0;n<this.length;n++){var a=this[n],t=r.apply(a,[n,a]);if(t&&!a.locked()){var o=a._private.position;o.x=t.x,o.y=t.y}}var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;i?l.trigger(\"position\"):l.rtrigger(\"position\")}return this},silentPositions:function(e){return this.positions(e,!0)},updateCompoundBounds:function(){function t(e){var t=e.children(),i=e._private.style,n=t.boundingBox({includeLabels:!1,includeEdges:!1}),a={top:i[\"padding-top\"].pxValue,bottom:i[\"padding-bottom\"].pxValue,left:i[\"padding-left\"].pxValue,right:i[\"padding-right\"].pxValue},o=e._private.position,s=!1;\"auto\"===i.width.value&&(e._private.autoWidth=n.w+a.left+a.right,o.x=(n.x1+n.x2-a.left+a.right)/2,s=!0),\"auto\"===i.height.value&&(e._private.autoHeight=n.h+a.top+a.bottom,o.y=(n.y1+n.y2-a.top+a.bottom)/2,s=!0),s&&r.push(e)}var i=this.cy();if(!i.styleEnabled()||!i.hasCompoundNodes())return i.collection();for(var r=[],n=this.parent();n.nonempty();){for(var a=0;a<n.length;a++){var o=n[a];t(o)}n=n.parent()}return new e.Collection(i,r)},renderedPosition:function(t,i){var r=this[0],n=this.cy(),a=n.zoom(),o=n.pan(),s=e.is.plainObject(t)?t:void 0,l=void 0!==s||void 0!==i&&e.is.string(t);if(r&&r.isNode()){if(!l){var u=r._private.position;return s={x:u.x*a+o.x,y:u.y*a+o.y},void 0===t?s:s[t]}for(var c=0;c<this.length;c++){var r=this[c];void 0!==i?r._private.position[t]=(i-o[t])/a:void 0!==s&&(r._private.position={x:(s.x-o.x)/a,y:(s.y-o.y)/a})}this.rtrigger(\"position\")}else if(!l)return void 0;return this},parentPosition:function(t,i){var r=this[0],n=this.cy(),a=e.is.plainObject(t)?t:void 0,o=void 0!==a||void 0!==i&&e.is.string(t),s=n.hasCompoundNodes();if(r&&r.isNode()){if(!o){var l=r._private.position,u=s?r.parent():null,c=u&&u.length>0,d=c;c&&(u=u[0]);var p=d?u._private.position:{x:0,y:0};return a={x:l.x-p.x,y:l.y-p.y},void 0===t?a:a[t]}for(var h=0;h<this.length;h++){var r=this[h],u=s?r.parent():null,c=u&&u.length>0,d=c;c&&(u=u[0]);var p=d?u._private.position:{x:0,y:0};void 0!==i?r._private.position[t]=i+p[t]:void 0!==a&&(r._private.position={x:a.x+p.x,y:a.y+p.y})}this.rtrigger(\"position\")}else if(!o)return void 0;return this},width:function(){var e=this[0],t=e._private.cy,i=t._private.styleEnabled;if(e){if(i){var r=e._private.style.width;return\"auto\"===r.strValue?e._private.autoWidth:r.pxValue}return 1}},outerWidth:function(){var e=this[0],r=e._private.cy,n=r._private.styleEnabled;if(e){if(n){var a=e._private.style,o=\"auto\"===a.width.strValue?e._private.autoWidth:a.width.pxValue,s=a[\"border-width\"]?a[\"border-width\"].pxValue*t+i:0;return o+s}return 1}},renderedWidth:function(){var e=this[0];if(e){var t=e.width();return t*this.cy().zoom()}},renderedOuterWidth:function(){var e=this[0];if(e){var t=e.outerWidth();return t*this.cy().zoom()}},height:function(){var e=this[0],t=e._private.cy,i=t._private.styleEnabled;if(e&&\"nodes\"===e._private.group){if(i){var r=e._private.style.height;return\"auto\"===r.strValue?e._private.autoHeight:r.pxValue}return 1}},outerHeight:function(){var e=this[0],r=e._private.cy,n=r._private.styleEnabled;if(e&&\"nodes\"===e._private.group){if(!n)return 1;var a=e._private.style,o=\"auto\"===a.height.strValue?e._private.autoHeight:a.height.pxValue,s=a[\"border-width\"]?a[\"border-width\"].pxValue*t+i:0;return o+s}},renderedHeight:function(){var e=this[0];if(e&&\"nodes\"===e._private.group){var t=e.height();return t*this.cy().zoom()}},renderedOuterHeight:function(){var e=this[0];if(e&&\"nodes\"===e._private.group){var t=e.outerHeight();return t*this.cy().zoom()}},renderedBoundingBox:function(e){var t=this.boundingBox(e),i=this.cy(),r=i.zoom(),n=i.pan(),a=t.x1*r+n.x,o=t.x2*r+n.x,s=t.y1*r+n.y,l=t.y2*r+n.y;return{x1:a,x2:o,y1:s,y2:l,w:o-a,h:l-s}},boundingBox:function(e){var t=this,i=t._private.cy,r=i._private,n=r.styleEnabled;e=e||{};var a=void 0===e.includeNodes?!0:e.includeNodes,o=void 0===e.includeEdges?!0:e.includeEdges,s=void 0===e.includeLabels?!0:e.includeLabels;n&&r.renderer.recalculateRenderedStyle(this);for(var l=1/0,u=-1/0,c=1/0,d=-1/0,p=0;p<t.length;p++){var h,v,g,f,y,m,x=t[p],b=x._private,w=n?b.style.display.value:\"element\",_=\"nodes\"===b.group,E=!1;if(\"none\"!==w){if(_&&a){E=!0;var S=b.position;y=S.x,m=S.y;var P=x.outerWidth(),D=P/2,k=x.outerHeight(),C=k/2;h=y-D,v=y+D,g=m-C,f=m+C,l=l>h?h:l,u=v>u?v:u,c=c>g?g:c,d=f>d?f:d}else if(x.isEdge()&&o){E=!0;var T=x._private.source._private.position,N=x._private.target._private.position,M=x._private.rstyle||{};if(h=T.x,v=N.x,g=T.y,f=N.y,h>v){var B=h;h=v,v=B}if(g>f){var B=g;g=f,f=B}if(l=l>h?h:l,u=v>u?v:u,c=c>g?g:c,d=f>d?f:d,n)for(var I=M.bezierPts||[],P=x._private.style.width.pxValue,z=P/2,L=0;L<I.length;L++){var O=I[L];h=O.x-z,v=O.x+z,g=O.y-z,f=O.y+z,l=l>h?h:l,u=v>u?v:u,c=c>g?g:c,d=f>d?f:d}}if(n){var R=x._private.style,M=x._private.rstyle,X=R.content.strValue,V=R[\"font-size\"],Y=R[\"text-halign\"],A=R[\"text-valign\"],q=M.labelWidth,F=M.labelHeight,j=M.labelX,W=M.labelY;if(E&&s&&X&&V&&null!=F&&null!=q&&null!=j&&null!=W&&Y&&A){var H,$,Z,U,G=F,K=q;if(x.isEdge())H=j-K/2,$=j+K/2,Z=W-G/2,U=W+G/2;else{switch(Y.value){case\"left\":H=j-K,$=j;break;case\"center\":H=j-K/2,$=j+K/2;break;case\"right\":H=j,$=j+K}switch(A.value){case\"top\":Z=W-G,U=W;break;case\"center\":Z=W-G/2,U=W+G/2;break;case\"bottom\":Z=W,U=W+G}}l=l>H?H:l,u=$>u?$:u,c=c>Z?Z:c,d=U>d?U:d}}}}return{x1:l,x2:u,y1:c,y2:d,w:u-l,h:d-c}}}),e.elesfn.modelPosition=e.elesfn.position,e.elesfn.modelPositions=e.elesfn.positions}(cytoscape),function(e){\"use strict\";function t(e){return function(t){var i=this;if(void 0===t&&(t=!0),0!==i.length&&i.isNode()&&!i.removed()){for(var r=0,n=i[0],a=n._private.edges,o=0;o<a.length;o++){var s=a[o];(t||!s.isLoop())&&(r+=e(n,s))}return r}}}function i(e,t){return function(i){for(var r,n=this.nodes(),a=0;a<n.length;a++){var o=n[a],s=o[e](i);void 0===s||void 0!==r&&!t(s,r)||(r=s)}return r}}e.fn.eles({degree:t(function(e,t){return t.source().same(t.target())?2:1}),indegree:t(function(e,t){return t.target().same(e)?1:0}),outdegree:t(function(e,t){return t.source().same(e)?1:0})}),e.fn.eles({minDegree:i(\"degree\",function(e,t){return t>e}),maxDegree:i(\"degree\",function(e,t){return e>t}),minIndegree:i(\"indegree\",function(e,t){return t>e}),maxIndegree:i(\"indegree\",function(e,t){return e>t}),minOutdegree:i(\"outdegree\",function(e,t){return t>e}),maxOutdegree:i(\"outdegree\",function(e,t){return e>t})}),e.fn.eles({totalDegree:function(e){for(var t=0,i=this.nodes(),r=0;r<i.length;r++)t+=i[r].degree(e);return t}})}(cytoscape),function(e){\"use strict\";e.fn.eles({on:e.define.on(),one:e.define.on({unbindSelfOnTrigger:!0}),once:e.define.on({unbindAllBindersOnTrigger:!0}),off:e.define.off(),trigger:e.define.trigger(),rtrigger:function(e,t){return 0!==this.length?(this.cy().notify({type:e,collection:this}),this.trigger(e,t),this):void 0}}),e.elesfn.bind=e.elesfn.on,e.elesfn.unbind=e.elesfn.off}(cytoscape),function(e){\"use strict\";e.fn.eles({nodes:function(e){return this.filter(function(e,t){return t.isNode()}).filter(e)},edges:function(e){return this.filter(function(e,t){return t.isEdge()}).filter(e)},filter:function(t){var i=this._private.cy;if(e.is.fn(t)){for(var r=[],n=0;n<this.length;n++){var a=this[n];t.apply(a,[n,a])&&r.push(a)}return new e.Collection(i,r)}return e.is.string(t)||e.is.elementOrCollection(t)?new e.Selector(t).filter(this):void 0===t?this:new e.Collection(i)},not:function(t){var i=this._private.cy;if(t){e.is.string(t)&&(t=this.filter(t));for(var r=[],n=0;n<this.length;n++){var a=this[n],o=t._private.ids[a.id()];o||r.push(a)}return new e.Collection(i,r)}return this},intersect:function(t){var i=this._private.cy;if(e.is.string(t)){var r=t;return this.filter(r)}for(var n=[],a=this,o=t,s=this.length<t.length,l=s?o._private.ids:a._private.ids,u=s?a:o,c=0;c<u.length;c++){var d=u[c]._private.data.id,p=l[d];p&&n.push(p)}return new e.Collection(i,n)},add:function(t){var i=this._private.cy;if(!t)return this;if(e.is.string(t)){var r=t;t=i.elements(r)}for(var n=[],a=0;a<this.length;a++)n.push(this[a]);for(var a=0;a<t.length;a++){var o=!this._private.ids[t[a].id()];o&&n.push(t[a])}return new e.Collection(i,n)},merge:function(t){var i=this._private,r=i.cy;if(!t)return this;if(e.is.string(t)){var n=t;t=r.elements(n)}for(var a=0;a<t.length;a++){var o=t[a],s=o.id(),l=!i.ids[s];if(l){var u=this.length++;this[u]=o,i.ids[s]=o,i.indexes[s]=u}}return this},unmergeOne:function(e){e=e[0];var t=this._private,i=e.id(),r=t.indexes[i];if(null==r)return this;this[r]=void 0,t.ids[i]=void 0,t.indexes[i]=void 0;var n=r===this.length-1;if(this.length>1&&!n){var a=this.length-1,o=this[a];this[a]=void 0,this[r]=o,t.indexes[o.id()]=r}return this.length--,this},unmerge:function(t){var i=this._private.cy;if(!t)return this;if(e.is.string(t)){var r=t;t=i.elements(r)}for(var n=0;n<t.length;n++)this.unmergeOne(t[n]);return this},map:function(e,t){for(var i=[],r=this,n=0;n<r.length;n++){var a=r[n],o=e.apply(t,[a,n,r]);i.push(o)}return i},stdFilter:function(t,i){for(var r=[],n=this,a=this._private.cy,o=0;o<n.length;o++){var s=n[o],l=t.apply(i,[s,o,n]);l&&r.push(s)}return new e.Collection(a,r)},max:function(e,t){for(var i,r=-1/0,n=this,a=0;a<n.length;a++){var o=n[a],s=e.apply(t,[o,a,n]);s>r&&(r=s,i=o)}return{value:r,ele:i}},min:function(e,t){for(var i,r=1/0,n=this,a=0;a<n.length;a++){var o=n[a],s=e.apply(t,[o,a,n]);r>s&&(r=s,i=o)}return{value:r,ele:i}}})}(cytoscape),function(e){\"use strict\";e.fn.eles({isNode:function(){return\"nodes\"===this.group()},isEdge:function(){return\"edges\"===this.group()},isLoop:function(){return this.isEdge()&&this.source().id()===this.target().id()},isSimple:function(){return this.isEdge()&&this.source().id()!==this.target().id()},group:function(){var e=this[0];return e?e._private.group:void 0}})}(cytoscape),function(e){\"use strict\";e.fn.eles({each:function(t){if(e.is.fn(t))for(var i=0;i<this.length;i++){var r=this[i],n=t.apply(r,[i,r]);if(n===!1)break}return this},forEach:function(t,i){if(e.is.fn(t))for(var r=0;r<this.length;r++){var n=this[r],a=t.apply(i,[n,r,this]);if(a===!1)break}return this},toArray:function(){for(var e=[],t=0;t<this.length;t++)e.push(this[t]);return e},slice:function(t,i){var r=[],n=this.length;null==i&&(i=n),null==t&&(t=0),0>t&&(t=n+t),0>i&&(i=n+i);for(var a=t;a>=0&&i>a&&n>a;a++)r.push(this[a]);return new e.Collection(this.cy(),r)},size:function(){return this.length},eq:function(t){return this[t]||new e.Collection(this.cy())},first:function(){return this[0]||new e.Collection(this.cy())},last:function(){return this[this.length-1]||new e.Collection(this.cy())},empty:function(){return 0===this.length},nonempty:function(){return!this.empty()},sort:function(t){if(!e.is.fn(t))return this;var i=this.cy(),r=this.toArray().sort(t);return new e.Collection(i,r)},sortByZIndex:function(){return this.sort(e.Collection.zIndexSort)},zDepth:function(){var e=this[0];if(!e)return void 0;var t=e._private,i=t.group;if(\"nodes\"===i)return t.data.parent?e.parents().size():0;var r=t.source,n=t.target,a=r._private.data.parent?r.parents().size():0,o=n._private.data.parent?n.parents().size():0;return Math.max(a-1,o-1,0)+.5}}),e.Collection.zIndexSort=function(e,t){var i=e.cy(),r=e._private,n=t._private,a=r.style[\"z-index\"].value-n.style[\"z-index\"].value,o=0,s=0,l=i.hasCompoundNodes(),u=\"nodes\"===r.group,c=\"edges\"===r.group,d=\"nodes\"===n.group,p=\"edges\"===n.group;l&&(o=e.zDepth(),s=t.zDepth());var h=o-s,v=0===h;return v?u&&p?1:c&&d?-1:0===a?r.index-n.index:a:h}}(cytoscape),function(e){\"use strict\";e.fn.eles({layoutPositions:function(t,i,r){var n=this.nodes(),a=this.cy();if(t.trigger({type:\"layoutstart\",layout:t}),i.animate){for(var o=0;o<n.length;o++){var s=n[o],l=o===n.length-1,u=r.call(s,o,s),c=s.position();e.is.number(c.x)&&e.is.number(c.y)||s.silentPosition({x:0,y:0}),s.animate({position:u},{duration:i.animationDuration,step:l?function(){i.fit&&a.fit(i.padding)}:void 0,complete:l?function(){null!=i.zoom&&a.zoom(i.zoom),i.pan&&a.pan(i.pan),i.fit&&a.fit(i.padding),t.one(\"layoutstop\",i.stop),t.trigger({type:\"layoutstop\",layout:t})}:void 0})}t.one(\"layoutready\",i.ready),t.trigger({type:\"layoutready\",layout:t})}else n.positions(r),i.fit&&a.fit(i.padding),null!=i.zoom&&a.zoom(i.zoom),i.pan&&a.pan(i.pan),t.one(\"layoutready\",i.ready),t.trigger({type:\"layoutready\",layout:t}),t.one(\"layoutstop\",i.stop),t.trigger({type:\"layoutstop\",layout:t});return this},layout:function(t){var i=this.cy();return i.layout(e.util.extend({},t,{eles:this})),this},makeLayout:function(t){var i=this.cy();return i.makeLayout(e.util.extend({},t,{eles:this}))}})}(cytoscape),function(e){\"use strict\";e.fn.eles({updateStyle:function(e){var t=this._private.cy;if(!t.styleEnabled())return this;if(t._private.batchingStyle){for(var i=t._private.batchStyleEles,r=0;r<this.length;r++){var n=this[r];i.ids[n._private.id]||i.push(n)}return this}var a=t.style();e=e||void 0===e?!0:!1,a.apply(this);var o=this.updateCompoundBounds(),s=o.length>0?this.add(o):this;return e?s.rtrigger(\"style\"):s.trigger(\"style\"),this},updateMappers:function(e){var t=this._private.cy,i=t.style();if(e=e||void 0===e?!0:!1,!t.styleEnabled())return this;i.updateMappers(this);var r=this.updateCompoundBounds(),n=r.length>0?this.add(r):this;return e?n.rtrigger(\"style\"):n.trigger(\"style\"),this},renderedCss:function(e){var t=this.cy();if(!t.styleEnabled())return this;var i=this[0];if(i){var r=i.cy().style().getRenderedStyle(i);return void 0===e?r:r[e]}},css:function(t,i){var r=this.cy();if(!r.styleEnabled())return this;var n=!1,a=r.style();if(e.is.plainObject(t)){var o=t;a.applyBypass(this,o,n);var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;l.rtrigger(\"style\")}else if(e.is.string(t)){if(void 0===i){var u=this[0];return u?u._private.style[t].strValue:void 0}a.applyBypass(this,t,i,n);var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;l.rtrigger(\"style\")}else if(void 0===t){var u=this[0];return u?a.getRawStyle(u):void 0}return this},removeCss:function(e){var t=this.cy();if(!t.styleEnabled())return this;var i=!1,r=t.style(),n=this;if(void 0===e)for(var a=0;a<n.length;a++){var o=n[a];r.removeAllBypasses(o,i)}else{e=e.split(/\\s+/);for(var a=0;a<n.length;a++){var o=n[a];r.removeBypasses(o,e,i)}}var s=this.updateCompoundBounds(),l=s.length>0?this.add(s):this;return l.rtrigger(\"style\"),this},show:function(){return this.css(\"display\",\"element\"),this},hide:function(){return this.css(\"display\",\"none\"),this},visible:function(){var e=this.cy();if(!e.styleEnabled())return!0;var t=this[0],i=e.hasCompoundNodes();if(t){var r=t._private.style;if(\"visible\"!==r.visibility.value||\"element\"!==r.display.value)return!1;if(\"nodes\"===t._private.group){if(!i)return!0;\nvar n=t._private.data.parent?t.parents():null;if(n)for(var a=0;a<n.length;a++){var o=n[a],s=o._private.style,l=s.visibility.value,u=s.display.value;if(\"visible\"!==l||\"element\"!==u)return!1}return!0}var c=t._private.source,d=t._private.target;return c.visible()&&d.visible()}},hidden:function(){var e=this[0];return e?!e.visible():void 0},effectiveOpacity:function(){var e=this.cy();if(!e.styleEnabled())return 1;var t=e.hasCompoundNodes(),i=this[0];if(i){var r=i._private,n=r.style.opacity.value;if(!t)return n;var a=r.data.parent?i.parents():null;if(a)for(var o=0;o<a.length;o++){var s=a[o],l=s._private.style.opacity.value;n=l*n}return n}},transparent:function(){var e=this[0],t=e.cy().hasCompoundNodes();return e?t?0===e.effectiveOpacity():0===e._private.style.opacity.value:void 0},isFullAutoParent:function(){var e=this.cy();if(!e.styleEnabled())return!1;var t=this[0];if(t){var i=\"auto\"===t._private.style.width.value,r=\"auto\"===t._private.style.height.value;return t.isParent()&&i&&r}}}),e.elesfn.style=e.elesfn.css,e.elesfn.renderedStyle=e.elesfn.renderedCss,e.elesfn.removeStyle=e.elesfn.removeCss}(cytoscape),function(e){\"use strict\";function t(e){return function(){var t=arguments;if(2===t.length){var i=t[0],r=t[1];this.bind(e.event,i,r)}else if(1===t.length){var r=t[0];this.bind(e.event,r)}else if(0===t.length){for(var n=0;n<this.length;n++){var a=this[n],o=!e.ableField||a._private[e.ableField];if(e.overrideAble){var s=e.overrideAble(a);if(void 0!==s&&(o=s,!s))return this}o&&(a._private[e.field]=e.value)}this.updateStyle(),this.trigger(e.event)}return this}}function i(i){e.elesfn[i.field]=function(){var e=this[0];if(e){if(i.overrideField){var t=i.overrideField(e);if(void 0!==t)return t}return e._private[i.field]}},e.elesfn[i.on]=t({event:i.on,field:i.field,ableField:i.ableField,overrideAble:i.overrideAble,value:!0}),e.elesfn[i.off]=t({event:i.off,field:i.field,ableField:i.ableField,overrideAble:i.overrideAble,value:!1})}i({field:\"locked\",overrideField:function(e){return e.cy().autolock()?!0:void 0},on:\"lock\",off:\"unlock\"}),i({field:\"grabbable\",overrideField:function(e){return e.cy().autoungrabify()?!1:void 0},on:\"grabify\",off:\"ungrabify\"}),i({field:\"selected\",ableField:\"selectable\",overrideAble:function(e){return e.cy().autounselectify()?!1:void 0},on:\"select\",off:\"unselect\"}),i({field:\"selectable\",overrideField:function(e){return e.cy().autounselectify()?!1:void 0},on:\"selectify\",off:\"unselectify\"}),e.elesfn.grabbed=function(){var e=this[0];return e?e._private.grabbed:void 0},i({field:\"active\",on:\"activate\",off:\"unactivate\"}),e.elesfn.inactive=function(){var e=this[0];return e?!e._private.active:void 0}}(cytoscape),function(e){\"use strict\";function t(t){return function(i){for(var r=[],n=this._private.cy,a=0;a<this.length;a++){var o=this[a],s=o._private[t.attr];s&&r.push(s)}return new e.Collection(n,r,{unique:!0}).filter(i)}}function i(t){return function(i){var r=[],n=this._private.cy,a=t||{};e.is.string(i)&&(i=n.$(i));for(var o=i.connectedEdges(),s=this._private.ids,l=0;l<o.length;l++){var u,c=o[l],d=c._private.data;if(a.thisIs){var p=d[a.thisIs];u=s[p]}else u=s[d.source]||s[d.target];u&&r.push(c)}return new e.Collection(n,r,{unique:!0})}}function r(t){var i={codirected:!1};return t=e.util.extend({},i,t),function(i){for(var r=this._private.cy,n=[],a=this.edges(),o=t,s=0;s<a.length;s++)for(var l=a[s],u=l.source()[0],c=u.id(),d=l.target()[0],p=d.id(),h=u._private.edges,v=0;v<h.length;v++){var g=h[v],f=g._private.data,y=f.target,m=f.source,x=y===p&&m===c,b=c===y&&p===m;(o.codirected&&x||!o.codirected&&(x||b))&&n.push(g)}return new e.Collection(r,n,{unique:!0}).filter(i)}}e.fn.eles({roots:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n];if(a.isNode()){var o=a.connectedEdges(function(){return this.data(\"target\")===a.id()&&this.data(\"source\")!==a.id()}).length>0;o||r.push(a)}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},leaves:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n];if(a.isNode()){var o=a.connectedEdges(function(){return this.data(\"source\")===a.id()&&this.data(\"target\")!==a.id()}).length>0;o||r.push(a)}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},outgoers:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n],o=a.id();if(a.isNode())for(var s=a._private.edges,l=0;l<s.length;l++){var u=s[l],c=u._private.data.source,d=u._private.data.target;c===o&&d!==o&&(r.push(u),r.push(u.target()[0]))}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},successors:function(t){for(var i=this,r=[],n={};;){var a=i.outgoers();if(0===a.length)break;for(var o=!1,s=0;s<a.length;s++){var l=a[s],u=l.id();n[u]||(n[u]=!0,r.push(l),o=!0)}if(!o)break;i=a}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},incomers:function(t){for(var i=this,r=[],n=0;n<i.length;n++){var a=i[n],o=a.id();if(a.isNode())for(var s=a._private.edges,l=0;l<s.length;l++){var u=s[l],c=u._private.data.source,d=u._private.data.target;d===o&&c!==o&&(r.push(u),r.push(u.source()[0]))}}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)},predecessors:function(t){for(var i=this,r=[],n={};;){var a=i.incomers();if(0===a.length)break;for(var o=!1,s=0;s<a.length;s++){var l=a[s],u=l.id();n[u]||(n[u]=!0,r.push(l),o=!0)}if(!o)break;i=a}return new e.Collection(this._private.cy,r,{unique:!0}).filter(t)}}),e.fn.eles({neighborhood:function(t){for(var i=[],r=this._private.cy,n=this.nodes(),a=0;a<n.length;a++)for(var o=n[a],s=o.connectedEdges(),l=0;l<s.length;l++){var u=s[l],c=u.connectedNodes().not(o);c.length>0&&i.push(c[0]),i.push(u[0])}return new e.Collection(r,i,{unique:!0}).filter(t)},closedNeighborhood:function(e){return this.neighborhood().add(this).filter(e)},openNeighborhood:function(e){return this.neighborhood(e)}}),e.fn.eles({source:function(e){var t,i=this[0];return i&&(t=i._private.source),t&&e?t.filter(e):t},target:function(e){var t,i=this[0];return i&&(t=i._private.target),t&&e?t.filter(e):t},sources:t({attr:\"source\"}),targets:t({attr:\"target\"})}),e.fn.eles({edgesWith:i(),edgesTo:i({thisIs:\"source\"})}),e.fn.eles({connectedEdges:function(t){for(var i=[],r=this._private.cy,n=this,a=0;a<n.length;a++){var o=n[a];if(o.isNode())for(var s=o._private.edges,l=0;l<s.length;l++){var u=s[l];i.push(u)}}return new e.Collection(r,i,{unique:!0}).filter(t)},connectedNodes:function(t){for(var i=[],r=this._private.cy,n=this,a=0;a<n.length;a++){var o=n[a];o.isEdge()&&(i.push(o.source()[0]),i.push(o.target()[0]))}return new e.Collection(r,i,{unique:!0}).filter(t)},parallelEdges:r(),codirectedEdges:r({codirected:!0})})}(cytoscape),function(e){\"use strict\";e.fn.eles({fit:function(){},center:function(){}})}(cytoscape),function(e){\"use strict\";e.Minheap=function(t,i,r){return new e.Heap(t,i,e.Heap.minHeapComparator,r)},e.Maxheap=function(t,i,r){return new e.Heap(t,i,e.Heap.maxHeapComparator,r)},e.Heap=function(t,i,r,n){if(\"undefined\"!=typeof r&&\"undefined\"!=typeof i){\"undefined\"==typeof n&&(n=e.Heap.idFn);var a,o,s,l=[],u={},c=[],d=0;for(i=this.getArgumentAsCollection(i,t),s=i.length,d=0;s>d;d+=1){if(l.push(n.call(t,i[d],d,i)),a=i[d].id(),u.hasOwnProperty(a))throw\"ERROR: Multiple items with the same id found: \"+a;u[a]=d,c.push(a)}for(this._private={cy:t,heap:l,pointers:u,elements:c,comparator:r,extractor:n,length:s},d=Math.floor(s/2);d>=0;d-=1)o=this.heapify(d);return o}},e.Heap.idFn=function(e){return e.id()},e.Heap.minHeapComparator=function(e,t){return e>=t},e.Heap.maxHeapComparator=function(e,t){return t>=e},e.fn.heap=function(t){for(var i in t){var r=t[i];e.Heap.prototype[i]=r}},e.heapfn=e.Heap.prototype,e.heapfn.size=function(){return this._private.length},e.heapfn.getArgumentAsCollection=function(t,i){var r;if(\"undefined\"==typeof i&&(i=this._private.cy),e.is.elementOrCollection(t))r=t;else{for(var n=[],a=[].concat.apply([],[t]),o=0;o<a.length;o++){var s=a[o],l=i.getElementById(s);l.length>0&&n.push(l)}r=new e.Collection(i,n)}return r},e.heapfn.isHeap=function(){var e,t,i,r,n,a=this._private.heap,o=a.length,s=this._private.comparator;for(e=0;o>e;e+=1)if(t=2*e+1,i=t+1,r=o>t?s(a[t],a[e]):!0,n=o>i?s(a[i],a[e]):!0,!r||!n)return!1;return!0},e.heapfn.heapSwap=function(e,t){var i=this._private.heap,r=this._private.pointers,n=this._private.elements,a=i[e],o=n[e],s=n[e],l=n[t];i[e]=i[t],n[e]=n[t],r[s]=t,r[l]=e,i[t]=a,n[t]=o},e.heapfn.heapify=function(e,t){var i,r,n,a,o,s,l,u=0,c=!1;for(\"undefined\"==typeof t&&(t=!0),i=this._private.heap,u=i.length,s=this._private.comparator,r=e;!c;)t?(n=2*r+1,a=n+1,o=r,u>n&&!s(i[n],i[o])&&(o=n),u>a&&!s(i[a],i[o])&&(o=a),c=o===r,c||(this.heapSwap(o,r),r=o)):(l=Math.floor((r-1)/2),o=r,c=0>l||s(i[o],i[l]),c||(this.heapSwap(o,l),r=l))},e.heapfn.insert=function(e){var t,i,r,n,a,o=this.getArgumentAsCollection(e),s=o.length;for(a=0;s>a;a+=1){if(t=o[a],i=this._private.heap.length,r=this._private.extractor(t),n=t.id(),this._private.pointers.hasOwnProperty(n))throw\"ERROR: Multiple items with the same id found: \"+n;this._private.heap.push(r),this._private.elements.push(n),this._private.pointers[n]=i,this.heapify(i,!1)}this._private.length=this._private.heap.length},e.heapfn.getValueById=function(e){if(this._private.pointers.hasOwnProperty(e)){var t=this._private.pointers[e];return this._private.heap[t]}},e.heapfn.contains=function(e){for(var t=this.getArgumentAsCollection(e),i=0;i<t.length;i+=1){var r=t[i].id();if(!this._private.pointers.hasOwnProperty(r))return!1}return!0},e.heapfn.top=function(){return this._private.length>0?{value:this._private.heap[0],id:this._private.elements[0]}:void 0},e.heapfn.pop=function(){if(this._private.length>0){var e,t,i,r=this.top(),n=this._private.length-1;return this.heapSwap(0,n),e=this._private.elements[n],t=this._private.heap[n],i=e,this._private.heap.pop(),this._private.elements.pop(),this._private.length=this._private.heap.length,this._private.pointers[i]=void 0,this.heapify(0),r}},e.heapfn.findDirectionHeapify=function(e){var t=Math.floor((e-1)/2),i=this._private.heap,r=0>t||this._private.comparator(i[e],i[t]);this.heapify(e,r)},e.heapfn.edit=function(t,i){for(var r=this.getArgumentAsCollection(t),n=0;n<r.length;n+=1){var a=r[n].id(),o=this._private.pointers[a],s=this._private.heap[o];e.is.number(i)?this._private.heap[o]=i:e.is.fn(i)&&(this._private.heap[o]=i.call(this._private.cy,s,o)),this.findDirectionHeapify(o)}},e.heapfn.delete=function(e){for(var t=this.getArgumentAsCollection(e),i=0;i<t.length;i+=1){var r,n,a,o=t[i].id(),s=this._private.pointers[o],l=this._private.length-1;s!==l&&this.heapSwap(s,l),r=this._private.elements[l],n=this._private.heap[l],a=r,this._private.heap.pop(),this._private.elements.pop(),this._private.length=this._private.heap.length,this._private.pointers[a]=void 0,this.findDirectionHeapify(s)}return n}}(cytoscape),function(e){\"use strict\";function t(e){t.CANVAS_LAYERS=5,t.SELECT_BOX=0,t.DRAG=2,t.NODE=4,t.TEXTURE_BUFFER=0,t.BUFFER_COUNT=2,this.options=e,this.data={select:[void 0,void 0,void 0,void 0,0],renderer:this,cy:e.cy,container:e.cy.container(),canvases:new Array(t.CANVAS_LAYERS),contexts:new Array(t.CANVAS_LAYERS),canvasNeedsRedraw:new Array(t.CANVAS_LAYERS),bufferCanvases:new Array(t.BUFFER_COUNT),bufferContexts:new Array(t.CANVAS_LAYERS)},this.hoverData={down:null,last:null,downTime:null,triggerMode:null,dragging:!1,initialPan:[null,null],capture:!1},this.timeoutData={panTimeout:null},this.dragData={possibleDragElements:[]},this.touchData={start:null,capture:!1,startPosition:[null,null,null,null,null,null],singleTouchStartTime:null,singleTouchMoved:!0,now:[null,null,null,null,null,null],earlier:[null,null,null,null,null,null]},this.zoomData={freeToZoom:!1,lastPointerX:null},this.redraws=0,this.showFps=e.showFps,this.bindings=[],this.data.canvasContainer=document.createElement(\"div\");var i=this.data.canvasContainer.style;i.position=\"absolute\",i.zIndex=\"0\",i.overflow=\"hidden\",this.data.container.appendChild(this.data.canvasContainer);for(var r=0;r<t.CANVAS_LAYERS;r++)this.data.canvases[r]=document.createElement(\"canvas\"),this.data.contexts[r]=this.data.canvases[r].getContext(\"2d\"),this.data.canvases[r].style.position=\"absolute\",this.data.canvases[r].setAttribute(\"data-id\",\"layer\"+r),this.data.canvases[r].style.zIndex=String(t.CANVAS_LAYERS-r),this.data.canvasContainer.appendChild(this.data.canvases[r]),this.data.canvasNeedsRedraw[r]=!1;this.data.topCanvas=this.data.canvases[0],this.data.canvases[t.NODE].setAttribute(\"data-id\",\"layer\"+t.NODE+\"-node\"),this.data.canvases[t.SELECT_BOX].setAttribute(\"data-id\",\"layer\"+t.SELECT_BOX+\"-selectbox\"),this.data.canvases[t.DRAG].setAttribute(\"data-id\",\"layer\"+t.DRAG+\"-drag\");for(var r=0;r<t.BUFFER_COUNT;r++)this.data.bufferCanvases[r]=document.createElement(\"canvas\"),this.data.bufferContexts[r]=this.data.bufferCanvases[r].getContext(\"2d\"),this.data.bufferCanvases[r].style.position=\"absolute\",this.data.bufferCanvases[r].setAttribute(\"data-id\",\"buffer\"+r),this.data.bufferCanvases[r].style.zIndex=String(-r-1),this.data.bufferCanvases[r].style.visibility=\"hidden\";this.hideEdgesOnViewport=e.hideEdgesOnViewport,this.hideLabelsOnViewport=e.hideLabelsOnViewport,this.textureOnViewport=e.textureOnViewport,this.wheelSensitivity=e.wheelSensitivity,this.motionBlurEnabled=void 0===e.motionBlur?!0:e.motionBlur,this.forcedPixelRatio=e.pixelRatio,this.motionBlur=!0,this.tapThreshold=e.tapThreshold,this.tapThreshold2=e.tapThreshold*e.tapThreshold,this.tapholdDuration=500,this.load()}t.panOrBoxSelectDelay=400,t.isTouch=e.is.touch();var i=\"undefined\"!=typeof Path2D;t.usePaths=function(){return i},t.prototype.notify=function(i){var r;r=e.is.array(i.type)?i.type:[i.type];for(var n=0;n<r.length;n++){var a=r[n];switch(a){case\"destroy\":return void this.destroy();case\"add\":case\"remove\":case\"load\":this.updateNodesCache(),this.updateEdgesCache();break;case\"viewport\":this.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;break;case\"style\":this.updateCachedZSortedEles()}(\"load\"===a||\"resize\"===a)&&(this.invalidateContainerClientCoordsCache(),this.matchCanvasSize(this.data.container))}this.data.canvasNeedsRedraw[t.NODE]=!0,this.data.canvasNeedsRedraw[t.DRAG]=!0,this.redraw()},t.prototype.destroy=function(){this.destroyed=!0;for(var e=0;e<this.bindings.length;e++){var t=this.bindings[e],i=t;i.target.removeEventListener(i.event,i.handler,i.useCapture)}this.removeObserver&&this.removeObserver.disconnect()};for(var r in e.math)t.prototype[r]=e.math[r];e(\"renderer\",\"canvas\",t)}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\"),i=t.prototype,r=t.arrowShapes={};t.arrowShapeHeight=.3;var n=function(e,t,i,r,n,a){var o=i-n/2,s=i+n/2,l=r-a/2,u=r+a/2;return e>=o&&s>=e&&t>=l&&u>=t},a=function(e,t,i,r,n){r=-r;var a=e*Math.cos(r)-t*Math.sin(r),o=e*Math.sin(r)+t*Math.cos(r),s=a*i,l=o*i,u=s+n.x,c=l+n.y;return{x:u,y:c}};r.arrow={_points:[-.15,-.3,0,0,.15,-.3],collide:function(t,i,n,a,o,s,l,u){var c=r.arrow._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.arrow._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r.triangle=r.arrow,r[\"triangle-backcurve\"]={_ctrlPt:[0,-.15],collide:function(t,i,n,a,o,s,l,u){var c=r.triangle._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o,s=r.triangle._points,l=0;l<s.length/2;l++){var u=a(s[2*l],s[2*l+1],t,i,n);0===l&&(o=u),e.lineTo(u.x,u.y)}var c=this._ctrlPt,d=a(c[0],c[1],t,i,n);e.quadraticCurveTo(d.x,d.y,o.x,o.y)},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r[\"triangle-tee\"]={_points:[-.15,-.3,0,0,.15,-.3,-.15,-.3],_pointsTee:[-.15,-.4,-.15,-.5,.15,-.5,.15,-.4],collide:function(t,i,n,a,o,s,l,u){var c=r[\"triangle-tee\"]._points,d=r[\"triangle-tee\"]._pointsTee,p=e.math.pointInsidePolygon(t,i,d,n,a,o,s,l,u)||e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u);return p},roughCollide:n,draw:function(e,t,i,n){for(var o=r[\"triangle-tee\"]._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}var u=r[\"triangle-tee\"]._pointsTee,c=a(u[0],u[1],t,i,n);e.moveTo(c.x,c.y);for(var s=0;s<u.length/2;s++){var l=a(u[2*s],u[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r[\"half-triangle-overshot\"]={_points:[0,-.25,-.5,-.25,.5,.25],leavePathOpen:!0,matchEdgeWidth:!0,collide:function(t,i,r,n,a,o,s,l){var u=this._points;return e.math.pointInsidePolygon(t,i,u,r,n,a,o,s,l)},roughCollide:n,draw:function(e,t,i,r){for(var n=this._points,o=0;o<n.length/2;o++){var s=a(n[2*o],n[2*o+1],t,i,r);e.lineTo(s.x,s.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r.none={collide:function(){return!1},roughCollide:function(){return!1},draw:function(){},spacing:function(){return 0},gap:function(){return 0}},r.circle={_baseRadius:.15,collide:function(e,t,i,n,a,o,s,l){if(a!=o){var u=(o+l)/(a+l);return t/=u,n/=u,Math.pow(i-e,2)+Math.pow(n-t,2)<=Math.pow((a+l)*r.circle._baseRadius,2)}return Math.pow(i-e,2)+Math.pow(n-t,2)<=Math.pow((a+l)*r.circle._baseRadius,2)},roughCollide:n,draw:function(e,t,i,n){e.arc(n.x,n.y,r.circle._baseRadius*t,0,2*Math.PI,!1)},spacing:function(e){return i.getArrowWidth(e._private.style.width.pxValue)*r.circle._baseRadius},gap:function(e){return 2*e._private.style.width.pxValue}},r.inhibitor={_points:[-.25,0,-.25,-.1,.25,-.1,.25,0],collide:function(t,i,n,a,o,s,l,u){var c=r.inhibitor._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.inhibitor._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 1},gap:function(){return 1}},r.tee=r.inhibitor,r.square={_points:[-.15,0,.15,0,.15,-.3,-.15,-.3],collide:function(t,i,n,a,o,s,l,u){var c=r.square._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.square._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return 2*e._private.style.width.pxValue}},r.diamond={_points:[-.15,-.15,0,-.3,.15,-.15,0,0],collide:function(t,i,n,a,o,s,l,u){var c=r.diamond._points;return e.math.pointInsidePolygon(t,i,c,n,a,o,s,l,u)},roughCollide:n,draw:function(e,t,i,n){for(var o=r.diamond._points,s=0;s<o.length/2;s++){var l=a(o[2*s],o[2*s+1],t,i,n);e.lineTo(l.x,l.y)}},spacing:function(){return 0},gap:function(e){return e._private.style.width.pxValue}}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.getCachedNodes=function(){var e=this.data,t=this.data.cy;return null==e.cache&&(e.cache={}),null==e.cache.cachedNodes&&(e.cache.cachedNodes=t.nodes()),e.cache.cachedNodes},t.prototype.updateNodesCache=function(){var e=this.data,t=this.data.cy;null==e.cache&&(e.cache={}),e.cache.cachedNodes=t.nodes()},t.prototype.getCachedEdges=function(){var e=this.data,t=this.data.cy;return null==e.cache&&(e.cache={}),null==e.cache.cachedEdges&&(e.cache.cachedEdges=t.edges()),e.cache.cachedEdges},t.prototype.updateEdgesCache=function(){var e=this.data,t=this.data.cy;null==e.cache&&(e.cache={}),e.cache.cachedEdges=t.edges()}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.projectIntoViewport=function(e,t){var i=this.findContainerClientCoords(),r=i[0],n=i[1],a=e-r,o=t-n;return a-=this.data.cy.pan().x,o-=this.data.cy.pan().y,a/=this.data.cy.zoom(),o/=this.data.cy.zoom(),[a,o]},t.prototype.findContainerClientCoords=function(){var e=this.data.container,t=this.containerBB=this.containerBB||e.getBoundingClientRect();return[t.left,t.top,t.right-t.left,t.bottom-t.top]},t.prototype.invalidateContainerClientCoordsCache=function(){this.containerBB=null},t.prototype.findNearestElement=function(i,r,n){function a(e){var a=e.outerWidth(),o=e.outerHeight(),l=a/2,c=o/2,d=e._private.position;if(d.x-l<=i&&i<=d.x+l&&d.y-c<=r&&r<=d.y+c){var p=!n||e.visible()&&!e.transparent();if(n&&!p)return;var h=t.nodeShapes[s.getNodeShape(e)],g=e._private.style[\"border-width\"].pxValue/2;h.checkPoint(i,r,g,a+v,o+v,d.x,d.y)&&u.push(e)}}function o(o){var l,c=o._private.rscratch,d=o._private.style,v=d.width.pxValue,g=v*v,f=2*v,y=o._private.source,m=o._private.target,x=!1,b=function(){if(void 0!==l)return l;if(!n)return l=!0,!0;var e=o.visible()&&!o.transparent();return e?(l=!0,!0):(l=!1,!1)};if(\"self\"===c.edgeType)((x=e.math.inBezierVicinity(i,r,c.startX,c.startY,c.cp2ax,c.cp2ay,c.selfEdgeMidX,c.selfEdgeMidY,g))&&b()&&g+h>e.math.sqDistanceToQuadraticBezier(i,r,c.startX,c.startY,c.cp2ax,c.cp2ay,c.selfEdgeMidX,c.selfEdgeMidY)||(x=e.math.inBezierVicinity(i,r,c.selfEdgeMidX,c.selfEdgeMidY,c.cp2cx,c.cp2cy,c.endX,c.endY,g))&&b()&&g+h>e.math.sqDistanceToQuadraticBezier(i,r,c.selfEdgeMidX,c.selfEdgeMidY,c.cp2cx,c.cp2cy,c.endX,c.endY))&&u.push(o);else if(\"haystack\"===c.edgeType){var w=d[\"haystack-radius\"].value,_=w/2,E=m._private.position,S=m.width(),P=m.height(),D=y._private.position,k=y.width(),C=y.height(),T=D.x+c.source.x*k*_,N=D.y+c.source.y*C*_,M=E.x+c.target.x*S*_,B=E.y+c.target.y*P*_;(x=e.math.inLineVicinity(i,r,T,N,M,B,f))&&b()&&g+h>e.math.sqDistanceToFiniteLine(i,r,T,N,M,B)&&u.push(o)}else\"straight\"===c.edgeType?(x=e.math.inLineVicinity(i,r,c.startX,c.startY,c.endX,c.endY,f))&&b()&&g+h>e.math.sqDistanceToFiniteLine(i,r,c.startX,c.startY,c.endX,c.endY)&&u.push(o):\"bezier\"===c.edgeType&&(x=e.math.inBezierVicinity(i,r,c.startX,c.startY,c.cp2x,c.cp2y,c.endX,c.endY,g))&&b()&&g+h>e.math.sqDistanceToQuadraticBezier(i,r,c.startX,c.startY,c.cp2x,c.cp2y,c.endX,c.endY)&&u.push(o);if(x&&b()&&0===u.length||u[u.length-1]!==o){var I=t.arrowShapes[d[\"source-arrow-shape\"].value],z=t.arrowShapes[d[\"target-arrow-shape\"].value],y=y||o._private.source,m=m||o._private.target,E=m._private.position,D=y._private.position,L=s.getArrowWidth(d.width.pxValue),O=s.getArrowHeight(d.width.pxValue),R=L,X=O;(I.roughCollide(i,r,c.arrowStartX,c.arrowStartY,L,O,[c.arrowStartX-D.x,c.arrowStartY-D.y],0)&&I.collide(i,r,c.arrowStartX,c.arrowStartY,L,O,[c.arrowStartX-D.x,c.arrowStartY-D.y],0)||z.roughCollide(i,r,c.arrowEndX,c.arrowEndY,R,X,[c.arrowEndX-E.x,c.arrowEndY-E.y],0)&&z.collide(i,r,c.arrowEndX,c.arrowEndY,R,X,[c.arrowEndX-E.x,c.arrowEndY-E.y],0))&&u.push(o)}p&&u.length>0&&u[u.length-1]===o&&(a(y),a(m))}for(var s=this,l=this.getCachedZSortedEles(),u=[],c=t.isTouch,d=this.data.cy.zoom(),p=this.data.cy.hasCompoundNodes(),h=(c?256:32)/d,v=(c?16:0)/d,g=l.length-1;g>=0;g--){var f=l[g];if(u.length>0)break;\"nodes\"===f._private.group?a(l[g]):o(l[g])}return u.length>0?u[u.length-1]:null},t.prototype.getAllInBox=function(i,r,n,a){var o=this.getCachedNodes(),s=this.getCachedEdges(),l=[],u=Math.min(i,n),c=Math.max(i,n),d=Math.min(r,a),p=Math.max(r,a);i=u,n=c,r=d,a=p;for(var h,v=0;v<o.length;v++){var g=o[v]._private.position,f=this.getNodeShape(o[v]),y=this.getNodeWidth(o[v]),m=this.getNodeHeight(o[v]),x=o[v]._private.style[\"border-width\"].pxValue/2,b=t.nodeShapes[f];b.intersectBox(i,r,n,a,y,m,g.x,g.y,x)&&l.push(o[v])}for(var v=0;v<s.length;v++){var w=s[v]._private.rscratch;if(\"self\"==s[v]._private.rscratch.edgeType&&((h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,w.cp2ax,w.cp2ay,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkBezierInBox(i,r,n,a,w.startX,w.startY,w.cp2ax,w.cp2ay,w.endX,w.endY,s[v]._private.style.width.pxValue))||(h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,w.cp2cx,w.cp2cy,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkBezierInBox(i,r,n,a,w.startX,w.startY,w.cp2cx,w.cp2cy,w.endX,w.endY,s[v]._private.style.width.pxValue)))&&l.push(s[v]),\"bezier\"==w.edgeType&&(h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,w.cp2x,w.cp2y,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkBezierInBox(i,r,n,a,w.startX,w.startY,w.cp2x,w.cp2y,w.endX,w.endY,s[v]._private.style.width.pxValue))&&l.push(s[v]),\"straight\"==w.edgeType&&(h=e.math.boxInBezierVicinity(i,r,n,a,w.startX,w.startY,.5*w.startX+.5*w.endX,.5*w.startY+.5*w.endY,w.endX,w.endY,s[v]._private.style.width.pxValue))&&(2==h||1==h&&e.math.checkStraightEdgeInBox(i,r,n,a,w.startX,w.startY,w.endX,w.endY,s[v]._private.style.width.pxValue))&&l.push(s[v]),\"haystack\"==w.edgeType){var _=s[v].target()[0],E=_.position(),S=s[v].source()[0],P=S.position(),D=P.x+w.source.x,k=P.y+w.source.y,C=E.x+w.target.x,T=E.y+w.target.y,N=D>=i&&n>=D&&k>=r&&a>=k,M=C>=i&&n>=C&&T>=r&&a>=T;N&&M&&l.push(s[v])}}return l},t.prototype.getNodeWidth=function(e){return e.width()},t.prototype.getNodeHeight=function(e){return e.height()},t.prototype.getNodeShape=function(e){var t=e._private.style.shape.value;return e.isParent()?\"rectangle\"===t||\"roundrectangle\"===t?t:\"rectangle\":t},t.prototype.getNodePadding=function(e){var t=e._private.style[\"padding-left\"].pxValue,i=e._private.style[\"padding-right\"].pxValue,r=e._private.style[\"padding-top\"].pxValue,n=e._private.style[\"padding-bottom\"].pxValue;return isNaN(t)&&(t=0),isNaN(i)&&(i=0),isNaN(r)&&(r=0),isNaN(n)&&(n=0),{left:t,right:i,top:r,bottom:n}},t.prototype.zOrderSort=e.Collection.zIndexSort,t.prototype.updateCachedZSortedEles=function(){this.getCachedZSortedEles(!0)},t.prototype.getCachedZSortedEles=function(e){var t=this.lastZOrderCachedNodes,i=this.lastZOrderCachedEdges,r=this.getCachedNodes(),n=this.getCachedEdges(),a=[];if(!e&&t&&i&&t===r&&i===n)a=this.cachedZSortedEles;else{for(var o=0;o<r.length;o++)r[o].visible()&&!r[o].transparent()&&a.push(r[o]);for(var o=0;o<n.length;o++)n[o].visible()&&!n[o].transparent()&&a.push(n[o]);a.sort(this.zOrderSort),this.cachedZSortedEles=a}return this.lastZOrderCachedNodes=r,this.lastZOrderCachedEdges=n,a},t.prototype.projectBezier=function(t){function i(e){a.push({x:r(e[0],e[2],e[4],.05),y:r(e[1],e[3],e[5],.05)}),a.push({x:r(e[0],e[2],e[4],.25),y:r(e[1],e[3],e[5],.25)}),a.push({x:r(e[0],e[2],e[4],.4),y:r(e[1],e[3],e[5],.4)});var t={x:r(e[0],e[2],e[4],.5),y:r(e[1],e[3],e[5],.5)};a.push(t),\"self\"===n.edgeType?(n.midX=n.selfEdgeMidX,n.midY=n.selfEdgeMidY):(n.midX=t.x,n.midY=t.y),a.push({x:r(e[0],e[2],e[4],.6),y:r(e[1],e[3],e[5],.6)}),a.push({x:r(e[0],e[2],e[4],.75),y:r(e[1],e[3],e[5],.75)}),a.push({x:r(e[0],e[2],e[4],.95),y:r(e[1],e[3],e[5],.95)})}var r=e.math.qbezierAt,n=t._private.rscratch,a=t._private.rstyle.bezierPts=[];\"self\"===n.edgeType?(i([n.startX,n.startY,n.cp2ax,n.cp2ay,n.selfEdgeMidX,n.selfEdgeMidY]),i([n.selfEdgeMidX,n.selfEdgeMidY,n.cp2cx,n.cp2cy,n.endX,n.endY])):\"bezier\"===n.edgeType&&i([n.startX,n.startY,n.cp2x,n.cp2y,n.endX,n.endY])},t.prototype.recalculateNodeLabelProjection=function(e){var t=e._private.style.content.strValue;if(t&&!t.match(/^\\s+$/)){var i,r,n=e.outerWidth(),a=e.outerHeight(),o=e._private.position,s=e._private.style[\"text-halign\"].strValue,l=e._private.style[\"text-valign\"].strValue,u=e._private.rscratch,c=e._private.rstyle;switch(s){case\"left\":i=o.x-n/2;break;case\"right\":i=o.x+n/2;break;default:i=o.x}switch(l){case\"top\":r=o.y-a/2;break;case\"bottom\":r=o.y+a/2;break;default:r=o.y}u.labelX=i,u.labelY=r,c.labelX=i,c.labelY=r,this.applyLabelDimensions(e)}},t.prototype.recalculateEdgeLabelProjection=function(t){var i=t._private.style.content.strValue;if(i&&!i.match(/^\\s+$/)){var r,n,a,o,s=t._private.rscratch,l=t._private.rstyle;if(\"self\"==s.edgeType)a=s.selfEdgeMidX,o=s.selfEdgeMidY;else if(\"straight\"==s.edgeType)a=(s.startX+s.endX)/2,o=(s.startY+s.endY)/2;else if(\"bezier\"==s.edgeType)a=e.math.qbezierAt(s.startX,s.cp2x,s.endX,.5),o=e.math.qbezierAt(s.startY,s.cp2y,s.endY,.5);else if(\"haystack\"==s.edgeType){var u=t._private.source._private.position,c=t._private.target._private.position;a=(u.x+s.source.x+c.x+s.target.x)/2,o=(u.y+s.source.y+c.y+s.target.y)/2}r=a,n=o,s.labelX=r,s.labelY=n,l.labelX=r,l.labelY=n,this.applyLabelDimensions(t)}},t.prototype.applyLabelDimensions=function(e){var t=e._private.rscratch,i=e._private.rstyle,r=this.getLabelText(e),n=this.calculateLabelDimensions(e,r);i.labelWidth=n.width,t.labelWidth=n.width,i.labelHeight=n.height,t.labelHeight=n.height},t.prototype.getLabelText=function(e){var t=e._private.style,i=e._private.style.content.strValue,r=t[\"text-transform\"].value;return\"none\"==r||(\"uppercase\"==r?i=i.toUpperCase():\"lowercase\"==r&&(i=i.toLowerCase())),i},t.prototype.calculateLabelDimensions=function(e,t){var i=this,r=e._private.style,n=r[\"font-style\"].strValue,a=r[\"font-size\"].pxValue+\"px\",o=r[\"font-family\"].strValue,s=r[\"font-weight\"].strValue,l=e._private.labelKey,u=i.labelDimCache||(i.labelDimCache={});if(u[l])return u[l];var c=this.labelCalcDiv;c||(c=this.labelCalcDiv=document.createElement(\"div\"),document.body.appendChild(c));var d=c.style;return d.fontFamily=o,d.fontStyle=n,d.fontSize=a,d.fontWeight=s,d.position=\"absolute\",d.left=\"-9999px\",d.top=\"-9999px\",d.zIndex=\"-1\",d.visibility=\"hidden\",d.pointerEvents=\"none\",d.padding=\"0\",d.lineHeight=\"1\",c.textContent=t,u[l]={width:c.clientWidth,height:c.clientHeight},u[l]},t.prototype.recalculateRenderedStyle=function(e){for(var t=[],i=[],r={},n=0;n<e.length;n++){var a=e[n],o=a._private,s=o.rscratch,l=o.rstyle,u=o.data.id,c=null!=s.boundingBoxKey&&o.boundingBoxKey===s.boundingBoxKey,d=null!=s.labelKey&&o.labelKey===s.labelKey,p=c&&d;if(\"nodes\"===a._private.group){var h=o.position,v=null!=l.nodeX&&null!=l.nodeY&&h.x===l.nodeX&&h.y===l.nodeY;v&&p||i.push(a),l.nodeX=h.x,l.nodeY=h.y}else{var g=a._private.source._private.position,f=a._private.target._private.position,y=null!=l.srcX&&null!=l.srcY&&g.x===l.srcX&&g.y===l.srcY,m=null!=l.tgtX&&null!=l.tgtY&&f.x===l.tgtX&&f.y===l.tgtY,x=y&&m;if(!x||!p){var b=o.style[\"curve-style\"].value;if(\"bezier\"===b){if(!r[u]){t.push(a),r[u]=!0;for(var w=a.parallelEdges(),n=0;n<w.length;n++){var _=w[n],E=_._private.data.id;r[E]||(t.push(_),r[E]=!0)}}}else t.push(a)}l.srcX=g.x,l.srcY=g.y,l.tgtX=f.x,l.tgtY=f.y}s.boundingBoxKey=o.boundingBoxKey,s.labelKey=o.labelKey}this.recalculateEdgeProjections(t),this.recalculateLabelProjections(i,t)},t.prototype.recalculateLabelProjections=function(e,t){for(var i=0;i<e.length;i++)this.recalculateNodeLabelProjection(e[i]);for(var i=0;i<t.length;i++)this.recalculateEdgeLabelProjection(t[i])},t.prototype.recalculateEdgeProjections=function(e){this.findEdgeControlPoints(e)},t.prototype.findEdgeControlPoints=function(i){if(i&&0!==i.length){for(var r,n={},a=[],o=[],s=0;s<i.length;s++){var l=i[s],u=l._private.style,c=\"unbundled-bezier\"===u[\"curve-style\"].value;if(\"none\"!==u.display.value)if(\"haystack\"!==u[\"curve-style\"].value){var d=l._private.data.source,p=l._private.data.target;r=d>p?p+\"-\"+d:d+\"-\"+p,c&&(r=\"unbundled\"+l._private.data.id),null==n[r]&&(n[r]=[],a.push(r)),n[r].push(l),c&&(n[r].hasUnbundled=!0)}else o.push(l)}for(var h,v,g,f,y,m,x,b,w,_,E,S,P,D,k=0;k<a.length;k++){r=a[k];var C=n[r];if(C.sort(function(e,t){return e._private.index-t._private.index}),h=C[0]._private.source,v=C[0]._private.target,h._private.data.id>v._private.data.id){var T=h;h=v,v=T}if(g=h._private.position,f=v._private.position,y=this.getNodeWidth(h),m=this.getNodeHeight(h),x=this.getNodeWidth(v),b=this.getNodeHeight(v),w=t.nodeShapes[this.getNodeShape(h)],_=t.nodeShapes[this.getNodeShape(v)],E=h._private.style[\"border-width\"].pxValue,S=v._private.style[\"border-width\"].pxValue,D=!1,C.length>1&&h!==v||C.hasUnbundled){var N=w.intersectLine(g.x,g.y,y,m,f.x,f.y,E/2),M=_.intersectLine(f.x,f.y,x,b,g.x,g.y,S/2),B={x1:N[0],x2:M[0],y1:N[1],y2:M[1]},I=M[1]-N[1],z=M[0]-N[0],L=Math.sqrt(z*z+I*I),O={x:z,y:I},R={x:O.x/L,y:O.y/L};P={x:-R.y,y:R.x},(_.checkPoint(N[0],N[1],S/2,x,b,f.x,f.y)||w.checkPoint(M[0],M[1],E/2,y,m,g.x,g.y))&&(P={},D=!0)}for(var l,X,s=0;s<C.length;s++){l=C[s],X=l._private.rscratch;var V=X.lastEdgeIndex,Y=s,A=X.lastNumEdges,q=C.length,F=l._private.style,j=F[\"control-point-step-size\"].pxValue,W=void 0!==F[\"control-point-distance\"]?F[\"control-point-distance\"].pxValue:void 0,H=F[\"control-point-weight\"].value,c=\"unbundled-bezier\"===F[\"curve-style\"].value,$=X.lastSrcCtlPtX,Z=g.x,U=X.lastSrcCtlPtY,G=g.y,K=X.lastSrcCtlPtW,J=h.outerWidth(),Q=X.lastSrcCtlPtH,et=h.outerHeight(),tt=X.lastTgtCtlPtX,it=f.x,rt=X.lastTgtCtlPtY,nt=f.y,at=X.lastTgtCtlPtW,ot=v.outerWidth(),st=X.lastTgtCtlPtH,lt=v.outerHeight();\nif(X.badBezier=D?!0:!1,$!==Z||U!==G||K!==J||Q!==et||tt!==it||rt!==nt||at!==ot||st!==lt||!(V===Y&&A===q||c)){if(X.lastSrcCtlPtX=Z,X.lastSrcCtlPtY=G,X.lastSrcCtlPtW=J,X.lastSrcCtlPtH=et,X.lastTgtCtlPtX=it,X.lastTgtCtlPtY=nt,X.lastTgtCtlPtW=ot,X.lastTgtCtlPtH=lt,X.lastEdgeIndex=Y,X.lastNumEdges=q,h===v){X.edgeType=\"self\";var ut=s,ct=j;c&&(ut=0,ct=W),X.cp2ax=g.x,X.cp2ay=g.y-(1+Math.pow(m,1.12)/100)*ct*(ut/3+1),X.cp2cx=h._private.position.x-(1+Math.pow(y,1.12)/100)*ct*(ut/3+1),X.cp2cy=g.y,X.selfEdgeMidX=(X.cp2ax+X.cp2cx)/2,X.selfEdgeMidY=(X.cp2ay+X.cp2cy)/2}else if(C.length%2!==1||s!==Math.floor(C.length/2)||c){var dt,pt=(.5-C.length/2+s)*j,ht=e.math.signum(pt);dt=c?W:void 0!==W?ht*W:void 0;var vt=void 0!==dt?dt:pt,gt=1-H,ft=H,yt=l._private.source!==h;yt&&(gt=H,ft=1-H);var mt={x:B.x1*gt+B.x2*ft,y:B.y1*gt+B.y2*ft};X.edgeType=\"bezier\",X.cp2x=mt.x+P.x*vt,X.cp2y=mt.y+P.y*vt}else X.edgeType=\"straight\";this.findEndpoints(l);var xt=!e.is.number(X.startX)||!e.is.number(X.startY),bt=!e.is.number(X.arrowStartX)||!e.is.number(X.arrowStartY),wt=!e.is.number(X.endX)||!e.is.number(X.endY),_t=!e.is.number(X.arrowEndX)||!e.is.number(X.arrowEndY),Et=3,St=this.getArrowWidth(l._private.style.width.pxValue)*t.arrowShapeHeight,Pt=Et*St,Dt=e.math.distance({x:X.cp2x,y:X.cp2y},{x:X.startX,y:X.startY}),kt=Pt>Dt,Ct=e.math.distance({x:X.cp2x,y:X.cp2y},{x:X.endX,y:X.endY}),Tt=Pt>Ct;if(\"bezier\"===X.edgeType){var Nt=!1;if(xt||bt||kt){Nt=!0;var Mt={x:X.cp2x-g.x,y:X.cp2y-g.y},Bt=Math.sqrt(Mt.x*Mt.x+Mt.y*Mt.y),It={x:Mt.x/Bt,y:Mt.y/Bt},zt=Math.max(y,m),Lt={x:X.cp2x+2*It.x*zt,y:X.cp2y+2*It.y*zt},Ot=w.intersectLine(g.x,g.y,y,m,Lt.x,Lt.y,E/2);kt?(X.cp2x=X.cp2x+It.x*(Pt-Dt),X.cp2y=X.cp2y+It.y*(Pt-Dt)):(X.cp2x=Ot[0]+It.x*Pt,X.cp2y=Ot[1]+It.y*Pt)}if(wt||_t||Tt){Nt=!0;var Mt={x:X.cp2x-f.x,y:X.cp2y-f.y},Bt=Math.sqrt(Mt.x*Mt.x+Mt.y*Mt.y),It={x:Mt.x/Bt,y:Mt.y/Bt},zt=Math.max(y,m),Lt={x:X.cp2x+2*It.x*zt,y:X.cp2y+2*It.y*zt},Rt=_.intersectLine(f.x,f.y,x,b,Lt.x,Lt.y,S/2);Tt?(X.cp2x=X.cp2x+It.x*(Pt-Ct),X.cp2y=X.cp2y+It.y*(Pt-Ct)):(X.cp2x=Rt[0]+It.x*Pt,X.cp2y=Rt[1]+It.y*Pt)}Nt&&this.findEndpoints(l)}else\"straight\"===X.edgeType&&(X.midX=(Z+it)/2,X.midY=(G+nt)/2);this.projectBezier(l)}}}for(var s=0;s<o.length;s++){var l=o[s],Xt=l._private.rscratch;if(!Xt.haystack){var Vt=2*Math.random()*Math.PI;Xt.source={x:Math.cos(Vt),y:Math.sin(Vt)};var Vt=2*Math.random()*Math.PI;Xt.target={x:Math.cos(Vt),y:Math.sin(Vt)},Xt.edgeType=\"haystack\",Xt.haystack=!0}}return n}},t.prototype.findEndpoints=function(i){var r,n=i.source()[0],a=i.target()[0],o=i._private.style[\"target-arrow-shape\"].value,s=i._private.style[\"source-arrow-shape\"].value,l=a._private.style[\"border-width\"].pxValue,u=n._private.style[\"border-width\"].pxValue,c=i._private.rscratch;if(\"self\"==i._private.rscratch.edgeType){var d=[c.cp2cx,c.cp2cy];r=t.nodeShapes[this.getNodeShape(a)].intersectLine(a._private.position.x,a._private.position.y,this.getNodeWidth(a),this.getNodeHeight(a),d[0],d[1],l/2);var p=e.math.shortenIntersection(r,d,t.arrowShapes[o].spacing(i)),h=e.math.shortenIntersection(r,d,t.arrowShapes[o].gap(i));c.endX=h[0],c.endY=h[1],c.arrowEndX=p[0],c.arrowEndY=p[1];var d=[c.cp2ax,c.cp2ay];r=t.nodeShapes[this.getNodeShape(n)].intersectLine(n._private.position.x,n._private.position.y,this.getNodeWidth(n),this.getNodeHeight(n),d[0],d[1],u/2);var v=e.math.shortenIntersection(r,d,t.arrowShapes[s].spacing(i)),g=e.math.shortenIntersection(r,d,t.arrowShapes[s].gap(i));c.startX=g[0],c.startY=g[1],c.arrowStartX=v[0],c.arrowStartY=v[1]}else if(\"straight\"==c.edgeType){r=t.nodeShapes[this.getNodeShape(a)].intersectLine(a._private.position.x,a._private.position.y,this.getNodeWidth(a),this.getNodeHeight(a),n.position().x,n.position().y,l/2),c.noArrowPlacement=0===r.length?!0:!1;var p=e.math.shortenIntersection(r,[n.position().x,n.position().y],t.arrowShapes[o].spacing(i)),h=e.math.shortenIntersection(r,[n.position().x,n.position().y],t.arrowShapes[o].gap(i));c.endX=h[0],c.endY=h[1],c.arrowEndX=p[0],c.arrowEndY=p[1],r=t.nodeShapes[this.getNodeShape(n)].intersectLine(n._private.position.x,n._private.position.y,this.getNodeWidth(n),this.getNodeHeight(n),a.position().x,a.position().y,u/2),c.noArrowPlacement=0===r.length?!0:!1;var v=e.math.shortenIntersection(r,[a.position().x,a.position().y],t.arrowShapes[s].spacing(i)),g=e.math.shortenIntersection(r,[a.position().x,a.position().y],t.arrowShapes[s].gap(i));c.startX=g[0],c.startY=g[1],c.arrowStartX=v[0],c.arrowStartY=v[1]}else if(\"bezier\"==c.edgeType){var d=[c.cp2x,c.cp2y];r=t.nodeShapes[this.getNodeShape(a)].intersectLine(a._private.position.x,a._private.position.y,this.getNodeWidth(a),this.getNodeHeight(a),d[0],d[1],l/2);var p=e.math.shortenIntersection(r,d,t.arrowShapes[o].spacing(i)),h=e.math.shortenIntersection(r,d,t.arrowShapes[o].gap(i));c.endX=h[0],c.endY=h[1],c.arrowEndX=p[0],c.arrowEndY=p[1],r=t.nodeShapes[this.getNodeShape(n)].intersectLine(n._private.position.x,n._private.position.y,this.getNodeWidth(n),this.getNodeHeight(n),d[0],d[1],u/2);var v=e.math.shortenIntersection(r,d,t.arrowShapes[s].spacing(i)),g=e.math.shortenIntersection(r,d,t.arrowShapes[s].gap(i));c.startX=g[0],c.startY=g[1],c.arrowStartX=v[0],c.arrowStartY=v[1]}else if(c.isArcEdge)return},t.prototype.findEdges=function(e){for(var t=this.getCachedEdges(),i={},r=[],n=0;n<e.length;n++)i[e[n]._private.data.id]=e[n];for(var n=0;n<t.length;n++)(i[t[n]._private.data.source]||i[t[n]._private.data.target])&&r.push(t[n]);return r},t.prototype.getArrowWidth=t.prototype.getArrowHeight=function(e){var t=this.arrowWidthCache=this.arrowWidthCache||{},i=t[e];return i?i:(i=Math.max(Math.pow(13.37*e,.9),29),t[e]=i,i)}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.drawEdge=function(e,i,r){var n=i._private.rscratch,a=t.usePaths();if(!n.badBezier&&(\"bezier\"!==n.edgeType&&\"straight\"!==n.edgeType||!isNaN(n.startX))){var o=i._private.style;if(!(o.width.pxValue<=0)){var s=o[\"overlay-padding\"].pxValue,l=o[\"overlay-opacity\"].value,u=o[\"overlay-color\"].value;if(r){if(0===l)return;this.strokeStyle(e,u[0],u[1],u[2],l),e.lineCap=\"round\",\"self\"!=i._private.rscratch.edgeType||a||(e.lineCap=\"butt\")}else{var c=o[\"line-color\"].value;this.strokeStyle(e,c[0],c[1],c[2],o.opacity.value),e.lineCap=\"butt\"}var d,p,h,v;h=d=i._private.source,v=p=i._private.target;var g=v._private.position,f=v.width(),y=v.height(),m=h._private.position,x=h.width(),b=h.height(),w=o.width.pxValue+(r?2*s:0),_=r?\"solid\":o[\"line-style\"].value;if(e.lineWidth=w,\"haystack\"!==n.edgeType,\"haystack\"===n.edgeType){var E=o[\"haystack-radius\"].value,S=E/2;this.drawStyledEdge(i,e,n.haystackPts=[n.source.x*x*S+m.x,n.source.y*b*S+m.y,n.target.x*f*S+g.x,n.target.y*y*S+g.y],_,w)}else if(\"self\"===n.edgeType){var P=i._private.rscratch,D=[P.startX,P.startY,P.cp2ax,P.cp2ay,P.selfEdgeMidX,P.selfEdgeMidY,P.selfEdgeMidX,P.selfEdgeMidY,P.cp2cx,P.cp2cy,P.endX,P.endY],P=i._private.rscratch;this.drawStyledEdge(i,e,D,_,w)}else if(\"straight\"===n.edgeType){var k=p._private.position.x-d._private.position.x,C=p._private.position.y-d._private.position.y,T=n.endX-n.startX,N=n.endY-n.startY;if(0>k*T+C*N)n.straightEdgeTooShort=!0;else{var P=n;this.drawStyledEdge(i,e,[P.startX,P.startY,P.endX,P.endY],_,w),n.straightEdgeTooShort=!1}}else{var P=n;this.drawStyledEdge(i,e,[P.startX,P.startY,P.cp2x,P.cp2y,P.endX,P.endY],_,w)}\"haystack\"===n.edgeType?this.drawArrowheads(e,i,r):n.noArrowPlacement!==!0&&void 0!==n.startX&&this.drawArrowheads(e,i,r)}}},t.prototype.drawStyledEdge=function(e,i,r,n){var a,o=e._private.rscratch,s=i,l=!1,u=t.usePaths();if(u){for(var c=r,d=o.pathCacheKey&&c.length===o.pathCacheKey.length,p=d,h=0;p&&h<c.length;h++)o.pathCacheKey[h]!==c[h]&&(p=!1);p?(a=i=o.pathCache,l=!0):(a=i=new Path2D,o.pathCacheKey=c,o.pathCache=a)}if(s.setLineDash)switch(n){case\"dotted\":s.setLineDash([1,1]);break;case\"dashed\":s.setLineDash([6,3]);break;case\"solid\":s.setLineDash([])}l||(i.beginPath&&i.beginPath(),i.moveTo(r[0],r[1]),6===r.length?i.quadraticCurveTo(r[2],r[3],r[4],r[5]):12===r.length?(i.quadraticCurveTo(r[2],r[3],r[4],r[5]),i.quadraticCurveTo(r[8],r[9],r[10],r[11])):i.lineTo(r[2],r[3])),i=s,u?i.stroke(a):i.stroke(),i.setLineDash&&i.setLineDash([])},t.prototype.drawArrowheads=function(e,t,i){function r(i,r,n,a,o){var s=g[i+\"-arrow-shape\"].value;if(\"none\"!==s){var l=e.globalCompositeOperation;e.globalCompositeOperation=\"destination-out\",d.fillStyle(e,255,255,255,1);var u=\"hollow\"===g[i+\"-arrow-fill\"].value?\"both\":\"filled\",c=g[i+\"-arrow-fill\"].value;\"half-triangle-overshot\"===s&&(c=\"hollow\",u=\"hollow\"),d.drawArrowShape(t,i,e,u,g.width.pxValue,g[i+\"-arrow-shape\"].value,r,n,a,o),e.globalCompositeOperation=l;var p=g[i+\"-arrow-color\"].value;d.fillStyle(e,p[0],p[1],p[2],g.opacity.value),d.drawArrowShape(t,i,e,c,g.width.pxValue,g[i+\"-arrow-shape\"].value,r,n,a,o)}}if(!i){var n,a,o,s,l,u,c=t._private.rscratch,d=this,p=\"haystack\"===c.edgeType,h=t.source().position(),v=t.target().position();p?(o=c.haystackPts[0],s=c.haystackPts[1],l=c.haystackPts[2],u=c.haystackPts[3]):(o=c.arrowStartX,s=c.arrowStartY,l=c.arrowEndX,u=c.arrowEndY);var g=t._private.style;n=o-h.x,a=s-h.y,p||isNaN(o)||isNaN(s)||isNaN(n)||isNaN(a)||r(\"source\",o,s,n,a);var f=c.midX,y=c.midY;p&&(f=(o+l)/2,y=(s+u)/2),n=o-l,a=s-u,\"self\"===c.edgeType&&(n=1,a=-1),isNaN(f)||isNaN(y)||r(\"mid-target\",f,y,n,a),n*=-1,a*=-1,isNaN(f)||isNaN(y)||r(\"mid-source\",f,y,n,a),n=l-v.x,a=u-v.y,p||isNaN(l)||isNaN(u)||isNaN(n)||isNaN(a)||r(\"target\",l,u,n,a)}},t.prototype.drawArrowShape=function(e,i,r,n,a,o,s,l,u,c){var d,p=t.usePaths(),h=e._private.rscratch,v=!1,g=r,f={x:s,y:l},y=Math.asin(c/Math.sqrt(u*u+c*c));0>u?y+=Math.PI/2:y=-(Math.PI/2+y);var m=this.getArrowWidth(a),x=t.arrowShapes[o];if(p){var b=m+\"$\"+o+\"$\"+y+\"$\"+s+\"$\"+l;h.arrowPathCacheKey=h.arrowPathCacheKey||{},h.arrowPathCache=h.arrowPathCache||{};var w=h.arrowPathCacheKey[i]===b;w?(d=r=h.arrowPathCache[i],v=!0):(d=r=new Path2D,h.arrowPathCacheKey[i]=b,h.arrowPathCache[i]=d)}r.beginPath&&r.beginPath(),v||x.draw(r,m,y,f),!x.leavePathOpen&&r.closePath&&r.closePath(),r=g,(\"filled\"===n||\"both\"===n)&&(p?r.fill(d):r.fill()),(\"hollow\"===n||\"both\"===n)&&(r.lineWidth=x.matchEdgeWidth?a:1,r.lineJoin=\"miter\",p?r.stroke(d):r.stroke())}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.getCachedImage=function(e,t){var i=this,r=i.imageCache=i.imageCache||{};if(r[e]&&r[e].image)return r[e].image;var n=r[e]=r[e]||{},a=n.image=new Image;return a.addEventListener(\"load\",t),a.src=e,a},t.prototype.drawInscribedImage=function(e,i,r){var n=this,a=r._private.position.x,o=r._private.position.y,s=r._private.style,l=s[\"background-fit\"].value,u=s[\"background-position-x\"],c=s[\"background-position-y\"],d=s[\"background-repeat\"].value,p=r.width(),h=r.height(),v=r._private.rscratch,g=s[\"background-clip\"].value,f=\"node\"===g,y=s[\"background-image-opacity\"].value,m=i.width,x=i.height;if(0!==m&&0!==x){if(\"contain\"===l){var b=Math.min(p/m,h/x);m*=b,x*=b}else if(\"cover\"===l){var b=Math.max(p/m,h/x);m*=b,x*=b}var w=a-p/2;w+=\"%\"===u.units?(p-m)*u.value/100:u.pxValue;var _=o-h/2;_+=\"%\"===c.units?(h-x)*c.value/100:c.pxValue,v.pathCache&&(w-=a,_-=o,a=0,o=0);var E=e.globalAlpha;if(e.globalAlpha=y,\"no-repeat\"===d)f&&(e.save(),v.pathCache?e.clip(v.pathCache):(t.nodeShapes[n.getNodeShape(r)].drawPath(e,a,o,p,h),e.clip())),e.drawImage(i,0,0,i.width,i.height,w,_,m,x),f&&e.restore();else{var S=e.createPattern(i,d);e.fillStyle=S,t.nodeShapes[n.getNodeShape(r)].drawPath(e,a,o,p,h),e.translate(w,_),e.fill(),e.translate(-w,-_)}e.globalAlpha=E}}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.drawEdgeText=function(e,t){var i=t._private.style.content.strValue;if(!(!i||i.match(/^\\s+$/)||this.hideEdgesOnViewport&&(this.dragData.didDrag||this.pinching||this.hoverData.dragging||this.data.wheel||this.swipePanning))){var r=t._private.style[\"font-size\"].pxValue*t.cy().zoom(),n=t._private.style[\"min-zoomed-font-size\"].pxValue;if(!(n>r)){e.textAlign=\"center\",e.textBaseline=\"middle\";var a=t._private.rscratch;this.drawText(e,t,a.labelX,a.labelY)}}},t.prototype.drawNodeText=function(e,t){var i=t._private.style.content.strValue;if(i&&!i.match(/^\\s+$/)){var r=t._private.style[\"font-size\"].pxValue*t.cy().zoom(),n=t._private.style[\"min-zoomed-font-size\"].pxValue;if(!(n>r)){var a=t._private.style[\"text-halign\"].strValue,o=t._private.style[\"text-valign\"].strValue,s=t._private.rscratch;switch(a){case\"left\":e.textAlign=\"right\";break;case\"right\":e.textAlign=\"left\";break;default:e.textAlign=\"center\"}switch(o){case\"top\":e.textBaseline=\"bottom\";break;case\"bottom\":e.textBaseline=\"top\";break;default:e.textBaseline=\"middle\"}this.drawText(e,t,s.labelX,s.labelY)}}},t.prototype.getFontCache=function(e){var t;this.fontCaches=this.fontCaches||[];for(var i=0;i<this.fontCaches.length;i++)if(t=this.fontCaches[i],t.context===e)return t;return t={context:e},this.fontCaches.push(t),t},t.prototype.setupTextStyle=function(e,t){var i=t.effectiveOpacity(),r=t._private.style,n=r[\"font-style\"].strValue,a=r[\"font-size\"].pxValue+\"px\",o=r[\"font-family\"].strValue,s=r[\"font-weight\"].strValue,l=r[\"text-opacity\"].value*r.opacity.value*i,u=r[\"text-outline-opacity\"].value*l,c=r.color.value,d=r[\"text-outline-color\"].value,p=t._private.fontKey,h=this.getFontCache(e);h.key!==p&&(e.font=n+\" \"+s+\" \"+a+\" \"+o,h.key=p);var v=String(r.content.value),g=r[\"text-transform\"].value;return\"none\"==g||(\"uppercase\"==g?v=v.toUpperCase():\"lowercase\"==g&&(v=v.toLowerCase())),e.lineJoin=\"round\",this.fillStyle(e,c[0],c[1],c[2],l),this.strokeStyle(e,d[0],d[1],d[2],u),v},t.prototype.drawText=function(e,t,i,r){var n=t._private.style,a=t.effectiveOpacity();if(0!==a){var o=this.setupTextStyle(e,t);if(null!=o&&!isNaN(i)&&!isNaN(r)){var s=2*n[\"text-outline-width\"].value;s>0&&(e.lineWidth=s,e.strokeText(o,i,r)),e.fillText(o,i,r)}}}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.drawNode=function(e,i,r){var n,a,o,s=this,l=i._private.style,u=i._private.rscratch,c=t.usePaths(),d=e,p=!1,h=l[\"overlay-padding\"].pxValue,v=l[\"overlay-opacity\"].value,g=l[\"overlay-color\"].value;if(!r||0!==v){var f=i.effectiveOpacity();if(0!==f)if(n=this.getNodeWidth(i),a=this.getNodeHeight(i),e.lineWidth=l[\"border-width\"].pxValue,void 0!==r&&r)v>0&&(this.fillStyle(e,g[0],g[1],g[2],v),t.nodeShapes.roundrectangle.drawPath(e,i._private.position.x,i._private.position.y,n+2*h,a+2*h),e.fill());else{var y=l[\"background-color\"].value,m=l[\"border-color\"].value,x=l[\"border-style\"].value;if(this.fillStyle(e,y[0],y[1],y[2],l[\"background-opacity\"].value*l.opacity.value*f),this.strokeStyle(e,m[0],m[1],m[2],l[\"border-opacity\"].value*l.opacity.value*f),e.lineJoin=\"miter\",e.setLineDash)switch(x){case\"dotted\":e.setLineDash([1,1]);break;case\"dashed\":e.setLineDash([4,2]);break;case\"solid\":case\"double\":e.setLineDash([])}var b=l[\"background-image\"].value[2]||l[\"background-image\"].value[1],w=l.shape.strValue,_=i._private.position;if(c){var E=w+\"$\"+n+\"$\"+a;e.translate(_.x,_.y),u.pathCacheKey===E?(o=e=u.pathCache,p=!0):(o=e=new Path2D,u.pathCacheKey=E,u.pathCache=o)}if(!p){var S=_;c&&(S={x:0,y:0}),t.nodeShapes[this.getNodeShape(i)].drawPath(e,S.x,S.y,n,a)}if(e=d,c?e.fill(o):e.fill(),void 0!==b){var P=this.getCachedImage(b,function(){s.data.canvasNeedsRedraw[t.NODE]=!0,s.data.canvasNeedsRedraw[t.DRAG]=!0,s.redraw()});P.complete&&this.drawInscribedImage(e,P,i)}var D=l[\"background-blacken\"].value,k=l[\"border-width\"].pxValue;if(this.hasPie(i)&&(this.drawPie(e,i),(0!==D||0!==k)&&(c||t.nodeShapes[this.getNodeShape(i)].drawPath(e,_.x,_.y,n,a))),D>0?(this.fillStyle(e,0,0,0,D),c?e.fill(o):e.fill()):0>D&&(this.fillStyle(e,255,255,255,-D),c?e.fill(o):e.fill()),k>0&&(c?e.stroke(o):e.stroke(),\"double\"===x)){e.lineWidth=l[\"border-width\"].pxValue/3;var C=e.globalCompositeOperation;e.globalCompositeOperation=\"destination-out\",c?e.stroke(o):e.stroke(),e.globalCompositeOperation=C}c&&e.translate(-_.x,-_.y),e.setLineDash&&e.setLineDash([])}}},t.prototype.hasPie=function(e){return e=e[0],e._private.hasPie},t.prototype.drawPie=function(i,r){r=r[0];var n=r._private.style[\"pie-size\"],a=this.getNodeWidth(r),o=this.getNodeHeight(r),s=r._private.position.x,l=r._private.position.y,u=Math.min(a,o)/2,c=0,d=t.usePaths();d&&(s=0,l=0),\"%\"===n.units?u=u*n.value/100:void 0!==n.pxValue&&(u=n.pxValue/2);for(var p=1;p<=e.style.pieBackgroundN;p++){var h=r._private.style[\"pie-\"+p+\"-background-size\"].value,v=r._private.style[\"pie-\"+p+\"-background-color\"].value,g=r._private.style[\"pie-\"+p+\"-background-opacity\"].value,f=h/100,y=1.5*Math.PI+2*Math.PI*c,m=2*Math.PI*f,x=y+m;0===h||c>=1||c+f>1||(i.beginPath(),i.moveTo(s,l),i.arc(s,l,u,y,x),i.closePath(),this.fillStyle(i,v[0],v[1],v[2],g),i.fill(),c+=f)}}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.getPixelRatio=function(){var e=this.data.contexts[0];if(null!=this.forcedPixelRatio)return this.forcedPixelRatio;var t=e.backingStorePixelRatio||e.webkitBackingStorePixelRatio||e.mozBackingStorePixelRatio||e.msBackingStorePixelRatio||e.oBackingStorePixelRatio||e.backingStorePixelRatio||1;return(window.devicePixelRatio||1)/t},t.prototype.paintCache=function(e){for(var t,i=this.paintCaches=this.paintCaches||[],r=!0,n=0;n<i.length;n++)if(t=i[n],t.context===e){r=!1;break}return r&&(t={context:e},i.push(t)),t},t.prototype.fillStyle=function(e,t,i,r,n){e.fillStyle=\"rgba(\"+t+\",\"+i+\",\"+r+\",\"+n+\")\"},t.prototype.strokeStyle=function(e,t,i,r,n){e.strokeStyle=\"rgba(\"+t+\",\"+i+\",\"+r+\",\"+n+\")\"},t.prototype.matchCanvasSize=function(e){var i,r=this.data,n=e.clientWidth,a=e.clientHeight,o=this.getPixelRatio(),s=n*o,l=a*o;if(s!==this.canvasWidth||l!==this.canvasHeight){this.fontCaches=null;var u=r.canvasContainer;u.style.width=n+\"px\",u.style.height=a+\"px\";for(var c=0;c<t.CANVAS_LAYERS;c++)i=r.canvases[c],(i.width!==s||i.height!==l)&&(i.width=s,i.height=l,i.style.width=n+\"px\",i.style.height=a+\"px\");for(var c=0;c<t.BUFFER_COUNT;c++)i=r.bufferCanvases[c],(i.width!==s||i.height!==l)&&(i.width=s,i.height=l,i.style.width=n+\"px\",i.style.height=a+\"px\");this.textureMult=1,1>=o&&(i=r.bufferCanvases[t.TEXTURE_BUFFER],this.textureMult=2,i.width=s*this.textureMult,i.height=l*this.textureMult),this.canvasWidth=s,this.canvasHeight=l}},t.prototype.renderTo=function(e,t,i,r){this.redraw({forcedContext:e,forcedZoom:t,forcedPan:i,drawAllLayers:!0,forcedPxRatio:r})},t.prototype.timeToRender=function(){return this.redrawTotalTime/this.redrawCount},t.minRedrawLimit=1e3/60,t.maxRedrawLimit=1e3,t.motionBlurDelay=100,t.prototype.redraw=function(i){function r(){function i(e,t){if(e.setTransform(1,0,0,1,0,0),\"motionBlur\"===t){var i=e.globalCompositeOperation;e.globalCompositeOperation=\"destination-out\",u.fillStyle(e,255,255,255,.666),e.fillRect(0,0,u.canvasWidth,u.canvasHeight),e.globalCompositeOperation=i}else n||void 0!==t&&!t||e.clearRect(0,0,u.canvasWidth,u.canvasHeight);a||(e.translate(b.x,b.y),e.scale(m,m)),l&&e.translate(l.x,l.y),s&&e.scale(s,s)}function r(e,t){for(var i=e.eles,r=0;r<i.length;r++){var n=i[r];n.isNode()?(u.drawNode(t,n),I||u.drawNodeText(t,n),u.drawNode(t,n,!0)):B||(u.drawEdge(t,n),I||u.drawEdgeText(t,n),u.drawEdge(t,n,!0))}}var g=u.getCachedEdges(),f=d.style()._private.coreStyle,y=d.zoom(),m=void 0!==s?s:y,x=d.pan(),b={x:x.x,y:x.y};l&&(b=l),m*=c,b.x*=c,b.y*=c;var _={drag:{nodes:[],edges:[],eles:[]},nondrag:{nodes:[],edges:[],eles:[]}},E=u.textureOnViewport&&!n&&(u.pinching||u.hoverData.dragging||u.swipePanning||u.data.wheelZooming);if(E){var S;if(!u.textureCache){u.textureCache={},S=u.textureCache.bb=d.elements().boundingBox(),u.textureCache.texture=u.data.bufferCanvases[t.TEXTURE_BUFFER];var P=u.data.bufferContexts[t.TEXTURE_BUFFER];P.setTransform(1,0,0,1,0,0),P.clearRect(0,0,u.canvasWidth*u.textureMult,u.canvasHeight*u.textureMult),u.redraw({forcedContext:P,drawOnlyNodeLayer:!0,forcedPxRatio:c*u.textureMult});var D=u.textureCache.viewport={zoom:d.zoom(),pan:d.pan(),width:u.canvasWidth,height:u.canvasHeight};D.mpan={x:(0-D.pan.x)/D.zoom,y:(0-D.pan.y)/D.zoom}}h[t.DRAG]=!1,h[t.NODE]=!1;var k=p.contexts[t.NODE],C=u.textureCache.texture,D=u.textureCache.viewport;S=u.textureCache.bb,k.setTransform(1,0,0,1,0,0),k.clearRect(0,0,D.width,D.height);var T=f[\"outside-texture-bg-color\"].value,N=f[\"outside-texture-bg-opacity\"].value;u.fillStyle(k,T[0],T[1],T[2],N),k.fillRect(0,0,D.width,D.height);var y=d.zoom();i(k,!1),k.clearRect(D.mpan.x,D.mpan.y,D.width/D.zoom/c,D.height/D.zoom/c),k.drawImage(C,D.mpan.x,D.mpan.y,D.width/D.zoom/c,D.height/D.zoom/c)}else u.textureOnViewport&&!n&&(u.textureCache=null);var M=u.pinching||u.hoverData.dragging||u.swipePanning||u.data.wheelZooming||u.hoverData.draggingEles,B=u.hideEdgesOnViewport&&M,I=u.hideLabelsOnViewport&&M;if(h[t.DRAG]||h[t.NODE]||a||o){B||u.findEdgeControlPoints(g);for(var z=u.getCachedZSortedEles(),L=d.extent(),O=0;O<z.length;O++){var R,X=z[O],S=n?null:X.boundingBox(),V=n?!0:e.math.boundingBoxesIntersect(L,S);V&&(R=X._private.rscratch.inDragLayer?_.drag:_.nondrag,R.eles.push(X))}}var Y=h[t.DRAG]&&!h[t.NODE]&&v&&!u.clearedNodeLayerForMotionBlur;if(Y&&(u.clearedNodeLayerForMotionBlur=!0),h[t.NODE]||a||o||Y){var k=n||p.contexts[t.NODE];i(k,v&&!Y?\"motionBlur\":void 0),r(_.nondrag,k),a||(h[t.NODE]=!1)}if(!o&&(h[t.DRAG]||a)){var k=n||p.contexts[t.DRAG];i(k,v?\"motionBlur\":void 0),r(_.drag,k),a||(h[t.DRAG]=!1)}if(u.showFps||!o&&h[t.SELECT_BOX]&&!a){var k=n||p.contexts[t.SELECT_BOX];if(i(k),1==p.select[4]&&u.hoverData.selecting){var y=p.cy.zoom(),A=f[\"selection-box-border-width\"].value/y;k.lineWidth=A,k.fillStyle=\"rgba(\"+f[\"selection-box-color\"].value[0]+\",\"+f[\"selection-box-color\"].value[1]+\",\"+f[\"selection-box-color\"].value[2]+\",\"+f[\"selection-box-opacity\"].value+\")\",k.fillRect(p.select[0],p.select[1],p.select[2]-p.select[0],p.select[3]-p.select[1]),A>0&&(k.strokeStyle=\"rgba(\"+f[\"selection-box-border-color\"].value[0]+\",\"+f[\"selection-box-border-color\"].value[1]+\",\"+f[\"selection-box-border-color\"].value[2]+\",\"+f[\"selection-box-opacity\"].value+\")\",k.strokeRect(p.select[0],p.select[1],p.select[2]-p.select[0],p.select[3]-p.select[1]))}if(p.bgActivePosistion&&!u.hoverData.selecting){var y=p.cy.zoom(),q=p.bgActivePosistion;k.fillStyle=\"rgba(\"+f[\"active-bg-color\"].value[0]+\",\"+f[\"active-bg-color\"].value[1]+\",\"+f[\"active-bg-color\"].value[2]+\",\"+f[\"active-bg-opacity\"].value+\")\",k.beginPath(),k.arc(q.x,q.y,f[\"active-bg-size\"].pxValue/y,0,2*Math.PI),k.fill()}var F=u.averageRedrawTime;if(u.showFps&&F){F=Math.round(F);var j=Math.round(1e3/F);k.setTransform(1,0,0,1,0,0),k.fillStyle=\"rgba(255, 0, 0, 0.75)\",k.strokeStyle=\"rgba(255, 0, 0, 0.75)\",k.lineWidth=1,k.fillText(\"1 frame = \"+F+\" ms = \"+j+\" fps\",0,20);var W=60;k.strokeRect(0,30,250,20),k.fillRect(0,30,250*Math.min(j/W,1),20)}a||(h[t.SELECT_BOX]=!1)}var H=+new Date;void 0===u.averageRedrawTime&&(u.averageRedrawTime=H-w),void 0===u.redrawCount&&(u.redrawCount=0),u.redrawCount++,void 0===u.redrawTotalTime&&(u.redrawTotalTime=0),u.redrawTotalTime+=H-w,u.lastRedrawTime=H-w,u.averageRedrawTime=u.averageRedrawTime/2+(H-w)/2,u.currentlyDrawing=!1,u.clearingMotionBlur&&(u.clearingMotionBlur=!1,u.motionBlurCleared=!0,u.motionBlur=!0),v&&(u.motionBlurTimeout=setTimeout(function(){u.motionBlurTimeout=null,u.clearedNodeLayerForMotionBlur=!1,u.motionBlur=!1,u.clearingMotionBlur=!0,h[t.NODE]=!0,h[t.DRAG]=!0,u.redraw()},t.motionBlurDelay))}i=i||{};var n=i.forcedContext,a=i.drawAllLayers,o=i.drawOnlyNodeLayer,s=i.forcedZoom,l=i.forcedPan,u=this,c=void 0===i.forcedPxRatio?this.getPixelRatio():i.forcedPxRatio,d=u.data.cy,p=u.data,h=p.canvasNeedsRedraw,v=void 0!==i.motionBlur?i.motionBlur:u.motionBlur;v=v&&!n&&u.motionBlurEnabled,v&&u.motionBlurTimeout&&clearTimeout(u.motionBlurTimeout),!n&&this.redrawTimeout&&clearTimeout(this.redrawTimeout),this.redrawTimeout=null,void 0===this.averageRedrawTime&&(this.averageRedrawTime=0);var g=t.minRedrawLimit,f=t.maxRedrawLimit,y=this.averageRedrawTime;y=g>y?g:y,y=f>y?y:f,void 0===this.lastDrawTime&&(this.lastDrawTime=0);var m=+new Date,x=m-this.lastDrawTime,b=x>=y;if(!n){if(!b||this.currentlyDrawing)return void(this.redrawTimeout=setTimeout(function(){u.redraw()},y));this.lastDrawTime=m,this.currentlyDrawing=!0}var w=+new Date;n?r():e.util.requestAnimationFrame(r),n||u.initrender||(u.initrender=!0,d.trigger(\"initrender\"))}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.drawPolygonPath=function(e,t,i,r,n,a){var o=r/2,s=n/2;e.beginPath&&e.beginPath(),e.moveTo(t+o*a[0],i+s*a[1]);for(var l=1;l<a.length/2;l++)e.lineTo(t+o*a[2*l],i+s*a[2*l+1]);e.closePath()},t.prototype.drawPolygon=function(e,t,i,r,n,a){this.drawPolygonPath(e,t,i,r,n,a),e.fill()},t.prototype.drawRoundRectanglePath=function(t,i,r,n,a){var o=n/2,s=a/2,l=e.math.getRoundRectangleRadius(n,a);t.beginPath&&t.beginPath(),t.moveTo(i,r-s),t.arcTo(i+o,r-s,i+o,r,l),t.arcTo(i+o,r+s,i,r+s,l),t.arcTo(i-o,r+s,i-o,r,l),t.arcTo(i-o,r-s,i,r-s,l),t.lineTo(i,r-s),t.closePath()},t.prototype.drawRoundRectangle=function(e,t,i,r,n,a){this.drawRoundRectanglePath(e,t,i,r,n,a),e.fill()}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.createBuffer=function(e,t){var i=document.createElement(\"canvas\");return i.width=e,i.height=t,[i,i.getContext(\"2d\")]},t.prototype.bufferCanvasImage=function(e){var t=this.data,i=t.cy,r=i.elements().boundingBox(),n=e.full?Math.ceil(r.w):this.data.container.clientWidth,a=e.full?Math.ceil(r.h):this.data.container.clientHeight,o=1;void 0!==e.scale&&(n*=e.scale,a*=e.scale,o=e.scale);var s=document.createElement(\"canvas\");s.width=n,s.height=a,s.style.width=n+\"px\",s.style.height=a+\"px\";var l=s.getContext(\"2d\");if(n>0&&a>0)if(l.clearRect(0,0,n,a),e.bg&&(l.fillStyle=e.bg,l.rect(0,0,n,a),l.fill()),l.globalCompositeOperation=\"source-over\",e.full)this.redraw({forcedContext:l,drawAllLayers:!0,forcedZoom:o,forcedPan:{x:-r.x1*o,y:-r.y1*o},forcedPxRatio:1});else{var u=i.pan(),c={x:u.x*o,y:u.y*o},d=i.zoom()*o;this.redraw({forcedContext:l,drawAllLayers:!0,forcedZoom:d,forcedPan:c,forcedPxRatio:1})}return s},t.prototype.png=function(e){return this.bufferCanvasImage(e).toDataURL(\"image/png\")}}(cytoscape),function(e){\"use strict\";var t=e(\"renderer\",\"canvas\");t.prototype.registerBinding=function(e,t,i,r){this.bindings.push({target:e,event:t,handler:i,useCapture:r}),e.addEventListener(t,i,r)},t.prototype.nodeIsDraggable=function(e){return 0!==e._private.style.opacity.value&&\"visible\"==e._private.style.visibility.value&&\"element\"==e._private.style.display.value&&!e.locked()&&e.grabbable()?!0:!1},t.prototype.load=function(){var i=this,r=function(e){var t;if(e.addToList&&i.data.cy.hasCompoundNodes()){if(!e.addToList.hasId){e.addToList.hasId={};for(var r=0;r<e.addToList.length;r++){var n=e.addToList[r];e.addToList.hasId[n.id()]=!0}}t=e.addToList.hasId}return t||{}},n=function(e,t){if(e._private.cy.hasCompoundNodes())for(var i=r(t),n=e.descendants(),a=0;a<n.size();a++){var o=n[a],s=o._private;t.inDragLayer&&(s.rscratch.inDragLayer=!0),t.addToList&&!i[o.id()]&&(t.addToList.push(o),i[o.id()]=!0,s.grabbed=!0);for(var l=s.edges,u=0;t.inDragLayer&&u<l.length;u++)l[u]._private.rscratch.inDragLayer=!0}},a=function(e,t){var i=e._private,a=r(t);t.inDragLayer&&(i.rscratch.inDragLayer=!0),t.addToList&&!a[e.id()]&&(t.addToList.push(e),a[e.id()]=!0,i.grabbed=!0);for(var s=i.edges,l=0;t.inDragLayer&&l<s.length;l++)s[l]._private.rscratch.inDragLayer=!0;n(e,t),o(e,{inDragLayer:!0})},o=function(e,t){var i=e;if(e._private.cy.hasCompoundNodes()){for(;i.parent().nonempty();)i=i.parent()[0];if(i!=e){for(var n=i.descendants().add(i).not(e).not(e.descendants()),a=n.connectedEdges(),o=r(t),s=0;s<n.size();s++)void 0!==t.inDragLayer&&(n[s]._private.rscratch.inDragLayer=t.inDragLayer),t.addToList&&!o[n[s].id()]&&(t.addToList.push(n[s]),o[n[s].id()]=!0,n[s]._private.grabbed=!0);for(var l=0;void 0!==t.inDragLayer&&l<a.length;l++)a[l]._private.rscratch.inDragLayer=t.inDragLayer}}};\"undefined\"!=typeof MutationObserver?(i.removeObserver=new MutationObserver(function(e){for(var t=0;t<e.length;t++){var r=e[t],n=r.removedNodes;if(n)for(var a=0;a<n.length;a++){var o=n[a];if(o===i.data.container){i.destroy();break}}}}),i.removeObserver.observe(i.data.container.parentNode,{childList:!0})):i.registerBinding(i.data.container,\"DOMNodeRemoved\",function(){i.destroy()}),i.registerBinding(window,\"resize\",e.util.debounce(function(){i.invalidateContainerClientCoordsCache(),i.matchCanvasSize(i.data.container),i.data.canvasNeedsRedraw[t.NODE]=!0,i.redraw()},100));for(var s=function(e){i.registerBinding(e,\"scroll\",function(){i.invalidateContainerClientCoordsCache()})},l=i.data.cy.container();s(l),l.parentNode;)l=l.parentNode;i.registerBinding(i.data.container,\"contextmenu\",function(e){e.preventDefault()});var u=function(){return 0!==i.data.select[4]};i.registerBinding(i.data.container,\"mousedown\",function(r){r.preventDefault(),i.hoverData.capture=!0,i.hoverData.which=r.which;var n=i.data.cy,o=i.projectIntoViewport(r.clientX,r.clientY),s=i.data.select,l=i.findNearestElement(o[0],o[1],!0),u=i.dragData.possibleDragElements;i.hoverData.mdownPos=o;var c=function(){i.hoverData.tapholdCancelled=!1,clearTimeout(i.hoverData.tapholdTimeout),i.hoverData.tapholdTimeout=setTimeout(function(){if(!i.hoverData.tapholdCancelled){var t=i.hoverData.down;t?t.trigger(new e.Event(r,{type:\"taphold\",cyPosition:{x:o[0],y:o[1]}})):n.trigger(new e.Event(r,{type:\"taphold\",cyPosition:{x:o[0],y:o[1]}}))}},i.tapholdDuration)};if(3==r.which){i.hoverData.cxtStarted=!0;var d=new e.Event(r,{type:\"cxttapstart\",cyPosition:{x:o[0],y:o[1]}});l?(l.activate(),l.trigger(d),i.hoverData.down=l):n.trigger(d),i.hoverData.downTime=(new Date).getTime(),i.hoverData.cxtDragged=!1}else if(1==r.which){if(l&&l.activate(),null!=l){if(i.nodeIsDraggable(l)){var p=new e.Event(r,{type:\"grab\",cyPosition:{x:o[0],y:o[1]}});if(l.isNode()&&!l.selected())u=i.dragData.possibleDragElements=[],a(l,{addToList:u}),l.trigger(p);else if(l.isNode()&&l.selected()){u=i.dragData.possibleDragElements=[];for(var h=n.$(function(){return this.isNode()&&this.selected()}),v=0;v<h.length;v++)i.nodeIsDraggable(h[v])&&a(h[v],{addToList:u});l.trigger(p)}i.data.canvasNeedsRedraw[t.NODE]=!0,i.data.canvasNeedsRedraw[t.DRAG]=!0}l.trigger(new e.Event(r,{type:\"mousedown\",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:\"tapstart\",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:\"vmousedown\",cyPosition:{x:o[0],y:o[1]}}))}else null==l&&n.trigger(new e.Event(r,{type:\"mousedown\",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:\"tapstart\",cyPosition:{x:o[0],y:o[1]}})).trigger(new e.Event(r,{type:\"vmousedown\",cyPosition:{x:o[0],y:o[1]}}));if(i.hoverData.down=l,i.hoverData.downTime=(new Date).getTime(),null==l||l.isEdge()){s[4]=1;var g=Math.max(0,t.panOrBoxSelectDelay-(+new Date-i.hoverData.downTime));clearTimeout(i.bgActiveTimeout),n.boxSelectionEnabled()||l&&l.isEdge()?i.bgActiveTimeout=setTimeout(function(){l&&l.unactivate(),i.data.bgActivePosistion={x:o[0],y:o[1]},c(),i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()},g):(i.data.bgActivePosistion={x:o[0],y:o[1]},c(),i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw())}}s[0]=s[2]=o[0],s[1]=s[3]=o[1]},!1),i.registerBinding(window,\"mousemove\",e.util.throttle(function(r){var n=!1,o=i.hoverData.capture;if(!o){var s=i.findContainerClientCoords();if(!(r.clientX>s[0]&&r.clientX<s[0]+i.canvasWidth&&r.clientY>s[1]&&r.clientY<s[1]+i.canvasHeight))return;for(var l=i.data.container,u=r.target,c=u.parentNode,d=!1;c;){if(c===l){d=!0;break}c=c.parentNode}if(!d)return}var p=i.data.cy,h=p.zoom(),v=(p.pan(),i.projectIntoViewport(r.clientX,r.clientY)),g=i.data.select,f=null;i.hoverData.draggingEles||(f=i.findNearestElement(v[0],v[1],!0));var y=i.hoverData.last,m=i.hoverData.down,x=[v[0]-g[2],v[1]-g[3]],b=i.dragData.possibleDragElements,w=g[2]-g[0],_=w*w,E=g[3]-g[1],S=E*E,P=_+S,D=P*h*h;i.hoverData.tapholdCancelled=!0;var k=function(){var e=i.hoverData.dragDelta=i.hoverData.dragDelta||[];0===e.length?(e.push(0),e.push(0)):(e[0]+=x[0],e[1]+=x[1])};if(n=!0,null!=f?f.trigger(new e.Event(r,{type:\"mousemove\",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:\"vmousemove\",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:\"tapdrag\",cyPosition:{x:v[0],y:v[1]}})):null==f&&p.trigger(new e.Event(r,{type:\"mousemove\",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:\"vmousemove\",cyPosition:{x:v[0],y:v[1]}})).trigger(new e.Event(r,{type:\"tapdrag\",cyPosition:{x:v[0],y:v[1]}})),3===i.hoverData.which){var C=new e.Event(r,{type:\"cxtdrag\",cyPosition:{x:v[0],y:v[1]}});\nm?m.trigger(C):p.trigger(C),i.hoverData.cxtDragged=!0,i.hoverData.cxtOver&&f===i.hoverData.cxtOver||(i.hoverData.cxtOver&&i.hoverData.cxtOver.trigger(new e.Event(r,{type:\"cxtdragout\",cyPosition:{x:v[0],y:v[1]}})),i.hoverData.cxtOver=f,f&&f.trigger(new e.Event(r,{type:\"cxtdragover\",cyPosition:{x:v[0],y:v[1]}})))}else if(i.hoverData.dragging){if(n=!0,p.panningEnabled()&&p.userPanningEnabled()){var T;if(i.hoverData.justStartedPan){var N=i.hoverData.mdownPos;T={x:(v[0]-N[0])*h,y:(v[1]-N[1])*h},i.hoverData.justStartedPan=!1}else T={x:x[0]*h,y:x[1]*h};p.panBy(T)}v=i.projectIntoViewport(r.clientX,r.clientY)}else if(1==g[4]&&(null==m||m.isEdge())&&(!p.boxSelectionEnabled()||+new Date-i.hoverData.downTime>=t.panOrBoxSelectDelay)&&!i.hoverData.selecting&&D>=i.tapThreshold2&&p.panningEnabled()&&p.userPanningEnabled())i.hoverData.dragging=!0,i.hoverData.selecting=!1,i.hoverData.justStartedPan=!0,g[4]=0;else{if(p.boxSelectionEnabled()&&Math.pow(g[2]-g[0],2)+Math.pow(g[3]-g[1],2)>7&&g[4]&&(clearTimeout(i.bgActiveTimeout),i.data.bgActivePosistion=void 0,i.hoverData.selecting=!0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()),m&&m.isEdge()&&m.active()&&m.unactivate(),f!=y&&(y&&(y.trigger(new e.Event(r,{type:\"mouseout\",cyPosition:{x:v[0],y:v[1]}})),y.trigger(new e.Event(r,{type:\"tapdragout\",cyPosition:{x:v[0],y:v[1]}}))),f&&(f.trigger(new e.Event(r,{type:\"mouseover\",cyPosition:{x:v[0],y:v[1]}})),f.trigger(new e.Event(r,{type:\"tapdragover\",cyPosition:{x:v[0],y:v[1]}}))),i.hoverData.last=f),m&&m.isNode()&&i.nodeIsDraggable(m))if(D>=i.tapThreshold2){var M=!i.dragData.didDrag;M&&(i.data.canvasNeedsRedraw[t.NODE]=!0),i.dragData.didDrag=!0;for(var B=[],I=0;I<b.length;I++){var z=b[I];if(i.hoverData.draggingEles||a(z,{inDragLayer:!0}),z.isNode()&&i.nodeIsDraggable(z)&&z.grabbed()){var L=z._private.position;if(B.push(z),e.is.number(x[0])&&e.is.number(x[1])&&(L.x+=x[0],L.y+=x[1],M)){var O=i.hoverData.dragDelta;e.is.number(O[0])&&e.is.number(O[1])&&(L.x+=O[0],L.y+=O[1])}}}i.hoverData.draggingEles=!0;var R=new e.Collection(p,B);R.updateCompoundBounds(),R.trigger(\"position drag\"),i.data.canvasNeedsRedraw[t.DRAG]=!0,i.redraw()}else k();n=!0}return g[2]=v[0],g[3]=v[1],n?(r.stopPropagation&&r.stopPropagation(),r.preventDefault&&r.preventDefault(),!1):void 0},1e3/30,{trailing:!0}),!1),i.registerBinding(window,\"mouseup\",function(r){var n=i.hoverData.capture;if(n){i.hoverData.capture=!1;var a=i.data.cy,s=i.projectIntoViewport(r.clientX,r.clientY),l=i.data.select,u=i.findNearestElement(s[0],s[1],!0),c=i.dragData.possibleDragElements,d=i.hoverData.down,p=r.shiftKey;if(i.data.bgActivePosistion&&(i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()),i.data.bgActivePosistion=void 0,clearTimeout(i.bgActiveTimeout),i.hoverData.cxtStarted=!1,i.hoverData.draggingEles=!1,i.hoverData.selecting=!1,d&&d.unactivate(),3===i.hoverData.which){var h=new e.Event(r,{type:\"cxttapend\",cyPosition:{x:s[0],y:s[1]}});if(d?d.trigger(h):a.trigger(h),!i.hoverData.cxtDragged){var v=new e.Event(r,{type:\"cxttap\",cyPosition:{x:s[0],y:s[1]}});d?d.trigger(v):a.trigger(v)}i.hoverData.cxtDragged=!1,i.hoverData.which=null}else{if(null!=d||i.dragData.didDrag||Math.pow(l[2]-l[0],2)+Math.pow(l[3]-l[1],2)>7&&l[4]||i.hoverData.dragging||(a.$(function(){return this.selected()}).unselect(),c.length>0&&(i.data.canvasNeedsRedraw[t.NODE]=!0),i.dragData.possibleDragElements=c=[]),null!=u?u.trigger(new e.Event(r,{type:\"mouseup\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"tapend\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"vmouseup\",cyPosition:{x:s[0],y:s[1]}})):null==u&&a.trigger(new e.Event(r,{type:\"mouseup\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"tapend\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"vmouseup\",cyPosition:{x:s[0],y:s[1]}})),Math.pow(l[2]-l[0],2)+Math.pow(l[3]-l[1],2)===0&&(null!=u?u.trigger(new e.Event(r,{type:\"click\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"tap\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"vclick\",cyPosition:{x:s[0],y:s[1]}})):null==u&&a.trigger(new e.Event(r,{type:\"click\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"tap\",cyPosition:{x:s[0],y:s[1]}})).trigger(new e.Event(r,{type:\"vclick\",cyPosition:{x:s[0],y:s[1]}}))),u!=d||i.dragData.didDrag||null!=u&&u._private.selectable&&(i.hoverData.dragging||(\"additive\"===a.selectionType()||p?u.selected()?u.unselect():u.select():p||(a.$(\":selected\").not(u).unselect(),u.select())),i.data.canvasNeedsRedraw[t.NODE]=!0),a.boxSelectionEnabled()&&Math.pow(l[2]-l[0],2)+Math.pow(l[3]-l[1],2)>7&&l[4]){var g=[],f=i.getAllInBox(l[0],l[1],l[2],l[3]);i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,f.length>0&&(i.data.canvasNeedsRedraw[t.NODE]=!0);for(var y=0;y<f.length;y++)f[y]._private.selectable&&g.push(f[y]);var m=new e.Collection(a,g);\"additive\"===a.selectionType()?m.select():(p||a.$(\":selected\").not(m).unselect(),m.select()),i.redraw()}if(i.hoverData.dragging&&(i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw()),i.hoverData.dragging=!1,!l[4]){i.data.canvasNeedsRedraw[t.DRAG]=!0,i.data.canvasNeedsRedraw[t.NODE]=!0;for(var y=0;y<c.length;y++)if(\"nodes\"===c[y]._private.group){c[y]._private.rscratch.inDragLayer=!1,c[y]._private.grabbed=!1;for(var x=c[y]._private.edges,b=0;b<x.length;b++)x[b]._private.rscratch.inDragLayer=!1;o(c[y],{inDragLayer:!1})}else\"edges\"===c[y]._private.group&&(c[y]._private.rscratch.inDragLayer=!1);d&&d.trigger(\"free\")}}l[4]=0,i.hoverData.down=null,i.dragData.didDrag=!1,i.hoverData.dragDelta=[]}},!1);var c=function(e){if(!i.scrollingPage){var r=i.data.cy,n=i.projectIntoViewport(e.clientX,e.clientY),a=[n[0]*r.zoom()+r.pan().x,n[1]*r.zoom()+r.pan().y];if(i.hoverData.draggingEles||i.hoverData.dragging||i.hoverData.cxtStarted||u())return void e.preventDefault();if(r.panningEnabled()&&r.userPanningEnabled()&&r.zoomingEnabled()&&r.userZoomingEnabled()){e.preventDefault(),i.data.wheelZooming=!0,clearTimeout(i.data.wheelTimeout),i.data.wheelTimeout=setTimeout(function(){i.data.wheelZooming=!1,i.data.canvasNeedsRedraw[t.NODE]=!0,i.redraw()},150);var o=e.deltaY/-250||e.wheelDeltaY/1e3||e.wheelDelta/1e3;o*=i.wheelSensitivity;var s=1===e.deltaMode;s&&(o*=33),r.zoom({level:r.zoom()*Math.pow(10,o),renderedPosition:{x:a[0],y:a[1]}})}}};i.registerBinding(i.data.container,\"wheel\",c,!0),i.registerBinding(window,\"scroll\",function(){i.scrollingPage=!0,clearTimeout(i.scrollingPageTimeout),i.scrollingPageTimeout=setTimeout(function(){i.scrollingPage=!1},250)},!0),i.registerBinding(i.data.container,\"mouseout\",function(t){var r=i.projectIntoViewport(t.clientX,t.clientY);i.data.cy.trigger(new e.Event(t,{type:\"mouseout\",cyPosition:{x:r[0],y:r[1]}}))},!1),i.registerBinding(i.data.container,\"mouseover\",function(t){var r=i.projectIntoViewport(t.clientX,t.clientY);i.data.cy.trigger(new e.Event(t,{type:\"mouseover\",cyPosition:{x:r[0],y:r[1]}}))},!1);var d,p,h,v,g,f,y,m,x,b,w,_,E,S=function(e,t,i,r){return Math.sqrt((i-e)*(i-e)+(r-t)*(r-t))},P=function(e,t,i,r){return(i-e)*(i-e)+(r-t)*(r-t)};i.registerBinding(i.data.container,\"touchstart\",function(r){clearTimeout(this.threeFingerSelectTimeout),r.target!==i.data.link&&r.preventDefault(),i.touchData.capture=!0,i.data.bgActivePosistion=void 0;var n=i.data.cy,o=i.getCachedNodes(),s=i.getCachedEdges(),l=i.touchData.now,u=i.touchData.earlier;if(r.touches[0]){var c=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=c[0],l[1]=c[1]}if(r.touches[1]){var c=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);l[2]=c[0],l[3]=c[1]}if(r.touches[2]){var c=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);l[4]=c[0],l[5]=c[1]}if(r.touches[1]){var D=function(e){for(var t=0;t<e.length;t++)e[t]._private.grabbed=!1,e[t]._private.rscratch.inDragLayer=!1,e[t].active()&&e[t].unactivate()};D(o),D(s);var k=i.findContainerClientCoords();x=k[0],b=k[1],w=k[2],_=k[3],d=r.touches[0].clientX-x,p=r.touches[0].clientY-b,h=r.touches[1].clientX-x,v=r.touches[1].clientY-b,E=d>=0&&w>=d&&h>=0&&w>=h&&p>=0&&_>=p&&v>=0&&_>=v;var C=n.pan(),T=n.zoom();g=S(d,p,h,v),f=P(d,p,h,v),y=[(d+h)/2,(p+v)/2],m=[(y[0]-C.x)/T,(y[1]-C.y)/T];var N=200,M=N*N;if(M>f&&!r.touches[2]){var B=i.findNearestElement(l[0],l[1],!0),I=i.findNearestElement(l[2],l[3],!0);return B&&B.isNode()?(B.activate().trigger(new e.Event(r,{type:\"cxttapstart\",cyPosition:{x:l[0],y:l[1]}})),i.touchData.start=B):I&&I.isNode()?(I.activate().trigger(new e.Event(r,{type:\"cxttapstart\",cyPosition:{x:l[0],y:l[1]}})),i.touchData.start=I):(n.trigger(new e.Event(r,{type:\"cxttapstart\",cyPosition:{x:l[0],y:l[1]}})),i.touchData.start=null),i.touchData.start&&(i.touchData.start._private.grabbed=!1),i.touchData.cxt=!0,i.touchData.cxtDragged=!1,i.data.bgActivePosistion=void 0,void i.redraw()}}if(r.touches[2]);else if(r.touches[1]);else if(r.touches[0]){var z=i.findNearestElement(l[0],l[1],!0);if(null!=z){if(z.activate(),i.touchData.start=z,z.isNode()&&i.nodeIsDraggable(z)){var L=i.dragData.touchDragEles=[];if(i.data.canvasNeedsRedraw[t.NODE]=!0,i.data.canvasNeedsRedraw[t.DRAG]=!0,z.selected())for(var O=n.$(function(){return this.isNode()&&this.selected()}),R=0;R<O.length;R++){var X=O[R];i.nodeIsDraggable(X)&&a(X,{addToList:L})}else a(z,{addToList:L});z.trigger(new e.Event(r,{type:\"grab\",cyPosition:{x:l[0],y:l[1]}}))}z.trigger(new e.Event(r,{type:\"touchstart\",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:\"tapstart\",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:\"vmousdown\",cyPosition:{x:l[0],y:l[1]}}))}null==z&&(n.trigger(new e.Event(r,{type:\"touchstart\",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:\"tapstart\",cyPosition:{x:l[0],y:l[1]}})).trigger(new e.Event(r,{type:\"vmousedown\",cyPosition:{x:l[0],y:l[1]}})),i.data.bgActivePosistion={x:c[0],y:c[1]},i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.redraw());for(var V=0;V<l.length;V++)u[V]=l[V],i.touchData.startPosition[V]=l[V];i.touchData.singleTouchMoved=!1,i.touchData.singleTouchStartTime=+new Date,clearTimeout(i.touchData.tapholdTimeout),i.touchData.tapholdTimeout=setTimeout(function(){i.touchData.singleTouchMoved!==!1||i.pinching||(i.touchData.start?i.touchData.start.trigger(new e.Event(r,{type:\"taphold\",cyPosition:{x:l[0],y:l[1]}})):(i.data.cy.trigger(new e.Event(r,{type:\"taphold\",cyPosition:{x:l[0],y:l[1]}})),n.$(\":selected\").unselect()))},i.tapholdDuration)}},!1),i.registerBinding(window,\"touchmove\",e.util.throttle(function(r){var n=i.data.select,o=i.touchData.capture;o&&r.preventDefault();var s=i.data.cy,l=i.touchData.now,u=i.touchData.earlier,c=s.zoom();if(r.touches[0]){var y=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=y[0],l[1]=y[1]}if(r.touches[1]){var y=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);l[2]=y[0],l[3]=y[1]}if(r.touches[2]){var y=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);l[4]=y[0],l[5]=y[1]}for(var w=[],_=0;_<l.length;_++)w[_]=l[_]-u[_];var D=i.touchData.startPosition,k=l[0]-D[0],C=k*k,T=l[1]-D[1],N=T*T,M=C+N,B=M*c*c;if(o&&i.touchData.cxt){var I=r.touches[0].clientX-x,z=r.touches[0].clientY-b,L=r.touches[1].clientX-x,O=r.touches[1].clientY-b,R=P(I,z,L,O),X=R/f,V=150,Y=V*V,A=1.5,q=A*A;if(X>=q||R>=Y){i.touchData.cxt=!1,i.touchData.start&&(i.touchData.start.unactivate(),i.touchData.start=null),i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;var F=new e.Event(r,{type:\"cxttapend\",cyPosition:{x:l[0],y:l[1]}});i.touchData.start?i.touchData.start.trigger(F):s.trigger(F)}}if(o&&i.touchData.cxt){var F=new e.Event(r,{type:\"cxtdrag\",cyPosition:{x:l[0],y:l[1]}});i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.touchData.start?i.touchData.start.trigger(F):s.trigger(F),i.touchData.start&&(i.touchData.start._private.grabbed=!1),i.touchData.cxtDragged=!0;var j=i.findNearestElement(l[0],l[1],!0);i.touchData.cxtOver&&j===i.touchData.cxtOver||(i.touchData.cxtOver&&i.touchData.cxtOver.trigger(new e.Event(r,{type:\"cxtdragout\",cyPosition:{x:l[0],y:l[1]}})),i.touchData.cxtOver=j,j&&j.trigger(new e.Event(r,{type:\"cxtdragover\",cyPosition:{x:l[0],y:l[1]}})))}else if(o&&r.touches[2]&&s.boxSelectionEnabled())i.data.bgActivePosistion=void 0,clearTimeout(this.threeFingerSelectTimeout),this.lastThreeTouch=+new Date,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,n&&0!==n.length&&void 0!==n[0]?(n[2]=(l[0]+l[2]+l[4])/3,n[3]=(l[1]+l[3]+l[5])/3):(n[0]=(l[0]+l[2]+l[4])/3,n[1]=(l[1]+l[3]+l[5])/3,n[2]=(l[0]+l[2]+l[4])/3+1,n[3]=(l[1]+l[3]+l[5])/3+1),n[4]=1,i.redraw();else if(o&&r.touches[1]&&s.zoomingEnabled()&&s.panningEnabled()&&s.userZoomingEnabled()&&s.userPanningEnabled()){i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;var W=i.dragData.touchDragEles;if(W){i.data.canvasNeedsRedraw[t.DRAG]=!0;for(var H=0;H<W.length;H++)W[H]._private.grabbed=!1,W[H]._private.rscratch.inDragLayer=!1}var I=r.touches[0].clientX-x,z=r.touches[0].clientY-b,L=r.touches[1].clientX-x,O=r.touches[1].clientY-b,$=S(I,z,L,O),Z=$/g;if(1!=Z&&E){var U=I-d,G=z-p,K=L-h,J=O-v,Q=(U+K)/2,et=(G+J)/2,tt=s.zoom(),it=tt*Z,rt=s.pan(),nt=m[0]*tt+rt.x,at=m[1]*tt+rt.y,ot={x:-it/tt*(nt-rt.x-Q)+nt,y:-it/tt*(at-rt.y-et)+at};if(i.touchData.start){var W=i.dragData.touchDragEles;if(W)for(var H=0;H<W.length;H++)W[H]._private.grabbed=!1,W[H]._private.rscratch.inDragLayer=!1;i.touchData.start._private.active=!1,i.touchData.start._private.grabbed=!1,i.touchData.start._private.rscratch.inDragLayer=!1,i.data.canvasNeedsRedraw[t.DRAG]=!0,i.touchData.start.trigger(\"free\").trigger(\"unactivate\")}s.viewport({zoom:it,pan:ot,cancelOnFailedZoom:!0}),g=$,d=I,p=z,h=L,v=O,i.pinching=!0}if(r.touches[0]){var y=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=y[0],l[1]=y[1]}if(r.touches[1]){var y=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);l[2]=y[0],l[3]=y[1]}if(r.touches[2]){var y=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);l[4]=y[0],l[5]=y[1]}}else if(r.touches[0]){var st=i.touchData.start,lt=i.touchData.last,j=j||i.findNearestElement(l[0],l[1],!0);if(null!=st&&\"nodes\"==st._private.group&&i.nodeIsDraggable(st))if(B>=i.tapThreshold2){for(var W=i.dragData.touchDragEles,ut=0;ut<W.length;ut++){var ct=W[ut];if(i.nodeIsDraggable(ct)&&ct.isNode()&&ct.grabbed()){i.dragData.didDrag=!0;var dt=ct._private.position,pt=!i.hoverData.draggingEles;if(e.is.number(w[0])&&e.is.number(w[1])&&(dt.x+=w[0],dt.y+=w[1]),pt){a(ct,{inDragLayer:!0});var ht=i.touchData.dragDelta;e.is.number(ht[0])&&e.is.number(ht[1])&&(dt.x+=ht[0],dt.y+=ht[1])}}}var vt=new e.Collection(s,ct);vt.updateCompoundBounds(),vt.trigger(\"position drag\"),i.hoverData.draggingEles=!0,i.data.canvasNeedsRedraw[t.DRAG]=!0,i.touchData.startPosition[0]==u[0]&&i.touchData.startPosition[1]==u[1]&&(i.data.canvasNeedsRedraw[t.NODE]=!0),i.redraw()}else{var ht=i.touchData.dragDelta=i.touchData.dragDelta||[];0===ht.length?(ht.push(0),ht.push(0)):(ht[0]+=w[0],ht[1]+=w[1])}null!=st&&(st.trigger(new e.Event(r,{type:\"touchmove\",cyPosition:{x:l[0],y:l[1]}})),st.trigger(new e.Event(r,{type:\"tapdrag\",cyPosition:{x:l[0],y:l[1]}})),st.trigger(new e.Event(r,{type:\"vmousemove\",cyPosition:{x:l[0],y:l[1]}}))),null==st&&(null!=j&&(j.trigger(new e.Event(r,{type:\"touchmove\",cyPosition:{x:l[0],y:l[1]}})),j.trigger(new e.Event(r,{type:\"tapdrag\",cyPosition:{x:l[0],y:l[1]}})),j.trigger(new e.Event(r,{type:\"vmousemove\",cyPosition:{x:l[0],y:l[1]}}))),null==j&&(s.trigger(new e.Event(r,{type:\"touchmove\",cyPosition:{x:l[0],y:l[1]}})),s.trigger(new e.Event(r,{type:\"tapdrag\",cyPosition:{x:l[0],y:l[1]}})),s.trigger(new e.Event(r,{type:\"vmousemove\",cyPosition:{x:l[0],y:l[1]}})))),j!=lt&&(lt&&lt.trigger(new e.Event(r,{type:\"tapdragout\",cyPosition:{x:l[0],y:l[1]}})),j&&j.trigger(new e.Event(r,{type:\"tapdragover\",cyPosition:{x:l[0],y:l[1]}}))),i.touchData.last=j;for(var H=0;H<l.length;H++)l[H]&&i.touchData.startPosition[H]&&Math.abs(l[H]-i.touchData.startPosition[H])>4&&(i.touchData.singleTouchMoved=!0);if(o&&(null==st||st.isEdge())&&s.panningEnabled()&&s.userPanningEnabled()){i.swipePanning?s.panBy({x:w[0]*c,y:w[1]*c}):B>=i.tapThreshold2&&(i.swipePanning=!0,s.panBy({x:k*c,y:T*c})),st&&(st.unactivate(),i.data.bgActivePosistion||(i.data.bgActivePosistion={x:l[0],y:l[1]}),i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,i.touchData.start=null);var y=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);l[0]=y[0],l[1]=y[1]}}for(var _=0;_<l.length;_++)u[_]=l[_]},1e3/30,{trailing:!0}),!1),i.registerBinding(window,\"touchcancel\",function(){var e=i.touchData.start;i.touchData.capture=!1,e&&e.unactivate()}),i.registerBinding(window,\"touchend\",function(r){var n=i.touchData.start,a=i.touchData.capture;if(a){i.touchData.capture=!1,r.preventDefault();var s=i.data.select;i.swipePanning=!1,i.hoverData.draggingEles=!1;var l=i.data.cy,u=l.zoom(),c=i.touchData.now,d=i.touchData.earlier;if(r.touches[0]){var p=i.projectIntoViewport(r.touches[0].clientX,r.touches[0].clientY);c[0]=p[0],c[1]=p[1]}if(r.touches[1]){var p=i.projectIntoViewport(r.touches[1].clientX,r.touches[1].clientY);c[2]=p[0],c[3]=p[1]}if(r.touches[2]){var p=i.projectIntoViewport(r.touches[2].clientX,r.touches[2].clientY);c[4]=p[0],c[5]=p[1]}n&&n.unactivate();var h;if(i.touchData.cxt){if(h=new e.Event(r,{type:\"cxttapend\",cyPosition:{x:c[0],y:c[1]}}),n?n.trigger(h):l.trigger(h),!i.touchData.cxtDragged){var v=new e.Event(r,{type:\"cxttap\",cyPosition:{x:c[0],y:c[1]}});n?n.trigger(v):l.trigger(v)}return i.touchData.start&&(i.touchData.start._private.grabbed=!1),i.touchData.cxt=!1,i.touchData.start=null,void i.redraw()}if(!r.touches[2]&&l.boxSelectionEnabled()){clearTimeout(this.threeFingerSelectTimeout);var g=[],f=i.getAllInBox(s[0],s[1],s[2],s[3]);s[0]=void 0,s[1]=void 0,s[2]=void 0,s[3]=void 0,s[4]=0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;for(var y=0;y<f.length;y++)f[y]._private.selectable&&g.push(f[y]);var m=new e.Collection(l,g);\"single\"===l.selectionType()&&l.$(\":selected\").not(m).unselect(),m.select(),m.length>0?i.data.canvasNeedsRedraw[t.NODE]=!0:i.redraw()}var x=!1;if(null!=n&&(n._private.active=!1,x=!0,n.unactivate()),r.touches[2])i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0;else if(r.touches[1]);else if(r.touches[0]);else if(!r.touches[0]){if(i.data.bgActivePosistion=void 0,i.data.canvasNeedsRedraw[t.SELECT_BOX]=!0,null!=n){n._private.grabbed&&(n._private.grabbed=!1,n.trigger(\"free\"),n._private.rscratch.inDragLayer=!1);for(var b=n._private.edges,w=0;w<b.length;w++)b[w]._private.rscratch.inDragLayer=!1;if(o(n,!1),n.selected())for(var _=l.$(\"node:selected\"),E=0;E<_.length;E++){var S=_[E];S._private.rscratch.inDragLayer=!1,S._private.grabbed=!1;for(var b=S._private.edges,w=0;w<b.length;w++)b[w]._private.rscratch.inDragLayer=!1;o(S,!1)}i.data.canvasNeedsRedraw[t.DRAG]=!0,i.data.canvasNeedsRedraw[t.NODE]=!0,n.trigger(new e.Event(r,{type:\"touchend\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"tapend\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"vmouseup\",cyPosition:{x:c[0],y:c[1]}})),n.unactivate(),i.touchData.start=null}else{var P=i.findNearestElement(c[0],c[1],!0);null!=P&&P.trigger(new e.Event(r,{type:\"touchend\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"tapend\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"vmouseup\",cyPosition:{x:c[0],y:c[1]}})),null==P&&l.trigger(new e.Event(r,{type:\"touchend\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"tapend\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"vmouseup\",cyPosition:{x:c[0],y:c[1]}}))}var D=i.touchData.startPosition[0]-c[0],k=D*D,C=i.touchData.startPosition[1]-c[1],T=C*C,N=k+T,M=N*u*u;null!=n&&!i.dragData.didDrag&&n._private.selectable&&M<i.tapThreshold2&&!i.pinching&&(\"single\"===l.selectionType()?(l.$(\":selected\").not(n).unselect(),n.select()):n.selected()?n.unselect():n.select(),x=!0,i.data.canvasNeedsRedraw[t.NODE]=!0),i.touchData.singleTouchMoved===!1&&(n?n.trigger(new e.Event(r,{type:\"tap\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"vclick\",cyPosition:{x:c[0],y:c[1]}})):l.trigger(new e.Event(r,{type:\"tap\",cyPosition:{x:c[0],y:c[1]}})).trigger(new e.Event(r,{type:\"vclick\",cyPosition:{x:c[0],y:c[1]}}))),i.touchData.singleTouchMoved=!0}for(var w=0;w<c.length;w++)d[w]=c[w];i.dragData.didDrag=!1,r.touches[0]&&(i.touchData.dragDelta=[]),x&&n&&n.updateStyle(!1),r.touches.length<2&&(i.pinching=!1,i.data.canvasNeedsRedraw[t.NODE]=!0,i.redraw())}},!1)}}(cytoscape),function(e){\"use strict\";for(var t=e(\"renderer\",\"canvas\"),i=t.prototype,r=t.usePaths(),n=t.nodeShapes={},a=Math.sin(0),o=Math.cos(0),s={},l={},u=.1,c=0*Math.PI;c<2*Math.PI;c+=u)s[c]=Math.sin(c),l[c]=Math.cos(c);n.ellipse={draw:function(e,t,i,r,a){n.ellipse.drawPath(e,t,i,r,a),e.fill()},drawPath:function(e,t,i,n,c){if(r){e.beginPath&&e.beginPath();for(var d,p,h=n/2,v=c/2,g=0*Math.PI;g<2*Math.PI;g+=u)d=t-h*s[g]*a+h*l[g]*o,p=i+v*l[g]*a+v*s[g]*o,0===g?e.moveTo(d,p):e.lineTo(d,p);e.closePath()}else e.beginPath&&e.beginPath(),e.translate(t,i),e.scale(n/2,c/2),e.arc(0,0,1,0,2*Math.PI*.999,!1),e.closePath(),e.scale(2/n,2/c),e.translate(-t,-i)},intersectLine:function(t,i,r,n,a,o,s){var l=e.math.intersectLineEllipse(a,o,t,i,r/2+s,n/2+s);return l},intersectBox:function(t,i,r,n,a,o,s,l,u){return e.math.boxIntersectEllipse(t,i,r,n,u,a,o,s,l)},checkPoint:function(e,t,i,r,n,a,o){return e-=a,t-=o,e/=r/2+i,t/=n/2+i,Math.pow(e,2)+Math.pow(t,2)<=1}},n.triangle={points:e.math.generateUnitNgonPointsFitToSquare(3,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.triangle.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.triangle.points)},intersectLine:function(t,i,r,a,o,s,l){return e.math.polygonIntersectLine(o,s,n.triangle.points,t,i,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.triangle.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.triangle.points,s,l,a,o,[0,-1],r)}},n.square={points:e.math.generateUnitNgonPointsFitToSquare(4,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.square.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.square.points)},intersectLine:function(t,i,r,a,o,s,l){return e.math.polygonIntersectLine(o,s,n.square.points,t,i,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.square.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.square.points,s,l,a,o,[0,-1],r)}},n.rectangle=n.square,n.octogon={},n.roundrectangle={points:e.math.generateUnitNgonPointsFitToSquare(4,0),draw:function(e,t,r,n,a){i.drawRoundRectangle(e,t,r,n,a,10)},drawPath:function(e,t,r,n,a){i.drawRoundRectanglePath(e,t,r,n,a,10)},intersectLine:function(t,i,r,n,a,o,s){return e.math.roundRectangleIntersectLine(a,o,t,i,r,n,s)},intersectBox:function(t,i,r,n,a,o,s,l,u){return e.math.roundRectangleIntersectBox(t,i,r,n,a,o,s,l,u)},checkPoint:function(t,i,r,a,o,s,l){var u=e.math.getRoundRectangleRadius(a,o);if(e.math.pointInsidePolygon(t,i,n.roundrectangle.points,s,l,a,o-2*u,[0,-1],r))return!0;if(e.math.pointInsidePolygon(t,i,n.roundrectangle.points,s,l,a-2*u,o,[0,-1],r))return!0;var c=function(e,t,i,r,n,a,o){return e-=i,t-=r,e/=n/2+o,t/=a/2+o,Math.pow(e,2)+Math.pow(t,2)<=1};return c(t,i,s-a/2+u,l-o/2+u,2*u,2*u,r)?!0:c(t,i,s+a/2-u,l-o/2+u,2*u,2*u,r)?!0:c(t,i,s+a/2-u,l+o/2-u,2*u,2*u,r)?!0:c(t,i,s-a/2+u,l+o/2-u,2*u,2*u,r)?!0:!1}},n.pentagon={points:e.math.generateUnitNgonPointsFitToSquare(5,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.pentagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.pentagon.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.pentagon.points,e,t,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.pentagon.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.pentagon.points,s,l,a,o,[0,-1],r)}},n.hexagon={points:e.math.generateUnitNgonPointsFitToSquare(6,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.hexagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.hexagon.points)},intersectLine:function(t,i,r,a,o,s,l){return e.math.polygonIntersectLine(o,s,n.hexagon.points,t,i,r/2,a/2,l)},intersectBox:function(t,i,r,a,o,s,l,u,c){var d=n.hexagon.points;return e.math.boxIntersectPolygon(t,i,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.hexagon.points,s,l,a,o,[0,-1],r)}},n.heptagon={points:e.math.generateUnitNgonPointsFitToSquare(7,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.heptagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.heptagon.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.heptagon.points,e,t,r/2,a/2,l)},intersectBox:function(e,t,r,a,o,s,l,u,c){var d=n.heptagon.points;return i.boxIntersectPolygon(e,t,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.heptagon.points,s,l,a,o,[0,-1],r)}},n.octagon={points:e.math.generateUnitNgonPointsFitToSquare(8,0),draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.octagon.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.octagon.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.octagon.points,e,t,r/2,a/2,l)},intersectBox:function(e,t,r,a,o,s,l,u,c){var d=n.octagon.points;return i.boxIntersectPolygon(e,t,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.octagon.points,s,l,a,o,[0,-1],r)}};var d=new Array(20),p=e.math.generateUnitNgonPoints(5,0),h=e.math.generateUnitNgonPoints(5,Math.PI/5),v=.5*(3-Math.sqrt(5));v*=1.57;for(var c=0;c<h.length/2;c++)h[2*c]*=v,h[2*c+1]*=v;for(var c=0;5>c;c++)d[4*c]=p[2*c],d[4*c+1]=p[2*c+1],d[4*c+2]=h[2*c],d[4*c+3]=h[2*c+1];d=e.math.fitPolygonToSquare(d),n.star5=n.star={points:d,draw:function(e,t,r,a,o){i.drawPolygon(e,t,r,a,o,n.star5.points)},drawPath:function(e,t,r,a,o){i.drawPolygonPath(e,t,r,a,o,n.star5.points)},intersectLine:function(e,t,r,a,o,s,l){return i.polygonIntersectLine(o,s,n.star5.points,e,t,r/2,a/2,l)},intersectBox:function(e,t,r,a,o,s,l,u,c){var d=n.star5.points;return i.boxIntersectPolygon(e,t,r,a,d,o,s,l,u,[0,-1],c)},checkPoint:function(t,i,r,a,o,s,l){return e.math.pointInsidePolygon(t,i,n.star5.points,s,l,a,o,[0,-1],r)}}}(cytoscape),function(e){\"use strict\";function t(t){this._private={},this._private.options=e.util.extend({},i,t)}var i={animate:!0,maxSimulationTime:4e3,fit:!0,padding:30,boundingBox:void 0,ungrabifyWhileSimulating:!1,ready:void 0,stop:void 0,repulsion:void 0,stiffness:void 0,friction:void 0,gravity:!0,fps:void 0,precision:void 0,nodeMass:void 0,edgeLength:void 0,stepSize:.1,stableEnergy:function(e){var t=e;return t.max<=.5||t.mean<=.3},infinite:!1};t.prototype.run=function(){var t=this,i=this._private.options;return e.util.require(\"arbor\",function(r){function n(e,t){return null==t?void 0:\"function\"==typeof t?t.apply(e,[e._private.data,{nodes:u.length,edges:c.length,element:e}]):t}function a(e){if(!e.isFullAutoParent()){var t=e._private.data.id,r=n(e,i.nodeMass),a=e._private.locked,o=e.position(),s=h.fromScreen({x:o.x,y:o.y});e.scratch().arbor=h.addNode(t,{element:e,mass:r,fixed:a,x:a?s.x:void 0,y:a?s.y:void 0})}}function o(e){var t=e.source().id(),r=e.target().id(),a=n(e,i.edgeLength);e.scratch().arbor=h.addEdge(t,r,{length:a})}var s=i.cy,l=i.eles,u=l.nodes().not(\":parent\"),c=l.edges(),d=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:s.width(),h:s.height()}),p=!1;if(t.trigger({type:\"layoutstart\",layout:t}),void 0!==i.liveUpdate&&(i.animate=i.liveUpdate),s.nodes().size()<=1)return i.fit&&s.reset(),s.nodes().position({x:Math.round((d.x1+d.x2)/2),y:Math.round((d.y1+d.y2)/2)}),t.one(\"layoutready\",i.ready),t.trigger({type:\"layoutready\",layout:t}),t.one(\"layoutstop\",i.stop),void t.trigger({type:\"layoutstop\",layout:t});var h=t._private.system=r.ParticleSystem();h.parameters({repulsion:i.repulsion,stiffness:i.stiffness,friction:i.friction,gravity:i.gravity,fps:i.fps,dt:i.dt,precision:i.precision}),i.animate&&i.fit&&s.fit(d,i.padding);var v,g=250,f=!1,y=+new Date,m={init:function(){},redraw:function(){var e=h.energy();if(!i.infinite&&null!=i.stableEnergy&&null!=e&&e.n>0&&i.stableEnergy(e))return void t.stop();i.infinite||1/0==g||(clearTimeout(v),v=setTimeout(P,g));var r=s.collection();h.eachNode(function(e,t){var i=e.data,n=i.element;null!=n&&(n.locked()||n.grabbed()||(n.silentPosition({x:d.x1+t.x,y:d.y1+t.y}),r.merge(n)))}),i.animate&&r.length>0&&(p=!0,r.rtrigger(\"position\"),i.fit&&s.fit(i.padding),y=+new Date,p=!1),f||(f=!0,t.one(\"layoutready\",i.ready),t.trigger({type:\"layoutready\",layout:t}))}};h.renderer=m,h.screenSize(d.w,d.h),h.screenPadding(i.padding,i.padding,i.padding,i.padding),h.screenStep(i.stepSize);var x;u.on(\"grab free position\",x=function(e){if(!p){var t=this.position(),n=h.fromScreen(t);if(n){var a=r.Point(n.x,n.y),o=i.padding;switch(d.x1+o<=t.x&&t.x<=d.x2-o&&d.y1+o<=t.y&&t.y<=d.y2-o&&(this.scratch().arbor.p=a),e.type){case\"grab\":this.scratch().arbor.fixed=!0;break;case\"free\":this.scratch().arbor.fixed=!1}}}});var b;u.on(\"lock unlock\",b=function(){node.scratch().arbor.fixed=node.locked()});var w;l.on(\"remove\",w=function(){});var _;s.on(\"add\",\"*\",_=function(){});var E;s.on(\"resize\",E=function(){if(null==i.boundingBox&&null!=t._private.system){var e=s.width(),r=s.height();h.screenSize(e,r)}}),u.each(function(e,t){a(t)}),c.each(function(e,t){o(t)});var S=u.filter(\":grabbable\");i.ungrabifyWhileSimulating&&S.ungrabify();var P=t._private.doneHandler=function(){t._private.doneHandler=null,i.animate||(i.fit&&s.reset(),u.rtrigger(\"position\")),u.off(\"grab free position\",x),u.off(\"lock unlock\",b),l.off(\"remove\",w),s.off(\"add\",\"*\",_),s.off(\"resize\",E),i.ungrabifyWhileSimulating&&S.grabify(),t.one(\"layoutstop\",i.stop),t.trigger({type:\"layoutstop\",layout:t})};h.start(),!i.infinite&&null!=i.maxSimulationTime&&i.maxSimulationTime>0&&1/0!==i.maxSimulationTime&&setTimeout(function(){t.stop()},i.maxSimulationTime)}),this},t.prototype.stop=function(){return null!=this._private.system&&this._private.system.stop(),this._private.doneHandler&&this._private.doneHandler(),this},e(\"layout\",\"arbor\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,directed:!1,padding:30,circle:!1,boundingBox:void 0,avoidOverlap:!0,roots:void 0,maximalAdjustments:0,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){var t,i=this.options,r=i,n=i.cy,a=r.eles,o=a.nodes().not(\":parent\"),s=a,l=e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()});if(e.is.elementOrCollection(r.roots))t=r.roots;else if(e.is.array(r.roots)){for(var u=[],c=0;c<r.roots.length;c++){var d=r.roots[c],p=n.getElementById(d);u.push(p)}t=new e.Collection(n,u)}else if(e.is.string(r.roots))t=n.$(r.roots);else if(r.directed)t=o.roots();else{for(var h=[],v=o;v.length>0;){var g=n.collection();a.bfs({roots:v[0],visit:function(e,t,i){g=g.add(i)},directed:!1}),v=v.not(g),h.push(g)}t=n.collection();for(var c=0;c<h.length;c++){var f=h[c],y=f.maxDegree(!1),m=f.filter(function(){return this.degree(!1)===y});t=t.add(m)}}var x=[],b={},w={},_={},E={},S={};s.bfs({roots:t,directed:r.directed,visit:function(e,t,i,r,n){var a=this[0],o=a.id();if(x[t]||(x[t]=[]),x[t].push(a),b[o]=!0,w[o]=t,_[o]=n,E[o]=r,n){var s=n.id(),l=S[s]=S[s]||[];l.push(i)}}});for(var P=[],c=0;c<o.length;c++){var p=o[c];b[p.id()]||P.push(p)}for(var D=3*P.length,k=0;0!==P.length&&D>k;){for(var C=P.shift(),T=C.neighborhood().nodes(),N=!1,c=0;c<T.length;c++){var M=w[T[c].id()];if(void 0!==M){x[M].push(C),N=!0;break}}N||P.push(C),k++}for(;0!==P.length;){var C=P.shift(),N=!1;N||(0===x.length&&x.push([]),x[0].push(C))}var B=function(){for(var e=0;e<x.length;e++)for(var t=x[e],i=0;i<t.length;i++){var r=t[i];r._private.scratch.breadthfirst={depth:e,index:i}}};B();for(var I=function(e){for(var t,i=e.connectedEdges(function(){return this.data(\"target\")===e.id()\n}),r=e._private.scratch.breadthfirst,n=0,a=0;a<i.length;a++){var o=i[a],s=o.source()[0],l=s._private.scratch.breadthfirst;r.depth<=l.depth&&n<l.depth&&(n=l.depth,t=s)}return t},z=0;z<r.maximalAdjustments;z++){for(var L=x.length,O=[],c=0;L>c;c++)for(var M=x[c],R=M.length,X=0;R>X;X++){var p=M[X],V=p._private.scratch.breadthfirst,Y=I(p);Y&&(V.intEle=Y,O.push(p))}for(var c=0;c<O.length;c++){var p=O[c],V=p._private.scratch.breadthfirst,Y=V.intEle,A=Y._private.scratch.breadthfirst;x[V.depth].splice(V.index,1);for(var q=A.depth+1;q>x.length-1;)x.push([]);x[q].push(p),V.depth=q,V.index=x[q].length-1}B()}var F=0;if(r.avoidOverlap){for(var c=0;c<o.length;c++){var j=o[c].outerWidth(),W=o[c].outerHeight();F=Math.max(F,j,W)}F*=1.75}for(var H={},$=function(e){if(H[e.id()])return H[e.id()];for(var t=e._private.scratch.breadthfirst.depth,i=e.neighborhood().nodes(),r=0,n=0,a=0;a<i.length;a++){var o=i[a],s=o._private.scratch.breadthfirst.index,l=o._private.scratch.breadthfirst.depth,u=x[l].length;(t>l||0===t)&&(r+=s/u,n++)}return n=Math.max(1,n),r/=n,0===n&&(r=void 0),H[e.id()]=r,r},Z=function(e,t){var i=$(e),r=$(t);return i-r},U=0;3>U;U++){for(var c=0;c<x.length;c++)x[c]=x[c].sort(Z);B()}for(var G=0,c=0;c<x.length;c++)G=Math.max(x[c].length,G);for(var K={x:l.x1+l.w/2,y:l.x1+l.h/2},J=function(e,t){var i=e._private.scratch.breadthfirst,n=i.depth,a=i.index,o=x[n].length;r.strictHierarchy&&(o=G);var s=Math.max(l.w/(o+1),F),u=Math.max(l.h/(x.length+1),F),c=Math.min(l.w/2/x.length,l.h/2/x.length);if(c=Math.max(c,F),r.strictHierarchy&&!r.circle){var d={x:K.x+(a+1-(o+1)/2)*s,y:(n+1)*u};if(t)return d;var p=S[e.id()];if(p){d.x=0;for(var h=0;h<p.length;h++){var v=Q[p[h].id()];d.x+=v.x}d.x/=p.length}return d}if(r.circle){var g=c*n+c-(x.length>0&&x[0].length<=3?c/2:0),f=2*Math.PI/x[n].length*a;return 0===n&&1===x[0].length&&(g=1),{x:K.x+g*Math.cos(f),y:K.y+g*Math.sin(f)}}return{x:K.x+(a+1-(o+1)/2)*s,y:(n+1)*u}},Q={},c=x.length-1;c>=0;c--)for(var M=x[c],X=0;X<M.length;X++){var C=M[X];Q[C.id()]=J(C,c===x.length-1)}return o.layoutPositions(this,r,function(){return Q[this.id()]}),this},e(\"layout\",\"breadthfirst\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,padding:30,boundingBox:void 0,avoidOverlap:!0,radius:void 0,startAngle:1.5*Math.PI,counterclockwise:!1,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){for(var t,i=this.options,r=i,n=i.cy,a=r.eles,o=a.nodes().not(\":parent\"),s=e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()}),l={x:s.x1+s.w/2,y:s.y1+s.h/2},u=r.startAngle,c=2*Math.PI/o.length,d=0,p=0;p<o.length;p++){var h=o[p].outerWidth(),v=o[p].outerHeight();d=Math.max(d,h,v)}if(t=e.is.number(r.radius)?r.radius:o.length<=1?0:Math.min(s.h,s.w)/2-d,o.length>1&&r.avoidOverlap){d*=1.75;var c=2*Math.PI/o.length,g=Math.cos(c)-Math.cos(0),f=Math.sin(c)-Math.sin(0),y=Math.sqrt(d*d/(g*g+f*f));t=Math.max(y,t)}var m=function(){var e=t*Math.cos(u),i=t*Math.sin(u),n={x:l.x+e,y:l.y+i};return u=r.counterclockwise?u-c:u+c,n};return o.layoutPositions(this,r,m),this},e(\"layout\",\"circle\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={animate:!0,refresh:1,maxSimulationTime:4e3,ungrabifyWhileSimulating:!1,fit:!0,padding:30,boundingBox:void 0,ready:function(){},stop:function(){},randomize:!1,avoidOverlap:!0,handleDisconnected:!0,nodeSpacing:function(){return 10},flow:void 0,alignment:void 0,edgeLength:void 0,edgeSymDiffLength:void 0,edgeJaccardLength:void 0,unconstrIter:void 0,userConstIter:void 0,allConstIter:void 0,infinite:!1};t.prototype.run=function(){var t=this,i=this.options;return e.util.require(\"cola\",function(r){var n=i.cy,a=i.eles,o=a.nodes(),s=a.edges(),l=!1,u=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()}),c=function(t,i){if(e.is.fn(t)){var r=t;return r.apply(i,[i])}return t},d=function(){for(var e={min:1/0,max:-1/0},t={min:1/0,max:-1/0},r=0;r<o.length;r++){var a=o[r],s=a._private.scratch.cola;e.min=Math.min(e.min,s.x),e.max=Math.max(e.max,s.x),t.min=Math.min(t.min,s.y),t.max=Math.max(t.max,s.y)}o.positions(function(i,r){var n=r._private.position,a=r._private.scratch.cola;r.grabbed()||(n.x=u.x1+a.x-e.min,n.y=u.y1+a.y-t.min)}),l||(h(),l=!0),i.fit&&n.fit(i.padding)},p=function(){t.manuallyStopped=!1,i.ungrabifyWhileSimulating&&y.grabify(),o.off(\"grab free position\",m),o.off(\"lock unlock\",x),t.one(\"layoutstop\",i.stop),t.trigger({type:\"layoutstop\",layout:t})},h=function(){t.one(\"layoutready\",i.ready),t.trigger({type:\"layoutready\",layout:t})},v=i.refresh,g=1;i.refresh<0?(g=Math.abs(i.refresh),v=1):v=Math.max(1,v);var f=r.adaptor({trigger:function(e){switch(e.type){case\"tick\":i.animate&&d();break;case\"end\":d(),(!i.infinite||t.manuallyStopped)&&p()}},kick:function(t){var r=0,n=function(){var e=t();return e&&i.infinite&&f.resume(),e},a=function(){var e,t=r;if(r=(r+1)%g,0!==t)return!1;for(var i=0;v>i&&!e;i++)e=e||n();return e};if(i.animate){var o=function(){a()||e.util.requestAnimationFrame(o)};e.util.requestAnimationFrame(o)}else for(;!n(););},on:function(){},drag:function(){}});t.adaptor=f;var y=o.filter(\":grabbable\");i.ungrabifyWhileSimulating&&y.ungrabify();var m;o.on(\"grab free position\",m=function(t){var i=this,r=i._private.scratch.cola,n=i._private.position;switch(i.grabbed()?(r.x=n.x-u.x1,r.y=n.y-u.y1,f.dragstart(r)):e.is.number(r.x)&&e.is.number(r.y)&&(n.x=r.x+u.x1,n.y=r.y+u.y1),t.type){case\"grab\":f.dragstart(r),f.resume();break;case\"free\":f.dragend(r)}});var x;o.on(\"lock unlock\",x=function(){var e=this,t=e._private.scratch.cola;e.locked()?f.dragstart(t):f.dragend(t)});var b=o.stdFilter(function(e){return!e.isParent()});if(f.nodes(b.map(function(e,t){var r=c(i.nodeSpacing,e),n=e.position(),a=e._private.scratch.cola={x:i.randomize?Math.round(Math.random()*u.w):n.x,y:i.randomize?Math.round(Math.random()*u.h):n.y,width:e.outerWidth()+2*r,height:e.outerHeight()+2*r,index:t};return a})),i.alignment){var w=[],_=[];b.forEach(function(e){var t=c(i.alignment,e),r=e._private.scratch.cola,n=r.index;t&&(null!=t.x&&w.push({node:n,offset:t.x}),null!=t.y&&_.push({node:n,offset:t.y}))});var E=[];w.length>0&&E.push({type:\"alignment\",axis:\"x\",offsets:w}),_.length>0&&E.push({type:\"alignment\",axis:\"y\",offsets:_}),f.constraints(E)}f.groups(o.stdFilter(function(e){return e.isParent()}).map(function(e,t){return e._private.scratch.cola={index:t,leaves:e.children().stdFilter(function(e){return!e.isParent()}).map(function(e){return e[0]._private.scratch.cola.index})},e}).map(function(e){return e._private.scratch.cola.groups=e.children().stdFilter(function(e){return e.isParent()}).map(function(e){return e._private.scratch.cola.index}),e._private.scratch.cola}));var S,P;null!=i.edgeLength?(S=i.edgeLength,P=\"linkDistance\"):null!=i.edgeSymDiffLength?(S=i.edgeSymDiffLength,P=\"symmetricDiffLinkLengths\"):null!=i.edgeJaccardLength?(S=i.edgeJaccardLength,P=\"jaccardLinkLengths\"):(S=100,P=\"linkDistance\");var D=function(e){return e.calcLength};if(f.links(s.stdFilter(function(e){return!e.source().isParent()&&!e.target().isParent()}).map(function(e){var t=e._private.scratch.cola={source:e.source()[0]._private.scratch.cola.index,target:e.target()[0]._private.scratch.cola.index};return null!=S&&(t.calcLength=c(S,e)),t})),f.size([u.w,u.h]),null!=S&&f[P](D),i.flow){var k,C=\"y\",T=50;e.is.string(i.flow)?k={axis:i.flow,minSeparation:T}:e.is.number(i.flow)?k={axis:C,minSeparation:i.flow}:e.is.plainObject(i.flow)?(k=i.flow,k.axis=k.axis||C,k.minSeparation=null!=k.minSeparation?k.minSeparation:T):k={axis:C,minSeparation:T},f.flowLayout(k.axis,k.minSeparation)}f.avoidOverlaps(i.avoidOverlap).handleDisconnected(i.handleDisconnected).start(i.unconstrIter,i.userConstIter,i.allConstIter),t.trigger({type:\"layoutstart\",layout:t}),i.infinite||setTimeout(function(){f.stop()},i.maxSimulationTime)}),this},t.prototype.stop=function(){return this.adaptor&&(this.manuallyStopped=!0,this.adaptor.stop()),this},e(\"layout\",\"cola\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,padding:30,startAngle:1.5*Math.PI,counterclockwise:!1,minNodeSpacing:10,boundingBox:void 0,avoidOverlap:!0,height:void 0,width:void 0,concentric:function(){return this.degree()},levelWidth:function(e){return e.maxDegree()/4},animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){for(var t=this.options,i=t,r=t.cy,n=i.eles,a=n.nodes().not(\":parent\"),o=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:r.width(),h:r.height()}),s={x:o.x1+o.w/2,y:o.y1+o.h/2},l=[],u=i.startAngle,c=0,d=0;d<a.length;d++){var p,h=a[d];p=i.concentric.call(h),l.push({value:p,node:h}),h._private.layoutData.concentric=p}a.updateStyle();for(var d=0;d<a.length;d++){var h=a[d];c=Math.max(c,h.outerWidth(),h.outerHeight())}l.sort(function(e,t){return t.value-e.value});for(var v=i.levelWidth(a),g=[[]],f=g[0],d=0;d<l.length;d++){var y=l[d];if(f.length>0){var m=Math.abs(f[0].value-y.value);m>=v&&(f=[],g.push(f))}f.push(y)}var x={},b=0,w=c+i.minNodeSpacing;if(!i.avoidOverlap){var _=g.length>0&&g[0].length>1,E=Math.min(o.w,o.h)/2-w,S=E/(g.length+_?1:0);w=Math.min(w,S)}for(var d=0;d<g.length;d++){var P=g[d],D=2*Math.PI/P.length;if(P.length>1&&i.avoidOverlap){var k=Math.cos(D)-Math.cos(0),C=Math.sin(D)-Math.sin(0),T=Math.sqrt(w*w/(k*k+C*C));b=Math.max(T,b)}for(var N=0;N<P.length;N++){var y=P[N],u=i.startAngle+(i.counterclockwise?1:-1)*D*N,M={x:s.x+b*Math.cos(u),y:s.y+b*Math.sin(u)};x[y.node.id()]=M}b+=w}return a.layoutPositions(this,i,function(){var e=this.id();return x[e]}),this},e(\"layout\",\"concentric\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend({},r,t)}var i,r={ready:function(){},stop:function(){},animate:!0,refresh:4,fit:!0,padding:30,boundingBox:void 0,randomize:!0,debug:!1,nodeRepulsion:4e5,nodeOverlap:10,idealEdgeLength:10,edgeElasticity:100,nestingFactor:5,gravity:250,numIter:100,initialTemp:200,coolingFactor:.95,minTemp:1};t.prototype.run=function(){var t=this.options,r=t.cy,a=this;a.stopped=!1,a.trigger({type:\"layoutstart\",layout:a}),i=!0===t.debug?!0:!1;var o=new Date,d=n(r,a,t);i&&s(d),!0===t.randomize&&l(d,r),m(d,r,t);var p=function(e){return a.stopped?(w(\"Layout manually stopped. Stopping computation in step \"+e),!1):(c(d,r,t,e),d.temperature=d.temperature*t.coolingFactor,w(\"New temperature: \"+d.temperature),d.temperature<t.minTemp?(w(\"Temperature drop below minimum threshold. Stopping computation in step \"+e),!1):!0)},h=function(){u(d,r,t),!0===t.fit&&r.fit(t.padding);var e=new Date;console.info(\"Layout took \"+(e-o)+\" ms\"),a.one(\"layoutstop\",t.stop),a.trigger({type:\"layoutstop\",layout:a})};if(t.animate){var v=0,g=function(){for(var i,n=0;n<t.refresh&&v<t.numIter;){var i=p(v);if(i===!1)break;n++,v++}u(d,r,t),t.fit&&r.fit(t.padding),i!==!1&&v+1<t.numIter?e.util.requestAnimationFrame(g):h()};e.util.requestAnimationFrame(g)}else{for(var v=0;v<t.numIter&&p(v)!==!1;v++);h()}return this},t.prototype.stop=function(){return this.stopped=!0,this};var n=function(t,i,r){for(var n=r.eles.edges(),o=r.eles.nodes(),s={layout:i,layoutNodes:[],idToIndex:{},nodeSize:o.size(),graphSet:[],indexToGraph:[],layoutEdges:[],edgeSize:n.size(),temperature:r.initialTemp,clientWidth:t.width(),clientHeight:t.width(),boundingBox:e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:t.width(),h:t.height()})},l=0;l<s.nodeSize;l++){var u={};u.id=o[l].data(\"id\"),u.parentId=o[l].data(\"parent\"),u.children=[],u.positionX=o[l].position(\"x\"),u.positionY=o[l].position(\"y\"),u.offsetX=0,u.offsetY=0,u.height=o[l].height(),u.width=o[l].width(),u.maxX=u.positionX+u.width/2,u.minX=u.positionX-u.width/2,u.maxY=u.positionY+u.height/2,u.minY=u.positionY-u.height/2,u.padLeft=o[l]._private.style[\"padding-left\"].pxValue,u.padRight=o[l]._private.style[\"padding-right\"].pxValue,u.padTop=o[l]._private.style[\"padding-top\"].pxValue,u.padBottom=o[l]._private.style[\"padding-bottom\"].pxValue,s.layoutNodes.push(u),s.idToIndex[u.id]=l}for(var c=[],d=0,p=-1,h=[],l=0;l<s.nodeSize;l++){var v=s.layoutNodes[l],g=v.parentId;null!=g?s.layoutNodes[s.idToIndex[g]].children.push(v.id):(c[++p]=v.id,h.push(v.id))}for(s.graphSet.push(h);p>=d;){var f=c[d++],y=s.idToIndex[f],m=s.layoutNodes[y],x=m.children;if(x.length>0){s.graphSet.push(x);for(var l=0;l<x.length;l++)c[++p]=x[l]}}for(var l=0;l<s.graphSet.length;l++)for(var b=s.graphSet[l],_=0;_<b.length;_++){var E=s.idToIndex[b[_]];s.indexToGraph[E]=l}for(var l=0;l<s.edgeSize;l++){var S=n[l],P={};P.id=S.data(\"id\"),P.sourceId=S.data(\"source\"),P.targetId=S.data(\"target\");var D=r.idealEdgeLength,k=s.idToIndex[P.sourceId],C=s.idToIndex[P.targetId],T=s.indexToGraph[k],N=s.indexToGraph[C];if(T!=N){for(var M=a(P.sourceId,P.targetId,s),B=s.graphSet[M],I=0,u=s.layoutNodes[k];-1===$.inArray(u.id,B);)u=s.layoutNodes[s.idToIndex[u.parentId]],I++;for(u=s.layoutNodes[C];-1===$.inArray(u.id,B);)u=s.layoutNodes[s.idToIndex[u.parentId]],I++;w(\"LCA of nodes \"+P.sourceId+\" and \"+P.targetId+\". Index: \"+M+\" Contents: \"+B.toString()+\". Depth: \"+I),D*=I*r.nestingFactor}P.idealLength=D,s.layoutEdges.push(P)}return s},a=function(e,t,i){var r=o(e,t,0,i);return 2>r.count?0:r.graph},o=function(e,t,i,r){var n=r.graphSet[i];if(-1<$.inArray(e,n)&&-1<$.inArray(t,n))return{count:2,graph:i};for(var a=0,s=0;s<n.length;s++){var l=n[s],u=r.idToIndex[l],c=r.layoutNodes[u].children;if(0!==c.length){var d=r.indexToGraph[r.idToIndex[c[0]]],p=o(e,t,d,r);if(0!==p.count){if(1!==p.count)return p;if(a++,2===a)break}}}return{count:a,graph:i}},s=function(e){if(i){console.debug(\"layoutNodes:\");for(var t=0;t<e.nodeSize;t++){var r=e.layoutNodes[t],n=\"\\nindex: \"+t+\"\\nId: \"+r.id+\"\\nChildren: \"+r.children.toString()+\"\\nparentId: \"+r.parentId+\"\\npositionX: \"+r.positionX+\"\\npositionY: \"+r.positionY+\"\\nOffsetX: \"+r.offsetX+\"\\nOffsetY: \"+r.offsetY+\"\\npadLeft: \"+r.padLeft+\"\\npadRight: \"+r.padRight+\"\\npadTop: \"+r.padTop+\"\\npadBottom: \"+r.padBottom;console.debug(n)}console.debug(\"idToIndex\");for(var t in e.idToIndex)console.debug(\"Id: \"+t+\"\\nIndex: \"+e.idToIndex[t]);console.debug(\"Graph Set\");for(var a=e.graphSet,t=0;t<a.length;t++)console.debug(\"Set : \"+t+\": \"+a[t].toString());for(var n=\"IndexToGraph\",t=0;t<e.indexToGraph.length;t++)n+=\"\\nIndex : \"+t+\" Graph: \"+e.indexToGraph[t];console.debug(n),n=\"Layout Edges\";for(var t=0;t<e.layoutEdges.length;t++){var o=e.layoutEdges[t];n+=\"\\nEdge Index: \"+t+\" ID: \"+o.id+\" SouceID: \"+o.sourceId+\" TargetId: \"+o.targetId+\" Ideal Length: \"+o.idealLength}console.debug(n),n=\"nodeSize: \"+e.nodeSize,n+=\"\\nedgeSize: \"+e.edgeSize,n+=\"\\ntemperature: \"+e.temperature,console.debug(n)}},l=function(e){for(var t=e.clientWidth,i=e.clientHeight,r=0;r<e.nodeSize;r++){var n=e.layoutNodes[r];n.positionX=Math.random()*t,n.positionY=Math.random()*i}},u=function(e,t,i){var r=\"Refreshing positions\";w(r);var n=e.layout,a=i.eles.nodes(),o=e.boundingBox,s={x1:1/0,x2:-1/0,y1:1/0,y2:-1/0};i.boundingBox&&(a.forEach(function(t){var i=e.layoutNodes[e.idToIndex[t.data(\"id\")]];s.x1=Math.min(s.x1,i.positionX),s.x2=Math.max(s.x2,i.positionX),s.y1=Math.min(s.y1,i.positionY),s.y2=Math.max(s.y2,i.positionY)}),s.w=s.x2-s.x1,s.h=s.y2-s.y1),a.positions(function(t,n){var a=e.layoutNodes[e.idToIndex[n.data(\"id\")]];if(r=\"Node: \"+a.id+\". Refreshed position: (\"+a.positionX+\", \"+a.positionY+\").\",w(r),i.boundingBox){var l=(a.positionX-s.x1)/s.w,u=(a.positionY-s.y1)/s.h;return{x:o.x1+l*o.w,y:o.y1+u*o.h}}return{x:a.positionX,y:a.positionY}}),!0!==e.ready&&(r=\"Triggering layoutready\",w(r),e.ready=!0,n.one(\"layoutready\",i.ready),n.trigger({type:\"layoutready\",layout:this}))},c=function(e,t,i,r){var n=\"\\n\\n###############################\";n+=\"\\nSTEP: \"+r,n+=\"\\n###############################\\n\",w(n),d(e,t,i),g(e,t,i),f(e,t,i),y(e,t,i),m(e,t,i)},d=function(e,t,i){var r=\"calculateNodeForces\";w(r);for(var n=0;n<e.graphSet.length;n++){var a=e.graphSet[n],o=a.length;r=\"Set: \"+a.toString(),w(r);for(var s=0;o>s;s++)for(var l=e.layoutNodes[e.idToIndex[a[s]]],u=s+1;o>u;u++){var c=e.layoutNodes[e.idToIndex[a[u]]];p(l,c,e,t,i)}}},p=function(e,t,i,r,n){var a=\"Node repulsion. Node1: \"+e.id+\" Node2: \"+t.id,o=t.positionX-e.positionX,s=t.positionY-e.positionY;if(a+=\"\\ndirectionX: \"+o+\", directionY: \"+s,0===o&&0===s)return void(a+=\"\\nNodes have the same position.\");var l=v(e,t,o,s);if(l>0){a+=\"\\nNodes DO overlap.\",a+=\"\\nOverlap: \"+l;var u=n.nodeOverlap*l,c=Math.sqrt(o*o+s*s);a+=\"\\nDistance: \"+c;var d=u*o/c,p=u*s/c}else{a+=\"\\nNodes do NOT overlap.\";var g=h(e,o,s),f=h(t,-1*o,-1*s),y=f.x-g.x,m=f.y-g.y,x=y*y+m*m,c=Math.sqrt(x);a+=\"\\nDistance: \"+c;var u=n.nodeRepulsion/x,d=u*y/c,p=u*m/c}e.offsetX-=d,e.offsetY-=p,t.offsetX+=d,t.offsetY+=p,a+=\"\\nForceX: \"+d+\" ForceY: \"+p,w(a)},h=function(e,t,i){var r=e.positionX,n=e.positionY,a=e.height,o=e.width,s=i/t,l=a/o,u=\"Computing clipping point of node \"+e.id+\" . Height:  \"+a+\", Width: \"+o+\"\\nDirection \"+t+\", \"+i,c={};do{if(0===t&&i>0){c.x=r,u+=\"\\nUp direction\",c.y=n+a/2;break}if(0===t&&0>i){c.x=r,c.y=n+a/2,u+=\"\\nDown direction\";break}if(t>0&&s>=-1*l&&l>=s){c.x=r+o/2,c.y=n+o*i/2/t,u+=\"\\nRightborder\";break}if(0>t&&s>=-1*l&&l>=s){c.x=r-o/2,c.y=n-o*i/2/t,u+=\"\\nLeftborder\";break}if(i>0&&(-1*l>=s||s>=l)){c.x=r+a*t/2/i,c.y=n+a/2,u+=\"\\nTop border\";break}if(0>i&&(-1*l>=s||s>=l)){c.x=r-a*t/2/i,c.y=n-a/2,u+=\"\\nBottom border\";break}}while(!1);return u+=\"\\nClipping point found at \"+c.x+\", \"+c.y,w(u),c},v=function(e,t,i,r){if(i>0)var n=e.maxX-t.minX;else var n=t.maxX-e.minX;if(r>0)var a=e.maxY-t.minY;else var a=t.maxY-e.minY;return n>=0&&a>=0?Math.sqrt(n*n+a*a):0},g=function(e,t,i){for(var r=0;r<e.edgeSize;r++){var n=e.layoutEdges[r],a=e.idToIndex[n.sourceId],o=e.layoutNodes[a],s=e.idToIndex[n.targetId],l=e.layoutNodes[s],u=l.positionX-o.positionX,c=l.positionY-o.positionY;if(0===u&&0===c)return;var d=h(o,u,c),p=h(l,-1*u,-1*c),v=p.x-d.x,g=p.y-d.y,f=Math.sqrt(v*v+g*g),y=Math.pow(n.idealLength-f,2)/i.edgeElasticity;if(0!==f)var m=y*v/f,x=y*g/f;else var m=0,x=0;o.offsetX+=m,o.offsetY+=x,l.offsetX-=m,l.offsetY-=x;var b=\"Edge force between nodes \"+o.id+\" and \"+l.id;b+=\"\\nDistance: \"+f+\" Force: (\"+m+\", \"+x+\")\",w(b)}},f=function(e,t,i){var r=\"calculateGravityForces\";w(r);for(var n=0;n<e.graphSet.length;n++){var a=e.graphSet[n],o=a.length;if(r=\"Set: \"+a.toString(),w(r),0===n)var s=e.clientHeight/2,l=e.clientWidth/2;else var u=e.layoutNodes[e.idToIndex[a[0]]],c=e.layoutNodes[e.idToIndex[u.parentId]],s=c.positionX,l=c.positionY;r=\"Center found at: \"+s+\", \"+l,w(r);for(var d=0;o>d;d++){var p=e.layoutNodes[e.idToIndex[a[d]]];r=\"Node: \"+p.id;var h=s-p.positionX,v=l-p.positionY,g=Math.sqrt(h*h+v*v);if(g>1){var f=i.gravity*h/g,y=i.gravity*v/g;p.offsetX+=f,p.offsetY+=y,r+=\": Applied force: \"+f+\", \"+y}else r+=\": skypped since it's too close to center\";w(r)}}},y=function(e){var t=[],i=0,r=-1;for(w(\"propagateForces\"),t.push.apply(t,e.graphSet[0]),r+=e.graphSet[0].length;r>=i;){var n=t[i++],a=e.idToIndex[n],o=e.layoutNodes[a],s=o.children;if(0<s.length){var l=o.offsetX,u=o.offsetY,c=\"Propagating offset from parent node : \"+o.id+\". OffsetX: \"+l+\". OffsetY: \"+u;c+=\"\\n Children: \"+s.toString(),w(c);for(var d=0;d<s.length;d++){var p=e.layoutNodes[e.idToIndex[s[d]]];p.offsetX+=l,p.offsetY+=u,t[++r]=s[d]}o.offsetX=0,o.offsetY=0}}},m=function(e){var t=\"Updating positions\";w(t);for(var i=0;i<e.nodeSize;i++){var r=e.layoutNodes[i];0<r.children.length&&(w(\"Resetting boundaries of compound node: \"+r.id),r.maxX=void 0,r.minX=void 0,r.maxY=void 0,r.minY=void 0)}for(var i=0;i<e.nodeSize;i++){var r=e.layoutNodes[i];if(0<r.children.length)w(\"Skipping position update of node: \"+r.id);else{t=\"Node: \"+r.id+\" Previous position: (\"+r.positionX+\", \"+r.positionY+\").\";var n=x(r.offsetX,r.offsetY,e.temperature);r.positionX+=n.x,r.positionY+=n.y,r.offsetX=0,r.offsetY=0,r.minX=r.positionX-r.width,r.maxX=r.positionX+r.width,r.minY=r.positionY-r.height,r.maxY=r.positionY+r.height,t+=\" New Position: (\"+r.positionX+\", \"+r.positionY+\").\",w(t),b(r,e)}}for(var i=0;i<e.nodeSize;i++){var r=e.layoutNodes[i];0<r.children.length&&(r.positionX=(r.maxX+r.minX)/2,r.positionY=(r.maxY+r.minY)/2,r.width=r.maxX-r.minX,r.height=r.maxY-r.minY,t=\"Updating position, size of compound node \"+r.id,t+=\"\\nPositionX: \"+r.positionX+\", PositionY: \"+r.positionY,t+=\"\\nWidth: \"+r.width+\", Height: \"+r.height,w(t))}},x=function(e,t,i){var r=\"Limiting force: (\"+e+\", \"+t+\"). Max: \"+i,n=Math.sqrt(e*e+t*t);if(n>i)var a={x:i*e/n,y:i*t/n};else var a={x:e,y:t};return r+=\".\\nResult: (\"+a.x+\", \"+a.y+\")\",w(r),a},b=function(e,t){var i=\"Propagating new position/size of node \"+e.id,r=e.parentId;if(null==r)return i+=\". No parent node.\",void w(i);var n=t.layoutNodes[t.idToIndex[r]],a=!1;return(null==n.maxX||e.maxX+n.padRight>n.maxX)&&(n.maxX=e.maxX+n.padRight,a=!0,i+=\"\\nNew maxX for parent node \"+n.id+\": \"+n.maxX),(null==n.minX||e.minX-n.padLeft<n.minX)&&(n.minX=e.minX-n.padLeft,a=!0,i+=\"\\nNew minX for parent node \"+n.id+\": \"+n.minX),(null==n.maxY||e.maxY+n.padBottom>n.maxY)&&(n.maxY=e.maxY+n.padBottom,a=!0,i+=\"\\nNew maxY for parent node \"+n.id+\": \"+n.maxY),(null==n.minY||e.minY-n.padTop<n.minY)&&(n.minY=e.minY-n.padTop,a=!0,i+=\"\\nNew minY for parent node \"+n.id+\": \"+n.minY),a?(w(i),b(n,t)):(i+=\". No changes in boundaries/position of parent node \"+n.id,void w(i))},w=function(e){i&&console.debug(e)};e(\"layout\",\"cose\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={nodeSep:void 0,edgeSep:void 0,rankSep:void 0,rankDir:void 0,minLen:function(){return 1},fit:!0,padding:30,animate:!1,animationDuration:500,boundingBox:void 0,ready:function(){},stop:function(){}};t.prototype.run=function(){var t=this.options,i=this;return e.util.require(\"dagre\",function(r){for(var n=t.cy,a=t.eles,o=e.util.makeBoundingBox(t.boundingBox?t.boundingBox:{x1:0,y1:0,w:n.width(),h:n.height()}),s=new r.Digraph,l=a.nodes().not(\":parent\"),u=0;u<l.length;u++){var c=l[u];s.addNode(c.id(),{width:c.width(),height:c.height()})}for(var d=a.edges(),u=0;u<d.length;u++){var p=d[u];s.addEdge(p.id(),p.source().id(),p.target().id(),{minLen:e.is.fn(t.minLen)?t.minLen.apply(p,[p]):t.minLen})}var h=r.layout();t.nodeSep&&h.nodeSep(t.nodeSep),t.edgeSep&&h.edgeSep(t.edgeSep),t.rankSep&&h.rankSep(t.rankSep),t.rankDir&&h.rankDir(t.rankDir),h=h.run(s),h.eachNode(function(e,t){n.getElementById(e).scratch().dagre=t});var v;t.boundingBox?(v={x1:1/0,x2:-1/0,y1:1/0,y2:-1/0},l.forEach(function(e){var t=e.scratch().dagre;v.x1=Math.min(v.x1,t.x),v.x2=Math.max(v.x2,t.x),v.y1=Math.min(v.y1,t.y),v.y2=Math.max(v.y2,t.y)}),v.w=v.x2-v.x1,v.h=v.y2-v.y1):v=o;var g=function(e){if(t.boundingBox){var i=(e.x-v.x1)/v.w,r=(e.y-v.y1)/v.h;return{x:o.x1+i*o.w,y:o.y1+r*o.h}}return e};l.layoutPositions(i,t,function(){var e=this.scratch().dagre;return g({x:e.x,y:e.y})})}),this},e(\"layout\",\"dagre\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend({},i,t)}var i={fit:!0,padding:30,boundingBox:void 0,avoidOverlap:!0,rows:void 0,columns:void 0,position:function(){},animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){var t=this.options,i=t,r=t.cy,n=i.eles,a=n.nodes().not(\":parent\"),o=e.util.makeBoundingBox(i.boundingBox?i.boundingBox:{x1:0,y1:0,w:r.width(),h:r.height()});if(0===o.h||0===o.w)a.layoutPositions(this,i,function(){return{x:o.x1,y:o.y1}});else{var s=a.size(),l=Math.sqrt(s*o.h/o.w),u=Math.round(l),c=Math.round(o.w/o.h*l),d=function(e){if(null==e)return Math.min(u,c);var t=Math.min(u,c);t==u?u=e:c=e},p=function(e){if(null==e)return Math.max(u,c);var t=Math.max(u,c);t==u?u=e:c=e};if(null!=i.rows&&null!=i.columns)u=i.rows,c=i.columns;else if(null!=i.rows&&null==i.columns)u=i.rows,c=Math.ceil(s/u);else if(null==i.rows&&null!=i.columns)c=i.columns,u=Math.ceil(s/c);else if(c*u>s){var h=d(),v=p();(h-1)*v>=s?d(h-1):(v-1)*h>=s&&p(v-1)}else for(;s>c*u;){var h=d(),v=p();(v+1)*h>=s?p(v+1):d(h+1)}var g=o.w/c,f=o.h/u;if(i.avoidOverlap)for(var y=0;y<a.length;y++){var m=a[y],x=m.outerWidth(),b=m.outerHeight();g=Math.max(g,x),f=Math.max(f,b)}for(var w={},_=function(e,t){return w[\"c-\"+e+\"-\"+t]?!0:!1},E=function(e,t){w[\"c-\"+e+\"-\"+t]=!0},S=0,P=0,D=function(){P++,P>=c&&(P=0,S++)},k={},y=0;y<a.length;y++){var m=a[y],C=i.position(m);if(C&&(void 0!==C.row||void 0!==C.col)){var T={row:C.row,col:C.col};if(void 0===T.col)for(T.col=0;_(T.row,T.col);)T.col++;else if(void 0===T.row)for(T.row=0;_(T.row,T.col);)T.row++;k[m.id()]=T,E(T.row,T.col)}}var N=function(e,t){var i,r;if(t.locked()||t.isFullAutoParent())return!1;var n=k[t.id()];if(n)i=n.col*g+g/2+o.x1,r=n.row*f+f/2+o.y1;else{for(;_(S,P);)D();i=P*g+g/2+o.x1,r=S*f+f/2+o.y1,E(S,P),D()}return{x:i,y:r}};a.layoutPositions(this,i,N)}return this},e(\"layout\",\"grid\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={ready:function(){},stop:function(){}};t.prototype.run=function(){{var e=this.options,t=e.eles,i=this;e.cy}return i.trigger(\"layoutstart\"),t.nodes().positions(function(){return{x:0,y:0}}),i.one(\"layoutready\",e.ready),i.trigger(\"layoutready\"),i.one(\"layoutstop\",e.stop),i.trigger(\"layoutstop\"),this},t.prototype.stop=function(){return this},e(\"layout\",\"null\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={positions:void 0,zoom:void 0,pan:void 0,fit:!0,padding:30,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){function t(e){if(null==i.positions)return null;if(a)return i.positions.apply(e,[e]);var t=i.positions[e._private.data.id];return null==t?null:t}var i=this.options,r=i.eles,n=r.nodes(),a=e.is.fn(i.positions);return n.layoutPositions(this,i,function(e,i){var r=t(i);return i.locked()||null==r?!1:r}),this},e(\"layout\",\"preset\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={fit:!0,padding:30,boundingBox:void 0,animate:!1,animationDuration:500,ready:void 0,stop:void 0};t.prototype.run=function(){var t=this.options,i=t.cy,r=t.eles,n=r.nodes().not(\":parent\"),a=e.util.makeBoundingBox(t.boundingBox?t.boundingBox:{x1:0,y1:0,w:i.width(),h:i.height()}),o=function(){return{x:a.x1+Math.round(Math.random()*a.w),y:a.y1+Math.round(Math.random()*a.h)}};return n.layoutPositions(this,t,o),this},e(\"layout\",\"random\",t)}(cytoscape),function(e){\"use strict\";function t(t){this.options=e.util.extend(!0,{},i,t)}var i={animate:!0,maxSimulationTime:4e3,ungrabifyWhileSimulating:!1,fit:!0,padding:30,boundingBox:void 0,random:!1,infinite:!1,ready:void 0,stop:void 0,stiffness:400,repulsion:400,damping:.5};t.prototype.run=function(){var t=this,i=this,r=this.options;return e.util.require(\"Springy\",function(n){function a(e){var t=e.scratch(\"springy\").model.id,i=w.layout.nodePoints[t].p,r=e.position(),n=null!=r.x&&null!=r.y?y(e.position()):{x:4*Math.random()-2,y:4*Math.random()-2};i.x=n.x,i.y=n.y}function o(){r.ungrabifyWhileSimulating&&E.ungrabify(),w.start()}var s=!1,l=r.cy;t.trigger({type:\"layoutstart\",layout:t});var u=r.eles,c=u.nodes().not(\":parent\"),d=u.edges(),p=e.util.makeBoundingBox(r.boundingBox?r.boundingBox:{x1:0,y1:0,w:l.width(),h:l.height()}),h=new n.Graph;c.each(function(e,t){t.scratch(\"springy\",{model:h.newNode({element:t})})}),d.each(function(e,t){var i=t.source().scratch(\"springy\").model,r=t.target().scratch(\"springy\").model;t.scratch(\"springy\",{model:h.newEdge(i,r,{element:t})})});var v=window.sim=new n.Layout.ForceDirected(h,r.stiffness,r.repulsion,r.damping);r.infinite&&(v.minEnergyThreshold=-1/0);var g=v.getBoundingBox(),f=function(e){g=v.getBoundingBox();var t=g.topright.subtract(g.bottomleft),i=e.subtract(g.bottomleft).divide(t.x).x*p.w+p.x1,r=e.subtract(g.bottomleft).divide(t.y).y*p.h+p.x1;return new n.Vector(i,r)},y=function(e){g=v.getBoundingBox();var t=g.topright.subtract(g.bottomleft),i=(e.x-p.x1)/p.w*t.x+g.bottomleft.x,r=(e.y-p.y1)/p.h*t.y+g.bottomleft.y;return new n.Vector(i,r)},m=l.collection(),x=l.nodes().size(),b=1,w=new n.Renderer(v,function(){m.length>0&&r.animate&&(s=!0,m.rtrigger(\"position\"),r.fit&&l.fit(r.padding),m=l.collection(),s=!1)},function(){},function(e,i){var n=f(i),a=e.data.element;a.locked()||a.grabbed()||(a._private.position={x:n.x,y:n.y},m.merge(a)),b==x&&(t.one(\"layoutready\",r.ready),t.trigger({type:\"layoutready\",layout:t})),b++});c.each(function(e,t){r.random||a(t)});var _;c.on(\"position\",_=function(){s||a(this)});var E=c.filter(\":grabbable\");i.stopSystem=function(){h.filterNodes(function(){return!1}),r.ungrabifyWhileSimulating&&E.grabify(),r.fit&&l.fit(r.padding),c.off(\"drag position\",_),t.one(\"layoutstop\",r.stop),t.trigger({type:\"layoutstop\",layout:t}),i.stopSystem=null},o(),r.infinite||setTimeout(function(){i.stop()},r.maxSimulationTime)}),this},t.prototype.stop=function(){return null!=this.stopSystem&&this.stopSystem(),this},e(\"layout\",\"springy\",t)}(cytoscape),function(e){\"use strict\";function t(e){this.options=e}t.prototype.recalculateRenderedStyle=function(){},t.prototype.notify=function(){},e(\"renderer\",\"null\",t)}(cytoscape);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/cytoscape/dist/cytoscape.min.js\n ** module id = 204\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/cytoscape/dist/cytoscape.min.js?");

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar bindAutoBindMethods = __webpack_require__(247);\n\n/**\n * Updates a React component recursively, so even if children define funky\n * `shouldComponentUpdate`, they are forced to re-render.\n * Makes sure that any newly added methods are properly auto-bound.\n */\nfunction deepForceUpdate(component) {\n  if (component._instance) {\n    // React 0.13\n    component = component._instance;\n  }\n\n  bindAutoBindMethods(component);\n\n  if (component.forceUpdate) {\n    component.forceUpdate();\n  }\n\n  if (component._renderedComponent) {\n    deepForceUpdate(component._renderedComponent);\n  }\n\n  for (var key in component._renderedChildren) {\n    deepForceUpdate(component._renderedChildren[key]);\n  }\n}\n\nmodule.exports = deepForceUpdate;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/deepForceUpdate.js\n ** module id = 205\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/deepForceUpdate.js?");

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule emptyObject\n */\n\n\"use strict\";\n\nvar emptyObject = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  Object.freeze(emptyObject);\n}\n\nmodule.exports = emptyObject;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/emptyObject.js\n ** module id = 206\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/emptyObject.js?");

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CallbackQueue\n */\n\n\"use strict\";\n\nvar PooledClass = __webpack_require__(135);\n\nvar assign = __webpack_require__(51);\nvar invariant = __webpack_require__(36);\n\n/**\n * A specialized pseudo-event module to help keep track of components waiting to\n * be notified when their DOM representations are available for use.\n *\n * This implements `PooledClass`, so you should never need to instantiate this.\n * Instead, use `CallbackQueue.getPooled()`.\n *\n * @class ReactMountReady\n * @implements PooledClass\n * @internal\n */\nfunction CallbackQueue() {\n  this._callbacks = null;\n  this._contexts = null;\n}\n\nassign(CallbackQueue.prototype, {\n\n  /**\n   * Enqueues a callback to be invoked when `notifyAll` is invoked.\n   *\n   * @param {function} callback Invoked when `notifyAll` is invoked.\n   * @param {?object} context Context to call `callback` with.\n   * @internal\n   */\n  enqueue: function(callback, context) {\n    this._callbacks = this._callbacks || [];\n    this._contexts = this._contexts || [];\n    this._callbacks.push(callback);\n    this._contexts.push(context);\n  },\n\n  /**\n   * Invokes all enqueued callbacks and clears the queue. This is invoked after\n   * the DOM representation of a component has been created or updated.\n   *\n   * @internal\n   */\n  notifyAll: function() {\n    var callbacks = this._callbacks;\n    var contexts = this._contexts;\n    if (callbacks) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        callbacks.length === contexts.length,\n        \"Mismatched list of contexts in callback queue\"\n      ) : invariant(callbacks.length === contexts.length));\n      this._callbacks = null;\n      this._contexts = null;\n      for (var i = 0, l = callbacks.length; i < l; i++) {\n        callbacks[i].call(contexts[i]);\n      }\n      callbacks.length = 0;\n      contexts.length = 0;\n    }\n  },\n\n  /**\n   * Resets the internal queue.\n   *\n   * @internal\n   */\n  reset: function() {\n    this._callbacks = null;\n    this._contexts = null;\n  },\n\n  /**\n   * `PooledClass` looks for this.\n   */\n  destructor: function() {\n    this.reset();\n  }\n\n});\n\nPooledClass.addPoolingTo(CallbackQueue);\n\nmodule.exports = CallbackQueue;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CallbackQueue.js\n ** module id = 207\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CallbackQueue.js?");

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Transaction\n */\n\n\"use strict\";\n\nvar invariant = __webpack_require__(36);\n\n/**\n * `Transaction` creates a black box that is able to wrap any method such that\n * certain invariants are maintained before and after the method is invoked\n * (Even if an exception is thrown while invoking the wrapped method). Whoever\n * instantiates a transaction can provide enforcers of the invariants at\n * creation time. The `Transaction` class itself will supply one additional\n * automatic invariant for you - the invariant that any transaction instance\n * should not be run while it is already being run. You would typically create a\n * single instance of a `Transaction` for reuse multiple times, that potentially\n * is used to wrap several different methods. Wrappers are extremely simple -\n * they only require implementing two methods.\n *\n * <pre>\n *                       wrappers (injected at creation time)\n *                                      +        +\n *                                      |        |\n *                    +-----------------|--------|--------------+\n *                    |                 v        |              |\n *                    |      +---------------+   |              |\n *                    |   +--|    wrapper1   |---|----+         |\n *                    |   |  +---------------+   v    |         |\n *                    |   |          +-------------+  |         |\n *                    |   |     +----|   wrapper2  |--------+   |\n *                    |   |     |    +-------------+  |     |   |\n *                    |   |     |                     |     |   |\n *                    |   v     v                     v     v   | wrapper\n *                    | +---+ +---+   +---------+   +---+ +---+ | invariants\n * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained\n * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | |   | |   |   |         |   |   | |   | |\n *                    | +---+ +---+   +---------+   +---+ +---+ |\n *                    |  initialize                    close    |\n *                    +-----------------------------------------+\n * </pre>\n *\n * Use cases:\n * - Preserving the input selection ranges before/after reconciliation.\n *   Restoring selection even in the event of an unexpected error.\n * - Deactivating events while rearranging the DOM, preventing blurs/focuses,\n *   while guaranteeing that afterwards, the event system is reactivated.\n * - Flushing a queue of collected DOM mutations to the main UI thread after a\n *   reconciliation takes place in a worker thread.\n * - Invoking any collected `componentDidUpdate` callbacks after rendering new\n *   content.\n * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue\n *   to preserve the `scrollTop` (an automatic scroll aware DOM).\n * - (Future use case): Layout calculations before and after DOM upates.\n *\n * Transactional plugin API:\n * - A module that has an `initialize` method that returns any precomputation.\n * - and a `close` method that accepts the precomputation. `close` is invoked\n *   when the wrapped process is completed, or has failed.\n *\n * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules\n * that implement `initialize` and `close`.\n * @return {Transaction} Single transaction for reuse in thread.\n *\n * @class Transaction\n */\nvar Mixin = {\n  /**\n   * Sets up this instance so that it is prepared for collecting metrics. Does\n   * so such that this setup method may be used on an instance that is already\n   * initialized, in a way that does not consume additional memory upon reuse.\n   * That can be useful if you decide to make your subclass of this mixin a\n   * \"PooledClass\".\n   */\n  reinitializeTransaction: function() {\n    this.transactionWrappers = this.getTransactionWrappers();\n    if (!this.wrapperInitData) {\n      this.wrapperInitData = [];\n    } else {\n      this.wrapperInitData.length = 0;\n    }\n    this._isInTransaction = false;\n  },\n\n  _isInTransaction: false,\n\n  /**\n   * @abstract\n   * @return {Array<TransactionWrapper>} Array of transaction wrappers.\n   */\n  getTransactionWrappers: null,\n\n  isInTransaction: function() {\n    return !!this._isInTransaction;\n  },\n\n  /**\n   * Executes the function within a safety window. Use this for the top level\n   * methods that result in large amounts of computation/mutations that would\n   * need to be safety checked.\n   *\n   * @param {function} method Member of scope to call.\n   * @param {Object} scope Scope to invoke from.\n   * @param {Object?=} args... Arguments to pass to the method (optional).\n   *                           Helps prevent need to bind in many cases.\n   * @return Return value from `method`.\n   */\n  perform: function(method, scope, a, b, c, d, e, f) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      !this.isInTransaction(),\n      'Transaction.perform(...): Cannot initialize a transaction when there ' +\n      'is already an outstanding transaction.'\n    ) : invariant(!this.isInTransaction()));\n    var errorThrown;\n    var ret;\n    try {\n      this._isInTransaction = true;\n      // Catching errors makes debugging more difficult, so we start with\n      // errorThrown set to true before setting it to false after calling\n      // close -- if it's still set to true in the finally block, it means\n      // one of these calls threw.\n      errorThrown = true;\n      this.initializeAll(0);\n      ret = method.call(scope, a, b, c, d, e, f);\n      errorThrown = false;\n    } finally {\n      try {\n        if (errorThrown) {\n          // If `method` throws, prefer to show that stack trace over any thrown\n          // by invoking `closeAll`.\n          try {\n            this.closeAll(0);\n          } catch (err) {\n          }\n        } else {\n          // Since `method` didn't throw, we don't want to silence the exception\n          // here.\n          this.closeAll(0);\n        }\n      } finally {\n        this._isInTransaction = false;\n      }\n    }\n    return ret;\n  },\n\n  initializeAll: function(startIndex) {\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      try {\n        // Catching errors makes debugging more difficult, so we start with the\n        // OBSERVED_ERROR state before overwriting it with the real return value\n        // of initialize -- if it's still set to OBSERVED_ERROR in the finally\n        // block, it means wrapper.initialize threw.\n        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;\n        this.wrapperInitData[i] = wrapper.initialize ?\n          wrapper.initialize.call(this) :\n          null;\n      } finally {\n        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {\n          // The initializer for wrapper i threw an error; initialize the\n          // remaining wrappers but silence any exceptions from them to ensure\n          // that the first error is the one to bubble up.\n          try {\n            this.initializeAll(i + 1);\n          } catch (err) {\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into\n   * them the respective return values of `this.transactionWrappers.init[i]`\n   * (`close`rs that correspond to initializers that failed will not be\n   * invoked).\n   */\n  closeAll: function(startIndex) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      this.isInTransaction(),\n      'Transaction.closeAll(): Cannot close transaction when none are open.'\n    ) : invariant(this.isInTransaction()));\n    var transactionWrappers = this.transactionWrappers;\n    for (var i = startIndex; i < transactionWrappers.length; i++) {\n      var wrapper = transactionWrappers[i];\n      var initData = this.wrapperInitData[i];\n      var errorThrown;\n      try {\n        // Catching errors makes debugging more difficult, so we start with\n        // errorThrown set to true before setting it to false after calling\n        // close -- if it's still set to true in the finally block, it means\n        // wrapper.close threw.\n        errorThrown = true;\n        if (initData !== Transaction.OBSERVED_ERROR) {\n          wrapper.close && wrapper.close.call(this, initData);\n        }\n        errorThrown = false;\n      } finally {\n        if (errorThrown) {\n          // The closer for wrapper i threw an error; close the remaining\n          // wrappers but silence any exceptions from them to ensure that the\n          // first error is the one to bubble up.\n          try {\n            this.closeAll(i + 1);\n          } catch (e) {\n          }\n        }\n      }\n    }\n    this.wrapperInitData.length = 0;\n  }\n};\n\nvar Transaction = {\n\n  Mixin: Mixin,\n\n  /**\n   * Token to look for to determine if an error occured.\n   */\n  OBSERVED_ERROR: {}\n\n};\n\nmodule.exports = Transaction;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Transaction.js\n ** module id = 208\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Transaction.js?");

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule joinClasses\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * Combines multiple className strings into one.\n * http://jsperf.com/joinclasses-args-vs-array\n *\n * @param {...?string} classes\n * @return {string}\n */\nfunction joinClasses(className/*, ... */) {\n  if (!className) {\n    className = '';\n  }\n  var nextClass;\n  var argLength = arguments.length;\n  if (argLength > 1) {\n    for (var ii = 1; ii < argLength; ii++) {\n      nextClass = arguments[ii];\n      if (nextClass) {\n        className = (className ? className + ' ' : '') + nextClass;\n      }\n    }\n  }\n  return className;\n}\n\nmodule.exports = joinClasses;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/joinClasses.js\n ** module id = 209\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/joinClasses.js?");

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule CSSProperty\n */\n\n\"use strict\";\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  columnCount: true,\n  flex: true,\n  flexGrow: true,\n  flexShrink: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  strokeOpacity: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop) {\n  prefixes.forEach(function(prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Most style properties can be unset by doing .style[prop] = '' but IE8\n * doesn't like doing that with shorthand properties so for the properties that\n * IE8 breaks on, which are listed here, we instead unset each of the\n * individual properties. See http://bugs.jquery.com/ticket/12385.\n * The 4-value 'clock' properties like margin, padding, border-width seem to\n * behave without any problems. Curiously, list-style works too without any\n * special prodding.\n */\nvar shorthandPropertyExpansions = {\n  background: {\n    backgroundImage: true,\n    backgroundPosition: true,\n    backgroundRepeat: true,\n    backgroundColor: true\n  },\n  border: {\n    borderWidth: true,\n    borderStyle: true,\n    borderColor: true\n  },\n  borderBottom: {\n    borderBottomWidth: true,\n    borderBottomStyle: true,\n    borderBottomColor: true\n  },\n  borderLeft: {\n    borderLeftWidth: true,\n    borderLeftStyle: true,\n    borderLeftColor: true\n  },\n  borderRight: {\n    borderRightWidth: true,\n    borderRightStyle: true,\n    borderRightColor: true\n  },\n  borderTop: {\n    borderTopWidth: true,\n    borderTopStyle: true,\n    borderTopColor: true\n  },\n  font: {\n    fontStyle: true,\n    fontVariant: true,\n    fontWeight: true,\n    fontSize: true,\n    lineHeight: true,\n    fontFamily: true\n  }\n};\n\nvar CSSProperty = {\n  isUnitlessNumber: isUnitlessNumber,\n  shorthandPropertyExpansions: shorthandPropertyExpansions\n};\n\nmodule.exports = CSSProperty;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/CSSProperty.js\n ** module id = 210\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/CSSProperty.js?");

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule camelizeStyleName\n * @typechecks\n */\n\n\"use strict\";\n\nvar camelize = __webpack_require__(248);\n\nvar msPattern = /^-ms-/;\n\n/**\n * Camelcases a hyphenated CSS property name, for example:\n *\n *   > camelizeStyleName('background-color')\n *   < \"backgroundColor\"\n *   > camelizeStyleName('-moz-transition')\n *   < \"MozTransition\"\n *   > camelizeStyleName('-ms-transition')\n *   < \"msTransition\"\n *\n * As Andi Smith suggests\n * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n * is converted to lowercase `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelizeStyleName(string) {\n  return camelize(string.replace(msPattern, 'ms-'));\n}\n\nmodule.exports = camelizeStyleName;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/camelizeStyleName.js\n ** module id = 211\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/camelizeStyleName.js?");

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule dangerousStyleValue\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar CSSProperty = __webpack_require__(210);\n\nvar isUnitlessNumber = CSSProperty.isUnitlessNumber;\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  var isNonNumeric = isNaN(value);\n  if (isNonNumeric || value === 0 ||\n      isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {\n    return '' + value; // cast to string\n  }\n\n  if (typeof value === 'string') {\n    value = value.trim();\n  }\n  return value + 'px';\n}\n\nmodule.exports = dangerousStyleValue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/dangerousStyleValue.js\n ** module id = 212\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/dangerousStyleValue.js?");

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule hyphenateStyleName\n * @typechecks\n */\n\n\"use strict\";\n\nvar hyphenate = __webpack_require__(249);\n\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenateStyleName(string) {\n  return hyphenate(string).replace(msPattern, '-ms-');\n}\n\nmodule.exports = hyphenateStyleName;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/hyphenateStyleName.js\n ** module id = 213\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/hyphenateStyleName.js?");

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n\"use strict\";\n\nvar EventConstants = __webpack_require__(46);\nvar EventPluginHub = __webpack_require__(47);\n\nvar accumulateInto = __webpack_require__(127);\nvar forEachAccumulated = __webpack_require__(128);\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName =\n    event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    if (!domID) {\n      throw new Error('Dispatching id must not be null');\n    }\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners =\n      accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We can not perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(\n      event.dispatchMarker,\n      accumulateDirectionalDispatches,\n      event\n    );\n  }\n}\n\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners =\n        accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(\n    fromID,\n    toID,\n    accumulateDispatches,\n    leave,\n    enter\n  );\n}\n\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventPropagators.js\n ** module id = 214\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventPropagators.js?");

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticInputEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticEvent = __webpack_require__(216);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar InputEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticInputEvent(\n  dispatchConfig,\n  dispatchMarker,\n  nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(\n  SyntheticInputEvent,\n  InputEventInterface\n);\n\nmodule.exports = SyntheticInputEvent;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticInputEvent.js\n ** module id = 215\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticInputEvent.js?");

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar PooledClass = __webpack_require__(135);\n\nvar assign = __webpack_require__(51);\nvar emptyFunction = __webpack_require__(59);\nvar getEventTarget = __webpack_require__(229);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: getEventTarget,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function(event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n */\nfunction SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  this.dispatchConfig = dispatchConfig;\n  this.dispatchMarker = dispatchMarker;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      this[propName] = nativeEvent[propName];\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ?\n    nativeEvent.defaultPrevented :\n    nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n}\n\nassign(SyntheticEvent.prototype, {\n\n  preventDefault: function() {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    event.preventDefault ? event.preventDefault() : event.returnValue = false;\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function() {\n    var event = this.nativeEvent;\n    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function() {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function() {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      this[propName] = null;\n    }\n    this.dispatchConfig = null;\n    this.dispatchMarker = null;\n    this.nativeEvent = null;\n  }\n\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function(Class, Interface) {\n  var Super = this;\n\n  var prototype = Object.create(Super.prototype);\n  assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n\n  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);\n};\n\nPooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);\n\nmodule.exports = SyntheticEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticEvent.js\n ** module id = 216\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticEvent.js?");

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule isTextInputElement\n */\n\n\"use strict\";\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  'color': true,\n  'date': true,\n  'datetime': true,\n  'datetime-local': true,\n  'email': true,\n  'month': true,\n  'number': true,\n  'password': true,\n  'range': true,\n  'search': true,\n  'tel': true,\n  'text': true,\n  'time': true,\n  'url': true,\n  'week': true\n};\n\nfunction isTextInputElement(elem) {\n  return elem && (\n    (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) ||\n    elem.nodeName === 'TEXTAREA'\n  );\n}\n\nmodule.exports = isTextInputElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/isTextInputElement.js\n ** module id = 217\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/isTextInputElement.js?");

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInputSelection\n */\n\n\"use strict\";\n\nvar ReactDOMSelection = __webpack_require__(250);\n\nvar containsNode = __webpack_require__(32);\nvar focusNode = __webpack_require__(251);\nvar getActiveElement = __webpack_require__(230);\n\nfunction isInDocument(node) {\n  return containsNode(document.documentElement, node);\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\nvar ReactInputSelection = {\n\n  hasSelectionCapabilities: function(elem) {\n    return elem && (\n      (elem.nodeName === 'INPUT' && elem.type === 'text') ||\n      elem.nodeName === 'TEXTAREA' ||\n      elem.contentEditable === 'true'\n    );\n  },\n\n  getSelectionInformation: function() {\n    var focusedElem = getActiveElement();\n    return {\n      focusedElem: focusedElem,\n      selectionRange:\n          ReactInputSelection.hasSelectionCapabilities(focusedElem) ?\n          ReactInputSelection.getSelection(focusedElem) :\n          null\n    };\n  },\n\n  /**\n   * @restoreSelection: If any selection information was potentially lost,\n   * restore it. This is useful when performing operations that could remove dom\n   * nodes and place them back in, resulting in focus being lost.\n   */\n  restoreSelection: function(priorSelectionInformation) {\n    var curFocusedElem = getActiveElement();\n    var priorFocusedElem = priorSelectionInformation.focusedElem;\n    var priorSelectionRange = priorSelectionInformation.selectionRange;\n    if (curFocusedElem !== priorFocusedElem &&\n        isInDocument(priorFocusedElem)) {\n      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n        ReactInputSelection.setSelection(\n          priorFocusedElem,\n          priorSelectionRange\n        );\n      }\n      focusNode(priorFocusedElem);\n    }\n  },\n\n  /**\n   * @getSelection: Gets the selection bounds of a focused textarea, input or\n   * contentEditable node.\n   * -@input: Look up selection bounds of this input\n   * -@return {start: selectionStart, end: selectionEnd}\n   */\n  getSelection: function(input) {\n    var selection;\n\n    if ('selectionStart' in input) {\n      // Modern browser with input or textarea.\n      selection = {\n        start: input.selectionStart,\n        end: input.selectionEnd\n      };\n    } else if (document.selection && input.nodeName === 'INPUT') {\n      // IE8 input.\n      var range = document.selection.createRange();\n      // There can only be one selection per document in IE, so it must\n      // be in our element.\n      if (range.parentElement() === input) {\n        selection = {\n          start: -range.moveStart('character', -input.value.length),\n          end: -range.moveEnd('character', -input.value.length)\n        };\n      }\n    } else {\n      // Content editable or old IE textarea.\n      selection = ReactDOMSelection.getOffsets(input);\n    }\n\n    return selection || {start: 0, end: 0};\n  },\n\n  /**\n   * @setSelection: Sets the selection bounds of a textarea or input and focuses\n   * the input.\n   * -@input     Set selection bounds of this input or textarea\n   * -@offsets   Object of same form that is returned from get*\n   */\n  setSelection: function(input, offsets) {\n    var start = offsets.start;\n    var end = offsets.end;\n    if (typeof end === 'undefined') {\n      end = start;\n    }\n\n    if ('selectionStart' in input) {\n      input.selectionStart = start;\n      input.selectionEnd = Math.min(end, input.value.length);\n    } else if (document.selection && input.nodeName === 'INPUT') {\n      var range = input.createTextRange();\n      range.collapse(true);\n      range.moveStart('character', start);\n      range.moveEnd('character', end - start);\n      range.select();\n    } else {\n      ReactDOMSelection.setOffsets(input, offsets);\n    }\n  }\n};\n\nmodule.exports = ReactInputSelection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactInputSelection.js\n ** module id = 218\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactInputSelection.js?");

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticCompositionEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticEvent = __webpack_require__(216);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar CompositionEventInterface = {\n  data: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticCompositionEvent(\n  dispatchConfig,\n  dispatchMarker,\n  nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(\n  SyntheticCompositionEvent,\n  CompositionEventInterface\n);\n\nmodule.exports = SyntheticCompositionEvent;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticCompositionEvent.js\n ** module id = 219\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticCompositionEvent.js?");

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentAccessor\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar contentKey = null;\n\n/**\n * Gets the key used to access text content on a DOM node.\n *\n * @return {?string} Key used to access text content.\n * @internal\n */\nfunction getTextContentAccessor() {\n  if (!contentKey && ExecutionEnvironment.canUseDOM) {\n    // Prefer textContent to innerText because many browsers support both but\n    // SVG <text> elements don't support innerText even when <div> does.\n    contentKey = 'textContent' in document.documentElement ?\n      'textContent' :\n      'innerText';\n  }\n  return contentKey;\n}\n\nmodule.exports = getTextContentAccessor;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getTextContentAccessor.js\n ** module id = 220\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getTextContentAccessor.js?");

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticMouseEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticUIEvent = __webpack_require__(237);\nvar ViewportMetrics = __webpack_require__(50);\n\nvar getEventModifierState = __webpack_require__(252);\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar MouseEventInterface = {\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: function(event) {\n    // Webkit, Firefox, IE9+\n    // which:  1 2 3\n    // button: 0 1 2 (standard)\n    var button = event.button;\n    if ('which' in event) {\n      return button;\n    }\n    // IE<9\n    // which:  undefined\n    // button: 0 0 0\n    // button: 1 4 2 (onmouseup)\n    return button === 2 ? 2 : button === 4 ? 1 : 0;\n  },\n  buttons: null,\n  relatedTarget: function(event) {\n    return event.relatedTarget || (\n      event.fromElement === event.srcElement ?\n        event.toElement :\n        event.fromElement\n    );\n  },\n  // \"Proprietary\" Interface.\n  pageX: function(event) {\n    return 'pageX' in event ?\n      event.pageX :\n      event.clientX + ViewportMetrics.currentScrollLeft;\n  },\n  pageY: function(event) {\n    return 'pageY' in event ?\n      event.pageY :\n      event.clientY + ViewportMetrics.currentScrollTop;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n\nmodule.exports = SyntheticMouseEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticMouseEvent.js\n ** module id = 221\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticMouseEvent.js?");

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMIDOperations\n * @typechecks static-only\n */\n\n/*jslint evil: true */\n\n\"use strict\";\n\nvar CSSPropertyOperations = __webpack_require__(145);\nvar DOMChildrenOperations = __webpack_require__(253);\nvar DOMPropertyOperations = __webpack_require__(61);\nvar ReactMount = __webpack_require__(10);\nvar ReactPerf = __webpack_require__(31);\n\nvar invariant = __webpack_require__(36);\nvar setInnerHTML = __webpack_require__(224);\n\n/**\n * Errors for properties that should not be updated with `updatePropertyById()`.\n *\n * @type {object}\n * @private\n */\nvar INVALID_PROPERTY_ERRORS = {\n  dangerouslySetInnerHTML:\n    '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',\n  style: '`style` must be set using `updateStylesByID()`.'\n};\n\n/**\n * Operations used to process updates to DOM nodes. This is made injectable via\n * `ReactComponent.BackendIDOperations`.\n */\nvar ReactDOMIDOperations = {\n\n  /**\n   * Updates a DOM node with new property values. This should only be used to\n   * update DOM properties in `DOMProperty`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} name A valid property name, see `DOMProperty`.\n   * @param {*} value New value of the property.\n   * @internal\n   */\n  updatePropertyByID: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'updatePropertyByID',\n    function(id, name, value) {\n      var node = ReactMount.getNode(id);\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),\n        'updatePropertyByID(...): %s',\n        INVALID_PROPERTY_ERRORS[name]\n      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));\n\n      // If we're updating to null or undefined, we should remove the property\n      // from the DOM node instead of inadvertantly setting to a string. This\n      // brings us in line with the same behavior we have on initial render.\n      if (value != null) {\n        DOMPropertyOperations.setValueForProperty(node, name, value);\n      } else {\n        DOMPropertyOperations.deleteValueForProperty(node, name);\n      }\n    }\n  ),\n\n  /**\n   * Updates a DOM node to remove a property. This should only be used to remove\n   * DOM properties in `DOMProperty`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} name A property name to remove, see `DOMProperty`.\n   * @internal\n   */\n  deletePropertyByID: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'deletePropertyByID',\n    function(id, name, value) {\n      var node = ReactMount.getNode(id);\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),\n        'updatePropertyByID(...): %s',\n        INVALID_PROPERTY_ERRORS[name]\n      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));\n      DOMPropertyOperations.deleteValueForProperty(node, name, value);\n    }\n  ),\n\n  /**\n   * Updates a DOM node with new style values. If a value is specified as '',\n   * the corresponding style property will be unset.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {object} styles Mapping from styles to values.\n   * @internal\n   */\n  updateStylesByID: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'updateStylesByID',\n    function(id, styles) {\n      var node = ReactMount.getNode(id);\n      CSSPropertyOperations.setValueForStyles(node, styles);\n    }\n  ),\n\n  /**\n   * Updates a DOM node's innerHTML.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} html An HTML string.\n   * @internal\n   */\n  updateInnerHTMLByID: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'updateInnerHTMLByID',\n    function(id, html) {\n      var node = ReactMount.getNode(id);\n      setInnerHTML(node, html);\n    }\n  ),\n\n  /**\n   * Updates a DOM node's text content set by `props.content`.\n   *\n   * @param {string} id ID of the node to update.\n   * @param {string} content Text content.\n   * @internal\n   */\n  updateTextContentByID: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'updateTextContentByID',\n    function(id, content) {\n      var node = ReactMount.getNode(id);\n      DOMChildrenOperations.updateTextContent(node, content);\n    }\n  ),\n\n  /**\n   * Replaces a DOM node that exists in the document with markup.\n   *\n   * @param {string} id ID of child to be replaced.\n   * @param {string} markup Dangerous markup to inject in place of child.\n   * @internal\n   * @see {Danger.dangerouslyReplaceNodeWithMarkup}\n   */\n  dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'dangerouslyReplaceNodeWithMarkupByID',\n    function(id, markup) {\n      var node = ReactMount.getNode(id);\n      DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);\n    }\n  ),\n\n  /**\n   * Updates a component's children by processing a series of updates.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markup List of markup strings.\n   * @internal\n   */\n  dangerouslyProcessChildrenUpdates: ReactPerf.measure(\n    'ReactDOMIDOperations',\n    'dangerouslyProcessChildrenUpdates',\n    function(updates, markup) {\n      for (var i = 0; i < updates.length; i++) {\n        updates[i].parentNode = ReactMount.getNode(updates[i].parentID);\n      }\n      DOMChildrenOperations.processUpdates(updates, markup);\n    }\n  )\n};\n\nmodule.exports = ReactDOMIDOperations;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMIDOperations.js\n ** module id = 222\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMIDOperations.js?");

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactReconcileTransaction\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar CallbackQueue = __webpack_require__(207);\nvar PooledClass = __webpack_require__(135);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\nvar ReactInputSelection = __webpack_require__(218);\nvar ReactPutListenerQueue = __webpack_require__(243);\nvar Transaction = __webpack_require__(208);\n\nvar assign = __webpack_require__(51);\n\n/**\n * Ensures that, when possible, the selection range (currently selected text\n * input) is not disturbed by performing the transaction.\n */\nvar SELECTION_RESTORATION = {\n  /**\n   * @return {Selection} Selection information.\n   */\n  initialize: ReactInputSelection.getSelectionInformation,\n  /**\n   * @param {Selection} sel Selection information returned from `initialize`.\n   */\n  close: ReactInputSelection.restoreSelection\n};\n\n/**\n * Suppresses events (blur/focus) that could be inadvertently dispatched due to\n * high level DOM manipulations (like temporarily removing a text input from the\n * DOM).\n */\nvar EVENT_SUPPRESSION = {\n  /**\n   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before\n   * the reconciliation.\n   */\n  initialize: function() {\n    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();\n    ReactBrowserEventEmitter.setEnabled(false);\n    return currentlyEnabled;\n  },\n\n  /**\n   * @param {boolean} previouslyEnabled Enabled status of\n   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`\n   *   restores the previous value.\n   */\n  close: function(previouslyEnabled) {\n    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);\n  }\n};\n\n/**\n * Provides a queue for collecting `componentDidMount` and\n * `componentDidUpdate` callbacks during the the transaction.\n */\nvar ON_DOM_READY_QUEUEING = {\n  /**\n   * Initializes the internal `onDOMReady` queue.\n   */\n  initialize: function() {\n    this.reactMountReady.reset();\n  },\n\n  /**\n   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.\n   */\n  close: function() {\n    this.reactMountReady.notifyAll();\n  }\n};\n\nvar PUT_LISTENER_QUEUEING = {\n  initialize: function() {\n    this.putListenerQueue.reset();\n  },\n\n  close: function() {\n    this.putListenerQueue.putListeners();\n  }\n};\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [\n  PUT_LISTENER_QUEUEING,\n  SELECTION_RESTORATION,\n  EVENT_SUPPRESSION,\n  ON_DOM_READY_QUEUEING\n];\n\n/**\n * Currently:\n * - The order that these are listed in the transaction is critical:\n * - Suppresses events.\n * - Restores selection range.\n *\n * Future:\n * - Restore document/overflow scroll positions that were unintentionally\n *   modified via DOM insertions above the top viewport boundary.\n * - Implement/integrate with customized constraint based layout system and keep\n *   track of which dimensions must be remeasured.\n *\n * @class ReactReconcileTransaction\n */\nfunction ReactReconcileTransaction() {\n  this.reinitializeTransaction();\n  // Only server-side rendering really needs this option (see\n  // `ReactServerRendering`), but server-side uses\n  // `ReactServerRenderingTransaction` instead. This option is here so that it's\n  // accessible and defaults to false when `ReactDOMComponent` and\n  // `ReactTextComponent` checks it in `mountComponent`.`\n  this.renderToStaticMarkup = false;\n  this.reactMountReady = CallbackQueue.getPooled(null);\n  this.putListenerQueue = ReactPutListenerQueue.getPooled();\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array<object>} List of operation wrap proceedures.\n   *   TODO: convert to array<TransactionWrapper>\n   */\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function() {\n    return this.reactMountReady;\n  },\n\n  getPutListenerQueue: function() {\n    return this.putListenerQueue;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be resused.\n   */\n  destructor: function() {\n    CallbackQueue.release(this.reactMountReady);\n    this.reactMountReady = null;\n\n    ReactPutListenerQueue.release(this.putListenerQueue);\n    this.putListenerQueue = null;\n  }\n};\n\n\nassign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);\n\nPooledClass.addPoolingTo(ReactReconcileTransaction);\n\nmodule.exports = ReactReconcileTransaction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactReconcileTransaction.js\n ** module id = 223\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactReconcileTransaction.js?");

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule setInnerHTML\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar WHITESPACE_TEST = /^[ \\r\\n\\t\\f]/;\nvar NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \\r\\n\\t\\f\\/>]/;\n\n/**\n * Set the innerHTML property of a node, ensuring that whitespace is preserved\n * even in IE8.\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = function(node, html) {\n  node.innerHTML = html;\n};\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE8: When updating a just created node with innerHTML only leading\n  // whitespace is removed. When updating an existing node with innerHTML\n  // whitespace in root TextNodes is also collapsed.\n  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html\n\n  // Feature detection; only IE8 is known to behave improperly like this.\n  var testElement = document.createElement('div');\n  testElement.innerHTML = ' ';\n  if (testElement.innerHTML === '') {\n    setInnerHTML = function(node, html) {\n      // Magic theory: IE8 supposedly differentiates between added and updated\n      // nodes when processing innerHTML, innerHTML on updated nodes suffers\n      // from worse whitespace behavior. Re-adding a node like this triggers\n      // the initial and more favorable whitespace behavior.\n      // TODO: What to do on a detached node?\n      if (node.parentNode) {\n        node.parentNode.replaceChild(node, node);\n      }\n\n      // We also implement a workaround for non-visible tags disappearing into\n      // thin air on IE8, this only happens if there is no visible text\n      // in-front of the non-visible tags. Piggyback on the whitespace fix\n      // and simply check if any non-visible tags appear in the source.\n      if (WHITESPACE_TEST.test(html) ||\n          html[0] === '<' && NONVISIBLE_TEST.test(html)) {\n        // Recover leading whitespace by temporarily prepending any character.\n        // \\uFEFF has the potential advantage of being zero-width/invisible.\n        node.innerHTML = '\\uFEFF' + html;\n\n        // deleteData leaves an empty `TextNode` which offsets the index of all\n        // children. Definitely want to avoid this.\n        var textNode = node.firstChild;\n        if (textNode.data.length === 1) {\n          node.removeChild(textNode);\n        } else {\n          textNode.deleteData(0, 1);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    };\n  }\n}\n\nmodule.exports = setInnerHTML;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/setInnerHTML.js\n ** module id = 224\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/setInnerHTML.js?");

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AutoFocusMixin\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar focusNode = __webpack_require__(251);\n\nvar AutoFocusMixin = {\n  componentDidMount: function() {\n    if (this.props.autoFocus) {\n      focusNode(this.getDOMNode());\n    }\n  }\n};\n\nmodule.exports = AutoFocusMixin;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/AutoFocusMixin.js\n ** module id = 225\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/AutoFocusMixin.js?");

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule LocalEventTrapMixin\n */\n\n\"use strict\";\n\nvar ReactBrowserEventEmitter = __webpack_require__(26);\n\nvar accumulateInto = __webpack_require__(127);\nvar forEachAccumulated = __webpack_require__(128);\nvar invariant = __webpack_require__(36);\n\nfunction remove(event) {\n  event.remove();\n}\n\nvar LocalEventTrapMixin = {\n  trapBubbledEvent:function(topLevelType, handlerBaseName) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));\n    var listener = ReactBrowserEventEmitter.trapBubbledEvent(\n      topLevelType,\n      handlerBaseName,\n      this.getDOMNode()\n    );\n    this._localEventListeners =\n      accumulateInto(this._localEventListeners, listener);\n  },\n\n  // trapCapturedEvent would look nearly identical. We don't implement that\n  // method because it isn't currently needed.\n\n  componentWillUnmount:function() {\n    if (this._localEventListeners) {\n      forEachAccumulated(this._localEventListeners, remove);\n    }\n  }\n};\n\nmodule.exports = LocalEventTrapMixin;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/LocalEventTrapMixin.js\n ** module id = 226\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/LocalEventTrapMixin.js?");

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule LinkedValueUtils\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar ReactPropTypes = __webpack_require__(71);\n\nvar invariant = __webpack_require__(36);\n\nvar hasReadOnlyValue = {\n  'button': true,\n  'checkbox': true,\n  'image': true,\n  'hidden': true,\n  'radio': true,\n  'reset': true,\n  'submit': true\n};\n\nfunction _assertSingleLink(input) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    input.props.checkedLink == null || input.props.valueLink == null,\n    'Cannot provide a checkedLink and a valueLink. If you want to use ' +\n    'checkedLink, you probably don\\'t want to use valueLink and vice versa.'\n  ) : invariant(input.props.checkedLink == null || input.props.valueLink == null));\n}\nfunction _assertValueLink(input) {\n  _assertSingleLink(input);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    input.props.value == null && input.props.onChange == null,\n    'Cannot provide a valueLink and a value or onChange event. If you want ' +\n    'to use value or onChange, you probably don\\'t want to use valueLink.'\n  ) : invariant(input.props.value == null && input.props.onChange == null));\n}\n\nfunction _assertCheckedLink(input) {\n  _assertSingleLink(input);\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    input.props.checked == null && input.props.onChange == null,\n    'Cannot provide a checkedLink and a checked property or onChange event. ' +\n    'If you want to use checked or onChange, you probably don\\'t want to ' +\n    'use checkedLink'\n  ) : invariant(input.props.checked == null && input.props.onChange == null));\n}\n\n/**\n * @param {SyntheticEvent} e change event to handle\n */\nfunction _handleLinkedValueChange(e) {\n  /*jshint validthis:true */\n  this.props.valueLink.requestChange(e.target.value);\n}\n\n/**\n  * @param {SyntheticEvent} e change event to handle\n  */\nfunction _handleLinkedCheckChange(e) {\n  /*jshint validthis:true */\n  this.props.checkedLink.requestChange(e.target.checked);\n}\n\n/**\n * Provide a linked `value` attribute for controlled forms. You should not use\n * this outside of the ReactDOM controlled form components.\n */\nvar LinkedValueUtils = {\n  Mixin: {\n    propTypes: {\n      value: function(props, propName, componentName) {\n        if (!props[propName] ||\n            hasReadOnlyValue[props.type] ||\n            props.onChange ||\n            props.readOnly ||\n            props.disabled) {\n          return;\n        }\n        return new Error(\n          'You provided a `value` prop to a form field without an ' +\n          '`onChange` handler. This will render a read-only field. If ' +\n          'the field should be mutable use `defaultValue`. Otherwise, ' +\n          'set either `onChange` or `readOnly`.'\n        );\n      },\n      checked: function(props, propName, componentName) {\n        if (!props[propName] ||\n            props.onChange ||\n            props.readOnly ||\n            props.disabled) {\n          return;\n        }\n        return new Error(\n          'You provided a `checked` prop to a form field without an ' +\n          '`onChange` handler. This will render a read-only field. If ' +\n          'the field should be mutable use `defaultChecked`. Otherwise, ' +\n          'set either `onChange` or `readOnly`.'\n        );\n      },\n      onChange: ReactPropTypes.func\n    }\n  },\n\n  /**\n   * @param {ReactComponent} input Form component\n   * @return {*} current value of the input either from value prop or link.\n   */\n  getValue: function(input) {\n    if (input.props.valueLink) {\n      _assertValueLink(input);\n      return input.props.valueLink.value;\n    }\n    return input.props.value;\n  },\n\n  /**\n   * @param {ReactComponent} input Form component\n   * @return {*} current checked status of the input either from checked prop\n   *             or link.\n   */\n  getChecked: function(input) {\n    if (input.props.checkedLink) {\n      _assertCheckedLink(input);\n      return input.props.checkedLink.value;\n    }\n    return input.props.checked;\n  },\n\n  /**\n   * @param {ReactComponent} input Form component\n   * @return {function} change callback either from onChange prop or link.\n   */\n  getOnChange: function(input) {\n    if (input.props.valueLink) {\n      _assertValueLink(input);\n      return _handleLinkedValueChange;\n    } else if (input.props.checkedLink) {\n      _assertCheckedLink(input);\n      return _handleLinkedCheckChange;\n    }\n    return input.props.onChange;\n  }\n};\n\nmodule.exports = LinkedValueUtils;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/LinkedValueUtils.js\n ** module id = 227\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/LinkedValueUtils.js?");

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @providesModule EventListener\n * @typechecks\n */\n\nvar emptyFunction = __webpack_require__(59);\n\n/**\n * Upstream version of event listener. Does not take into account specific\n * nature of platform.\n */\nvar EventListener = {\n  /**\n   * Listen to DOM events during the bubble phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  listen: function(target, eventType, callback) {\n    if (target.addEventListener) {\n      target.addEventListener(eventType, callback, false);\n      return {\n        remove: function() {\n          target.removeEventListener(eventType, callback, false);\n        }\n      };\n    } else if (target.attachEvent) {\n      target.attachEvent('on' + eventType, callback);\n      return {\n        remove: function() {\n          target.detachEvent('on' + eventType, callback);\n        }\n      };\n    }\n  },\n\n  /**\n   * Listen to DOM events during the capture phase.\n   *\n   * @param {DOMEventTarget} target DOM element to register listener on.\n   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.\n   * @param {function} callback Callback function.\n   * @return {object} Object with a `remove` method.\n   */\n  capture: function(target, eventType, callback) {\n    if (!target.addEventListener) {\n      if (\"production\" !== process.env.NODE_ENV) {\n        console.error(\n          'Attempted to listen to events during the capture phase on a ' +\n          'browser that does not support the capture phase. Your application ' +\n          'will not receive some events.'\n        );\n      }\n      return {\n        remove: emptyFunction\n      };\n    } else {\n      target.addEventListener(eventType, callback, true);\n      return {\n        remove: function() {\n          target.removeEventListener(eventType, callback, true);\n        }\n      };\n    }\n  },\n\n  registerDefault: function() {}\n};\n\nmodule.exports = EventListener;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/EventListener.js\n ** module id = 228\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/EventListener.js?");

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventTarget\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === 3 ? target.parentNode : target;\n}\n\nmodule.exports = getEventTarget;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventTarget.js\n ** module id = 229\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventTarget.js?");

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getActiveElement\n * @typechecks\n */\n\n/**\n * Same as document.activeElement but wraps in a try-catch block. In IE it is\n * not safe to call document.activeElement if there is nothing focused.\n *\n * The activeElement will be null only if the document body is not yet defined.\n */\nfunction getActiveElement() /*?DOMElement*/ {\n  try {\n    return document.activeElement || document.body;\n  } catch (e) {\n    return document.body;\n  }\n}\n\nmodule.exports = getActiveElement;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getActiveElement.js\n ** module id = 230\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getActiveElement.js?");

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule shallowEqual\n */\n\n\"use strict\";\n\n/**\n * Performs equality by iterating through keys on an object and returning\n * false when any key has values which are not strictly equal between\n * objA and objB. Returns true when the values of all keys are strictly equal.\n *\n * @return {boolean}\n */\nfunction shallowEqual(objA, objB) {\n  if (objA === objB) {\n    return true;\n  }\n  var key;\n  // Test for A's keys different from B.\n  for (key in objA) {\n    if (objA.hasOwnProperty(key) &&\n        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {\n      return false;\n    }\n  }\n  // Test for B's keys missing from A.\n  for (key in objB) {\n    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = shallowEqual;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/shallowEqual.js\n ** module id = 231\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/shallowEqual.js?");

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticClipboardEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticEvent = __webpack_require__(216);\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar ClipboardEventInterface = {\n  clipboardData: function(event) {\n    return (\n      'clipboardData' in event ?\n        event.clipboardData :\n        window.clipboardData\n    );\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n\nmodule.exports = SyntheticClipboardEvent;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticClipboardEvent.js\n ** module id = 232\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticClipboardEvent.js?");

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticFocusEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticUIEvent = __webpack_require__(237);\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar FocusEventInterface = {\n  relatedTarget: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n\nmodule.exports = SyntheticFocusEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticFocusEvent.js\n ** module id = 233\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticFocusEvent.js?");

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticKeyboardEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticUIEvent = __webpack_require__(237);\n\nvar getEventCharCode = __webpack_require__(239);\nvar getEventKey = __webpack_require__(254);\nvar getEventModifierState = __webpack_require__(252);\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar KeyboardEventInterface = {\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function(event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function(event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function(event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n\nmodule.exports = SyntheticKeyboardEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticKeyboardEvent.js\n ** module id = 234\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticKeyboardEvent.js?");

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticDragEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticMouseEvent = __webpack_require__(221);\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar DragEventInterface = {\n  dataTransfer: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);\n\nmodule.exports = SyntheticDragEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticDragEvent.js\n ** module id = 235\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticDragEvent.js?");

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticTouchEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticUIEvent = __webpack_require__(237);\n\nvar getEventModifierState = __webpack_require__(252);\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar TouchEventInterface = {\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticUIEvent}\n */\nfunction SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n\nmodule.exports = SyntheticTouchEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticTouchEvent.js\n ** module id = 236\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticTouchEvent.js?");

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticUIEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticEvent = __webpack_require__(216);\n\nvar getEventTarget = __webpack_require__(229);\n\n/**\n * @interface UIEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar UIEventInterface = {\n  view: function(event) {\n    if (event.view) {\n      return event.view;\n    }\n\n    var target = getEventTarget(event);\n    if (target != null && target.window === target) {\n      // target is a window object\n      return target;\n    }\n\n    var doc = target.ownerDocument;\n    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n    if (doc) {\n      return doc.defaultView || doc.parentWindow;\n    } else {\n      return window;\n    }\n  },\n  detail: function(event) {\n    return event.detail || 0;\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticEvent}\n */\nfunction SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);\n\nmodule.exports = SyntheticUIEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticUIEvent.js\n ** module id = 237\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticUIEvent.js?");

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule SyntheticWheelEvent\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar SyntheticMouseEvent = __webpack_require__(221);\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar WheelEventInterface = {\n  deltaX: function(event) {\n    return (\n      'deltaX' in event ? event.deltaX :\n      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n      'wheelDeltaX' in event ? -event.wheelDeltaX : 0\n    );\n  },\n  deltaY: function(event) {\n    return (\n      'deltaY' in event ? event.deltaY :\n      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n      'wheelDeltaY' in event ? -event.wheelDeltaY :\n      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n      'wheelDelta' in event ? -event.wheelDelta : 0\n    );\n  },\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @extends {SyntheticMouseEvent}\n */\nfunction SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {\n  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);\n}\n\nSyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n\nmodule.exports = SyntheticWheelEvent;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/SyntheticWheelEvent.js\n ** module id = 238\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/SyntheticWheelEvent.js?");

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventCharCode\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\nmodule.exports = getEventCharCode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventCharCode.js\n ** module id = 239\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventCharCode.js?");

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDefaultPerfAnalysis\n */\n\nvar assign = __webpack_require__(51);\n\n// Don't try to save users less than 1.2ms (a number I made up)\nvar DONT_CARE_THRESHOLD = 1.2;\nvar DOM_OPERATION_TYPES = {\n  'mountImageIntoNode': 'set innerHTML',\n  INSERT_MARKUP: 'set innerHTML',\n  MOVE_EXISTING: 'move',\n  REMOVE_NODE: 'remove',\n  TEXT_CONTENT: 'set textContent',\n  'updatePropertyByID': 'update attribute',\n  'deletePropertyByID': 'delete attribute',\n  'updateStylesByID': 'update styles',\n  'updateInnerHTMLByID': 'set innerHTML',\n  'dangerouslyReplaceNodeWithMarkupByID': 'replace'\n};\n\nfunction getTotalTime(measurements) {\n  // TODO: return number of DOM ops? could be misleading.\n  // TODO: measure dropped frames after reconcile?\n  // TODO: log total time of each reconcile and the top-level component\n  // class that triggered it.\n  var totalTime = 0;\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    totalTime += measurement.totalTime;\n  }\n  return totalTime;\n}\n\nfunction getDOMSummary(measurements) {\n  var items = [];\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var id;\n\n    for (id in measurement.writes) {\n      measurement.writes[id].forEach(function(write) {\n        items.push({\n          id: id,\n          type: DOM_OPERATION_TYPES[write.type] || write.type,\n          args: write.args\n        });\n      });\n    }\n  }\n  return items;\n}\n\nfunction getExclusiveSummary(measurements) {\n  var candidates = {};\n  var displayName;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign(\n      {},\n      measurement.exclusive,\n      measurement.inclusive\n    );\n\n    for (var id in allIDs) {\n      displayName = measurement.displayNames[id].current;\n\n      candidates[displayName] = candidates[displayName] || {\n        componentName: displayName,\n        inclusive: 0,\n        exclusive: 0,\n        render: 0,\n        count: 0\n      };\n      if (measurement.render[id]) {\n        candidates[displayName].render += measurement.render[id];\n      }\n      if (measurement.exclusive[id]) {\n        candidates[displayName].exclusive += measurement.exclusive[id];\n      }\n      if (measurement.inclusive[id]) {\n        candidates[displayName].inclusive += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[displayName].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (displayName in candidates) {\n    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[displayName]);\n    }\n  }\n\n  arr.sort(function(a, b) {\n    return b.exclusive - a.exclusive;\n  });\n\n  return arr;\n}\n\nfunction getInclusiveSummary(measurements, onlyClean) {\n  var candidates = {};\n  var inclusiveKey;\n\n  for (var i = 0; i < measurements.length; i++) {\n    var measurement = measurements[i];\n    var allIDs = assign(\n      {},\n      measurement.exclusive,\n      measurement.inclusive\n    );\n    var cleanComponents;\n\n    if (onlyClean) {\n      cleanComponents = getUnchangedComponents(measurement);\n    }\n\n    for (var id in allIDs) {\n      if (onlyClean && !cleanComponents[id]) {\n        continue;\n      }\n\n      var displayName = measurement.displayNames[id];\n\n      // Inclusive time is not useful for many components without knowing where\n      // they are instantiated. So we aggregate inclusive time with both the\n      // owner and current displayName as the key.\n      inclusiveKey = displayName.owner + ' > ' + displayName.current;\n\n      candidates[inclusiveKey] = candidates[inclusiveKey] || {\n        componentName: inclusiveKey,\n        time: 0,\n        count: 0\n      };\n\n      if (measurement.inclusive[id]) {\n        candidates[inclusiveKey].time += measurement.inclusive[id];\n      }\n      if (measurement.counts[id]) {\n        candidates[inclusiveKey].count += measurement.counts[id];\n      }\n    }\n  }\n\n  // Now make a sorted array with the results.\n  var arr = [];\n  for (inclusiveKey in candidates) {\n    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {\n      arr.push(candidates[inclusiveKey]);\n    }\n  }\n\n  arr.sort(function(a, b) {\n    return b.time - a.time;\n  });\n\n  return arr;\n}\n\nfunction getUnchangedComponents(measurement) {\n  // For a given reconcile, look at which components did not actually\n  // render anything to the DOM and return a mapping of their ID to\n  // the amount of time it took to render the entire subtree.\n  var cleanComponents = {};\n  var dirtyLeafIDs = Object.keys(measurement.writes);\n  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);\n\n  for (var id in allIDs) {\n    var isDirty = false;\n    // For each component that rendered, see if a component that triggered\n    // a DOM op is in its subtree.\n    for (var i = 0; i < dirtyLeafIDs.length; i++) {\n      if (dirtyLeafIDs[i].indexOf(id) === 0) {\n        isDirty = true;\n        break;\n      }\n    }\n    if (!isDirty && measurement.counts[id] > 0) {\n      cleanComponents[id] = true;\n    }\n  }\n  return cleanComponents;\n}\n\nvar ReactDefaultPerfAnalysis = {\n  getExclusiveSummary: getExclusiveSummary,\n  getInclusiveSummary: getInclusiveSummary,\n  getDOMSummary: getDOMSummary,\n  getTotalTime: getTotalTime\n};\n\nmodule.exports = ReactDefaultPerfAnalysis;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDefaultPerfAnalysis.js\n ** module id = 240\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDefaultPerfAnalysis.js?");

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule performanceNow\n * @typechecks\n */\n\nvar performance = __webpack_require__(255);\n\n/**\n * Detect if we can use `window.performance.now()` and gracefully fallback to\n * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now\n * because of Facebook's testing infrastructure.\n */\nif (!performance || !performance.now) {\n  performance = Date;\n}\n\nvar performanceNow = performance.now.bind(performance);\n\nmodule.exports = performanceNow;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/performanceNow.js\n ** module id = 241\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/performanceNow.js?");

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule adler32\n */\n\n/* jslint bitwise:true */\n\n\"use strict\";\n\nvar MOD = 65521;\n\n// This is a clean-room implementation of adler32 designed for detecting\n// if markup is not what we expect it to be. It does not need to be\n// cryptographically strong, only reasonably good at detecting if markup\n// generated on the server is different than that on the client.\nfunction adler32(data) {\n  var a = 1;\n  var b = 0;\n  for (var i = 0; i < data.length; i++) {\n    a = (a + data.charCodeAt(i)) % MOD;\n    b = (b + a) % MOD;\n  }\n  return a | (b << 16);\n}\n\nmodule.exports = adler32;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/adler32.js\n ** module id = 242\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/adler32.js?");

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactPutListenerQueue\n */\n\n\"use strict\";\n\nvar PooledClass = __webpack_require__(135);\nvar ReactBrowserEventEmitter = __webpack_require__(26);\n\nvar assign = __webpack_require__(51);\n\nfunction ReactPutListenerQueue() {\n  this.listenersToPut = [];\n}\n\nassign(ReactPutListenerQueue.prototype, {\n  enqueuePutListener: function(rootNodeID, propKey, propValue) {\n    this.listenersToPut.push({\n      rootNodeID: rootNodeID,\n      propKey: propKey,\n      propValue: propValue\n    });\n  },\n\n  putListeners: function() {\n    for (var i = 0; i < this.listenersToPut.length; i++) {\n      var listenerToPut = this.listenersToPut[i];\n      ReactBrowserEventEmitter.putListener(\n        listenerToPut.rootNodeID,\n        listenerToPut.propKey,\n        listenerToPut.propValue\n      );\n    }\n  },\n\n  reset: function() {\n    this.listenersToPut.length = 0;\n  },\n\n  destructor: function() {\n    this.reset();\n  }\n});\n\nPooledClass.addPoolingTo(ReactPutListenerQueue);\n\nmodule.exports = ReactPutListenerQueue;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactPutListenerQueue.js\n ** module id = 243\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactPutListenerQueue.js?");

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	eval("var _ = __webpack_require__(188);\n\nmodule.exports = function mix(def) {\n    var composed = {\n        init: [],\n        preEmit: [],\n        shouldEmit: []\n    };\n\n    var updated = (function mixDef(mixin) {\n        var mixed = {};\n        if (mixin.mixins) {\n            mixin.mixins.forEach(function (subMixin) {\n                _.extend(mixed, mixDef(subMixin));\n            });\n        }\n        _.extend(mixed, mixin);\n        Object.keys(composed).forEach(function (composable) {\n            if (mixin.hasOwnProperty(composable)) {\n                composed[composable].push(mixin[composable]);\n            }\n        });\n        return mixed;\n    }(def));\n\n    if (composed.init.length > 1) {\n        updated.init = function () {\n            var args = arguments;\n            composed.init.forEach(function (init) {\n                init.apply(this, args);\n            }, this);\n        };\n    }\n    if (composed.preEmit.length > 1) {\n        updated.preEmit = function () {\n            return composed.preEmit.reduce(function (args, preEmit) {\n                var newValue = preEmit.apply(this, args);\n                return newValue === undefined ? args : [newValue];\n            }.bind(this), arguments);\n        };\n    }\n    if (composed.shouldEmit.length > 1) {\n        updated.shouldEmit = function () {\n            var args = arguments;\n            return !composed.shouldEmit.some(function (shouldEmit) {\n                return !shouldEmit.apply(this, args);\n            }, this);\n        };\n    }\n    Object.keys(composed).forEach(function (composable) {\n        if (composed[composable].length === 1) {\n            updated[composable] = composed[composable][0];\n        }\n    });\n\n    return updated;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/mixer.js\n ** module id = 244\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/mixer.js?");

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = function(store, definition) {\n  for (var name in definition) {\n    var property = definition[name];\n\n    if (typeof property !== 'function' || !definition.hasOwnProperty(name)) {\n      continue;\n    }\n\n    store[name] = property.bind(store);\n  }\n\n  return store;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/src/bindMethods.js\n ** module id = 245\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/src/bindMethods.js?");

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} once Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Holds the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  if (!this._events || !this._events[event]) return [];\n  if (this._events[event].fn) return [this._events[event].fn];\n\n  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {\n    ee[i] = this._events[event][i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  if (!this._events || !this._events[event]) return false;\n\n  var listeners = this._events[event]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true);\n\n  if (!this._events) this._events = {};\n  if (!this._events[event]) this._events[event] = listener;\n  else {\n    if (!this._events[event].fn) this._events[event].push(listener);\n    else this._events[event] = [\n      this._events[event], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, once) {\n  if (!this._events || !this._events[event]) return this;\n\n  var listeners = this._events[event]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {\n      events.push(listeners);\n    }\n    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {\n      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {\n        events.push(listeners[i]);\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[event] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[event];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[event];\n  else this._events = {};\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the module.\n//\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.EventEmitter2 = EventEmitter;\nEventEmitter.EventEmitter3 = EventEmitter;\n\n//\n// Expose the module.\n//\nmodule.exports = EventEmitter;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/~/eventemitter3/index.js\n ** module id = 246\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/~/eventemitter3/index.js?");

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n/**\n * Based on https://github.com/facebook/react/blob/master/src/class/ReactClass.js#L637\n */\nfunction bindAutoBindMethod(component, method) {\n  var boundMethod = method.bind(component);\n\n  boundMethod.__reactBoundContext = component;\n  boundMethod.__reactBoundMethod = method;\n  boundMethod.__reactBoundArguments = null;\n\n  var componentName = component.constructor.displayName,\n      _bind = boundMethod.bind;\n\n  boundMethod.bind = function (newThis) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (newThis !== component && newThis !== null) {\n      console.warn(\n        'bind(): React component methods may only be bound to the ' +\n        'component instance. See ' + componentName\n      );\n    } else if (!args.length) {\n      console.warn(\n        'bind(): You are binding a component method to the component. ' +\n        'React does this for you automatically in a high-performance ' +\n        'way, so you can safely remove this call. See ' + componentName\n      );\n      return boundMethod;\n    }\n\n    var reboundMethod = _bind.apply(boundMethod, arguments);\n    reboundMethod.__reactBoundContext = component;\n    reboundMethod.__reactBoundMethod = method;\n    reboundMethod.__reactBoundArguments = args;\n\n    return reboundMethod;\n  };\n\n  return boundMethod;\n}\n\n/**\n * Performs auto-binding similar to how React does it.\n * Skips already auto-bound methods.\n * Based on https://github.com/facebook/react/blob/master/src/class/ReactClass.js#L679.\n */\nmodule.exports = function bindAutoBindMethods(component) {\n  for (var autoBindKey in component.__reactAutoBindMap) {\n    if (!component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {\n      continue;\n    }\n\n    // Skip already bound methods\n    if (component.hasOwnProperty(autoBindKey) &&\n        component[autoBindKey].__reactBoundContext === component) {\n      continue;\n    }\n\n    var method = component.__reactAutoBindMap[autoBindKey];\n    component[autoBindKey] = bindAutoBindMethod(component, method);\n  }\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react-hot-loader/~/react-hot-api/modules/bindAutoBindMethods.js\n ** module id = 247\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react-hot-loader/~/react-hot-api/modules/bindAutoBindMethods.js?");

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule camelize\n * @typechecks\n */\n\nvar _hyphenPattern = /-(.)/g;\n\n/**\n * Camelcases a hyphenated string, for example:\n *\n *   > camelize('background-color')\n *   < \"backgroundColor\"\n *\n * @param {string} string\n * @return {string}\n */\nfunction camelize(string) {\n  return string.replace(_hyphenPattern, function(_, character) {\n    return character.toUpperCase();\n  });\n}\n\nmodule.exports = camelize;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/camelize.js\n ** module id = 248\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/camelize.js?");

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule hyphenate\n * @typechecks\n */\n\nvar _uppercasePattern = /([A-Z])/g;\n\n/**\n * Hyphenates a camelcased string, for example:\n *\n *   > hyphenate('backgroundColor')\n *   < \"background-color\"\n *\n * For CSS style names, use `hyphenateStyleName` instead which works properly\n * with all vendor prefixes, including `ms`.\n *\n * @param {string} string\n * @return {string}\n */\nfunction hyphenate(string) {\n  return string.replace(_uppercasePattern, '-$1').toLowerCase();\n}\n\nmodule.exports = hyphenate;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/hyphenate.js\n ** module id = 249\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/hyphenate.js?");

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMSelection\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar getNodeForCharacterOffset = __webpack_require__(257);\nvar getTextContentAccessor = __webpack_require__(220);\n\n/**\n * While `isCollapsed` is available on the Selection object and `collapsed`\n * is available on the Range object, IE11 sometimes gets them wrong.\n * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n */\nfunction isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {\n  return anchorNode === focusNode && anchorOffset === focusOffset;\n}\n\n/**\n * Get the appropriate anchor and focus node/offset pairs for IE.\n *\n * The catch here is that IE's selection API doesn't provide information\n * about whether the selection is forward or backward, so we have to\n * behave as though it's always forward.\n *\n * IE text differs from modern selection in that it behaves as though\n * block elements end with a new line. This means character offsets will\n * differ between the two APIs.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getIEOffsets(node) {\n  var selection = document.selection;\n  var selectedRange = selection.createRange();\n  var selectedLength = selectedRange.text.length;\n\n  // Duplicate selection so we can move range without breaking user selection.\n  var fromStart = selectedRange.duplicate();\n  fromStart.moveToElementText(node);\n  fromStart.setEndPoint('EndToStart', selectedRange);\n\n  var startOffset = fromStart.text.length;\n  var endOffset = startOffset + selectedLength;\n\n  return {\n    start: startOffset,\n    end: endOffset\n  };\n}\n\n/**\n * @param {DOMElement} node\n * @return {?object}\n */\nfunction getModernOffsets(node) {\n  var selection = window.getSelection && window.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode;\n  var anchorOffset = selection.anchorOffset;\n  var focusNode = selection.focusNode;\n  var focusOffset = selection.focusOffset;\n\n  var currentRange = selection.getRangeAt(0);\n\n  // If the node and offset values are the same, the selection is collapsed.\n  // `Selection.isCollapsed` is available natively, but IE sometimes gets\n  // this value wrong.\n  var isSelectionCollapsed = isCollapsed(\n    selection.anchorNode,\n    selection.anchorOffset,\n    selection.focusNode,\n    selection.focusOffset\n  );\n\n  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n\n  var tempRange = currentRange.cloneRange();\n  tempRange.selectNodeContents(node);\n  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n\n  var isTempRangeCollapsed = isCollapsed(\n    tempRange.startContainer,\n    tempRange.startOffset,\n    tempRange.endContainer,\n    tempRange.endOffset\n  );\n\n  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n  var end = start + rangeLength;\n\n  // Detect whether the selection is backward.\n  var detectionRange = document.createRange();\n  detectionRange.setStart(anchorNode, anchorOffset);\n  detectionRange.setEnd(focusNode, focusOffset);\n  var isBackward = detectionRange.collapsed;\n\n  return {\n    start: isBackward ? end : start,\n    end: isBackward ? start : end\n  };\n}\n\n/**\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setIEOffsets(node, offsets) {\n  var range = document.selection.createRange().duplicate();\n  var start, end;\n\n  if (typeof offsets.end === 'undefined') {\n    start = offsets.start;\n    end = start;\n  } else if (offsets.start > offsets.end) {\n    start = offsets.end;\n    end = offsets.start;\n  } else {\n    start = offsets.start;\n    end = offsets.end;\n  }\n\n  range.moveToElementText(node);\n  range.moveStart('character', start);\n  range.setEndPoint('EndToStart', range);\n  range.moveEnd('character', end - start);\n  range.select();\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setModernOffsets(node, offsets) {\n  if (!window.getSelection) {\n    return;\n  }\n\n  var selection = window.getSelection();\n  var length = node[getTextContentAccessor()].length;\n  var start = Math.min(offsets.start, length);\n  var end = typeof offsets.end === 'undefined' ?\n            start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    var range = document.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nvar useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;\n\nvar ReactDOMSelection = {\n  /**\n   * @param {DOMElement} node\n   */\n  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,\n\n  /**\n   * @param {DOMElement|DOMTextNode} node\n   * @param {object} offsets\n   */\n  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets\n};\n\nmodule.exports = ReactDOMSelection;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/ReactDOMSelection.js\n ** module id = 250\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/ReactDOMSelection.js?");

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule focusNode\n */\n\n\"use strict\";\n\n/**\n * @param {DOMElement} node input/textarea to focus\n */\nfunction focusNode(node) {\n  // IE8 can throw \"Can't move focus to the control because it is invisible,\n  // not enabled, or of a type that does not accept the focus.\" for all kinds of\n  // reasons that are too expensive and fragile to test.\n  try {\n    node.focus();\n  } catch(e) {\n  }\n}\n\nmodule.exports = focusNode;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/focusNode.js\n ** module id = 251\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/focusNode.js?");

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013 Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventModifierState\n * @typechecks static-only\n */\n\n\"use strict\";\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  'Alt': 'altKey',\n  'Control': 'ctrlKey',\n  'Meta': 'metaKey',\n  'Shift': 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  /*jshint validthis:true */\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\nmodule.exports = getEventModifierState;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventModifierState.js\n ** module id = 252\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventModifierState.js?");

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DOMChildrenOperations\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar Danger = __webpack_require__(258);\nvar ReactMultiChildUpdateTypes = __webpack_require__(172);\n\nvar getTextContentAccessor = __webpack_require__(220);\nvar invariant = __webpack_require__(36);\n\n/**\n * The DOM property to use when setting text content.\n *\n * @type {string}\n * @private\n */\nvar textContentAccessor = getTextContentAccessor();\n\n/**\n * Inserts `childNode` as a child of `parentNode` at the `index`.\n *\n * @param {DOMElement} parentNode Parent node in which to insert.\n * @param {DOMElement} childNode Child node to insert.\n * @param {number} index Index at which to insert the child.\n * @internal\n */\nfunction insertChildAt(parentNode, childNode, index) {\n  // By exploiting arrays returning `undefined` for an undefined index, we can\n  // rely exclusively on `insertBefore(node, null)` instead of also using\n  // `appendChild(node)`. However, using `undefined` is not allowed by all\n  // browsers so we must replace it with `null`.\n  parentNode.insertBefore(\n    childNode,\n    parentNode.childNodes[index] || null\n  );\n}\n\nvar updateTextContent;\nif (textContentAccessor === 'textContent') {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function(node, text) {\n    node.textContent = text;\n  };\n} else {\n  /**\n   * Sets the text content of `node` to `text`.\n   *\n   * @param {DOMElement} node Node to change\n   * @param {string} text New text content\n   */\n  updateTextContent = function(node, text) {\n    // In order to preserve newlines correctly, we can't use .innerText to set\n    // the contents (see #1080), so we empty the element then append a text node\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    if (text) {\n      var doc = node.ownerDocument || document;\n      node.appendChild(doc.createTextNode(text));\n    }\n  };\n}\n\n/**\n * Operations for updating with DOM children.\n */\nvar DOMChildrenOperations = {\n\n  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,\n\n  updateTextContent: updateTextContent,\n\n  /**\n   * Updates a component's children by processing a series of updates. The\n   * update configurations are each expected to have a `parentNode` property.\n   *\n   * @param {array<object>} updates List of update configurations.\n   * @param {array<string>} markupList List of markup strings.\n   * @internal\n   */\n  processUpdates: function(updates, markupList) {\n    var update;\n    // Mapping from parent IDs to initial child orderings.\n    var initialChildren = null;\n    // List of children that will be moved or removed.\n    var updatedChildren = null;\n\n    for (var i = 0; update = updates[i]; i++) {\n      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||\n          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {\n        var updatedIndex = update.fromIndex;\n        var updatedChild = update.parentNode.childNodes[updatedIndex];\n        var parentID = update.parentID;\n\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          updatedChild,\n          'processUpdates(): Unable to find child %s of element. This ' +\n          'probably means the DOM was unexpectedly mutated (e.g., by the ' +\n          'browser), usually due to forgetting a <tbody> when using tables, ' +\n          'nesting tags like <form>, <p>, or <a>, or using non-SVG elements '+\n          'in an <svg> parent. Try inspecting the child nodes of the element ' +\n          'with React ID `%s`.',\n          updatedIndex,\n          parentID\n        ) : invariant(updatedChild));\n\n        initialChildren = initialChildren || {};\n        initialChildren[parentID] = initialChildren[parentID] || [];\n        initialChildren[parentID][updatedIndex] = updatedChild;\n\n        updatedChildren = updatedChildren || [];\n        updatedChildren.push(updatedChild);\n      }\n    }\n\n    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);\n\n    // Remove updated children first so that `toIndex` is consistent.\n    if (updatedChildren) {\n      for (var j = 0; j < updatedChildren.length; j++) {\n        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);\n      }\n    }\n\n    for (var k = 0; update = updates[k]; k++) {\n      switch (update.type) {\n        case ReactMultiChildUpdateTypes.INSERT_MARKUP:\n          insertChildAt(\n            update.parentNode,\n            renderedMarkup[update.markupIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.MOVE_EXISTING:\n          insertChildAt(\n            update.parentNode,\n            initialChildren[update.parentID][update.fromIndex],\n            update.toIndex\n          );\n          break;\n        case ReactMultiChildUpdateTypes.TEXT_CONTENT:\n          updateTextContent(\n            update.parentNode,\n            update.textContent\n          );\n          break;\n        case ReactMultiChildUpdateTypes.REMOVE_NODE:\n          // Already removed by the for-loop above.\n          break;\n      }\n    }\n  }\n\n};\n\nmodule.exports = DOMChildrenOperations;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/DOMChildrenOperations.js\n ** module id = 253\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/DOMChildrenOperations.js?");

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getEventKey\n * @typechecks static-only\n */\n\n\"use strict\";\n\nvar getEventCharCode = __webpack_require__(239);\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  'Esc': 'Escape',\n  'Spacebar': ' ',\n  'Left': 'ArrowLeft',\n  'Up': 'ArrowUp',\n  'Right': 'ArrowRight',\n  'Down': 'ArrowDown',\n  'Del': 'Delete',\n  'Win': 'OS',\n  'Menu': 'ContextMenu',\n  'Apps': 'ContextMenu',\n  'Scroll': 'ScrollLock',\n  'MozPrintableKey': 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  8: 'Backspace',\n  9: 'Tab',\n  12: 'Clear',\n  13: 'Enter',\n  16: 'Shift',\n  17: 'Control',\n  18: 'Alt',\n  19: 'Pause',\n  20: 'CapsLock',\n  27: 'Escape',\n  32: ' ',\n  33: 'PageUp',\n  34: 'PageDown',\n  35: 'End',\n  36: 'Home',\n  37: 'ArrowLeft',\n  38: 'ArrowUp',\n  39: 'ArrowRight',\n  40: 'ArrowDown',\n  45: 'Insert',\n  46: 'Delete',\n  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',\n  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',\n  144: 'NumLock',\n  145: 'ScrollLock',\n  224: 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\nmodule.exports = getEventKey;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getEventKey.js\n ** module id = 254\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getEventKey.js?");

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule performance\n * @typechecks\n */\n\n\"use strict\";\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar performance;\n\nif (ExecutionEnvironment.canUseDOM) {\n  performance =\n    window.performance ||\n    window.msPerformance ||\n    window.webkitPerformance;\n}\n\nmodule.exports = performance || {};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/performance.js\n ** module id = 255\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/performance.js?");

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*! Native Promise Only\n    v0.7.6-a (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n!function(t,n,e){n[t]=n[t]||e(),\"undefined\"!=typeof module&&module.exports?module.exports=n[t]:\"function\"==\"function\"&&__webpack_require__(203)&&!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return n[t]}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}(\"Promise\",\"undefined\"!=typeof global?global:this,function(){\"use strict\";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||\"object\"!=e&&\"function\"!=e||(n=t.then),\"function\"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError(\"Promise-chain cycle\")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u,a=this;if(!a.triggered){a.triggered=!0,a.def&&(a=a.def);try{(c=n(o))?(u=new f(a),c.call(o,function(){r.apply(u,arguments)},function(){i.apply(u,arguments)})):(a.msg=o,a.state=1,a.chain.length>0&&t(e,a))}catch(s){i.call(u||new f(a),s)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if(\"function\"!=typeof n)throw TypeError(\"Not a function\");if(0!==this.__NPO__)throw TypeError(\"Not a promise\");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:\"function\"==typeof n?n:!0,failure:\"function\"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if(\"function\"!=typeof t||\"function\"!=typeof n)throw TypeError(\"Not a function\");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this[\"catch\"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y=\"undefined\"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},\"x\",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},\"constructor\",a,!1);return s(a,\"prototype\",g,!1),s(g,\"__NPO__\",0,!1),s(a,\"resolve\",function(t){var n=this;return t&&\"object\"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");n(t)})}),s(a,\"reject\",function(t){return new this(function(n,e){if(\"function\"!=typeof n||\"function\"!=typeof e)throw TypeError(\"Not a function\");e(t)})}),s(a,\"all\",function(t){var n=this;return\"[object Array]\"!=p.call(t)?n.reject(TypeError(\"Not an array\")):0===t.length?n.resolve([]):new n(function(e,o){if(\"function\"!=typeof e||\"function\"!=typeof o)throw TypeError(\"Not a function\");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,\"race\",function(t){var n=this;return\"[object Array]\"!=p.call(t)?n.reject(TypeError(\"Not an array\")):new n(function(e,o){if(\"function\"!=typeof e||\"function\"!=typeof o)throw TypeError(\"Not a function\");c(n,t,function(t,n){e(n)},o)})}),a});\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(259).setImmediate))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflux/~/native-promise-only/npo.js\n ** module id = 256\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/reflux/~/native-promise-only/npo.js?");

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getNodeForCharacterOffset\n */\n\n\"use strict\";\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType == 3) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\nmodule.exports = getNodeForCharacterOffset;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getNodeForCharacterOffset.js\n ** module id = 257\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getNodeForCharacterOffset.js?");

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule Danger\n * @typechecks static-only\n */\n\n/*jslint evil: true, sub: true */\n\n\"use strict\";\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar createNodesFromMarkup = __webpack_require__(260);\nvar emptyFunction = __webpack_require__(59);\nvar getMarkupWrap = __webpack_require__(261);\nvar invariant = __webpack_require__(36);\n\nvar OPEN_TAG_NAME_EXP = /^(<[^ \\/>]+)/;\nvar RESULT_INDEX_ATTR = 'data-danger-index';\n\n/**\n * Extracts the `nodeName` from a string of markup.\n *\n * NOTE: Extracting the `nodeName` does not require a regular expression match\n * because we make assumptions about React-generated markup (i.e. there are no\n * spaces surrounding the opening tag and there is at least one attribute).\n *\n * @param {string} markup String of markup.\n * @return {string} Node name of the supplied markup.\n * @see http://jsperf.com/extract-nodename\n */\nfunction getNodeName(markup) {\n  return markup.substring(1, markup.indexOf(' '));\n}\n\nvar Danger = {\n\n  /**\n   * Renders markup into an array of nodes. The markup is expected to render\n   * into a list of root nodes. Also, the length of `resultList` and\n   * `markupList` should be the same.\n   *\n   * @param {array<string>} markupList List of markup strings to render.\n   * @return {array<DOMElement>} List of rendered nodes.\n   * @internal\n   */\n  dangerouslyRenderMarkup: function(markupList) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ExecutionEnvironment.canUseDOM,\n      'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' +\n      'thread. Make sure `window` and `document` are available globally ' +\n      'before requiring React when unit testing or use ' +\n      'React.renderToString for server rendering.'\n    ) : invariant(ExecutionEnvironment.canUseDOM));\n    var nodeName;\n    var markupByNodeName = {};\n    // Group markup by `nodeName` if a wrap is necessary, else by '*'.\n    for (var i = 0; i < markupList.length; i++) {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        markupList[i],\n        'dangerouslyRenderMarkup(...): Missing markup.'\n      ) : invariant(markupList[i]));\n      nodeName = getNodeName(markupList[i]);\n      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';\n      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];\n      markupByNodeName[nodeName][i] = markupList[i];\n    }\n    var resultList = [];\n    var resultListAssignmentCount = 0;\n    for (nodeName in markupByNodeName) {\n      if (!markupByNodeName.hasOwnProperty(nodeName)) {\n        continue;\n      }\n      var markupListByNodeName = markupByNodeName[nodeName];\n\n      // This for-in loop skips the holes of the sparse array. The order of\n      // iteration should follow the order of assignment, which happens to match\n      // numerical index order, but we don't rely on that.\n      for (var resultIndex in markupListByNodeName) {\n        if (markupListByNodeName.hasOwnProperty(resultIndex)) {\n          var markup = markupListByNodeName[resultIndex];\n\n          // Push the requested markup with an additional RESULT_INDEX_ATTR\n          // attribute.  If the markup does not start with a < character, it\n          // will be discarded below (with an appropriate console.error).\n          markupListByNodeName[resultIndex] = markup.replace(\n            OPEN_TAG_NAME_EXP,\n            // This index will be parsed back out below.\n            '$1 ' + RESULT_INDEX_ATTR + '=\"' + resultIndex + '\" '\n          );\n        }\n      }\n\n      // Render each group of markup with similar wrapping `nodeName`.\n      var renderNodes = createNodesFromMarkup(\n        markupListByNodeName.join(''),\n        emptyFunction // Do nothing special with <script> tags.\n      );\n\n      for (i = 0; i < renderNodes.length; ++i) {\n        var renderNode = renderNodes[i];\n        if (renderNode.hasAttribute &&\n            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {\n\n          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);\n          renderNode.removeAttribute(RESULT_INDEX_ATTR);\n\n          (\"production\" !== process.env.NODE_ENV ? invariant(\n            !resultList.hasOwnProperty(resultIndex),\n            'Danger: Assigning to an already-occupied result index.'\n          ) : invariant(!resultList.hasOwnProperty(resultIndex)));\n\n          resultList[resultIndex] = renderNode;\n\n          // This should match resultList.length and markupList.length when\n          // we're done.\n          resultListAssignmentCount += 1;\n\n        } else if (\"production\" !== process.env.NODE_ENV) {\n          console.error(\n            \"Danger: Discarding unexpected node:\",\n            renderNode\n          );\n        }\n      }\n    }\n\n    // Although resultList was populated out of order, it should now be a dense\n    // array.\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      resultListAssignmentCount === resultList.length,\n      'Danger: Did not assign to every index of resultList.'\n    ) : invariant(resultListAssignmentCount === resultList.length));\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      resultList.length === markupList.length,\n      'Danger: Expected markup to render %s nodes, but rendered %s.',\n      markupList.length,\n      resultList.length\n    ) : invariant(resultList.length === markupList.length));\n\n    return resultList;\n  },\n\n  /**\n   * Replaces a node with a string of markup at its current position within its\n   * parent. The markup must render into a single root node.\n   *\n   * @param {DOMElement} oldChild Child node to replace.\n   * @param {string} markup Markup to render in place of the child node.\n   * @internal\n   */\n  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ExecutionEnvironment.canUseDOM,\n      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +\n      'worker thread. Make sure `window` and `document` are available ' +\n      'globally before requiring React when unit testing or use ' +\n      'React.renderToString for server rendering.'\n    ) : invariant(ExecutionEnvironment.canUseDOM));\n    (\"production\" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      oldChild.tagName.toLowerCase() !== 'html',\n      'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' +\n      '<html> node. This is because browser quirks make this unreliable ' +\n      'and/or slow. If you want to render to the root you must use ' +\n      'server rendering. See renderComponentToString().'\n    ) : invariant(oldChild.tagName.toLowerCase() !== 'html'));\n\n    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];\n    oldChild.parentNode.replaceChild(newChild, oldChild);\n  }\n\n};\n\nmodule.exports = Danger;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/Danger.js\n ** module id = 258\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/Danger.js?");

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(263).nextTick;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nif (typeof setTimeout !== 'undefined') exports.setTimeout = function() { return setTimeout.apply(window, arguments); };\nif (typeof clearTimeout !== 'undefined') exports.clearTimeout = function() { clearTimeout.apply(window, arguments); };\nif (typeof setInterval !== 'undefined') exports.setInterval = function() { return setInterval.apply(window, arguments); };\nif (typeof clearInterval !== 'undefined') exports.clearInterval = function() { clearInterval.apply(window, arguments); };\n\n// TODO: Change to more efficient list approach used in Node.js\n// For now, we just implement the APIs using the primitives above.\n\nexports.enroll = function(item, delay) {\n  item._timeoutID = setTimeout(item._onTimeout, delay);\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._timeoutID);\n};\n\nexports.active = function(item) {\n  // our naive impl doesn't care (correctness is still preserved)\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(259).setImmediate, __webpack_require__(259).clearImmediate))\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/main.js\n ** module id = 259\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/main.js?");

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createNodesFromMarkup\n * @typechecks\n */\n\n/*jslint evil: true, sub: true */\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar createArrayFrom = __webpack_require__(262);\nvar getMarkupWrap = __webpack_require__(261);\nvar invariant = __webpack_require__(36);\n\n/**\n * Dummy container used to render all markup.\n */\nvar dummyNode =\n  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;\n\n/**\n * Pattern used by `getNodeName`.\n */\nvar nodeNamePattern = /^\\s*<(\\w+)/;\n\n/**\n * Extracts the `nodeName` of the first element in a string of markup.\n *\n * @param {string} markup String of markup.\n * @return {?string} Node name of the supplied markup.\n */\nfunction getNodeName(markup) {\n  var nodeNameMatch = markup.match(nodeNamePattern);\n  return nodeNameMatch && nodeNameMatch[1].toLowerCase();\n}\n\n/**\n * Creates an array containing the nodes rendered from the supplied markup. The\n * optionally supplied `handleScript` function will be invoked once for each\n * <script> element that is rendered. If no `handleScript` function is supplied,\n * an exception is thrown if any <script> elements are rendered.\n *\n * @param {string} markup A string of valid HTML markup.\n * @param {?function} handleScript Invoked once for each rendered <script>.\n * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.\n */\nfunction createNodesFromMarkup(markup, handleScript) {\n  var node = dummyNode;\n  (\"production\" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));\n  var nodeName = getNodeName(markup);\n\n  var wrap = nodeName && getMarkupWrap(nodeName);\n  if (wrap) {\n    node.innerHTML = wrap[1] + markup + wrap[2];\n\n    var wrapDepth = wrap[0];\n    while (wrapDepth--) {\n      node = node.lastChild;\n    }\n  } else {\n    node.innerHTML = markup;\n  }\n\n  var scripts = node.getElementsByTagName('script');\n  if (scripts.length) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      handleScript,\n      'createNodesFromMarkup(...): Unexpected <script> element rendered.'\n    ) : invariant(handleScript));\n    createArrayFrom(scripts).forEach(handleScript);\n  }\n\n  var nodes = createArrayFrom(node.childNodes);\n  while (node.lastChild) {\n    node.removeChild(node.lastChild);\n  }\n  return nodes;\n}\n\nmodule.exports = createNodesFromMarkup;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/createNodesFromMarkup.js\n ** module id = 260\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/createNodesFromMarkup.js?");

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getMarkupWrap\n */\n\nvar ExecutionEnvironment = __webpack_require__(75);\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Dummy container used to detect which wraps are necessary.\n */\nvar dummyNode =\n  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;\n\n/**\n * Some browsers cannot use `innerHTML` to render certain elements standalone,\n * so we wrap them, render the wrapped nodes, then extract the desired node.\n *\n * In IE8, certain elements cannot render alone, so wrap all elements ('*').\n */\nvar shouldWrap = {\n  // Force wrapping for SVG elements because if they get created inside a <div>,\n  // they will be initialized in the wrong namespace (and will not display).\n  'circle': true,\n  'defs': true,\n  'ellipse': true,\n  'g': true,\n  'line': true,\n  'linearGradient': true,\n  'path': true,\n  'polygon': true,\n  'polyline': true,\n  'radialGradient': true,\n  'rect': true,\n  'stop': true,\n  'text': true\n};\n\nvar selectWrap = [1, '<select multiple=\"true\">', '</select>'];\nvar tableWrap = [1, '<table>', '</table>'];\nvar trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\nvar svgWrap = [1, '<svg>', '</svg>'];\n\nvar markupWrap = {\n  '*': [1, '?<div>', '</div>'],\n\n  'area': [1, '<map>', '</map>'],\n  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  'legend': [1, '<fieldset>', '</fieldset>'],\n  'param': [1, '<object>', '</object>'],\n  'tr': [2, '<table><tbody>', '</tbody></table>'],\n\n  'optgroup': selectWrap,\n  'option': selectWrap,\n\n  'caption': tableWrap,\n  'colgroup': tableWrap,\n  'tbody': tableWrap,\n  'tfoot': tableWrap,\n  'thead': tableWrap,\n\n  'td': trWrap,\n  'th': trWrap,\n\n  'circle': svgWrap,\n  'defs': svgWrap,\n  'ellipse': svgWrap,\n  'g': svgWrap,\n  'line': svgWrap,\n  'linearGradient': svgWrap,\n  'path': svgWrap,\n  'polygon': svgWrap,\n  'polyline': svgWrap,\n  'radialGradient': svgWrap,\n  'rect': svgWrap,\n  'stop': svgWrap,\n  'text': svgWrap\n};\n\n/**\n * Gets the markup wrap configuration for the supplied `nodeName`.\n *\n * NOTE: This lazily detects which wraps are necessary for the current browser.\n *\n * @param {string} nodeName Lowercase `nodeName`.\n * @return {?array} Markup wrap configuration, if applicable.\n */\nfunction getMarkupWrap(nodeName) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));\n  if (!markupWrap.hasOwnProperty(nodeName)) {\n    nodeName = '*';\n  }\n  if (!shouldWrap.hasOwnProperty(nodeName)) {\n    if (nodeName === '*') {\n      dummyNode.innerHTML = '<link />';\n    } else {\n      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';\n    }\n    shouldWrap[nodeName] = !dummyNode.firstChild;\n  }\n  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;\n}\n\n\nmodule.exports = getMarkupWrap;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/getMarkupWrap.js\n ** module id = 261\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/getMarkupWrap.js?");

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule createArrayFrom\n * @typechecks\n */\n\nvar toArray = __webpack_require__(264);\n\n/**\n * Perform a heuristic test to determine if an object is \"array-like\".\n *\n *   A monk asked Joshu, a Zen master, \"Has a dog Buddha nature?\"\n *   Joshu replied: \"Mu.\"\n *\n * This function determines if its argument has \"array nature\": it returns\n * true if the argument is an actual array, an `arguments' object, or an\n * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).\n *\n * It will return false for other array-like objects like Filelist.\n *\n * @param {*} obj\n * @return {boolean}\n */\nfunction hasArrayNature(obj) {\n  return (\n    // not null/false\n    !!obj &&\n    // arrays are objects, NodeLists are functions in Safari\n    (typeof obj == 'object' || typeof obj == 'function') &&\n    // quacks like an array\n    ('length' in obj) &&\n    // not window\n    !('setInterval' in obj) &&\n    // no DOM node should be considered an array-like\n    // a 'select' element has 'length' and 'item' properties on IE8\n    (typeof obj.nodeType != 'number') &&\n    (\n      // a real array\n      (// HTMLCollection/NodeList\n      (Array.isArray(obj) ||\n      // arguments\n      ('callee' in obj) || 'item' in obj))\n    )\n  );\n}\n\n/**\n * Ensure that the argument is an array by wrapping it in an array if it is not.\n * Creates a copy of the argument if it is already an array.\n *\n * This is mostly useful idiomatically:\n *\n *   var createArrayFrom = require('createArrayFrom');\n *\n *   function takesOneOrMoreThings(things) {\n *     things = createArrayFrom(things);\n *     ...\n *   }\n *\n * This allows you to treat `things' as an array, but accept scalars in the API.\n *\n * If you need to convert an array-like object, like `arguments`, into an array\n * use toArray instead.\n *\n * @param {*} obj\n * @return {array}\n */\nfunction createArrayFrom(obj) {\n  if (!hasArrayNature(obj)) {\n    return [obj];\n  } else if (Array.isArray(obj)) {\n    return obj.slice();\n  } else {\n    return toArray(obj);\n  }\n}\n\nmodule.exports = createArrayFrom;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/createArrayFrom.js\n ** module id = 262\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/createArrayFrom.js?");

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	eval("// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/timers-browserify/~/process/browser.js\n ** module id = 263\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///(webpack)/~/node-libs-browser/~/timers-browserify/~/process/browser.js?");

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * Copyright 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule toArray\n * @typechecks\n */\n\nvar invariant = __webpack_require__(36);\n\n/**\n * Convert array-like objects to arrays.\n *\n * This API assumes the caller knows the contents of the data type. For less\n * well defined inputs use createArrayFrom.\n *\n * @param {object|function|filelist} obj\n * @return {array}\n */\nfunction toArray(obj) {\n  var length = obj.length;\n\n  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in\n  // old versions of Safari).\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    !Array.isArray(obj) &&\n    (typeof obj === 'object' || typeof obj === 'function'),\n    'toArray: Array-like object expected'\n  ) : invariant(!Array.isArray(obj) &&\n  (typeof obj === 'object' || typeof obj === 'function')));\n\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    typeof length === 'number',\n    'toArray: Object needs a length property'\n  ) : invariant(typeof length === 'number'));\n\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    length === 0 ||\n    (length - 1) in obj,\n    'toArray: Object should have keys for indices'\n  ) : invariant(length === 0 ||\n  (length - 1) in obj));\n\n  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs\n  // without method will throw during the slice call and skip straight to the\n  // fallback.\n  if (obj.hasOwnProperty) {\n    try {\n      return Array.prototype.slice.call(obj);\n    } catch (e) {\n      // IE < 9 does not support Array#slice on collections objects\n    }\n  }\n\n  // Fall back to copying key by key. This assumes all keys have a value,\n  // so will not preserve sparsely populated inputs.\n  var ret = Array(length);\n  for (var ii = 0; ii < length; ii++) {\n    ret[ii] = obj[ii];\n  }\n  return ret;\n}\n\nmodule.exports = toArray;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/react/lib/toArray.js\n ** module id = 264\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/react/lib/toArray.js?");

/***/ }
/******/ ])